/*
 * obj/x86_64-unknown-linux-gnu/xrl/interfaces/pim_xif.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#include "pim_xif.hh"

bool
XrlPimV0p1Client::send_enable_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const bool&	enable,
	const EnableVifCB&	cb
)
{
    Xrl* x = ap_xrl_enable_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/enable_vif");
        x->args().add("vif_name", vif_name);
        x->args().add("enable", enable);
        ap_xrl_enable_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, enable);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_enable_vif, cb));
}


/* Unmarshall enable_vif */
void
XrlPimV0p1Client::unmarshall_enable_vif(
	const XrlError&	e,
	XrlArgs*	a,
	EnableVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const StartVifCB&	cb
)
{
    Xrl* x = ap_xrl_start_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/start_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_start_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_start_vif, cb));
}


/* Unmarshall start_vif */
void
XrlPimV0p1Client::unmarshall_start_vif(
	const XrlError&	e,
	XrlArgs*	a,
	StartVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const StopVifCB&	cb
)
{
    Xrl* x = ap_xrl_stop_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/stop_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_stop_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_stop_vif, cb));
}


/* Unmarshall stop_vif */
void
XrlPimV0p1Client::unmarshall_stop_vif(
	const XrlError&	e,
	XrlArgs*	a,
	StopVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_all_vifs(
	const char*	dst_xrl_target_name,
	const bool&	enable,
	const EnableAllVifsCB&	cb
)
{
    Xrl* x = ap_xrl_enable_all_vifs.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/enable_all_vifs");
        x->args().add("enable", enable);
        ap_xrl_enable_all_vifs.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, enable);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_enable_all_vifs, cb));
}


/* Unmarshall enable_all_vifs */
void
XrlPimV0p1Client::unmarshall_enable_all_vifs(
	const XrlError&	e,
	XrlArgs*	a,
	EnableAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_all_vifs(
	const char*	dst_xrl_target_name,
	const StartAllVifsCB&	cb
)
{
    Xrl* x = ap_xrl_start_all_vifs.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/start_all_vifs");
        ap_xrl_start_all_vifs.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_start_all_vifs, cb));
}


/* Unmarshall start_all_vifs */
void
XrlPimV0p1Client::unmarshall_start_all_vifs(
	const XrlError&	e,
	XrlArgs*	a,
	StartAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_all_vifs(
	const char*	dst_xrl_target_name,
	const StopAllVifsCB&	cb
)
{
    Xrl* x = ap_xrl_stop_all_vifs.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/stop_all_vifs");
        ap_xrl_stop_all_vifs.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_stop_all_vifs, cb));
}


/* Unmarshall stop_all_vifs */
void
XrlPimV0p1Client::unmarshall_stop_all_vifs(
	const XrlError&	e,
	XrlArgs*	a,
	StopAllVifsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_pim(
	const char*	dst_xrl_target_name,
	const bool&	enable,
	const EnablePimCB&	cb
)
{
    Xrl* x = ap_xrl_enable_pim.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/enable_pim");
        x->args().add("enable", enable);
        ap_xrl_enable_pim.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, enable);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_enable_pim, cb));
}


/* Unmarshall enable_pim */
void
XrlPimV0p1Client::unmarshall_enable_pim(
	const XrlError&	e,
	XrlArgs*	a,
	EnablePimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_pim(
	const char*	dst_xrl_target_name,
	const StartPimCB&	cb
)
{
    Xrl* x = ap_xrl_start_pim.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/start_pim");
        ap_xrl_start_pim.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_start_pim, cb));
}


/* Unmarshall start_pim */
void
XrlPimV0p1Client::unmarshall_start_pim(
	const XrlError&	e,
	XrlArgs*	a,
	StartPimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_pim(
	const char*	dst_xrl_target_name,
	const StopPimCB&	cb
)
{
    Xrl* x = ap_xrl_stop_pim.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/stop_pim");
        ap_xrl_stop_pim.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_stop_pim, cb));
}


/* Unmarshall stop_pim */
void
XrlPimV0p1Client::unmarshall_stop_pim(
	const XrlError&	e,
	XrlArgs*	a,
	StopPimCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_cli(
	const char*	dst_xrl_target_name,
	const bool&	enable,
	const EnableCliCB&	cb
)
{
    Xrl* x = ap_xrl_enable_cli.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/enable_cli");
        x->args().add("enable", enable);
        ap_xrl_enable_cli.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, enable);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_enable_cli, cb));
}


/* Unmarshall enable_cli */
void
XrlPimV0p1Client::unmarshall_enable_cli(
	const XrlError&	e,
	XrlArgs*	a,
	EnableCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_cli(
	const char*	dst_xrl_target_name,
	const StartCliCB&	cb
)
{
    Xrl* x = ap_xrl_start_cli.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/start_cli");
        ap_xrl_start_cli.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_start_cli, cb));
}


/* Unmarshall start_cli */
void
XrlPimV0p1Client::unmarshall_start_cli(
	const XrlError&	e,
	XrlArgs*	a,
	StartCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_cli(
	const char*	dst_xrl_target_name,
	const StopCliCB&	cb
)
{
    Xrl* x = ap_xrl_stop_cli.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/stop_cli");
        ap_xrl_stop_cli.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_stop_cli, cb));
}


/* Unmarshall stop_cli */
void
XrlPimV0p1Client::unmarshall_stop_cli(
	const XrlError&	e,
	XrlArgs*	a,
	StopCliCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_enable_bsr(
	const char*	dst_xrl_target_name,
	const bool&	enable,
	const EnableBsrCB&	cb
)
{
    Xrl* x = ap_xrl_enable_bsr.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/enable_bsr");
        x->args().add("enable", enable);
        ap_xrl_enable_bsr.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, enable);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_enable_bsr, cb));
}


/* Unmarshall enable_bsr */
void
XrlPimV0p1Client::unmarshall_enable_bsr(
	const XrlError&	e,
	XrlArgs*	a,
	EnableBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_start_bsr(
	const char*	dst_xrl_target_name,
	const StartBsrCB&	cb
)
{
    Xrl* x = ap_xrl_start_bsr.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/start_bsr");
        ap_xrl_start_bsr.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_start_bsr, cb));
}


/* Unmarshall start_bsr */
void
XrlPimV0p1Client::unmarshall_start_bsr(
	const XrlError&	e,
	XrlArgs*	a,
	StartBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_stop_bsr(
	const char*	dst_xrl_target_name,
	const StopBsrCB&	cb
)
{
    Xrl* x = ap_xrl_stop_bsr.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/stop_bsr");
        ap_xrl_stop_bsr.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_stop_bsr, cb));
}


/* Unmarshall stop_bsr */
void
XrlPimV0p1Client::unmarshall_stop_bsr(
	const XrlError&	e,
	XrlArgs*	a,
	StopBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_apply_bsr_changes(
	const char*	dst_xrl_target_name,
	const ApplyBsrChangesCB&	cb
)
{
    Xrl* x = ap_xrl_apply_bsr_changes.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/apply_bsr_changes");
        ap_xrl_apply_bsr_changes.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_apply_bsr_changes, cb));
}


/* Unmarshall apply_bsr_changes */
void
XrlPimV0p1Client::unmarshall_apply_bsr_changes(
	const XrlError&	e,
	XrlArgs*	a,
	ApplyBsrChangesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_name4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	scope_zone_id,
	const string&	vif_name,
	const AddConfigScopeZoneByVifName4CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_scope_zone_by_vif_name4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_scope_zone_by_vif_name4");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_name", vif_name);
        ap_xrl_add_config_scope_zone_by_vif_name4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name4, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name4(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigScopeZoneByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_name6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	scope_zone_id,
	const string&	vif_name,
	const AddConfigScopeZoneByVifName6CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_scope_zone_by_vif_name6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_scope_zone_by_vif_name6");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_name", vif_name);
        ap_xrl_add_config_scope_zone_by_vif_name6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name6, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_name6(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigScopeZoneByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_addr6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	scope_zone_id,
	const IPv6&	vif_addr,
	const AddConfigScopeZoneByVifAddr6CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_scope_zone_by_vif_addr6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_scope_zone_by_vif_addr6");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_addr", vif_addr);
        ap_xrl_add_config_scope_zone_by_vif_addr6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr6, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_addr6 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr6(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigScopeZoneByVifAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_name6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	scope_zone_id,
	const string&	vif_name,
	const DeleteConfigScopeZoneByVifName6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_scope_zone_by_vif_name6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_scope_zone_by_vif_name6");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_name", vif_name);
        ap_xrl_delete_config_scope_zone_by_vif_name6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name6, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_name6 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigScopeZoneByVifName6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_addr6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	scope_zone_id,
	const IPv6&	vif_addr,
	const DeleteConfigScopeZoneByVifAddr6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_scope_zone_by_vif_addr6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_scope_zone_by_vif_addr6");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_addr", vif_addr);
        ap_xrl_delete_config_scope_zone_by_vif_addr6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr6, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_addr6 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigScopeZoneByVifAddr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_scope_zone_by_vif_addr4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	scope_zone_id,
	const IPv4&	vif_addr,
	const AddConfigScopeZoneByVifAddr4CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_scope_zone_by_vif_addr4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_scope_zone_by_vif_addr4");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_addr", vif_addr);
        ap_xrl_add_config_scope_zone_by_vif_addr4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr4, cb));
}


/* Unmarshall add_config_scope_zone_by_vif_addr4 */
void
XrlPimV0p1Client::unmarshall_add_config_scope_zone_by_vif_addr4(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigScopeZoneByVifAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_name4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	scope_zone_id,
	const string&	vif_name,
	const DeleteConfigScopeZoneByVifName4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_scope_zone_by_vif_name4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_scope_zone_by_vif_name4");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_name", vif_name);
        ap_xrl_delete_config_scope_zone_by_vif_name4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name4, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_name4 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_name4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigScopeZoneByVifName4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_scope_zone_by_vif_addr4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	scope_zone_id,
	const IPv4&	vif_addr,
	const DeleteConfigScopeZoneByVifAddr4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_scope_zone_by_vif_addr4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_scope_zone_by_vif_addr4");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("vif_addr", vif_addr);
        ap_xrl_delete_config_scope_zone_by_vif_addr4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, vif_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr4, cb));
}


/* Unmarshall delete_config_scope_zone_by_vif_addr4 */
void
XrlPimV0p1Client::unmarshall_delete_config_scope_zone_by_vif_addr4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigScopeZoneByVifAddr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const AddConfigCandBsr4CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_cand_bsr4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_cand_bsr4");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("vif_name", vif_name);
        x->args().add("vif_addr", vif_addr);
        x->args().add("bsr_priority", bsr_priority);
        x->args().add("hash_mask_len", hash_mask_len);
        ap_xrl_add_config_cand_bsr4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, is_scope_zone);
    x->args().set_arg(2, vif_name);
    x->args().set_arg(3, vif_addr);
    x->args().set_arg(4, bsr_priority);
    x->args().set_arg(5, hash_mask_len);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_cand_bsr4, cb));
}


/* Unmarshall add_config_cand_bsr4 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_bsr4(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigCandBsr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_bsr6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const AddConfigCandBsr6CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_cand_bsr6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_cand_bsr6");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("vif_name", vif_name);
        x->args().add("vif_addr", vif_addr);
        x->args().add("bsr_priority", bsr_priority);
        x->args().add("hash_mask_len", hash_mask_len);
        ap_xrl_add_config_cand_bsr6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, is_scope_zone);
    x->args().set_arg(2, vif_name);
    x->args().set_arg(3, vif_addr);
    x->args().set_arg(4, bsr_priority);
    x->args().set_arg(5, hash_mask_len);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_cand_bsr6, cb));
}


/* Unmarshall add_config_cand_bsr6 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_bsr6(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigCandBsr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_bsr6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const DeleteConfigCandBsr6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_cand_bsr6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_cand_bsr6");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("is_scope_zone", is_scope_zone);
        ap_xrl_delete_config_cand_bsr6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, is_scope_zone);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_cand_bsr6, cb));
}


/* Unmarshall delete_config_cand_bsr6 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_bsr6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigCandBsr6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_bsr4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const DeleteConfigCandBsr4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_cand_bsr4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_cand_bsr4");
        x->args().add("scope_zone_id", scope_zone_id);
        x->args().add("is_scope_zone", is_scope_zone);
        ap_xrl_delete_config_cand_bsr4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, scope_zone_id);
    x->args().set_arg(1, is_scope_zone);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_cand_bsr4, cb));
}


/* Unmarshall delete_config_cand_bsr4 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_bsr4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigCandBsr4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	const AddConfigCandRp4CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_cand_rp4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_cand_rp4");
        x->args().add("group_prefix", group_prefix);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("vif_name", vif_name);
        x->args().add("vif_addr", vif_addr);
        x->args().add("rp_priority", rp_priority);
        x->args().add("rp_holdtime", rp_holdtime);
        ap_xrl_add_config_cand_rp4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, is_scope_zone);
    x->args().set_arg(2, vif_name);
    x->args().set_arg(3, vif_addr);
    x->args().set_arg(4, rp_priority);
    x->args().set_arg(5, rp_holdtime);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_cand_rp4, cb));
}


/* Unmarshall add_config_cand_rp4 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_rp4(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigCandRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_cand_rp6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	const AddConfigCandRp6CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_cand_rp6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_cand_rp6");
        x->args().add("group_prefix", group_prefix);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("vif_name", vif_name);
        x->args().add("vif_addr", vif_addr);
        x->args().add("rp_priority", rp_priority);
        x->args().add("rp_holdtime", rp_holdtime);
        ap_xrl_add_config_cand_rp6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, is_scope_zone);
    x->args().set_arg(2, vif_name);
    x->args().set_arg(3, vif_addr);
    x->args().set_arg(4, rp_priority);
    x->args().set_arg(5, rp_holdtime);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_cand_rp6, cb));
}


/* Unmarshall add_config_cand_rp6 */
void
XrlPimV0p1Client::unmarshall_add_config_cand_rp6(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigCandRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const DeleteConfigCandRp6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_cand_rp6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_cand_rp6");
        x->args().add("group_prefix", group_prefix);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("vif_name", vif_name);
        x->args().add("vif_addr", vif_addr);
        ap_xrl_delete_config_cand_rp6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, is_scope_zone);
    x->args().set_arg(2, vif_name);
    x->args().set_arg(3, vif_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_cand_rp6, cb));
}


/* Unmarshall delete_config_cand_rp6 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_rp6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigCandRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_cand_rp4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const DeleteConfigCandRp4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_cand_rp4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_cand_rp4");
        x->args().add("group_prefix", group_prefix);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("vif_name", vif_name);
        x->args().add("vif_addr", vif_addr);
        ap_xrl_delete_config_cand_rp4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, is_scope_zone);
    x->args().set_arg(2, vif_name);
    x->args().set_arg(3, vif_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_cand_rp4, cb));
}


/* Unmarshall delete_config_cand_rp4 */
void
XrlPimV0p1Client::unmarshall_delete_config_cand_rp4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigCandRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_static_rp4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	hash_mask_len,
	const AddConfigStaticRp4CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_static_rp4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_static_rp4");
        x->args().add("group_prefix", group_prefix);
        x->args().add("rp_addr", rp_addr);
        x->args().add("rp_priority", rp_priority);
        x->args().add("hash_mask_len", hash_mask_len);
        ap_xrl_add_config_static_rp4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, rp_addr);
    x->args().set_arg(2, rp_priority);
    x->args().set_arg(3, hash_mask_len);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_static_rp4, cb));
}


/* Unmarshall add_config_static_rp4 */
void
XrlPimV0p1Client::unmarshall_add_config_static_rp4(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigStaticRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_config_static_rp6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	hash_mask_len,
	const AddConfigStaticRp6CB&	cb
)
{
    Xrl* x = ap_xrl_add_config_static_rp6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_config_static_rp6");
        x->args().add("group_prefix", group_prefix);
        x->args().add("rp_addr", rp_addr);
        x->args().add("rp_priority", rp_priority);
        x->args().add("hash_mask_len", hash_mask_len);
        ap_xrl_add_config_static_rp6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, rp_addr);
    x->args().set_arg(2, rp_priority);
    x->args().set_arg(3, hash_mask_len);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_config_static_rp6, cb));
}


/* Unmarshall add_config_static_rp6 */
void
XrlPimV0p1Client::unmarshall_add_config_static_rp6(
	const XrlError&	e,
	XrlArgs*	a,
	AddConfigStaticRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_static_rp6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const DeleteConfigStaticRp6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_static_rp6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_static_rp6");
        x->args().add("group_prefix", group_prefix);
        x->args().add("rp_addr", rp_addr);
        ap_xrl_delete_config_static_rp6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, rp_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_static_rp6, cb));
}


/* Unmarshall delete_config_static_rp6 */
void
XrlPimV0p1Client::unmarshall_delete_config_static_rp6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigStaticRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_all_static_group_prefixes_rp6(
	const char*	dst_xrl_target_name,
	const IPv6&	rp_addr,
	const DeleteConfigAllStaticGroupPrefixesRp6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_all_static_group_prefixes_rp6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_all_static_group_prefixes_rp6");
        x->args().add("rp_addr", rp_addr);
        ap_xrl_delete_config_all_static_group_prefixes_rp6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, rp_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_all_static_group_prefixes_rp6, cb));
}


/* Unmarshall delete_config_all_static_group_prefixes_rp6 */
void
XrlPimV0p1Client::unmarshall_delete_config_all_static_group_prefixes_rp6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigAllStaticGroupPrefixesRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_static_rp4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const DeleteConfigStaticRp4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_static_rp4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_static_rp4");
        x->args().add("group_prefix", group_prefix);
        x->args().add("rp_addr", rp_addr);
        ap_xrl_delete_config_static_rp4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, group_prefix);
    x->args().set_arg(1, rp_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_static_rp4, cb));
}


/* Unmarshall delete_config_static_rp4 */
void
XrlPimV0p1Client::unmarshall_delete_config_static_rp4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigStaticRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_all_static_group_prefixes_rp4(
	const char*	dst_xrl_target_name,
	const IPv4&	rp_addr,
	const DeleteConfigAllStaticGroupPrefixesRp4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_all_static_group_prefixes_rp4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_all_static_group_prefixes_rp4");
        x->args().add("rp_addr", rp_addr);
        ap_xrl_delete_config_all_static_group_prefixes_rp4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, rp_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_all_static_group_prefixes_rp4, cb));
}


/* Unmarshall delete_config_all_static_group_prefixes_rp4 */
void
XrlPimV0p1Client::unmarshall_delete_config_all_static_group_prefixes_rp4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigAllStaticGroupPrefixesRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_config_all_static_rps(
	const char*	dst_xrl_target_name,
	const DeleteConfigAllStaticRpsCB&	cb
)
{
    Xrl* x = ap_xrl_delete_config_all_static_rps.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_config_all_static_rps");
        ap_xrl_delete_config_all_static_rps.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_config_all_static_rps, cb));
}


/* Unmarshall delete_config_all_static_rps */
void
XrlPimV0p1Client::unmarshall_delete_config_all_static_rps(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteConfigAllStaticRpsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_config_static_rp_done(
	const char*	dst_xrl_target_name,
	const ConfigStaticRpDoneCB&	cb
)
{
    Xrl* x = ap_xrl_config_static_rp_done.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/config_static_rp_done");
        ap_xrl_config_static_rp_done.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_config_static_rp_done, cb));
}


/* Unmarshall config_static_rp_done */
void
XrlPimV0p1Client::unmarshall_config_static_rp_done(
	const XrlError&	e,
	XrlArgs*	a,
	ConfigStaticRpDoneCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_proto_version(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifProtoVersionCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_proto_version.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_proto_version");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_proto_version.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_proto_version, cb));
}


/* Unmarshall get_vif_proto_version */
void
XrlPimV0p1Client::unmarshall_get_vif_proto_version(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifProtoVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t proto_version;
    try {
	a->get("proto_version", proto_version);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &proto_version);
}

bool
XrlPimV0p1Client::send_set_vif_proto_version(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	proto_version,
	const SetVifProtoVersionCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_proto_version.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_proto_version");
        x->args().add("vif_name", vif_name);
        x->args().add("proto_version", proto_version);
        ap_xrl_set_vif_proto_version.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, proto_version);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_proto_version, cb));
}


/* Unmarshall set_vif_proto_version */
void
XrlPimV0p1Client::unmarshall_set_vif_proto_version(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifProtoVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_proto_version(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifProtoVersionCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_proto_version.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_proto_version");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_proto_version.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_proto_version, cb));
}


/* Unmarshall reset_vif_proto_version */
void
XrlPimV0p1Client::unmarshall_reset_vif_proto_version(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifProtoVersionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_hello_triggered_delay(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifHelloTriggeredDelayCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_hello_triggered_delay.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_hello_triggered_delay");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_hello_triggered_delay.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_hello_triggered_delay, cb));
}


/* Unmarshall get_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall_get_vif_hello_triggered_delay(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifHelloTriggeredDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t hello_triggered_delay;
    try {
	a->get("hello_triggered_delay", hello_triggered_delay);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &hello_triggered_delay);
}

bool
XrlPimV0p1Client::send_set_vif_hello_triggered_delay(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	hello_triggered_delay,
	const SetVifHelloTriggeredDelayCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_hello_triggered_delay.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_hello_triggered_delay");
        x->args().add("vif_name", vif_name);
        x->args().add("hello_triggered_delay", hello_triggered_delay);
        ap_xrl_set_vif_hello_triggered_delay.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, hello_triggered_delay);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_hello_triggered_delay, cb));
}


/* Unmarshall set_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall_set_vif_hello_triggered_delay(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifHelloTriggeredDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_triggered_delay(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifHelloTriggeredDelayCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_hello_triggered_delay.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_hello_triggered_delay");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_hello_triggered_delay.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_hello_triggered_delay, cb));
}


/* Unmarshall reset_vif_hello_triggered_delay */
void
XrlPimV0p1Client::unmarshall_reset_vif_hello_triggered_delay(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifHelloTriggeredDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_hello_period(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifHelloPeriodCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_hello_period.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_hello_period");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_hello_period.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_hello_period, cb));
}


/* Unmarshall get_vif_hello_period */
void
XrlPimV0p1Client::unmarshall_get_vif_hello_period(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifHelloPeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t hello_period;
    try {
	a->get("hello_period", hello_period);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &hello_period);
}

bool
XrlPimV0p1Client::send_set_vif_hello_period(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	hello_period,
	const SetVifHelloPeriodCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_hello_period.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_hello_period");
        x->args().add("vif_name", vif_name);
        x->args().add("hello_period", hello_period);
        ap_xrl_set_vif_hello_period.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, hello_period);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_hello_period, cb));
}


/* Unmarshall set_vif_hello_period */
void
XrlPimV0p1Client::unmarshall_set_vif_hello_period(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifHelloPeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_period(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifHelloPeriodCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_hello_period.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_hello_period");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_hello_period.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_hello_period, cb));
}


/* Unmarshall reset_vif_hello_period */
void
XrlPimV0p1Client::unmarshall_reset_vif_hello_period(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifHelloPeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_hello_holdtime(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifHelloHoldtimeCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_hello_holdtime.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_hello_holdtime");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_hello_holdtime.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_hello_holdtime, cb));
}


/* Unmarshall get_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall_get_vif_hello_holdtime(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifHelloHoldtimeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t hello_holdtime;
    try {
	a->get("hello_holdtime", hello_holdtime);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &hello_holdtime);
}

bool
XrlPimV0p1Client::send_set_vif_hello_holdtime(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	hello_holdtime,
	const SetVifHelloHoldtimeCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_hello_holdtime.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_hello_holdtime");
        x->args().add("vif_name", vif_name);
        x->args().add("hello_holdtime", hello_holdtime);
        ap_xrl_set_vif_hello_holdtime.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, hello_holdtime);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_hello_holdtime, cb));
}


/* Unmarshall set_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall_set_vif_hello_holdtime(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifHelloHoldtimeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_hello_holdtime(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifHelloHoldtimeCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_hello_holdtime.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_hello_holdtime");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_hello_holdtime.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_hello_holdtime, cb));
}


/* Unmarshall reset_vif_hello_holdtime */
void
XrlPimV0p1Client::unmarshall_reset_vif_hello_holdtime(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifHelloHoldtimeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_dr_priority(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifDrPriorityCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_dr_priority.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_dr_priority");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_dr_priority.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_dr_priority, cb));
}


/* Unmarshall get_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall_get_vif_dr_priority(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifDrPriorityCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t dr_priority;
    try {
	a->get("dr_priority", dr_priority);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &dr_priority);
}

bool
XrlPimV0p1Client::send_set_vif_dr_priority(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	dr_priority,
	const SetVifDrPriorityCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_dr_priority.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_dr_priority");
        x->args().add("vif_name", vif_name);
        x->args().add("dr_priority", dr_priority);
        ap_xrl_set_vif_dr_priority.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, dr_priority);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_dr_priority, cb));
}


/* Unmarshall set_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall_set_vif_dr_priority(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifDrPriorityCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_dr_priority(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifDrPriorityCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_dr_priority.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_dr_priority");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_dr_priority.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_dr_priority, cb));
}


/* Unmarshall reset_vif_dr_priority */
void
XrlPimV0p1Client::unmarshall_reset_vif_dr_priority(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifDrPriorityCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_propagation_delay(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifPropagationDelayCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_propagation_delay.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_propagation_delay");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_propagation_delay.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_propagation_delay, cb));
}


/* Unmarshall get_vif_propagation_delay */
void
XrlPimV0p1Client::unmarshall_get_vif_propagation_delay(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifPropagationDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t propagation_delay;
    try {
	a->get("propagation_delay", propagation_delay);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &propagation_delay);
}

bool
XrlPimV0p1Client::send_set_vif_propagation_delay(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	propagation_delay,
	const SetVifPropagationDelayCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_propagation_delay.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_propagation_delay");
        x->args().add("vif_name", vif_name);
        x->args().add("propagation_delay", propagation_delay);
        ap_xrl_set_vif_propagation_delay.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, propagation_delay);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_propagation_delay, cb));
}


/* Unmarshall set_vif_propagation_delay */
void
XrlPimV0p1Client::unmarshall_set_vif_propagation_delay(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifPropagationDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_propagation_delay(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifPropagationDelayCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_propagation_delay.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_propagation_delay");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_propagation_delay.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_propagation_delay, cb));
}


/* Unmarshall reset_vif_propagation_delay */
void
XrlPimV0p1Client::unmarshall_reset_vif_propagation_delay(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifPropagationDelayCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_override_interval(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifOverrideIntervalCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_override_interval.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_override_interval");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_override_interval.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_override_interval, cb));
}


/* Unmarshall get_vif_override_interval */
void
XrlPimV0p1Client::unmarshall_get_vif_override_interval(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifOverrideIntervalCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t override_interval;
    try {
	a->get("override_interval", override_interval);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &override_interval);
}

bool
XrlPimV0p1Client::send_set_vif_override_interval(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	override_interval,
	const SetVifOverrideIntervalCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_override_interval.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_override_interval");
        x->args().add("vif_name", vif_name);
        x->args().add("override_interval", override_interval);
        ap_xrl_set_vif_override_interval.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, override_interval);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_override_interval, cb));
}


/* Unmarshall set_vif_override_interval */
void
XrlPimV0p1Client::unmarshall_set_vif_override_interval(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifOverrideIntervalCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_override_interval(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifOverrideIntervalCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_override_interval.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_override_interval");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_override_interval.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_override_interval, cb));
}


/* Unmarshall reset_vif_override_interval */
void
XrlPimV0p1Client::unmarshall_reset_vif_override_interval(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifOverrideIntervalCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_is_tracking_support_disabled(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifIsTrackingSupportDisabledCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_is_tracking_support_disabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_is_tracking_support_disabled");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_is_tracking_support_disabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_is_tracking_support_disabled, cb));
}


/* Unmarshall get_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall_get_vif_is_tracking_support_disabled(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifIsTrackingSupportDisabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool is_tracking_support_disabled;
    try {
	a->get("is_tracking_support_disabled", is_tracking_support_disabled);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &is_tracking_support_disabled);
}

bool
XrlPimV0p1Client::send_set_vif_is_tracking_support_disabled(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const bool&	is_tracking_support_disabled,
	const SetVifIsTrackingSupportDisabledCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_is_tracking_support_disabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_is_tracking_support_disabled");
        x->args().add("vif_name", vif_name);
        x->args().add("is_tracking_support_disabled", is_tracking_support_disabled);
        ap_xrl_set_vif_is_tracking_support_disabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, is_tracking_support_disabled);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_is_tracking_support_disabled, cb));
}


/* Unmarshall set_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall_set_vif_is_tracking_support_disabled(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifIsTrackingSupportDisabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_is_tracking_support_disabled(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifIsTrackingSupportDisabledCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_is_tracking_support_disabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_is_tracking_support_disabled");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_is_tracking_support_disabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_is_tracking_support_disabled, cb));
}


/* Unmarshall reset_vif_is_tracking_support_disabled */
void
XrlPimV0p1Client::unmarshall_reset_vif_is_tracking_support_disabled(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifIsTrackingSupportDisabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_accept_nohello_neighbors(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifAcceptNohelloNeighborsCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_accept_nohello_neighbors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_accept_nohello_neighbors");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_accept_nohello_neighbors.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_accept_nohello_neighbors, cb));
}


/* Unmarshall get_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall_get_vif_accept_nohello_neighbors(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifAcceptNohelloNeighborsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool accept_nohello_neighbors;
    try {
	a->get("accept_nohello_neighbors", accept_nohello_neighbors);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &accept_nohello_neighbors);
}

bool
XrlPimV0p1Client::send_set_vif_accept_nohello_neighbors(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const bool&	accept_nohello_neighbors,
	const SetVifAcceptNohelloNeighborsCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_accept_nohello_neighbors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_accept_nohello_neighbors");
        x->args().add("vif_name", vif_name);
        x->args().add("accept_nohello_neighbors", accept_nohello_neighbors);
        ap_xrl_set_vif_accept_nohello_neighbors.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, accept_nohello_neighbors);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_accept_nohello_neighbors, cb));
}


/* Unmarshall set_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall_set_vif_accept_nohello_neighbors(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifAcceptNohelloNeighborsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_accept_nohello_neighbors(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifAcceptNohelloNeighborsCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_accept_nohello_neighbors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_accept_nohello_neighbors");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_accept_nohello_neighbors.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_accept_nohello_neighbors, cb));
}


/* Unmarshall reset_vif_accept_nohello_neighbors */
void
XrlPimV0p1Client::unmarshall_reset_vif_accept_nohello_neighbors(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifAcceptNohelloNeighborsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_vif_join_prune_period(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const GetVifJoinPrunePeriodCB&	cb
)
{
    Xrl* x = ap_xrl_get_vif_join_prune_period.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_vif_join_prune_period");
        x->args().add("vif_name", vif_name);
        ap_xrl_get_vif_join_prune_period.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_vif_join_prune_period, cb));
}


/* Unmarshall get_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall_get_vif_join_prune_period(
	const XrlError&	e,
	XrlArgs*	a,
	GetVifJoinPrunePeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t join_prune_period;
    try {
	a->get("join_prune_period", join_prune_period);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &join_prune_period);
}

bool
XrlPimV0p1Client::send_set_vif_join_prune_period(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const uint32_t&	join_prune_period,
	const SetVifJoinPrunePeriodCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_join_prune_period.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_vif_join_prune_period");
        x->args().add("vif_name", vif_name);
        x->args().add("join_prune_period", join_prune_period);
        ap_xrl_set_vif_join_prune_period.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, join_prune_period);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_vif_join_prune_period, cb));
}


/* Unmarshall set_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall_set_vif_join_prune_period(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifJoinPrunePeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_vif_join_prune_period(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ResetVifJoinPrunePeriodCB&	cb
)
{
    Xrl* x = ap_xrl_reset_vif_join_prune_period.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_vif_join_prune_period");
        x->args().add("vif_name", vif_name);
        ap_xrl_reset_vif_join_prune_period.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_vif_join_prune_period, cb));
}


/* Unmarshall reset_vif_join_prune_period */
void
XrlPimV0p1Client::unmarshall_reset_vif_join_prune_period(
	const XrlError&	e,
	XrlArgs*	a,
	ResetVifJoinPrunePeriodCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_get_switch_to_spt_threshold(
	const char*	dst_xrl_target_name,
	const GetSwitchToSptThresholdCB&	cb
)
{
    Xrl* x = ap_xrl_get_switch_to_spt_threshold.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/get_switch_to_spt_threshold");
        ap_xrl_get_switch_to_spt_threshold.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_get_switch_to_spt_threshold, cb));
}


/* Unmarshall get_switch_to_spt_threshold */
void
XrlPimV0p1Client::unmarshall_get_switch_to_spt_threshold(
	const XrlError&	e,
	XrlArgs*	a,
	GetSwitchToSptThresholdCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0);
	return;
    } else if (a && a->size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(3));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    bool is_enabled;
    uint32_t interval_sec;
    uint32_t bytes;
    try {
	a->get("is_enabled", is_enabled);
	a->get("interval_sec", interval_sec);
	a->get("bytes", bytes);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0);
	return;
    }
    cb->dispatch(e, &is_enabled, &interval_sec, &bytes);
}

bool
XrlPimV0p1Client::send_set_switch_to_spt_threshold(
	const char*	dst_xrl_target_name,
	const bool&	is_enabled,
	const uint32_t&	interval_sec,
	const uint32_t&	bytes,
	const SetSwitchToSptThresholdCB&	cb
)
{
    Xrl* x = ap_xrl_set_switch_to_spt_threshold.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/set_switch_to_spt_threshold");
        x->args().add("is_enabled", is_enabled);
        x->args().add("interval_sec", interval_sec);
        x->args().add("bytes", bytes);
        ap_xrl_set_switch_to_spt_threshold.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, is_enabled);
    x->args().set_arg(1, interval_sec);
    x->args().set_arg(2, bytes);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_set_switch_to_spt_threshold, cb));
}


/* Unmarshall set_switch_to_spt_threshold */
void
XrlPimV0p1Client::unmarshall_set_switch_to_spt_threshold(
	const XrlError&	e,
	XrlArgs*	a,
	SetSwitchToSptThresholdCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_reset_switch_to_spt_threshold(
	const char*	dst_xrl_target_name,
	const ResetSwitchToSptThresholdCB&	cb
)
{
    Xrl* x = ap_xrl_reset_switch_to_spt_threshold.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/reset_switch_to_spt_threshold");
        ap_xrl_reset_switch_to_spt_threshold.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_reset_switch_to_spt_threshold, cb));
}


/* Unmarshall reset_switch_to_spt_threshold */
void
XrlPimV0p1Client::unmarshall_reset_switch_to_spt_threshold(
	const XrlError&	e,
	XrlArgs*	a,
	ResetSwitchToSptThresholdCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_alternative_subnet4(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv4Net&	subnet,
	const AddAlternativeSubnet4CB&	cb
)
{
    Xrl* x = ap_xrl_add_alternative_subnet4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_alternative_subnet4");
        x->args().add("vif_name", vif_name);
        x->args().add("subnet", subnet);
        ap_xrl_add_alternative_subnet4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, subnet);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_alternative_subnet4, cb));
}


/* Unmarshall add_alternative_subnet4 */
void
XrlPimV0p1Client::unmarshall_add_alternative_subnet4(
	const XrlError&	e,
	XrlArgs*	a,
	AddAlternativeSubnet4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_alternative_subnet6(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv6Net&	subnet,
	const AddAlternativeSubnet6CB&	cb
)
{
    Xrl* x = ap_xrl_add_alternative_subnet6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_alternative_subnet6");
        x->args().add("vif_name", vif_name);
        x->args().add("subnet", subnet);
        ap_xrl_add_alternative_subnet6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, subnet);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_alternative_subnet6, cb));
}


/* Unmarshall add_alternative_subnet6 */
void
XrlPimV0p1Client::unmarshall_add_alternative_subnet6(
	const XrlError&	e,
	XrlArgs*	a,
	AddAlternativeSubnet6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_alternative_subnet6(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv6Net&	subnet,
	const DeleteAlternativeSubnet6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_alternative_subnet6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_alternative_subnet6");
        x->args().add("vif_name", vif_name);
        x->args().add("subnet", subnet);
        ap_xrl_delete_alternative_subnet6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, subnet);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_alternative_subnet6, cb));
}


/* Unmarshall delete_alternative_subnet6 */
void
XrlPimV0p1Client::unmarshall_delete_alternative_subnet6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteAlternativeSubnet6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_delete_alternative_subnet4(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv4Net&	subnet,
	const DeleteAlternativeSubnet4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_alternative_subnet4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/delete_alternative_subnet4");
        x->args().add("vif_name", vif_name);
        x->args().add("subnet", subnet);
        ap_xrl_delete_alternative_subnet4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, subnet);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_delete_alternative_subnet4, cb));
}


/* Unmarshall delete_alternative_subnet4 */
void
XrlPimV0p1Client::unmarshall_delete_alternative_subnet4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteAlternativeSubnet4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_remove_all_alternative_subnets(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const RemoveAllAlternativeSubnetsCB&	cb
)
{
    Xrl* x = ap_xrl_remove_all_alternative_subnets.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/remove_all_alternative_subnets");
        x->args().add("vif_name", vif_name);
        ap_xrl_remove_all_alternative_subnets.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_remove_all_alternative_subnets, cb));
}


/* Unmarshall remove_all_alternative_subnets */
void
XrlPimV0p1Client::unmarshall_remove_all_alternative_subnets(
	const XrlError&	e,
	XrlArgs*	a,
	RemoveAllAlternativeSubnetsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_log_trace_all(
	const char*	dst_xrl_target_name,
	const bool&	enable,
	const LogTraceAllCB&	cb
)
{
    Xrl* x = ap_xrl_log_trace_all.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/log_trace_all");
        x->args().add("enable", enable);
        ap_xrl_log_trace_all.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, enable);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_log_trace_all, cb));
}


/* Unmarshall log_trace_all */
void
XrlPimV0p1Client::unmarshall_log_trace_all(
	const XrlError&	e,
	XrlArgs*	a,
	LogTraceAllCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_jp_entry4(
	const char*	dst_xrl_target_name,
	const IPv4&	source_addr,
	const IPv4&	group_addr,
	const uint32_t&	group_mask_len,
	const string&	mrt_entry_type,
	const string&	action_jp,
	const uint32_t&	holdtime,
	const bool&	is_new_group,
	const AddTestJpEntry4CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_jp_entry4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_jp_entry4");
        x->args().add("source_addr", source_addr);
        x->args().add("group_addr", group_addr);
        x->args().add("group_mask_len", group_mask_len);
        x->args().add("mrt_entry_type", mrt_entry_type);
        x->args().add("action_jp", action_jp);
        x->args().add("holdtime", holdtime);
        x->args().add("is_new_group", is_new_group);
        ap_xrl_add_test_jp_entry4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, source_addr);
    x->args().set_arg(1, group_addr);
    x->args().set_arg(2, group_mask_len);
    x->args().set_arg(3, mrt_entry_type);
    x->args().set_arg(4, action_jp);
    x->args().set_arg(5, holdtime);
    x->args().set_arg(6, is_new_group);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_jp_entry4, cb));
}


/* Unmarshall add_test_jp_entry4 */
void
XrlPimV0p1Client::unmarshall_add_test_jp_entry4(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestJpEntry4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_jp_entry6(
	const char*	dst_xrl_target_name,
	const IPv6&	source_addr,
	const IPv6&	group_addr,
	const uint32_t&	group_mask_len,
	const string&	mrt_entry_type,
	const string&	action_jp,
	const uint32_t&	holdtime,
	const bool&	is_new_group,
	const AddTestJpEntry6CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_jp_entry6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_jp_entry6");
        x->args().add("source_addr", source_addr);
        x->args().add("group_addr", group_addr);
        x->args().add("group_mask_len", group_mask_len);
        x->args().add("mrt_entry_type", mrt_entry_type);
        x->args().add("action_jp", action_jp);
        x->args().add("holdtime", holdtime);
        x->args().add("is_new_group", is_new_group);
        ap_xrl_add_test_jp_entry6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, source_addr);
    x->args().set_arg(1, group_addr);
    x->args().set_arg(2, group_mask_len);
    x->args().set_arg(3, mrt_entry_type);
    x->args().set_arg(4, action_jp);
    x->args().set_arg(5, holdtime);
    x->args().set_arg(6, is_new_group);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_jp_entry6, cb));
}


/* Unmarshall add_test_jp_entry6 */
void
XrlPimV0p1Client::unmarshall_add_test_jp_entry6(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestJpEntry6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_jp_entry6(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv6&	nbr_addr,
	const SendTestJpEntry6CB&	cb
)
{
    Xrl* x = ap_xrl_send_test_jp_entry6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_jp_entry6");
        x->args().add("vif_name", vif_name);
        x->args().add("nbr_addr", nbr_addr);
        ap_xrl_send_test_jp_entry6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, nbr_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_jp_entry6, cb));
}


/* Unmarshall send_test_jp_entry6 */
void
XrlPimV0p1Client::unmarshall_send_test_jp_entry6(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestJpEntry6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_jp_entry4(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv4&	nbr_addr,
	const SendTestJpEntry4CB&	cb
)
{
    Xrl* x = ap_xrl_send_test_jp_entry4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_jp_entry4");
        x->args().add("vif_name", vif_name);
        x->args().add("nbr_addr", nbr_addr);
        ap_xrl_send_test_jp_entry4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, nbr_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_jp_entry4, cb));
}


/* Unmarshall send_test_jp_entry4 */
void
XrlPimV0p1Client::unmarshall_send_test_jp_entry4(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestJpEntry4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_assert4(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv4&	source_addr,
	const IPv4&	group_addr,
	const bool&	rpt_bit,
	const uint32_t&	metric_preference,
	const uint32_t&	metric,
	const SendTestAssert4CB&	cb
)
{
    Xrl* x = ap_xrl_send_test_assert4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_assert4");
        x->args().add("vif_name", vif_name);
        x->args().add("source_addr", source_addr);
        x->args().add("group_addr", group_addr);
        x->args().add("rpt_bit", rpt_bit);
        x->args().add("metric_preference", metric_preference);
        x->args().add("metric", metric);
        ap_xrl_send_test_assert4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, source_addr);
    x->args().set_arg(2, group_addr);
    x->args().set_arg(3, rpt_bit);
    x->args().set_arg(4, metric_preference);
    x->args().set_arg(5, metric);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_assert4, cb));
}


/* Unmarshall send_test_assert4 */
void
XrlPimV0p1Client::unmarshall_send_test_assert4(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestAssert4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_assert6(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv6&	source_addr,
	const IPv6&	group_addr,
	const bool&	rpt_bit,
	const uint32_t&	metric_preference,
	const uint32_t&	metric,
	const SendTestAssert6CB&	cb
)
{
    Xrl* x = ap_xrl_send_test_assert6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_assert6");
        x->args().add("vif_name", vif_name);
        x->args().add("source_addr", source_addr);
        x->args().add("group_addr", group_addr);
        x->args().add("rpt_bit", rpt_bit);
        x->args().add("metric_preference", metric_preference);
        x->args().add("metric", metric);
        ap_xrl_send_test_assert6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, source_addr);
    x->args().set_arg(2, group_addr);
    x->args().set_arg(3, rpt_bit);
    x->args().set_arg(4, metric_preference);
    x->args().set_arg(5, metric);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_assert6, cb));
}


/* Unmarshall send_test_assert6 */
void
XrlPimV0p1Client::unmarshall_send_test_assert6(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestAssert6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_zone4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4&	bsr_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const uint32_t&	fragment_tag,
	const AddTestBsrZone4CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_bsr_zone4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_bsr_zone4");
        x->args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
        x->args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
        x->args().add("bsr_addr", bsr_addr);
        x->args().add("bsr_priority", bsr_priority);
        x->args().add("hash_mask_len", hash_mask_len);
        x->args().add("fragment_tag", fragment_tag);
        ap_xrl_add_test_bsr_zone4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, zone_id_scope_zone_prefix);
    x->args().set_arg(1, zone_id_is_scope_zone);
    x->args().set_arg(2, bsr_addr);
    x->args().set_arg(3, bsr_priority);
    x->args().set_arg(4, hash_mask_len);
    x->args().set_arg(5, fragment_tag);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_bsr_zone4, cb));
}


/* Unmarshall add_test_bsr_zone4 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_zone4(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestBsrZone4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_zone6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6&	bsr_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const uint32_t&	fragment_tag,
	const AddTestBsrZone6CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_bsr_zone6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_bsr_zone6");
        x->args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
        x->args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
        x->args().add("bsr_addr", bsr_addr);
        x->args().add("bsr_priority", bsr_priority);
        x->args().add("hash_mask_len", hash_mask_len);
        x->args().add("fragment_tag", fragment_tag);
        ap_xrl_add_test_bsr_zone6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, zone_id_scope_zone_prefix);
    x->args().set_arg(1, zone_id_is_scope_zone);
    x->args().set_arg(2, bsr_addr);
    x->args().set_arg(3, bsr_priority);
    x->args().set_arg(4, hash_mask_len);
    x->args().set_arg(5, fragment_tag);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_bsr_zone6, cb));
}


/* Unmarshall add_test_bsr_zone6 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_zone6(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestBsrZone6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_group_prefix6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const uint32_t&	expected_rp_count,
	const AddTestBsrGroupPrefix6CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_bsr_group_prefix6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_bsr_group_prefix6");
        x->args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
        x->args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
        x->args().add("group_prefix", group_prefix);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("expected_rp_count", expected_rp_count);
        ap_xrl_add_test_bsr_group_prefix6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, zone_id_scope_zone_prefix);
    x->args().set_arg(1, zone_id_is_scope_zone);
    x->args().set_arg(2, group_prefix);
    x->args().set_arg(3, is_scope_zone);
    x->args().set_arg(4, expected_rp_count);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix6, cb));
}


/* Unmarshall add_test_bsr_group_prefix6 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix6(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestBsrGroupPrefix6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_rp6(
	const char*	dst_xrl_target_name,
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	const AddTestBsrRp6CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_bsr_rp6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_bsr_rp6");
        x->args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
        x->args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
        x->args().add("group_prefix", group_prefix);
        x->args().add("rp_addr", rp_addr);
        x->args().add("rp_priority", rp_priority);
        x->args().add("rp_holdtime", rp_holdtime);
        ap_xrl_add_test_bsr_rp6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, zone_id_scope_zone_prefix);
    x->args().set_arg(1, zone_id_is_scope_zone);
    x->args().set_arg(2, group_prefix);
    x->args().set_arg(3, rp_addr);
    x->args().set_arg(4, rp_priority);
    x->args().set_arg(5, rp_holdtime);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_bsr_rp6, cb));
}


/* Unmarshall add_test_bsr_rp6 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_rp6(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestBsrRp6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_bootstrap_by_dest6(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv6&	dest_addr,
	const SendTestBootstrapByDest6CB&	cb
)
{
    Xrl* x = ap_xrl_send_test_bootstrap_by_dest6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_bootstrap_by_dest6");
        x->args().add("vif_name", vif_name);
        x->args().add("dest_addr", dest_addr);
        ap_xrl_send_test_bootstrap_by_dest6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, dest_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest6, cb));
}


/* Unmarshall send_test_bootstrap_by_dest6 */
void
XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest6(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestBootstrapByDest6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_group_prefix4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const uint32_t&	expected_rp_count,
	const AddTestBsrGroupPrefix4CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_bsr_group_prefix4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_bsr_group_prefix4");
        x->args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
        x->args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
        x->args().add("group_prefix", group_prefix);
        x->args().add("is_scope_zone", is_scope_zone);
        x->args().add("expected_rp_count", expected_rp_count);
        ap_xrl_add_test_bsr_group_prefix4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, zone_id_scope_zone_prefix);
    x->args().set_arg(1, zone_id_is_scope_zone);
    x->args().set_arg(2, group_prefix);
    x->args().set_arg(3, is_scope_zone);
    x->args().set_arg(4, expected_rp_count);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix4, cb));
}


/* Unmarshall add_test_bsr_group_prefix4 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_group_prefix4(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestBsrGroupPrefix4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_add_test_bsr_rp4(
	const char*	dst_xrl_target_name,
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	const AddTestBsrRp4CB&	cb
)
{
    Xrl* x = ap_xrl_add_test_bsr_rp4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/add_test_bsr_rp4");
        x->args().add("zone_id_scope_zone_prefix", zone_id_scope_zone_prefix);
        x->args().add("zone_id_is_scope_zone", zone_id_is_scope_zone);
        x->args().add("group_prefix", group_prefix);
        x->args().add("rp_addr", rp_addr);
        x->args().add("rp_priority", rp_priority);
        x->args().add("rp_holdtime", rp_holdtime);
        ap_xrl_add_test_bsr_rp4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, zone_id_scope_zone_prefix);
    x->args().set_arg(1, zone_id_is_scope_zone);
    x->args().set_arg(2, group_prefix);
    x->args().set_arg(3, rp_addr);
    x->args().set_arg(4, rp_priority);
    x->args().set_arg(5, rp_holdtime);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_add_test_bsr_rp4, cb));
}


/* Unmarshall add_test_bsr_rp4 */
void
XrlPimV0p1Client::unmarshall_add_test_bsr_rp4(
	const XrlError&	e,
	XrlArgs*	a,
	AddTestBsrRp4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_bootstrap(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const SendTestBootstrapCB&	cb
)
{
    Xrl* x = ap_xrl_send_test_bootstrap.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_bootstrap");
        x->args().add("vif_name", vif_name);
        ap_xrl_send_test_bootstrap.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_bootstrap, cb));
}


/* Unmarshall send_test_bootstrap */
void
XrlPimV0p1Client::unmarshall_send_test_bootstrap(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestBootstrapCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_bootstrap_by_dest4(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const IPv4&	dest_addr,
	const SendTestBootstrapByDest4CB&	cb
)
{
    Xrl* x = ap_xrl_send_test_bootstrap_by_dest4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_bootstrap_by_dest4");
        x->args().add("vif_name", vif_name);
        x->args().add("dest_addr", dest_addr);
        ap_xrl_send_test_bootstrap_by_dest4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);
    x->args().set_arg(1, dest_addr);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest4, cb));
}


/* Unmarshall send_test_bootstrap_by_dest4 */
void
XrlPimV0p1Client::unmarshall_send_test_bootstrap_by_dest4(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestBootstrapByDest4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_send_test_cand_rp_adv(
	const char*	dst_xrl_target_name,
	const SendTestCandRpAdvCB&	cb
)
{
    Xrl* x = ap_xrl_send_test_cand_rp_adv.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/send_test_cand_rp_adv");
        ap_xrl_send_test_cand_rp_adv.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_send_test_cand_rp_adv, cb));
}


/* Unmarshall send_test_cand_rp_adv */
void
XrlPimV0p1Client::unmarshall_send_test_cand_rp_adv(
	const XrlError&	e,
	XrlArgs*	a,
	SendTestCandRpAdvCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_pimstat_neighbors4(
	const char*	dst_xrl_target_name,
	const PimstatNeighbors4CB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_neighbors4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_neighbors4");
        ap_xrl_pimstat_neighbors4.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_neighbors4, cb));
}


/* Unmarshall pimstat_neighbors4 */
void
XrlPimV0p1Client::unmarshall_pimstat_neighbors4(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNeighbors4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 8) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(8));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    uint32_t nbrs_number;
    XrlAtomList vifs;
    XrlAtomList addresses;
    XrlAtomList pim_versions;
    XrlAtomList dr_priorities;
    XrlAtomList holdtimes;
    XrlAtomList timeouts;
    XrlAtomList uptimes;
    try {
	a->get("nbrs_number", nbrs_number);
	a->get("vifs", vifs);
	a->get("addresses", addresses);
	a->get("pim_versions", pim_versions);
	a->get("dr_priorities", dr_priorities);
	a->get("holdtimes", holdtimes);
	a->get("timeouts", timeouts);
	a->get("uptimes", uptimes);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &nbrs_number, &vifs, &addresses, &pim_versions, &dr_priorities, &holdtimes, &timeouts, &uptimes);
}

bool
XrlPimV0p1Client::send_pimstat_neighbors6(
	const char*	dst_xrl_target_name,
	const PimstatNeighbors6CB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_neighbors6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_neighbors6");
        ap_xrl_pimstat_neighbors6.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_neighbors6, cb));
}


/* Unmarshall pimstat_neighbors6 */
void
XrlPimV0p1Client::unmarshall_pimstat_neighbors6(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNeighbors6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 8) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(8));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    uint32_t nbrs_number;
    XrlAtomList vifs;
    XrlAtomList addresses;
    XrlAtomList pim_versions;
    XrlAtomList dr_priorities;
    XrlAtomList holdtimes;
    XrlAtomList timeouts;
    XrlAtomList uptimes;
    try {
	a->get("nbrs_number", nbrs_number);
	a->get("vifs", vifs);
	a->get("addresses", addresses);
	a->get("pim_versions", pim_versions);
	a->get("dr_priorities", dr_priorities);
	a->get("holdtimes", holdtimes);
	a->get("timeouts", timeouts);
	a->get("uptimes", uptimes);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &nbrs_number, &vifs, &addresses, &pim_versions, &dr_priorities, &holdtimes, &timeouts, &uptimes);
}

bool
XrlPimV0p1Client::send_pimstat_interface4(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatInterface4CB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_interface4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_interface4");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_interface4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_interface4, cb));
}


/* Unmarshall pimstat_interface4 */
void
XrlPimV0p1Client::unmarshall_pimstat_interface4(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatInterface4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(5));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    uint32_t pim_version;
    bool is_dr;
    uint32_t dr_priority;
    IPv4 dr_address;
    uint32_t pim_nbrs_number;
    try {
	a->get("pim_version", pim_version);
	a->get("is_dr", is_dr);
	a->get("dr_priority", dr_priority);
	a->get("dr_address", dr_address);
	a->get("pim_nbrs_number", pim_nbrs_number);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &pim_version, &is_dr, &dr_priority, &dr_address, &pim_nbrs_number);
}

bool
XrlPimV0p1Client::send_pimstat_interface6(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatInterface6CB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_interface6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_interface6");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_interface6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_interface6, cb));
}


/* Unmarshall pimstat_interface6 */
void
XrlPimV0p1Client::unmarshall_pimstat_interface6(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatInterface6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(5));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    uint32_t pim_version;
    bool is_dr;
    uint32_t dr_priority;
    IPv6 dr_address;
    uint32_t pim_nbrs_number;
    try {
	a->get("pim_version", pim_version);
	a->get("is_dr", is_dr);
	a->get("dr_priority", dr_priority);
	a->get("dr_address", dr_address);
	a->get("pim_nbrs_number", pim_nbrs_number);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &pim_version, &is_dr, &dr_priority, &dr_address, &pim_nbrs_number);
}

bool
XrlPimV0p1Client::send_pimstat_rps4(
	const char*	dst_xrl_target_name,
	const PimstatRps4CB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rps4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rps4");
        ap_xrl_pimstat_rps4.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rps4, cb));
}


/* Unmarshall pimstat_rps4 */
void
XrlPimV0p1Client::unmarshall_pimstat_rps4(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRps4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(7));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    uint32_t rps_number;
    XrlAtomList addresses;
    XrlAtomList types;
    XrlAtomList priorities;
    XrlAtomList holdtimes;
    XrlAtomList timeouts;
    XrlAtomList group_prefixes;
    try {
	a->get("rps_number", rps_number);
	a->get("addresses", addresses);
	a->get("types", types);
	a->get("priorities", priorities);
	a->get("holdtimes", holdtimes);
	a->get("timeouts", timeouts);
	a->get("group_prefixes", group_prefixes);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &rps_number, &addresses, &types, &priorities, &holdtimes, &timeouts, &group_prefixes);
}

bool
XrlPimV0p1Client::send_pimstat_rps6(
	const char*	dst_xrl_target_name,
	const PimstatRps6CB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rps6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rps6");
        ap_xrl_pimstat_rps6.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rps6, cb));
}


/* Unmarshall pimstat_rps6 */
void
XrlPimV0p1Client::unmarshall_pimstat_rps6(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRps6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(7));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    uint32_t rps_number;
    XrlAtomList addresses;
    XrlAtomList types;
    XrlAtomList priorities;
    XrlAtomList holdtimes;
    XrlAtomList timeouts;
    XrlAtomList group_prefixes;
    try {
	a->get("rps_number", rps_number);
	a->get("addresses", addresses);
	a->get("types", types);
	a->get("priorities", priorities);
	a->get("holdtimes", holdtimes);
	a->get("timeouts", timeouts);
	a->get("group_prefixes", group_prefixes);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &rps_number, &addresses, &types, &priorities, &holdtimes, &timeouts, &group_prefixes);
}

bool
XrlPimV0p1Client::send_clear_pim_statistics(
	const char*	dst_xrl_target_name,
	const ClearPimStatisticsCB&	cb
)
{
    Xrl* x = ap_xrl_clear_pim_statistics.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/clear_pim_statistics");
        ap_xrl_clear_pim_statistics.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_clear_pim_statistics, cb));
}


/* Unmarshall clear_pim_statistics */
void
XrlPimV0p1Client::unmarshall_clear_pim_statistics(
	const XrlError&	e,
	XrlArgs*	a,
	ClearPimStatisticsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_clear_pim_statistics_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const ClearPimStatisticsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_clear_pim_statistics_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/clear_pim_statistics_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_clear_pim_statistics_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_clear_pim_statistics_per_vif, cb));
}


/* Unmarshall clear_pim_statistics_per_vif */
void
XrlPimV0p1Client::unmarshall_clear_pim_statistics_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	ClearPimStatisticsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlPimV0p1Client::send_pimstat_hello_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatHelloMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_hello_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_hello_messages_received");
        ap_xrl_pimstat_hello_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_hello_messages_received, cb));
}


/* Unmarshall pimstat_hello_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_hello_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatHelloMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_hello_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatHelloMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_hello_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_hello_messages_sent");
        ap_xrl_pimstat_hello_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_hello_messages_sent, cb));
}


/* Unmarshall pimstat_hello_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_hello_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatHelloMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_hello_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatHelloMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_hello_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_hello_messages_rx_errors");
        ap_xrl_pimstat_hello_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_hello_messages_rx_errors, cb));
}


/* Unmarshall pimstat_hello_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_hello_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatHelloMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatRegisterMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_messages_received");
        ap_xrl_pimstat_register_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_messages_received, cb));
}


/* Unmarshall pimstat_register_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_register_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatRegisterMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_messages_sent");
        ap_xrl_pimstat_register_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_messages_sent, cb));
}


/* Unmarshall pimstat_register_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_register_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatRegisterMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_messages_rx_errors");
        ap_xrl_pimstat_register_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_messages_rx_errors, cb));
}


/* Unmarshall pimstat_register_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_register_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_stop_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatRegisterStopMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_stop_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_stop_messages_received");
        ap_xrl_pimstat_register_stop_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_received, cb));
}


/* Unmarshall pimstat_register_stop_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterStopMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_stop_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatRegisterStopMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_stop_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_stop_messages_sent");
        ap_xrl_pimstat_register_stop_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_sent, cb));
}


/* Unmarshall pimstat_register_stop_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterStopMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_stop_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatRegisterStopMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_stop_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_stop_messages_rx_errors");
        ap_xrl_pimstat_register_stop_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_rx_errors, cb));
}


/* Unmarshall pimstat_register_stop_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterStopMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_join_prune_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatJoinPruneMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_join_prune_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_join_prune_messages_received");
        ap_xrl_pimstat_join_prune_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_received, cb));
}


/* Unmarshall pimstat_join_prune_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatJoinPruneMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_join_prune_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatJoinPruneMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_join_prune_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_join_prune_messages_sent");
        ap_xrl_pimstat_join_prune_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_sent, cb));
}


/* Unmarshall pimstat_join_prune_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatJoinPruneMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_join_prune_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatJoinPruneMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_join_prune_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_join_prune_messages_rx_errors");
        ap_xrl_pimstat_join_prune_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_rx_errors, cb));
}


/* Unmarshall pimstat_join_prune_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatJoinPruneMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bootstrap_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatBootstrapMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bootstrap_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bootstrap_messages_received");
        ap_xrl_pimstat_bootstrap_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_received, cb));
}


/* Unmarshall pimstat_bootstrap_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBootstrapMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bootstrap_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatBootstrapMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bootstrap_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bootstrap_messages_sent");
        ap_xrl_pimstat_bootstrap_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_sent, cb));
}


/* Unmarshall pimstat_bootstrap_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBootstrapMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bootstrap_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatBootstrapMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bootstrap_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bootstrap_messages_rx_errors");
        ap_xrl_pimstat_bootstrap_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_rx_errors, cb));
}


/* Unmarshall pimstat_bootstrap_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBootstrapMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_assert_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatAssertMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_assert_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_assert_messages_received");
        ap_xrl_pimstat_assert_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_assert_messages_received, cb));
}


/* Unmarshall pimstat_assert_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_assert_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatAssertMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_assert_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatAssertMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_assert_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_assert_messages_sent");
        ap_xrl_pimstat_assert_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_assert_messages_sent, cb));
}


/* Unmarshall pimstat_assert_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_assert_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatAssertMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_assert_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatAssertMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_assert_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_assert_messages_rx_errors");
        ap_xrl_pimstat_assert_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_assert_messages_rx_errors, cb));
}


/* Unmarshall pimstat_assert_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_assert_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatAssertMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatGraftMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_messages_received");
        ap_xrl_pimstat_graft_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_messages_received, cb));
}


/* Unmarshall pimstat_graft_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatGraftMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_messages_sent");
        ap_xrl_pimstat_graft_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_messages_sent, cb));
}


/* Unmarshall pimstat_graft_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatGraftMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_messages_rx_errors");
        ap_xrl_pimstat_graft_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_messages_rx_errors, cb));
}


/* Unmarshall pimstat_graft_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_ack_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatGraftAckMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_ack_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_ack_messages_received");
        ap_xrl_pimstat_graft_ack_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_received, cb));
}


/* Unmarshall pimstat_graft_ack_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftAckMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_ack_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatGraftAckMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_ack_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_ack_messages_sent");
        ap_xrl_pimstat_graft_ack_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_sent, cb));
}


/* Unmarshall pimstat_graft_ack_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftAckMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_ack_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatGraftAckMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_ack_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_ack_messages_rx_errors");
        ap_xrl_pimstat_graft_ack_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_rx_errors, cb));
}


/* Unmarshall pimstat_graft_ack_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftAckMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_candidate_rp_messages_received(
	const char*	dst_xrl_target_name,
	const PimstatCandidateRpMessagesReceivedCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_candidate_rp_messages_received.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_candidate_rp_messages_received");
        ap_xrl_pimstat_candidate_rp_messages_received.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_received, cb));
}


/* Unmarshall pimstat_candidate_rp_messages_received */
void
XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_received(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatCandidateRpMessagesReceivedCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_candidate_rp_messages_sent(
	const char*	dst_xrl_target_name,
	const PimstatCandidateRpMessagesSentCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_candidate_rp_messages_sent.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_candidate_rp_messages_sent");
        ap_xrl_pimstat_candidate_rp_messages_sent.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_sent, cb));
}


/* Unmarshall pimstat_candidate_rp_messages_sent */
void
XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_sent(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatCandidateRpMessagesSentCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_candidate_rp_messages_rx_errors(
	const char*	dst_xrl_target_name,
	const PimstatCandidateRpMessagesRxErrorsCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_candidate_rp_messages_rx_errors.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_candidate_rp_messages_rx_errors");
        ap_xrl_pimstat_candidate_rp_messages_rx_errors.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_rx_errors, cb));
}


/* Unmarshall pimstat_candidate_rp_messages_rx_errors */
void
XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_rx_errors(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatCandidateRpMessagesRxErrorsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_unknown_type_messages(
	const char*	dst_xrl_target_name,
	const PimstatUnknownTypeMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_unknown_type_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_unknown_type_messages");
        ap_xrl_pimstat_unknown_type_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_unknown_type_messages, cb));
}


/* Unmarshall pimstat_unknown_type_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_unknown_type_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatUnknownTypeMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_unknown_version_messages(
	const char*	dst_xrl_target_name,
	const PimstatUnknownVersionMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_unknown_version_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_unknown_version_messages");
        ap_xrl_pimstat_unknown_version_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_unknown_version_messages, cb));
}


/* Unmarshall pimstat_unknown_version_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_unknown_version_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatUnknownVersionMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_neighbor_unknown_messages(
	const char*	dst_xrl_target_name,
	const PimstatNeighborUnknownMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_neighbor_unknown_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_neighbor_unknown_messages");
        ap_xrl_pimstat_neighbor_unknown_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_neighbor_unknown_messages, cb));
}


/* Unmarshall pimstat_neighbor_unknown_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_neighbor_unknown_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNeighborUnknownMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bad_length_messages(
	const char*	dst_xrl_target_name,
	const PimstatBadLengthMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bad_length_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bad_length_messages");
        ap_xrl_pimstat_bad_length_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bad_length_messages, cb));
}


/* Unmarshall pimstat_bad_length_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_bad_length_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBadLengthMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bad_checksum_messages(
	const char*	dst_xrl_target_name,
	const PimstatBadChecksumMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bad_checksum_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bad_checksum_messages");
        ap_xrl_pimstat_bad_checksum_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bad_checksum_messages, cb));
}


/* Unmarshall pimstat_bad_checksum_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_bad_checksum_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBadChecksumMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bad_receive_interface_messages(
	const char*	dst_xrl_target_name,
	const PimstatBadReceiveInterfaceMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bad_receive_interface_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bad_receive_interface_messages");
        ap_xrl_pimstat_bad_receive_interface_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bad_receive_interface_messages, cb));
}


/* Unmarshall pimstat_bad_receive_interface_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_bad_receive_interface_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBadReceiveInterfaceMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_interface_disabled_messages(
	const char*	dst_xrl_target_name,
	const PimstatRxInterfaceDisabledMessagesCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_interface_disabled_messages.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_interface_disabled_messages");
        ap_xrl_pimstat_rx_interface_disabled_messages.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_interface_disabled_messages, cb));
}


/* Unmarshall pimstat_rx_interface_disabled_messages */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_interface_disabled_messages(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxInterfaceDisabledMessagesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_register_not_rp(
	const char*	dst_xrl_target_name,
	const PimstatRxRegisterNotRpCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_register_not_rp.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_register_not_rp");
        ap_xrl_pimstat_rx_register_not_rp.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_register_not_rp, cb));
}


/* Unmarshall pimstat_rx_register_not_rp */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_register_not_rp(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxRegisterNotRpCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rp_filtered_source(
	const char*	dst_xrl_target_name,
	const PimstatRpFilteredSourceCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rp_filtered_source.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rp_filtered_source");
        ap_xrl_pimstat_rp_filtered_source.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rp_filtered_source, cb));
}


/* Unmarshall pimstat_rp_filtered_source */
void
XrlPimV0p1Client::unmarshall_pimstat_rp_filtered_source(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRpFilteredSourceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_unknown_register_stop(
	const char*	dst_xrl_target_name,
	const PimstatUnknownRegisterStopCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_unknown_register_stop.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_unknown_register_stop");
        ap_xrl_pimstat_unknown_register_stop.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_unknown_register_stop, cb));
}


/* Unmarshall pimstat_unknown_register_stop */
void
XrlPimV0p1Client::unmarshall_pimstat_unknown_register_stop(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatUnknownRegisterStopCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_prune_no_state(
	const char*	dst_xrl_target_name,
	const PimstatRxJoinPruneNoStateCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_prune_no_state.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_prune_no_state");
        ap_xrl_pimstat_rx_join_prune_no_state.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_prune_no_state, cb));
}


/* Unmarshall pimstat_rx_join_prune_no_state */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_prune_no_state(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinPruneNoStateCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_graft_graft_ack_no_state(
	const char*	dst_xrl_target_name,
	const PimstatRxGraftGraftAckNoStateCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_graft_graft_ack_no_state.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_graft_graft_ack_no_state");
        ap_xrl_pimstat_rx_graft_graft_ack_no_state.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_graft_graft_ack_no_state, cb));
}


/* Unmarshall pimstat_rx_graft_graft_ack_no_state */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_graft_graft_ack_no_state(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxGraftGraftAckNoStateCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_graft_on_upstream_interface(
	const char*	dst_xrl_target_name,
	const PimstatRxGraftOnUpstreamInterfaceCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_graft_on_upstream_interface.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_graft_on_upstream_interface");
        ap_xrl_pimstat_rx_graft_on_upstream_interface.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_graft_on_upstream_interface, cb));
}


/* Unmarshall pimstat_rx_graft_on_upstream_interface */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_graft_on_upstream_interface(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxGraftOnUpstreamInterfaceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_candidate_rp_not_bsr(
	const char*	dst_xrl_target_name,
	const PimstatRxCandidateRpNotBsrCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_candidate_rp_not_bsr.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_candidate_rp_not_bsr");
        ap_xrl_pimstat_rx_candidate_rp_not_bsr.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_candidate_rp_not_bsr, cb));
}


/* Unmarshall pimstat_rx_candidate_rp_not_bsr */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_candidate_rp_not_bsr(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxCandidateRpNotBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_bsr_when_bsr(
	const char*	dst_xrl_target_name,
	const PimstatRxBsrWhenBsrCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_bsr_when_bsr.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_bsr_when_bsr");
        ap_xrl_pimstat_rx_bsr_when_bsr.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_when_bsr, cb));
}


/* Unmarshall pimstat_rx_bsr_when_bsr */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_when_bsr(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxBsrWhenBsrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_bsr_not_rpf_interface(
	const char*	dst_xrl_target_name,
	const PimstatRxBsrNotRpfInterfaceCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_bsr_not_rpf_interface.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_bsr_not_rpf_interface");
        ap_xrl_pimstat_rx_bsr_not_rpf_interface.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_not_rpf_interface, cb));
}


/* Unmarshall pimstat_rx_bsr_not_rpf_interface */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_not_rpf_interface(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxBsrNotRpfInterfaceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_unknown_hello_option(
	const char*	dst_xrl_target_name,
	const PimstatRxUnknownHelloOptionCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_unknown_hello_option.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_unknown_hello_option");
        ap_xrl_pimstat_rx_unknown_hello_option.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_unknown_hello_option, cb));
}


/* Unmarshall pimstat_rx_unknown_hello_option */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_unknown_hello_option(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxUnknownHelloOptionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_data_no_state(
	const char*	dst_xrl_target_name,
	const PimstatRxDataNoStateCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_data_no_state.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_data_no_state");
        ap_xrl_pimstat_rx_data_no_state.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_data_no_state, cb));
}


/* Unmarshall pimstat_rx_data_no_state */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_data_no_state(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxDataNoStateCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_rp_no_state(
	const char*	dst_xrl_target_name,
	const PimstatRxRpNoStateCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_rp_no_state.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_rp_no_state");
        ap_xrl_pimstat_rx_rp_no_state.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_rp_no_state, cb));
}


/* Unmarshall pimstat_rx_rp_no_state */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_rp_no_state(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxRpNoStateCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_aggregate(
	const char*	dst_xrl_target_name,
	const PimstatRxAggregateCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_aggregate.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_aggregate");
        ap_xrl_pimstat_rx_aggregate.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_aggregate, cb));
}


/* Unmarshall pimstat_rx_aggregate */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_aggregate(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxAggregateCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_malformed_packet(
	const char*	dst_xrl_target_name,
	const PimstatRxMalformedPacketCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_malformed_packet.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_malformed_packet");
        ap_xrl_pimstat_rx_malformed_packet.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_malformed_packet, cb));
}


/* Unmarshall pimstat_rx_malformed_packet */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_malformed_packet(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxMalformedPacketCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_no_rp(
	const char*	dst_xrl_target_name,
	const PimstatNoRpCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_no_rp.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_no_rp");
        ap_xrl_pimstat_no_rp.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_no_rp, cb));
}


/* Unmarshall pimstat_no_rp */
void
XrlPimV0p1Client::unmarshall_pimstat_no_rp(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNoRpCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_no_route_upstream(
	const char*	dst_xrl_target_name,
	const PimstatNoRouteUpstreamCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_no_route_upstream.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_no_route_upstream");
        ap_xrl_pimstat_no_route_upstream.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_no_route_upstream, cb));
}


/* Unmarshall pimstat_no_route_upstream */
void
XrlPimV0p1Client::unmarshall_pimstat_no_route_upstream(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNoRouteUpstreamCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rp_mismatch(
	const char*	dst_xrl_target_name,
	const PimstatRpMismatchCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rp_mismatch.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rp_mismatch");
        ap_xrl_pimstat_rp_mismatch.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rp_mismatch, cb));
}


/* Unmarshall pimstat_rp_mismatch */
void
XrlPimV0p1Client::unmarshall_pimstat_rp_mismatch(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRpMismatchCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rpf_neighbor_unknown(
	const char*	dst_xrl_target_name,
	const PimstatRpfNeighborUnknownCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rpf_neighbor_unknown.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rpf_neighbor_unknown");
        ap_xrl_pimstat_rpf_neighbor_unknown.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rpf_neighbor_unknown, cb));
}


/* Unmarshall pimstat_rpf_neighbor_unknown */
void
XrlPimV0p1Client::unmarshall_pimstat_rpf_neighbor_unknown(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRpfNeighborUnknownCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_rp(
	const char*	dst_xrl_target_name,
	const PimstatRxJoinRpCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_rp.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_rp");
        ap_xrl_pimstat_rx_join_rp.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_rp, cb));
}


/* Unmarshall pimstat_rx_join_rp */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_rp(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinRpCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_rp(
	const char*	dst_xrl_target_name,
	const PimstatRxPruneRpCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_rp.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_rp");
        ap_xrl_pimstat_rx_prune_rp.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_rp, cb));
}


/* Unmarshall pimstat_rx_prune_rp */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_rp(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneRpCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_wc(
	const char*	dst_xrl_target_name,
	const PimstatRxJoinWcCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_wc.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_wc");
        ap_xrl_pimstat_rx_join_wc.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_wc, cb));
}


/* Unmarshall pimstat_rx_join_wc */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_wc(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinWcCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_wc(
	const char*	dst_xrl_target_name,
	const PimstatRxPruneWcCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_wc.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_wc");
        ap_xrl_pimstat_rx_prune_wc.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_wc, cb));
}


/* Unmarshall pimstat_rx_prune_wc */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_wc(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneWcCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_sg(
	const char*	dst_xrl_target_name,
	const PimstatRxJoinSgCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_sg.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_sg");
        ap_xrl_pimstat_rx_join_sg.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg, cb));
}


/* Unmarshall pimstat_rx_join_sg */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinSgCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_sg(
	const char*	dst_xrl_target_name,
	const PimstatRxPruneSgCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_sg.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_sg");
        ap_xrl_pimstat_rx_prune_sg.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg, cb));
}


/* Unmarshall pimstat_rx_prune_sg */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneSgCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_sg_rpt(
	const char*	dst_xrl_target_name,
	const PimstatRxJoinSgRptCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_sg_rpt.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_sg_rpt");
        ap_xrl_pimstat_rx_join_sg_rpt.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg_rpt, cb));
}


/* Unmarshall pimstat_rx_join_sg_rpt */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg_rpt(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinSgRptCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_sg_rpt(
	const char*	dst_xrl_target_name,
	const PimstatRxPruneSgRptCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_sg_rpt.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_sg_rpt");
        ap_xrl_pimstat_rx_prune_sg_rpt.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg_rpt, cb));
}


/* Unmarshall pimstat_rx_prune_sg_rpt */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg_rpt(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneSgRptCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_hello_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatHelloMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_hello_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_hello_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_hello_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_hello_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_hello_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_hello_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatHelloMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_hello_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatHelloMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_hello_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_hello_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_hello_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_hello_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_hello_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_hello_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatHelloMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_hello_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatHelloMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_hello_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_hello_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_hello_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_hello_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_hello_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_hello_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatHelloMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRegisterMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_register_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_register_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_register_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRegisterMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_register_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_register_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_register_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRegisterMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_register_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_register_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_register_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_stop_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRegisterStopMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_stop_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_stop_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_register_stop_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_register_stop_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterStopMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_stop_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRegisterStopMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_stop_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_stop_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_register_stop_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_register_stop_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterStopMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_register_stop_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRegisterStopMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_register_stop_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_register_stop_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_register_stop_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_register_stop_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_register_stop_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRegisterStopMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_join_prune_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatJoinPruneMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_join_prune_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_join_prune_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_join_prune_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_join_prune_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatJoinPruneMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_join_prune_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatJoinPruneMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_join_prune_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_join_prune_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_join_prune_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_join_prune_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatJoinPruneMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_join_prune_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatJoinPruneMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_join_prune_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_join_prune_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_join_prune_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_join_prune_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_join_prune_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatJoinPruneMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bootstrap_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatBootstrapMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bootstrap_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bootstrap_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_bootstrap_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_bootstrap_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBootstrapMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bootstrap_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatBootstrapMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bootstrap_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bootstrap_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_bootstrap_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_bootstrap_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBootstrapMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bootstrap_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatBootstrapMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bootstrap_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bootstrap_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_bootstrap_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_bootstrap_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_bootstrap_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBootstrapMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_assert_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatAssertMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_assert_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_assert_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_assert_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_assert_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_assert_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_assert_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatAssertMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_assert_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatAssertMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_assert_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_assert_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_assert_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_assert_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_assert_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_assert_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatAssertMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_assert_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatAssertMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_assert_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_assert_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_assert_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_assert_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_assert_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_assert_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatAssertMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatGraftMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_graft_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_graft_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatGraftMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_graft_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_graft_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatGraftMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_graft_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_graft_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_ack_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatGraftAckMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_ack_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_ack_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_graft_ack_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_graft_ack_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftAckMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_ack_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatGraftAckMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_ack_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_ack_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_graft_ack_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_graft_ack_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftAckMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_graft_ack_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatGraftAckMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_graft_ack_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_graft_ack_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_graft_ack_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_graft_ack_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_graft_ack_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatGraftAckMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_candidate_rp_messages_received_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatCandidateRpMessagesReceivedPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_candidate_rp_messages_received_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_candidate_rp_messages_received_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_candidate_rp_messages_received_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_received_per_vif, cb));
}


/* Unmarshall pimstat_candidate_rp_messages_received_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_received_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatCandidateRpMessagesReceivedPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_candidate_rp_messages_sent_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatCandidateRpMessagesSentPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_candidate_rp_messages_sent_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_candidate_rp_messages_sent_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_candidate_rp_messages_sent_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_sent_per_vif, cb));
}


/* Unmarshall pimstat_candidate_rp_messages_sent_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_sent_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatCandidateRpMessagesSentPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_candidate_rp_messages_rx_errors_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatCandidateRpMessagesRxErrorsPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_candidate_rp_messages_rx_errors_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_candidate_rp_messages_rx_errors_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_candidate_rp_messages_rx_errors_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_rx_errors_per_vif, cb));
}


/* Unmarshall pimstat_candidate_rp_messages_rx_errors_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_candidate_rp_messages_rx_errors_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatCandidateRpMessagesRxErrorsPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_unknown_type_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatUnknownTypeMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_unknown_type_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_unknown_type_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_unknown_type_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_unknown_type_messages_per_vif, cb));
}


/* Unmarshall pimstat_unknown_type_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_unknown_type_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatUnknownTypeMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_unknown_version_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatUnknownVersionMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_unknown_version_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_unknown_version_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_unknown_version_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_unknown_version_messages_per_vif, cb));
}


/* Unmarshall pimstat_unknown_version_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_unknown_version_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatUnknownVersionMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_neighbor_unknown_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatNeighborUnknownMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_neighbor_unknown_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_neighbor_unknown_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_neighbor_unknown_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_neighbor_unknown_messages_per_vif, cb));
}


/* Unmarshall pimstat_neighbor_unknown_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_neighbor_unknown_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNeighborUnknownMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bad_length_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatBadLengthMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bad_length_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bad_length_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_bad_length_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bad_length_messages_per_vif, cb));
}


/* Unmarshall pimstat_bad_length_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_bad_length_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBadLengthMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bad_checksum_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatBadChecksumMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bad_checksum_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bad_checksum_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_bad_checksum_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bad_checksum_messages_per_vif, cb));
}


/* Unmarshall pimstat_bad_checksum_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_bad_checksum_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBadChecksumMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_bad_receive_interface_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatBadReceiveInterfaceMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_bad_receive_interface_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_bad_receive_interface_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_bad_receive_interface_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_bad_receive_interface_messages_per_vif, cb));
}


/* Unmarshall pimstat_bad_receive_interface_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_bad_receive_interface_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatBadReceiveInterfaceMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_interface_disabled_messages_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxInterfaceDisabledMessagesPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_interface_disabled_messages_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_interface_disabled_messages_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_interface_disabled_messages_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_interface_disabled_messages_per_vif, cb));
}


/* Unmarshall pimstat_rx_interface_disabled_messages_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_interface_disabled_messages_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxInterfaceDisabledMessagesPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_register_not_rp_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxRegisterNotRpPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_register_not_rp_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_register_not_rp_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_register_not_rp_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_register_not_rp_per_vif, cb));
}


/* Unmarshall pimstat_rx_register_not_rp_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_register_not_rp_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxRegisterNotRpPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rp_filtered_source_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRpFilteredSourcePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rp_filtered_source_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rp_filtered_source_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rp_filtered_source_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rp_filtered_source_per_vif, cb));
}


/* Unmarshall pimstat_rp_filtered_source_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rp_filtered_source_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRpFilteredSourcePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_unknown_register_stop_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatUnknownRegisterStopPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_unknown_register_stop_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_unknown_register_stop_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_unknown_register_stop_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_unknown_register_stop_per_vif, cb));
}


/* Unmarshall pimstat_unknown_register_stop_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_unknown_register_stop_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatUnknownRegisterStopPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_prune_no_state_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxJoinPruneNoStatePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_prune_no_state_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_prune_no_state_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_join_prune_no_state_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_prune_no_state_per_vif, cb));
}


/* Unmarshall pimstat_rx_join_prune_no_state_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_prune_no_state_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinPruneNoStatePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_graft_graft_ack_no_state_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxGraftGraftAckNoStatePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_graft_graft_ack_no_state_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_graft_graft_ack_no_state_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_graft_graft_ack_no_state_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_graft_graft_ack_no_state_per_vif, cb));
}


/* Unmarshall pimstat_rx_graft_graft_ack_no_state_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_graft_graft_ack_no_state_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxGraftGraftAckNoStatePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_graft_on_upstream_interface_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxGraftOnUpstreamInterfacePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_graft_on_upstream_interface_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_graft_on_upstream_interface_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_graft_on_upstream_interface_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_graft_on_upstream_interface_per_vif, cb));
}


/* Unmarshall pimstat_rx_graft_on_upstream_interface_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_graft_on_upstream_interface_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxGraftOnUpstreamInterfacePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_candidate_rp_not_bsr_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxCandidateRpNotBsrPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_candidate_rp_not_bsr_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_candidate_rp_not_bsr_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_candidate_rp_not_bsr_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_candidate_rp_not_bsr_per_vif, cb));
}


/* Unmarshall pimstat_rx_candidate_rp_not_bsr_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_candidate_rp_not_bsr_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxCandidateRpNotBsrPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_bsr_when_bsr_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxBsrWhenBsrPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_bsr_when_bsr_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_bsr_when_bsr_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_bsr_when_bsr_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_when_bsr_per_vif, cb));
}


/* Unmarshall pimstat_rx_bsr_when_bsr_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_when_bsr_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxBsrWhenBsrPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_bsr_not_rpf_interface_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxBsrNotRpfInterfacePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_bsr_not_rpf_interface_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_bsr_not_rpf_interface_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_bsr_not_rpf_interface_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_not_rpf_interface_per_vif, cb));
}


/* Unmarshall pimstat_rx_bsr_not_rpf_interface_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_bsr_not_rpf_interface_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxBsrNotRpfInterfacePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_unknown_hello_option_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxUnknownHelloOptionPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_unknown_hello_option_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_unknown_hello_option_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_unknown_hello_option_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_unknown_hello_option_per_vif, cb));
}


/* Unmarshall pimstat_rx_unknown_hello_option_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_unknown_hello_option_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxUnknownHelloOptionPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_data_no_state_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxDataNoStatePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_data_no_state_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_data_no_state_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_data_no_state_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_data_no_state_per_vif, cb));
}


/* Unmarshall pimstat_rx_data_no_state_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_data_no_state_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxDataNoStatePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_rp_no_state_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxRpNoStatePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_rp_no_state_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_rp_no_state_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_rp_no_state_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_rp_no_state_per_vif, cb));
}


/* Unmarshall pimstat_rx_rp_no_state_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_rp_no_state_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxRpNoStatePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_aggregate_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxAggregatePerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_aggregate_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_aggregate_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_aggregate_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_aggregate_per_vif, cb));
}


/* Unmarshall pimstat_rx_aggregate_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_aggregate_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxAggregatePerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_malformed_packet_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxMalformedPacketPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_malformed_packet_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_malformed_packet_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_malformed_packet_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_malformed_packet_per_vif, cb));
}


/* Unmarshall pimstat_rx_malformed_packet_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_malformed_packet_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxMalformedPacketPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_no_rp_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatNoRpPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_no_rp_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_no_rp_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_no_rp_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_no_rp_per_vif, cb));
}


/* Unmarshall pimstat_no_rp_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_no_rp_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNoRpPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_no_route_upstream_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatNoRouteUpstreamPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_no_route_upstream_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_no_route_upstream_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_no_route_upstream_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_no_route_upstream_per_vif, cb));
}


/* Unmarshall pimstat_no_route_upstream_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_no_route_upstream_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatNoRouteUpstreamPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rp_mismatch_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRpMismatchPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rp_mismatch_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rp_mismatch_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rp_mismatch_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rp_mismatch_per_vif, cb));
}


/* Unmarshall pimstat_rp_mismatch_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rp_mismatch_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRpMismatchPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rpf_neighbor_unknown_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRpfNeighborUnknownPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rpf_neighbor_unknown_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rpf_neighbor_unknown_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rpf_neighbor_unknown_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rpf_neighbor_unknown_per_vif, cb));
}


/* Unmarshall pimstat_rpf_neighbor_unknown_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rpf_neighbor_unknown_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRpfNeighborUnknownPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_rp_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxJoinRpPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_rp_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_rp_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_join_rp_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_rp_per_vif, cb));
}


/* Unmarshall pimstat_rx_join_rp_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_rp_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinRpPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_rp_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxPruneRpPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_rp_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_rp_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_prune_rp_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_rp_per_vif, cb));
}


/* Unmarshall pimstat_rx_prune_rp_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_rp_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneRpPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_wc_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxJoinWcPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_wc_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_wc_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_join_wc_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_wc_per_vif, cb));
}


/* Unmarshall pimstat_rx_join_wc_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_wc_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinWcPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_wc_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxPruneWcPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_wc_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_wc_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_prune_wc_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_wc_per_vif, cb));
}


/* Unmarshall pimstat_rx_prune_wc_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_wc_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneWcPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_sg_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxJoinSgPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_sg_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_sg_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_join_sg_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg_per_vif, cb));
}


/* Unmarshall pimstat_rx_join_sg_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinSgPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_sg_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxPruneSgPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_sg_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_sg_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_prune_sg_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg_per_vif, cb));
}


/* Unmarshall pimstat_rx_prune_sg_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneSgPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_join_sg_rpt_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxJoinSgRptPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_join_sg_rpt_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_join_sg_rpt_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_join_sg_rpt_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg_rpt_per_vif, cb));
}


/* Unmarshall pimstat_rx_join_sg_rpt_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_join_sg_rpt_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxJoinSgRptPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}

bool
XrlPimV0p1Client::send_pimstat_rx_prune_sg_rpt_per_vif(
	const char*	dst_xrl_target_name,
	const string&	vif_name,
	const PimstatRxPruneSgRptPerVifCB&	cb
)
{
    Xrl* x = ap_xrl_pimstat_rx_prune_sg_rpt_per_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "pim/0.1/pimstat_rx_prune_sg_rpt_per_vif");
        x->args().add("vif_name", vif_name);
        ap_xrl_pimstat_rx_prune_sg_rpt_per_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, vif_name);

    return _sender->send(*x, callback(&XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg_rpt_per_vif, cb));
}


/* Unmarshall pimstat_rx_prune_sg_rpt_per_vif */
void
XrlPimV0p1Client::unmarshall_pimstat_rx_prune_sg_rpt_per_vif(
	const XrlError&	e,
	XrlArgs*	a,
	PimstatRxPruneSgRptPerVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t value;
    try {
	a->get("value", value);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &value);
}
