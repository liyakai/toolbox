/*
 * obj/x86_64-unknown-linux-gnu/xrl/interfaces/wrapper4_xif.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#include "wrapper4_xif.hh"

bool
XrlWrapper4V0p1Client::send_get_admin_distance(
	const char*	dst_xrl_target_name,
	const GetAdminDistanceCB&	cb
)
{
    Xrl* x = ap_xrl_get_admin_distance.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/get_admin_distance");
        ap_xrl_get_admin_distance.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_get_admin_distance, cb));
}


/* Unmarshall get_admin_distance */
void
XrlWrapper4V0p1Client::unmarshall_get_admin_distance(
	const XrlError&	e,
	XrlArgs*	a,
	GetAdminDistanceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t admin;
    try {
	a->get("admin", admin);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &admin);
}

bool
XrlWrapper4V0p1Client::send_set_admin_distance(
	const char*	dst_xrl_target_name,
	const uint32_t&	admin,
	const SetAdminDistanceCB&	cb
)
{
    Xrl* x = ap_xrl_set_admin_distance.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/set_admin_distance");
        x->args().add("admin", admin);
        ap_xrl_set_admin_distance.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, admin);

    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_set_admin_distance, cb));
}


/* Unmarshall set_admin_distance */
void
XrlWrapper4V0p1Client::unmarshall_set_admin_distance(
	const XrlError&	e,
	XrlArgs*	a,
	SetAdminDistanceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlWrapper4V0p1Client::send_get_main_address(
	const char*	dst_xrl_target_name,
	const GetMainAddressCB&	cb
)
{
    Xrl* x = ap_xrl_get_main_address.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/get_main_address");
        ap_xrl_get_main_address.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_get_main_address, cb));
}


/* Unmarshall get_main_address */
void
XrlWrapper4V0p1Client::unmarshall_get_main_address(
	const XrlError&	e,
	XrlArgs*	a,
	GetMainAddressCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 addr;
    try {
	a->get("addr", addr);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addr);
}

bool
XrlWrapper4V0p1Client::send_set_main_address(
	const char*	dst_xrl_target_name,
	const IPv4&	addr,
	const SetMainAddressCB&	cb
)
{
    Xrl* x = ap_xrl_set_main_address.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/set_main_address");
        x->args().add("addr", addr);
        ap_xrl_set_main_address.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, addr);

    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_set_main_address, cb));
}


/* Unmarshall set_main_address */
void
XrlWrapper4V0p1Client::unmarshall_set_main_address(
	const XrlError&	e,
	XrlArgs*	a,
	SetMainAddressCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlWrapper4V0p1Client::send_restart(
	const char*	dst_xrl_target_name,
	const RestartCB&	cb
)
{
    Xrl* x = ap_xrl_restart.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/restart");
        ap_xrl_restart.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_restart, cb));
}


/* Unmarshall restart */
void
XrlWrapper4V0p1Client::unmarshall_restart(
	const XrlError&	e,
	XrlArgs*	a,
	RestartCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlWrapper4V0p1Client::send_get_interface_list(
	const char*	dst_xrl_target_name,
	const GetInterfaceListCB&	cb
)
{
    Xrl* x = ap_xrl_get_interface_list.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/get_interface_list");
        ap_xrl_get_interface_list.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_get_interface_list, cb));
}


/* Unmarshall get_interface_list */
void
XrlWrapper4V0p1Client::unmarshall_get_interface_list(
	const XrlError&	e,
	XrlArgs*	a,
	GetInterfaceListCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList interfaces;
    try {
	a->get("interfaces", interfaces);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &interfaces);
}

bool
XrlWrapper4V0p1Client::send_get_interface_info(
	const char*	dst_xrl_target_name,
	const uint32_t&	faceid,
	const GetInterfaceInfoCB&	cb
)
{
    Xrl* x = ap_xrl_get_interface_info.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "wrapper4/0.1/get_interface_info");
        x->args().add("faceid", faceid);
        ap_xrl_get_interface_info.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, faceid);

    return _sender->send(*x, callback(&XrlWrapper4V0p1Client::unmarshall_get_interface_info, cb));
}


/* Unmarshall get_interface_info */
void
XrlWrapper4V0p1Client::unmarshall_get_interface_info(
	const XrlError&	e,
	XrlArgs*	a,
	GetInterfaceInfoCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(6));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0);
	return;
    }
    string ifname;
    string vifname;
    IPv4 local_addr;
    uint32_t local_port;
    IPv4 all_nodes_addr;
    uint32_t all_nodes_port;
    try {
	a->get("ifname", ifname);
	a->get("vifname", vifname);
	a->get("local_addr", local_addr);
	a->get("local_port", local_port);
	a->get("all_nodes_addr", all_nodes_addr);
	a->get("all_nodes_port", all_nodes_port);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &ifname, &vifname, &local_addr, &local_port, &all_nodes_addr, &all_nodes_port);
}
