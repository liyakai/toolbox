/*
 * obj/x86_64-unknown-linux-gnu/xrl/interfaces/fea_ifmgr_xif.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#include "fea_ifmgr_xif.hh"

bool
XrlIfmgrV0p1Client::send_set_restore_original_config_on_shutdown(
	const char*	dst_xrl_target_name,
	const bool&	enable,
	const SetRestoreOriginalConfigOnShutdownCB&	cb
)
{
    Xrl* x = ap_xrl_set_restore_original_config_on_shutdown.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_restore_original_config_on_shutdown");
        x->args().add("enable", enable);
        ap_xrl_set_restore_original_config_on_shutdown.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, enable);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_restore_original_config_on_shutdown, cb));
}


/* Unmarshall set_restore_original_config_on_shutdown */
void
XrlIfmgrV0p1Client::unmarshall_set_restore_original_config_on_shutdown(
	const XrlError&	e,
	XrlArgs*	a,
	SetRestoreOriginalConfigOnShutdownCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_names(
	const char*	dst_xrl_target_name,
	const GetConfiguredInterfaceNamesCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_interface_names.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_interface_names");
        ap_xrl_get_configured_interface_names.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_interface_names, cb));
}


/* Unmarshall get_configured_interface_names */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_interface_names(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredInterfaceNamesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList ifnames;
    try {
	a->get("ifnames", ifnames);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &ifnames);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_names(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredVifNamesCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_vif_names.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_vif_names");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_vif_names.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_vif_names, cb));
}


/* Unmarshall get_configured_vif_names */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_vif_names(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredVifNamesCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList vifs;
    try {
	a->get("vifs", vifs);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &vifs);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_flags(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const GetConfiguredVifFlagsCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_vif_flags.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_vif_flags");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_get_configured_vif_flags.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_vif_flags, cb));
}


/* Unmarshall get_configured_vif_flags */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_vif_flags(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredVifFlagsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(5));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("broadcast", broadcast);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &broadcast, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_pif_index(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const GetConfiguredVifPifIndexCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_vif_pif_index.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_vif_pif_index");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_get_configured_vif_pif_index.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_vif_pif_index, cb));
}


/* Unmarshall get_configured_vif_pif_index */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_vif_pif_index(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredVifPifIndexCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t pif_index;
    try {
	a->get("pif_index", pif_index);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &pif_index);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_addresses4(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const GetConfiguredVifAddresses4CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_vif_addresses4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_vif_addresses4");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_get_configured_vif_addresses4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_vif_addresses4, cb));
}


/* Unmarshall get_configured_vif_addresses4 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_vif_addresses4(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredVifAddresses4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList addresses;
    try {
	a->get("addresses", addresses);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addresses);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_flags4(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const GetConfiguredAddressFlags4CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_address_flags4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_address_flags4");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_address_flags4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_address_flags4, cb));
}


/* Unmarshall get_configured_address_flags4 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_address_flags4(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredAddressFlags4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(5));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool broadcast;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("broadcast", broadcast);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &broadcast, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_enabled(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredInterfaceEnabledCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_interface_enabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_interface_enabled");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_interface_enabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_interface_enabled, cb));
}


/* Unmarshall get_configured_interface_enabled */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_interface_enabled(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredInterfaceEnabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_discard(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredInterfaceDiscardCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_interface_discard.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_interface_discard");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_interface_discard.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_interface_discard, cb));
}


/* Unmarshall get_configured_interface_discard */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_interface_discard(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredInterfaceDiscardCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool discard;
    try {
	a->get("discard", discard);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &discard);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_unreachable(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredInterfaceUnreachableCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_interface_unreachable.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_interface_unreachable");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_interface_unreachable.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_interface_unreachable, cb));
}


/* Unmarshall get_configured_interface_unreachable */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_interface_unreachable(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredInterfaceUnreachableCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool unreachable;
    try {
	a->get("unreachable", unreachable);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &unreachable);
}

bool
XrlIfmgrV0p1Client::send_get_configured_interface_management(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredInterfaceManagementCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_interface_management.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_interface_management");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_interface_management.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_interface_management, cb));
}


/* Unmarshall get_configured_interface_management */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_interface_management(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredInterfaceManagementCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool management;
    try {
	a->get("management", management);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &management);
}

bool
XrlIfmgrV0p1Client::send_get_configured_mac(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredMacCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_mac.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_mac");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_mac.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_mac, cb));
}


/* Unmarshall get_configured_mac */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_mac(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredMacCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    Mac mac;
    try {
	a->get("mac", mac);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &mac);
}

bool
XrlIfmgrV0p1Client::send_get_configured_mtu(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredMtuCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_mtu.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_mtu");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_mtu.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_mtu, cb));
}


/* Unmarshall get_configured_mtu */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_mtu(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredMtuCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t mtu;
    try {
	a->get("mtu", mtu);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &mtu);
}

bool
XrlIfmgrV0p1Client::send_get_configured_no_carrier(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredNoCarrierCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_no_carrier.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_no_carrier");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_no_carrier.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_no_carrier, cb));
}


/* Unmarshall get_configured_no_carrier */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_no_carrier(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredNoCarrierCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool no_carrier;
    try {
	a->get("no_carrier", no_carrier);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &no_carrier);
}

bool
XrlIfmgrV0p1Client::send_get_configured_baudrate(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const GetConfiguredBaudrateCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_baudrate.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_baudrate");
        x->args().add("ifname", ifname);
        ap_xrl_get_configured_baudrate.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_baudrate, cb));
}


/* Unmarshall get_configured_baudrate */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_baudrate(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredBaudrateCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint64_t baudrate;
    try {
	a->get("baudrate", baudrate);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &baudrate);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_enabled(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const GetConfiguredVifEnabledCB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_vif_enabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_vif_enabled");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_get_configured_vif_enabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_vif_enabled, cb));
}


/* Unmarshall get_configured_vif_enabled */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_vif_enabled(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredVifEnabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_get_configured_prefix4(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const GetConfiguredPrefix4CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_prefix4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_prefix4");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_prefix4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_prefix4, cb));
}


/* Unmarshall get_configured_prefix4 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_prefix4(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredPrefix4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t prefix_len;
    try {
	a->get("prefix_len", prefix_len);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &prefix_len);
}

bool
XrlIfmgrV0p1Client::send_get_configured_broadcast4(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const GetConfiguredBroadcast4CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_broadcast4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_broadcast4");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_broadcast4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_broadcast4, cb));
}


/* Unmarshall get_configured_broadcast4 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_broadcast4(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredBroadcast4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 broadcast;
    try {
	a->get("broadcast", broadcast);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &broadcast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_endpoint4(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const GetConfiguredEndpoint4CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_endpoint4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_endpoint4");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_endpoint4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_endpoint4, cb));
}


/* Unmarshall get_configured_endpoint4 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_endpoint4(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredEndpoint4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv4 endpoint;
    try {
	a->get("endpoint", endpoint);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &endpoint);
}

bool
XrlIfmgrV0p1Client::send_start_transaction(
	const char*	dst_xrl_target_name,
	const StartTransactionCB&	cb
)
{
    Xrl* x = ap_xrl_start_transaction.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/start_transaction");
        ap_xrl_start_transaction.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_start_transaction, cb));
}


/* Unmarshall start_transaction */
void
XrlIfmgrV0p1Client::unmarshall_start_transaction(
	const XrlError&	e,
	XrlArgs*	a,
	StartTransactionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t tid;
    try {
	a->get("tid", tid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &tid);
}

bool
XrlIfmgrV0p1Client::send_commit_transaction(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const CommitTransactionCB&	cb
)
{
    Xrl* x = ap_xrl_commit_transaction.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/commit_transaction");
        x->args().add("tid", tid);
        ap_xrl_commit_transaction.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_commit_transaction, cb));
}


/* Unmarshall commit_transaction */
void
XrlIfmgrV0p1Client::unmarshall_commit_transaction(
	const XrlError&	e,
	XrlArgs*	a,
	CommitTransactionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_abort_transaction(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const AbortTransactionCB&	cb
)
{
    Xrl* x = ap_xrl_abort_transaction.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/abort_transaction");
        x->args().add("tid", tid);
        ap_xrl_abort_transaction.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_abort_transaction, cb));
}


/* Unmarshall abort_transaction */
void
XrlIfmgrV0p1Client::unmarshall_abort_transaction(
	const XrlError&	e,
	XrlArgs*	a,
	AbortTransactionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_interface(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const CreateInterfaceCB&	cb
)
{
    Xrl* x = ap_xrl_create_interface.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/create_interface");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        ap_xrl_create_interface.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_create_interface, cb));
}


/* Unmarshall create_interface */
void
XrlIfmgrV0p1Client::unmarshall_create_interface(
	const XrlError&	e,
	XrlArgs*	a,
	CreateInterfaceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_interface(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const DeleteInterfaceCB&	cb
)
{
    Xrl* x = ap_xrl_delete_interface.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/delete_interface");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        ap_xrl_delete_interface.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_delete_interface, cb));
}


/* Unmarshall delete_interface */
void
XrlIfmgrV0p1Client::unmarshall_delete_interface(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteInterfaceCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_configure_all_interfaces_from_system(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const bool&	enable,
	const ConfigureAllInterfacesFromSystemCB&	cb
)
{
    Xrl* x = ap_xrl_configure_all_interfaces_from_system.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/configure_all_interfaces_from_system");
        x->args().add("tid", tid);
        x->args().add("enable", enable);
        ap_xrl_configure_all_interfaces_from_system.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, enable);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_configure_all_interfaces_from_system, cb));
}


/* Unmarshall configure_all_interfaces_from_system */
void
XrlIfmgrV0p1Client::unmarshall_configure_all_interfaces_from_system(
	const XrlError&	e,
	XrlArgs*	a,
	ConfigureAllInterfacesFromSystemCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_configure_interface_from_system(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enable,
	const ConfigureInterfaceFromSystemCB&	cb
)
{
    Xrl* x = ap_xrl_configure_interface_from_system.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/configure_interface_from_system");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("enable", enable);
        ap_xrl_configure_interface_from_system.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, enable);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_configure_interface_from_system, cb));
}


/* Unmarshall configure_interface_from_system */
void
XrlIfmgrV0p1Client::unmarshall_configure_interface_from_system(
	const XrlError&	e,
	XrlArgs*	a,
	ConfigureInterfaceFromSystemCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_interface_enabled(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enabled,
	const SetInterfaceEnabledCB&	cb
)
{
    Xrl* x = ap_xrl_set_interface_enabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_interface_enabled");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("enabled", enabled);
        ap_xrl_set_interface_enabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, enabled);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_interface_enabled, cb));
}


/* Unmarshall set_interface_enabled */
void
XrlIfmgrV0p1Client::unmarshall_set_interface_enabled(
	const XrlError&	e,
	XrlArgs*	a,
	SetInterfaceEnabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_interface_discard(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	discard,
	const SetInterfaceDiscardCB&	cb
)
{
    Xrl* x = ap_xrl_set_interface_discard.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_interface_discard");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("discard", discard);
        ap_xrl_set_interface_discard.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, discard);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_interface_discard, cb));
}


/* Unmarshall set_interface_discard */
void
XrlIfmgrV0p1Client::unmarshall_set_interface_discard(
	const XrlError&	e,
	XrlArgs*	a,
	SetInterfaceDiscardCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_interface_unreachable(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	unreachable,
	const SetInterfaceUnreachableCB&	cb
)
{
    Xrl* x = ap_xrl_set_interface_unreachable.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_interface_unreachable");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("unreachable", unreachable);
        ap_xrl_set_interface_unreachable.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, unreachable);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_interface_unreachable, cb));
}


/* Unmarshall set_interface_unreachable */
void
XrlIfmgrV0p1Client::unmarshall_set_interface_unreachable(
	const XrlError&	e,
	XrlArgs*	a,
	SetInterfaceUnreachableCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_interface_management(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	management,
	const SetInterfaceManagementCB&	cb
)
{
    Xrl* x = ap_xrl_set_interface_management.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_interface_management");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("management", management);
        ap_xrl_set_interface_management.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, management);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_interface_management, cb));
}


/* Unmarshall set_interface_management */
void
XrlIfmgrV0p1Client::unmarshall_set_interface_management(
	const XrlError&	e,
	XrlArgs*	a,
	SetInterfaceManagementCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_mac(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const Mac&	mac,
	const SetMacCB&	cb
)
{
    Xrl* x = ap_xrl_set_mac.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_mac");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("mac", mac);
        ap_xrl_set_mac.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, mac);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_mac, cb));
}


/* Unmarshall set_mac */
void
XrlIfmgrV0p1Client::unmarshall_set_mac(
	const XrlError&	e,
	XrlArgs*	a,
	SetMacCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_mac(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const Mac&	mac,
	const CreateMacCB&	cb
)
{
    Xrl* x = ap_xrl_create_mac.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/create_mac");
        x->args().add("ifname", ifname);
        x->args().add("mac", mac);
        ap_xrl_create_mac.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, mac);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_create_mac, cb));
}


/* Unmarshall create_mac */
void
XrlIfmgrV0p1Client::unmarshall_create_mac(
	const XrlError&	e,
	XrlArgs*	a,
	CreateMacCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_mac(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const Mac&	mac,
	const DeleteMacCB&	cb
)
{
    Xrl* x = ap_xrl_delete_mac.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/delete_mac");
        x->args().add("ifname", ifname);
        x->args().add("mac", mac);
        ap_xrl_delete_mac.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, mac);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_delete_mac, cb));
}


/* Unmarshall delete_mac */
void
XrlIfmgrV0p1Client::unmarshall_delete_mac(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteMacCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_restore_original_mac(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const RestoreOriginalMacCB&	cb
)
{
    Xrl* x = ap_xrl_restore_original_mac.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/restore_original_mac");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        ap_xrl_restore_original_mac.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_restore_original_mac, cb));
}


/* Unmarshall restore_original_mac */
void
XrlIfmgrV0p1Client::unmarshall_restore_original_mac(
	const XrlError&	e,
	XrlArgs*	a,
	RestoreOriginalMacCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_mtu(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const uint32_t&	mtu,
	const SetMtuCB&	cb
)
{
    Xrl* x = ap_xrl_set_mtu.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_mtu");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("mtu", mtu);
        ap_xrl_set_mtu.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, mtu);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_mtu, cb));
}


/* Unmarshall set_mtu */
void
XrlIfmgrV0p1Client::unmarshall_set_mtu(
	const XrlError&	e,
	XrlArgs*	a,
	SetMtuCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_restore_original_mtu(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const RestoreOriginalMtuCB&	cb
)
{
    Xrl* x = ap_xrl_restore_original_mtu.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/restore_original_mtu");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        ap_xrl_restore_original_mtu.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_restore_original_mtu, cb));
}


/* Unmarshall restore_original_mtu */
void
XrlIfmgrV0p1Client::unmarshall_restore_original_mtu(
	const XrlError&	e,
	XrlArgs*	a,
	RestoreOriginalMtuCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_vif(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const CreateVifCB&	cb
)
{
    Xrl* x = ap_xrl_create_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/create_vif");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_create_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_create_vif, cb));
}


/* Unmarshall create_vif */
void
XrlIfmgrV0p1Client::unmarshall_create_vif(
	const XrlError&	e,
	XrlArgs*	a,
	CreateVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_vif(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const DeleteVifCB&	cb
)
{
    Xrl* x = ap_xrl_delete_vif.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/delete_vif");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_delete_vif.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_delete_vif, cb));
}


/* Unmarshall delete_vif */
void
XrlIfmgrV0p1Client::unmarshall_delete_vif(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteVifCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_vif_enabled(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const bool&	enabled,
	const SetVifEnabledCB&	cb
)
{
    Xrl* x = ap_xrl_set_vif_enabled.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_vif_enabled");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("enabled", enabled);
        ap_xrl_set_vif_enabled.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, enabled);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_vif_enabled, cb));
}


/* Unmarshall set_vif_enabled */
void
XrlIfmgrV0p1Client::unmarshall_set_vif_enabled(
	const XrlError&	e,
	XrlArgs*	a,
	SetVifEnabledCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_parent_ifname(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	parent_ifname,
	const SetParentIfnameCB&	cb
)
{
    Xrl* x = ap_xrl_set_parent_ifname.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_parent_ifname");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("parent_ifname", parent_ifname);
        ap_xrl_set_parent_ifname.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, parent_ifname);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_parent_ifname, cb));
}


/* Unmarshall set_parent_ifname */
void
XrlIfmgrV0p1Client::unmarshall_set_parent_ifname(
	const XrlError&	e,
	XrlArgs*	a,
	SetParentIfnameCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_iface_type(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	iface_type,
	const SetIfaceTypeCB&	cb
)
{
    Xrl* x = ap_xrl_set_iface_type.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_iface_type");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("iface_type", iface_type);
        ap_xrl_set_iface_type.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, iface_type);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_iface_type, cb));
}


/* Unmarshall set_iface_type */
void
XrlIfmgrV0p1Client::unmarshall_set_iface_type(
	const XrlError&	e,
	XrlArgs*	a,
	SetIfaceTypeCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_vid(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vid,
	const SetVidCB&	cb
)
{
    Xrl* x = ap_xrl_set_vid.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_vid");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vid", vid);
        ap_xrl_set_vid.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vid);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_vid, cb));
}


/* Unmarshall set_vid */
void
XrlIfmgrV0p1Client::unmarshall_set_vid(
	const XrlError&	e,
	XrlArgs*	a,
	SetVidCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_address4(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const CreateAddress4CB&	cb
)
{
    Xrl* x = ap_xrl_create_address4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/create_address4");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_create_address4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_create_address4, cb));
}


/* Unmarshall create_address4 */
void
XrlIfmgrV0p1Client::unmarshall_create_address4(
	const XrlError&	e,
	XrlArgs*	a,
	CreateAddress4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_address4(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const DeleteAddress4CB&	cb
)
{
    Xrl* x = ap_xrl_delete_address4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/delete_address4");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_delete_address4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_delete_address4, cb));
}


/* Unmarshall delete_address4 */
void
XrlIfmgrV0p1Client::unmarshall_delete_address4(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteAddress4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_create_address_atomic(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_length,
	const CreateAddressAtomicCB&	cb
)
{
    Xrl* x = ap_xrl_create_address_atomic.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/create_address_atomic");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("prefix_length", prefix_length);
        ap_xrl_create_address_atomic.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);
    x->args().set_arg(3, prefix_length);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_create_address_atomic, cb));
}


/* Unmarshall create_address_atomic */
void
XrlIfmgrV0p1Client::unmarshall_create_address_atomic(
	const XrlError&	e,
	XrlArgs*	a,
	CreateAddressAtomicCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_address_atomic(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const DeleteAddressAtomicCB&	cb
)
{
    Xrl* x = ap_xrl_delete_address_atomic.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/delete_address_atomic");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_delete_address_atomic.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_delete_address_atomic, cb));
}


/* Unmarshall delete_address_atomic */
void
XrlIfmgrV0p1Client::unmarshall_delete_address_atomic(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteAddressAtomicCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_address_enabled4(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const bool&	enabled,
	const SetAddressEnabled4CB&	cb
)
{
    Xrl* x = ap_xrl_set_address_enabled4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_address_enabled4");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("enabled", enabled);
        ap_xrl_set_address_enabled4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, enabled);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_address_enabled4, cb));
}


/* Unmarshall set_address_enabled4 */
void
XrlIfmgrV0p1Client::unmarshall_set_address_enabled4(
	const XrlError&	e,
	XrlArgs*	a,
	SetAddressEnabled4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_enabled4(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const GetConfiguredAddressEnabled4CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_address_enabled4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_address_enabled4");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_address_enabled4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_address_enabled4, cb));
}


/* Unmarshall get_configured_address_enabled4 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_address_enabled4(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredAddressEnabled4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_set_prefix4(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_len,
	const SetPrefix4CB&	cb
)
{
    Xrl* x = ap_xrl_set_prefix4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_prefix4");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("prefix_len", prefix_len);
        ap_xrl_set_prefix4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, prefix_len);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_prefix4, cb));
}


/* Unmarshall set_prefix4 */
void
XrlIfmgrV0p1Client::unmarshall_set_prefix4(
	const XrlError&	e,
	XrlArgs*	a,
	SetPrefix4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_broadcast4(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	broadcast,
	const SetBroadcast4CB&	cb
)
{
    Xrl* x = ap_xrl_set_broadcast4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_broadcast4");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("broadcast", broadcast);
        ap_xrl_set_broadcast4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, broadcast);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_broadcast4, cb));
}


/* Unmarshall set_broadcast4 */
void
XrlIfmgrV0p1Client::unmarshall_set_broadcast4(
	const XrlError&	e,
	XrlArgs*	a,
	SetBroadcast4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_endpoint4(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	endpoint,
	const SetEndpoint4CB&	cb
)
{
    Xrl* x = ap_xrl_set_endpoint4.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_endpoint4");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("endpoint", endpoint);
        ap_xrl_set_endpoint4.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, endpoint);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_endpoint4, cb));
}


/* Unmarshall set_endpoint4 */
void
XrlIfmgrV0p1Client::unmarshall_set_endpoint4(
	const XrlError&	e,
	XrlArgs*	a,
	SetEndpoint4CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_startup_ifmgr(
	const char*	dst_xrl_target_name,
	const StartupIfmgrCB&	cb
)
{
    Xrl* x = ap_xrl_startup_ifmgr.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/startup_ifmgr");
        ap_xrl_startup_ifmgr.reset(x);
    }

    x->set_target(dst_xrl_target_name);


    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_startup_ifmgr, cb));
}


/* Unmarshall startup_ifmgr */
void
XrlIfmgrV0p1Client::unmarshall_startup_ifmgr(
	const XrlError&	e,
	XrlArgs*	a,
	StartupIfmgrCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_get_configured_vif_addresses6(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const GetConfiguredVifAddresses6CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_vif_addresses6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_vif_addresses6");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        ap_xrl_get_configured_vif_addresses6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_vif_addresses6, cb));
}


/* Unmarshall get_configured_vif_addresses6 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_vif_addresses6(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredVifAddresses6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    XrlAtomList addresses;
    try {
	a->get("addresses", addresses);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &addresses);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_flags6(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const GetConfiguredAddressFlags6CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_address_flags6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_address_flags6");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_address_flags6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_address_flags6, cb));
}


/* Unmarshall get_configured_address_flags6 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_address_flags6(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredAddressFlags6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0, 0, 0, 0);
	return;
    } else if (a && a->size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(4));
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    bool enabled;
    bool loopback;
    bool point_to_point;
    bool multicast;
    try {
	a->get("enabled", enabled);
	a->get("loopback", loopback);
	a->get("point_to_point", point_to_point);
	a->get("multicast", multicast);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0, 0, 0, 0);
	return;
    }
    cb->dispatch(e, &enabled, &loopback, &point_to_point, &multicast);
}

bool
XrlIfmgrV0p1Client::send_get_configured_prefix6(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const GetConfiguredPrefix6CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_prefix6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_prefix6");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_prefix6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_prefix6, cb));
}


/* Unmarshall get_configured_prefix6 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_prefix6(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredPrefix6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    uint32_t prefix_len;
    try {
	a->get("prefix_len", prefix_len);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &prefix_len);
}

bool
XrlIfmgrV0p1Client::send_get_configured_endpoint6(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const GetConfiguredEndpoint6CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_endpoint6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_endpoint6");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_endpoint6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_endpoint6, cb));
}


/* Unmarshall get_configured_endpoint6 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_endpoint6(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredEndpoint6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    IPv6 endpoint;
    try {
	a->get("endpoint", endpoint);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &endpoint);
}

bool
XrlIfmgrV0p1Client::send_create_address6(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const CreateAddress6CB&	cb
)
{
    Xrl* x = ap_xrl_create_address6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/create_address6");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_create_address6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_create_address6, cb));
}


/* Unmarshall create_address6 */
void
XrlIfmgrV0p1Client::unmarshall_create_address6(
	const XrlError&	e,
	XrlArgs*	a,
	CreateAddress6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_delete_address6(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const DeleteAddress6CB&	cb
)
{
    Xrl* x = ap_xrl_delete_address6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/delete_address6");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_delete_address6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_delete_address6, cb));
}


/* Unmarshall delete_address6 */
void
XrlIfmgrV0p1Client::unmarshall_delete_address6(
	const XrlError&	e,
	XrlArgs*	a,
	DeleteAddress6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_address_enabled6(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const bool&	enabled,
	const SetAddressEnabled6CB&	cb
)
{
    Xrl* x = ap_xrl_set_address_enabled6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_address_enabled6");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("enabled", enabled);
        ap_xrl_set_address_enabled6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, enabled);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_address_enabled6, cb));
}


/* Unmarshall set_address_enabled6 */
void
XrlIfmgrV0p1Client::unmarshall_set_address_enabled6(
	const XrlError&	e,
	XrlArgs*	a,
	SetAddressEnabled6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_get_configured_address_enabled6(
	const char*	dst_xrl_target_name,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const GetConfiguredAddressEnabled6CB&	cb
)
{
    Xrl* x = ap_xrl_get_configured_address_enabled6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/get_configured_address_enabled6");
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        ap_xrl_get_configured_address_enabled6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, ifname);
    x->args().set_arg(1, vif);
    x->args().set_arg(2, address);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_get_configured_address_enabled6, cb));
}


/* Unmarshall get_configured_address_enabled6 */
void
XrlIfmgrV0p1Client::unmarshall_get_configured_address_enabled6(
	const XrlError&	e,
	XrlArgs*	a,
	GetConfiguredAddressEnabled6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    bool enabled;
    try {
	a->get("enabled", enabled);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &enabled);
}

bool
XrlIfmgrV0p1Client::send_set_prefix6(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const uint32_t&	prefix_len,
	const SetPrefix6CB&	cb
)
{
    Xrl* x = ap_xrl_set_prefix6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_prefix6");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("prefix_len", prefix_len);
        ap_xrl_set_prefix6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, prefix_len);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_prefix6, cb));
}


/* Unmarshall set_prefix6 */
void
XrlIfmgrV0p1Client::unmarshall_set_prefix6(
	const XrlError&	e,
	XrlArgs*	a,
	SetPrefix6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlIfmgrV0p1Client::send_set_endpoint6(
	const char*	dst_xrl_target_name,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const IPv6&	endpoint,
	const SetEndpoint6CB&	cb
)
{
    Xrl* x = ap_xrl_set_endpoint6.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "ifmgr/0.1/set_endpoint6");
        x->args().add("tid", tid);
        x->args().add("ifname", ifname);
        x->args().add("vif", vif);
        x->args().add("address", address);
        x->args().add("endpoint", endpoint);
        ap_xrl_set_endpoint6.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, tid);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vif);
    x->args().set_arg(3, address);
    x->args().set_arg(4, endpoint);

    return _sender->send(*x, callback(&XrlIfmgrV0p1Client::unmarshall_set_endpoint6, cb));
}


/* Unmarshall set_endpoint6 */
void
XrlIfmgrV0p1Client::unmarshall_set_endpoint6(
	const XrlError&	e,
	XrlArgs*	a,
	SetEndpoint6CB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}
