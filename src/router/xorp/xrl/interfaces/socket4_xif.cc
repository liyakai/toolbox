/*
 * obj/x86_64-unknown-linux-gnu/xrl/interfaces/socket4_xif.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#include "socket4_xif.hh"

bool
XrlSocket4V0p1Client::send_tcp_open(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const TcpOpenCB&	cb
)
{
    Xrl* x = ap_xrl_tcp_open.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/tcp_open");
        x->args().add("creator", creator);
        ap_xrl_tcp_open.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_tcp_open, cb));
}


/* Unmarshall tcp_open */
void
XrlSocket4V0p1Client::unmarshall_tcp_open(
	const XrlError&	e,
	XrlArgs*	a,
	TcpOpenCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_udp_open(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const UdpOpenCB&	cb
)
{
    Xrl* x = ap_xrl_udp_open.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_open");
        x->args().add("creator", creator);
        ap_xrl_udp_open.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_open, cb));
}


/* Unmarshall udp_open */
void
XrlSocket4V0p1Client::unmarshall_udp_open(
	const XrlError&	e,
	XrlArgs*	a,
	UdpOpenCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_tcp_open_and_bind(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const TcpOpenAndBindCB&	cb
)
{
    Xrl* x = ap_xrl_tcp_open_and_bind.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/tcp_open_and_bind");
        x->args().add("creator", creator);
        x->args().add("local_addr", local_addr);
        x->args().add("local_port", local_port);
        ap_xrl_tcp_open_and_bind.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);
    x->args().set_arg(1, local_addr);
    x->args().set_arg(2, local_port);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_tcp_open_and_bind, cb));
}


/* Unmarshall tcp_open_and_bind */
void
XrlSocket4V0p1Client::unmarshall_tcp_open_and_bind(
	const XrlError&	e,
	XrlArgs*	a,
	TcpOpenAndBindCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_udp_open_and_bind(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const string&	local_dev,
	const uint32_t&	reuse,
	const UdpOpenAndBindCB&	cb
)
{
    Xrl* x = ap_xrl_udp_open_and_bind.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_open_and_bind");
        x->args().add("creator", creator);
        x->args().add("local_addr", local_addr);
        x->args().add("local_port", local_port);
        x->args().add("local_dev", local_dev);
        x->args().add("reuse", reuse);
        ap_xrl_udp_open_and_bind.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);
    x->args().set_arg(1, local_addr);
    x->args().set_arg(2, local_port);
    x->args().set_arg(3, local_dev);
    x->args().set_arg(4, reuse);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_open_and_bind, cb));
}


/* Unmarshall udp_open_and_bind */
void
XrlSocket4V0p1Client::unmarshall_udp_open_and_bind(
	const XrlError&	e,
	XrlArgs*	a,
	UdpOpenAndBindCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_udp_open_bind_join(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	const UdpOpenBindJoinCB&	cb
)
{
    Xrl* x = ap_xrl_udp_open_bind_join.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_open_bind_join");
        x->args().add("creator", creator);
        x->args().add("local_addr", local_addr);
        x->args().add("local_port", local_port);
        x->args().add("mcast_addr", mcast_addr);
        x->args().add("ttl", ttl);
        x->args().add("reuse", reuse);
        ap_xrl_udp_open_bind_join.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);
    x->args().set_arg(1, local_addr);
    x->args().set_arg(2, local_port);
    x->args().set_arg(3, mcast_addr);
    x->args().set_arg(4, ttl);
    x->args().set_arg(5, reuse);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_open_bind_join, cb));
}


/* Unmarshall udp_open_bind_join */
void
XrlSocket4V0p1Client::unmarshall_udp_open_bind_join(
	const XrlError&	e,
	XrlArgs*	a,
	UdpOpenBindJoinCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_tcp_open_bind_connect(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const TcpOpenBindConnectCB&	cb
)
{
    Xrl* x = ap_xrl_tcp_open_bind_connect.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/tcp_open_bind_connect");
        x->args().add("creator", creator);
        x->args().add("local_addr", local_addr);
        x->args().add("local_port", local_port);
        x->args().add("remote_addr", remote_addr);
        x->args().add("remote_port", remote_port);
        ap_xrl_tcp_open_bind_connect.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);
    x->args().set_arg(1, local_addr);
    x->args().set_arg(2, local_port);
    x->args().set_arg(3, remote_addr);
    x->args().set_arg(4, remote_port);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_tcp_open_bind_connect, cb));
}


/* Unmarshall tcp_open_bind_connect */
void
XrlSocket4V0p1Client::unmarshall_tcp_open_bind_connect(
	const XrlError&	e,
	XrlArgs*	a,
	TcpOpenBindConnectCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_udp_open_bind_connect(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const UdpOpenBindConnectCB&	cb
)
{
    Xrl* x = ap_xrl_udp_open_bind_connect.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_open_bind_connect");
        x->args().add("creator", creator);
        x->args().add("local_addr", local_addr);
        x->args().add("local_port", local_port);
        x->args().add("remote_addr", remote_addr);
        x->args().add("remote_port", remote_port);
        ap_xrl_udp_open_bind_connect.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);
    x->args().set_arg(1, local_addr);
    x->args().set_arg(2, local_port);
    x->args().set_arg(3, remote_addr);
    x->args().set_arg(4, remote_port);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_open_bind_connect, cb));
}


/* Unmarshall udp_open_bind_connect */
void
XrlSocket4V0p1Client::unmarshall_udp_open_bind_connect(
	const XrlError&	e,
	XrlArgs*	a,
	UdpOpenBindConnectCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_udp_open_bind_broadcast(
	const char*	dst_xrl_target_name,
	const string&	creator,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	local_port,
	const uint32_t&	remote_port,
	const bool&	reuse,
	const bool&	limited,
	const bool&	connected,
	const UdpOpenBindBroadcastCB&	cb
)
{
    Xrl* x = ap_xrl_udp_open_bind_broadcast.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_open_bind_broadcast");
        x->args().add("creator", creator);
        x->args().add("ifname", ifname);
        x->args().add("vifname", vifname);
        x->args().add("local_port", local_port);
        x->args().add("remote_port", remote_port);
        x->args().add("reuse", reuse);
        x->args().add("limited", limited);
        x->args().add("connected", connected);
        ap_xrl_udp_open_bind_broadcast.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, creator);
    x->args().set_arg(1, ifname);
    x->args().set_arg(2, vifname);
    x->args().set_arg(3, local_port);
    x->args().set_arg(4, remote_port);
    x->args().set_arg(5, reuse);
    x->args().set_arg(6, limited);
    x->args().set_arg(7, connected);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_open_bind_broadcast, cb));
}


/* Unmarshall udp_open_bind_broadcast */
void
XrlSocket4V0p1Client::unmarshall_udp_open_bind_broadcast(
	const XrlError&	e,
	XrlArgs*	a,
	UdpOpenBindBroadcastCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e, 0);
	return;
    } else if (a && a->size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(1));
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    string sockid;
    try {
	a->get("sockid", sockid);
    } catch (const XrlArgs::BadArgs& bad_args_err) {
	UNUSED(bad_args_err);
	XLOG_ERROR("Error decoding the arguments: %s", bad_args_err.str().c_str());
	cb->dispatch(XrlError::BAD_ARGS(), 0);
	return;
    }
    cb->dispatch(e, &sockid);
}

bool
XrlSocket4V0p1Client::send_bind(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const BindCB&	cb
)
{
    Xrl* x = ap_xrl_bind.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/bind");
        x->args().add("sockid", sockid);
        x->args().add("local_addr", local_addr);
        x->args().add("local_port", local_port);
        ap_xrl_bind.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, local_addr);
    x->args().set_arg(2, local_port);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_bind, cb));
}


/* Unmarshall bind */
void
XrlSocket4V0p1Client::unmarshall_bind(
	const XrlError&	e,
	XrlArgs*	a,
	BindCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_udp_join_group(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	join_if_addr,
	const UdpJoinGroupCB&	cb
)
{
    Xrl* x = ap_xrl_udp_join_group.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_join_group");
        x->args().add("sockid", sockid);
        x->args().add("mcast_addr", mcast_addr);
        x->args().add("join_if_addr", join_if_addr);
        ap_xrl_udp_join_group.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, mcast_addr);
    x->args().set_arg(2, join_if_addr);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_join_group, cb));
}


/* Unmarshall udp_join_group */
void
XrlSocket4V0p1Client::unmarshall_udp_join_group(
	const XrlError&	e,
	XrlArgs*	a,
	UdpJoinGroupCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_udp_leave_group(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	leave_if_addr,
	const UdpLeaveGroupCB&	cb
)
{
    Xrl* x = ap_xrl_udp_leave_group.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_leave_group");
        x->args().add("sockid", sockid);
        x->args().add("mcast_addr", mcast_addr);
        x->args().add("leave_if_addr", leave_if_addr);
        ap_xrl_udp_leave_group.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, mcast_addr);
    x->args().set_arg(2, leave_if_addr);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_leave_group, cb));
}


/* Unmarshall udp_leave_group */
void
XrlSocket4V0p1Client::unmarshall_udp_leave_group(
	const XrlError&	e,
	XrlArgs*	a,
	UdpLeaveGroupCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_close(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const CloseCB&	cb
)
{
    Xrl* x = ap_xrl_close.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/close");
        x->args().add("sockid", sockid);
        ap_xrl_close.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_close, cb));
}


/* Unmarshall close */
void
XrlSocket4V0p1Client::unmarshall_close(
	const XrlError&	e,
	XrlArgs*	a,
	CloseCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_tcp_listen(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const uint32_t&	backlog,
	const TcpListenCB&	cb
)
{
    Xrl* x = ap_xrl_tcp_listen.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/tcp_listen");
        x->args().add("sockid", sockid);
        x->args().add("backlog", backlog);
        ap_xrl_tcp_listen.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, backlog);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_tcp_listen, cb));
}


/* Unmarshall tcp_listen */
void
XrlSocket4V0p1Client::unmarshall_tcp_listen(
	const XrlError&	e,
	XrlArgs*	a,
	TcpListenCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_udp_enable_recv(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const UdpEnableRecvCB&	cb
)
{
    Xrl* x = ap_xrl_udp_enable_recv.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/udp_enable_recv");
        x->args().add("sockid", sockid);
        ap_xrl_udp_enable_recv.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_udp_enable_recv, cb));
}


/* Unmarshall udp_enable_recv */
void
XrlSocket4V0p1Client::unmarshall_udp_enable_recv(
	const XrlError&	e,
	XrlArgs*	a,
	UdpEnableRecvCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_send(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const vector<uint8_t>&	data,
	const SendCB&	cb
)
{
    Xrl* x = ap_xrl_send.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/send");
        x->args().add("sockid", sockid);
        x->args().add("data", data);
        ap_xrl_send.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, data);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_send, cb));
}


/* Unmarshall send */
void
XrlSocket4V0p1Client::unmarshall_send(
	const XrlError&	e,
	XrlArgs*	a,
	SendCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_send_to(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data,
	const SendToCB&	cb
)
{
    Xrl* x = ap_xrl_send_to.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/send_to");
        x->args().add("sockid", sockid);
        x->args().add("remote_addr", remote_addr);
        x->args().add("remote_port", remote_port);
        x->args().add("data", data);
        ap_xrl_send_to.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, remote_addr);
    x->args().set_arg(2, remote_port);
    x->args().set_arg(3, data);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_send_to, cb));
}


/* Unmarshall send_to */
void
XrlSocket4V0p1Client::unmarshall_send_to(
	const XrlError&	e,
	XrlArgs*	a,
	SendToCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_send_from_multicast_if(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const IPv4&	group_addr,
	const uint32_t&	group_port,
	const IPv4&	ifaddr,
	const vector<uint8_t>&	data,
	const SendFromMulticastIfCB&	cb
)
{
    Xrl* x = ap_xrl_send_from_multicast_if.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/send_from_multicast_if");
        x->args().add("sockid", sockid);
        x->args().add("group_addr", group_addr);
        x->args().add("group_port", group_port);
        x->args().add("ifaddr", ifaddr);
        x->args().add("data", data);
        ap_xrl_send_from_multicast_if.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, group_addr);
    x->args().set_arg(2, group_port);
    x->args().set_arg(3, ifaddr);
    x->args().set_arg(4, data);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_send_from_multicast_if, cb));
}


/* Unmarshall send_from_multicast_if */
void
XrlSocket4V0p1Client::unmarshall_send_from_multicast_if(
	const XrlError&	e,
	XrlArgs*	a,
	SendFromMulticastIfCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_set_socket_option(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval,
	const SetSocketOptionCB&	cb
)
{
    Xrl* x = ap_xrl_set_socket_option.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/set_socket_option");
        x->args().add("sockid", sockid);
        x->args().add("optname", optname);
        x->args().add("optval", optval);
        ap_xrl_set_socket_option.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, optname);
    x->args().set_arg(2, optval);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_set_socket_option, cb));
}


/* Unmarshall set_socket_option */
void
XrlSocket4V0p1Client::unmarshall_set_socket_option(
	const XrlError&	e,
	XrlArgs*	a,
	SetSocketOptionCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlSocket4V0p1Client::send_set_socket_option_txt(
	const char*	dst_xrl_target_name,
	const string&	sockid,
	const string&	optname,
	const string&	optval,
	const SetSocketOptionTxtCB&	cb
)
{
    Xrl* x = ap_xrl_set_socket_option_txt.get();

    if (!x) {
        x = new Xrl(dst_xrl_target_name, "socket4/0.1/set_socket_option_txt");
        x->args().add("sockid", sockid);
        x->args().add("optname", optname);
        x->args().add("optval", optval);
        ap_xrl_set_socket_option_txt.reset(x);
    }

    x->set_target(dst_xrl_target_name);

    x->args().set_arg(0, sockid);
    x->args().set_arg(1, optname);
    x->args().set_arg(2, optval);

    return _sender->send(*x, callback(&XrlSocket4V0p1Client::unmarshall_set_socket_option_txt, cb));
}


/* Unmarshall set_socket_option_txt */
void
XrlSocket4V0p1Client::unmarshall_set_socket_option_txt(
	const XrlError&	e,
	XrlArgs*	a,
	SetSocketOptionTxtCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", XORP_UINT_CAST(a->size()), XORP_UINT_CAST(0));
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}
