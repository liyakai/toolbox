/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/pim_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_PIM_BASE_HH__
#define __XRL_TARGETS_PIM_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlPimTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlPimTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlPimTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlPimTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "pim/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Process a CLI command.
     *
     *  @param processor_name the processor name for this command.
     *
     *  @param cli_term_name the terminal name the command was entered from.
     *
     *  @param cli_session_id the CLI session ID the command was entered from.
     *
     *  @param command_name the command name to process.
     *
     *  @param command_args the command arguments to process.
     *
     *  @param ret_processor_name the processor name to return back to the CLI.
     *
     *  @param ret_cli_term_name the terminal name to return back.
     *
     *  @param ret_cli_session_id the CLI session ID to return back.
     *
     *  @param ret_command_output the command output to return back.
     */
    virtual XrlCmdError cli_processor_0_1_process_command(
	// Input values,
	const string&	processor_name,
	const string&	cli_term_name,
	const uint32_t&	cli_session_id,
	const string&	command_name,
	const string&	command_args,
	// Output values,
	string&	ret_processor_name,
	string&	ret_cli_term_name,
	uint32_t&	ret_cli_session_id,
	string&	ret_command_output) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const string*,
	const string*,
	const uint32_t*,
	const string*>::RefPtr
    CliProcessor01ProcessCommandRF;

    class CliProcessor01ProcessCommandCB {
        CliProcessor01ProcessCommandRF cb;

    public:
        operator const CliProcessor01ProcessCommandRF& () const { return cb; }
        const CliProcessor01ProcessCommandRF& operator ->() const { return cb; }
        CliProcessor01ProcessCommandCB(const CliProcessor01ProcessCommandRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const string& arg_ret_processor_name,
                     const string& arg_ret_cli_term_name,
                     const uint32_t& arg_ret_cli_session_id,
                     const string& arg_ret_command_output) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ret_processor_name,
                         &arg_ret_cli_term_name,
                         &arg_ret_cli_session_id,
                         &arg_ret_command_output);
        }
    };

    struct CliProcessor01ProcessCommandRsp :
      public CliProcessor01ProcessCommandCB {
        struct args_str {
            string ret_processor_name;
            string ret_cli_term_name;
            uint32_t ret_cli_session_id;
            string ret_command_output;
        };

    private:
        args_str args;

    public:
        CliProcessor01ProcessCommandRsp(const CliProcessor01ProcessCommandRF& cb)
          : CliProcessor01ProcessCommandCB(cb) { }

        void respond() const {
            CliProcessor01ProcessCommandCB::
            respond(args.ret_processor_name,
                        args.ret_cli_term_name,
                        args.ret_cli_session_id,
                        args.ret_command_output);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_cli_processor_0_1_process_command
       (
	const string&	processor_name,
	const string&	cli_term_name,
	const uint32_t&	cli_session_id,
	const string&	command_name,
	const string&	command_args,
	CliProcessor01ProcessCommandCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Receive an IPv4 packet from a raw socket.
     *
     *  @param if_name the interface name the packet arrived on.
     *
     *  @param vif_name the vif name the packet arrived on.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, then
     *  the received value is unknown.
     *
     *  @param ip_tos the Type of Service (Diffserv/ECN bits for IPv4). If it
     *  has a negative value, then the received value is unknown.
     *
     *  @param ip_router_alert if true, the IP Router Alert option was included
     *  in the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet4_client_0_1_recv(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket4Client01RecvRF;

    class RawPacket4Client01RecvCB {
        RawPacket4Client01RecvRF cb;

    public:
        operator const RawPacket4Client01RecvRF& () const { return cb; }
        const RawPacket4Client01RecvRF& operator ->() const { return cb; }
        RawPacket4Client01RecvCB(const RawPacket4Client01RecvRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket4Client01RecvRsp :
      public RawPacket4Client01RecvCB {
        RawPacket4Client01RecvRsp(const RawPacket4Client01RecvRF& cb)
          : RawPacket4Client01RecvCB(cb) { }

    };

    virtual void async_raw_packet4_client_0_1_recv
       (
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload,
	RawPacket4Client01RecvCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Receive an IPv6 packet from a raw socket.
     *
     *  @param if_name the interface name the packet arrived on.
     *
     *  @param vif_name the vif name the packet arrived on.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, then
     *  the received value is unknown.
     *
     *  @param ip_tos the Type Of Service (IP traffic class for IPv4). If it
     *  has a negative value, then the received value is unknown.
     *
     *  @param ip_router_alert if true, the IP Router Alert option was included
     *  in the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param ext_headers_type a list of u32 integers with the types of the
     *  optional extention headers.
     *
     *  @param ext_headers_payload a list of payload data, one for each
     *  optional extention header. The number of entries must match
     *  ext_headers_type.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet6_client_0_1_recv(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket6Client01RecvRF;

    class RawPacket6Client01RecvCB {
        RawPacket6Client01RecvRF cb;

    public:
        operator const RawPacket6Client01RecvRF& () const { return cb; }
        const RawPacket6Client01RecvRF& operator ->() const { return cb; }
        RawPacket6Client01RecvCB(const RawPacket6Client01RecvRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket6Client01RecvRsp :
      public RawPacket6Client01RecvCB {
        RawPacket6Client01RecvRsp(const RawPacket6Client01RecvRF& cb)
          : RawPacket6Client01RecvCB(cb) { }

    };

    virtual void async_raw_packet6_client_0_1_recv
       (
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload,
	RawPacket6Client01RecvCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start transaction.
     *
     *  @param tid the transaction ID to use for this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    RedistTransaction601StartTransactionRF;

    class RedistTransaction601StartTransactionCB {
        RedistTransaction601StartTransactionRF cb;

    public:
        operator const RedistTransaction601StartTransactionRF& () const { return cb; }
        const RedistTransaction601StartTransactionRF& operator ->() const { return cb; }
        RedistTransaction601StartTransactionCB(const RedistTransaction601StartTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_tid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tid);
        }
    };

    struct RedistTransaction601StartTransactionRsp :
      public RedistTransaction601StartTransactionCB {
        struct args_str {
            uint32_t tid;
        };

    private:
        args_str args;

    public:
        RedistTransaction601StartTransactionRsp(const RedistTransaction601StartTransactionRF& cb)
          : RedistTransaction601StartTransactionCB(cb) { }

        void respond() const {
            RedistTransaction601StartTransactionCB::
            respond(args.tid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_redist_transaction6_0_1_start_transaction
       (
	RedistTransaction601StartTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601CommitTransactionRF;

    class RedistTransaction601CommitTransactionCB {
        RedistTransaction601CommitTransactionRF cb;

    public:
        operator const RedistTransaction601CommitTransactionRF& () const { return cb; }
        const RedistTransaction601CommitTransactionRF& operator ->() const { return cb; }
        RedistTransaction601CommitTransactionCB(const RedistTransaction601CommitTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601CommitTransactionRsp :
      public RedistTransaction601CommitTransactionCB {
        RedistTransaction601CommitTransactionRsp(const RedistTransaction601CommitTransactionRF& cb)
          : RedistTransaction601CommitTransactionCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_commit_transaction
       (
	const uint32_t&	tid,
	RedistTransaction601CommitTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601AbortTransactionRF;

    class RedistTransaction601AbortTransactionCB {
        RedistTransaction601AbortTransactionRF cb;

    public:
        operator const RedistTransaction601AbortTransactionRF& () const { return cb; }
        const RedistTransaction601AbortTransactionRF& operator ->() const { return cb; }
        RedistTransaction601AbortTransactionCB(const RedistTransaction601AbortTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601AbortTransactionRsp :
      public RedistTransaction601AbortTransactionCB {
        RedistTransaction601AbortTransactionRsp(const RedistTransaction601AbortTransactionRF& cb)
          : RedistTransaction601AbortTransactionCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_abort_transaction
       (
	const uint32_t&	tid,
	RedistTransaction601AbortTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete a routing entry.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param dst destination network.
     *
     *  @param nexthop nexthop router address.
     *
     *  @param ifname interface name associated with nexthop.
     *
     *  @param vifname virtual interface name with nexthop.
     *
     *  @param metric origin routing protocol metric for route.
     *
     *  @param admin_distance administrative distance of origin routing
     *  protocol.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError redist_transaction6_0_1_add_route(
	// Input values,
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601AddRouteRF;

    class RedistTransaction601AddRouteCB {
        RedistTransaction601AddRouteRF cb;

    public:
        operator const RedistTransaction601AddRouteRF& () const { return cb; }
        const RedistTransaction601AddRouteRF& operator ->() const { return cb; }
        RedistTransaction601AddRouteCB(const RedistTransaction601AddRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601AddRouteRsp :
      public RedistTransaction601AddRouteCB {
        RedistTransaction601AddRouteRsp(const RedistTransaction601AddRouteRF& cb)
          : RedistTransaction601AddRouteCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_add_route
       (
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction601AddRouteCB);
#endif

    virtual XrlCmdError redist_transaction6_0_1_delete_route(
	// Input values,
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601DeleteRouteRF;

    class RedistTransaction601DeleteRouteCB {
        RedistTransaction601DeleteRouteRF cb;

    public:
        operator const RedistTransaction601DeleteRouteRF& () const { return cb; }
        const RedistTransaction601DeleteRouteRF& operator ->() const { return cb; }
        RedistTransaction601DeleteRouteCB(const RedistTransaction601DeleteRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601DeleteRouteRsp :
      public RedistTransaction601DeleteRouteCB {
        RedistTransaction601DeleteRouteRsp(const RedistTransaction601DeleteRouteRF& cb)
          : RedistTransaction601DeleteRouteCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_delete_route
       (
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction601DeleteRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all routing entries.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     */
    virtual XrlCmdError redist_transaction6_0_1_delete_all_routes(
	// Input values,
	const uint32_t&	tid,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601DeleteAllRoutesRF;

    class RedistTransaction601DeleteAllRoutesCB {
        RedistTransaction601DeleteAllRoutesRF cb;

    public:
        operator const RedistTransaction601DeleteAllRoutesRF& () const { return cb; }
        const RedistTransaction601DeleteAllRoutesRF& operator ->() const { return cb; }
        RedistTransaction601DeleteAllRoutesCB(const RedistTransaction601DeleteAllRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601DeleteAllRoutesRsp :
      public RedistTransaction601DeleteAllRoutesCB {
        RedistTransaction601DeleteAllRoutesRsp(const RedistTransaction601DeleteAllRoutesRF& cb)
          : RedistTransaction601DeleteAllRoutesCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_delete_all_routes
       (
	const uint32_t&	tid,
	const string&	cookie,
	RedistTransaction601DeleteAllRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Receive a kernel signal message from the MFEA.
     *
     *  @param xrl_sender_name the XRL name of the originator of this XRL.
     *  (both sides must agree on the particular values).
     *
     *  @param message_type the type of the kernel signal message (TODO:
     *  integer for now: the particular types are well-known by both sides).
     *
     *  @param vif_name the name of the vif the message was received on.
     *
     *  @param vif_index the index of the vif the message was received on.
     *
     *  @param source_address the address of the sender.
     *
     *  @param dest_address the destination address.
     *
     *  @param protocol_message the protocol message.
     */
    virtual XrlCmdError mfea_client_0_1_recv_kernel_signal_message4(
	// Input values,
	const string&	xrl_sender_name,
	const uint32_t&	message_type,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv4&	source_address,
	const IPv4&	dest_address,
	const vector<uint8_t>&	protocol_message) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    MfeaClient01RecvKernelSignalMessage4RF;

    class MfeaClient01RecvKernelSignalMessage4CB {
        MfeaClient01RecvKernelSignalMessage4RF cb;

    public:
        operator const MfeaClient01RecvKernelSignalMessage4RF& () const { return cb; }
        const MfeaClient01RecvKernelSignalMessage4RF& operator ->() const { return cb; }
        MfeaClient01RecvKernelSignalMessage4CB(const MfeaClient01RecvKernelSignalMessage4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct MfeaClient01RecvKernelSignalMessage4Rsp :
      public MfeaClient01RecvKernelSignalMessage4CB {
        MfeaClient01RecvKernelSignalMessage4Rsp(const MfeaClient01RecvKernelSignalMessage4RF& cb)
          : MfeaClient01RecvKernelSignalMessage4CB(cb) { }

    };

    virtual void async_mfea_client_0_1_recv_kernel_signal_message4
       (
	const string&	xrl_sender_name,
	const uint32_t&	message_type,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv4&	source_address,
	const IPv4&	dest_address,
	const vector<uint8_t>&	protocol_message,
	MfeaClient01RecvKernelSignalMessage4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  A signal that a dataflow-related pre-condition is true.
     *
     *  @param xrl_sender_name the XRL name of the originator of this XRL.
     *
     *  @param source_address the source address of the dataflow.
     *
     *  @param group_address the group address of the dataflow.
     *
     *  @param threshold_interval_sec the number of seconds in the interval
     *  requested for measurement.
     *
     *  @param threshold_interval_usec the number of microseconds in the
     *  interval requested for measurement.
     *
     *  @param measured_interval_sec the number of seconds in the last measured
     *  interval that has triggered the signal.
     *
     *  @param measured_interval_usec the number of microseconds in the last
     *  measured interval that has triggered the signal.
     *
     *  @param threshold_packets the threshold value to trigger a signal (in
     *  number of packets).
     *
     *  @param threshold_bytes the threshold value to trigger a signal (in
     *  bytes).
     *
     *  @param measured_packets the number of packets measured within the
     *  measured interval.
     *
     *  @param measured_bytes the number of bytes measured within the measured
     *  interval.
     *
     *  @param is_threshold_in_packets if true, threshold_packets is valid.
     *
     *  @param is_threshold_in_bytes if true, threshold_bytes is valid.
     *
     *  @param is_geq_upcall if true, the operation for comparison is ">=".
     *
     *  @param is_leq_upcall if true, the operation for comparison is "<=".
     */
    virtual XrlCmdError mfea_client_0_1_recv_dataflow_signal4(
	// Input values,
	const string&	xrl_sender_name,
	const IPv4&	source_address,
	const IPv4&	group_address,
	const uint32_t&	threshold_interval_sec,
	const uint32_t&	threshold_interval_usec,
	const uint32_t&	measured_interval_sec,
	const uint32_t&	measured_interval_usec,
	const uint32_t&	threshold_packets,
	const uint32_t&	threshold_bytes,
	const uint32_t&	measured_packets,
	const uint32_t&	measured_bytes,
	const bool&	is_threshold_in_packets,
	const bool&	is_threshold_in_bytes,
	const bool&	is_geq_upcall,
	const bool&	is_leq_upcall) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    MfeaClient01RecvDataflowSignal4RF;

    class MfeaClient01RecvDataflowSignal4CB {
        MfeaClient01RecvDataflowSignal4RF cb;

    public:
        operator const MfeaClient01RecvDataflowSignal4RF& () const { return cb; }
        const MfeaClient01RecvDataflowSignal4RF& operator ->() const { return cb; }
        MfeaClient01RecvDataflowSignal4CB(const MfeaClient01RecvDataflowSignal4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct MfeaClient01RecvDataflowSignal4Rsp :
      public MfeaClient01RecvDataflowSignal4CB {
        MfeaClient01RecvDataflowSignal4Rsp(const MfeaClient01RecvDataflowSignal4RF& cb)
          : MfeaClient01RecvDataflowSignal4CB(cb) { }

    };

    virtual void async_mfea_client_0_1_recv_dataflow_signal4
       (
	const string&	xrl_sender_name,
	const IPv4&	source_address,
	const IPv4&	group_address,
	const uint32_t&	threshold_interval_sec,
	const uint32_t&	threshold_interval_usec,
	const uint32_t&	measured_interval_sec,
	const uint32_t&	measured_interval_usec,
	const uint32_t&	threshold_packets,
	const uint32_t&	threshold_bytes,
	const uint32_t&	measured_packets,
	const uint32_t&	measured_bytes,
	const bool&	is_threshold_in_packets,
	const bool&	is_threshold_in_bytes,
	const bool&	is_geq_upcall,
	const bool&	is_leq_upcall,
	MfeaClient01RecvDataflowSignal4CB);
#endif

    virtual XrlCmdError mfea_client_0_1_recv_kernel_signal_message6(
	// Input values,
	const string&	xrl_sender_name,
	const uint32_t&	message_type,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv6&	source_address,
	const IPv6&	dest_address,
	const vector<uint8_t>&	protocol_message) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    MfeaClient01RecvKernelSignalMessage6RF;

    class MfeaClient01RecvKernelSignalMessage6CB {
        MfeaClient01RecvKernelSignalMessage6RF cb;

    public:
        operator const MfeaClient01RecvKernelSignalMessage6RF& () const { return cb; }
        const MfeaClient01RecvKernelSignalMessage6RF& operator ->() const { return cb; }
        MfeaClient01RecvKernelSignalMessage6CB(const MfeaClient01RecvKernelSignalMessage6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct MfeaClient01RecvKernelSignalMessage6Rsp :
      public MfeaClient01RecvKernelSignalMessage6CB {
        MfeaClient01RecvKernelSignalMessage6Rsp(const MfeaClient01RecvKernelSignalMessage6RF& cb)
          : MfeaClient01RecvKernelSignalMessage6CB(cb) { }

    };

    virtual void async_mfea_client_0_1_recv_kernel_signal_message6
       (
	const string&	xrl_sender_name,
	const uint32_t&	message_type,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv6&	source_address,
	const IPv6&	dest_address,
	const vector<uint8_t>&	protocol_message,
	MfeaClient01RecvKernelSignalMessage6CB);
#endif

    virtual XrlCmdError mfea_client_0_1_recv_dataflow_signal6(
	// Input values,
	const string&	xrl_sender_name,
	const IPv6&	source_address,
	const IPv6&	group_address,
	const uint32_t&	threshold_interval_sec,
	const uint32_t&	threshold_interval_usec,
	const uint32_t&	measured_interval_sec,
	const uint32_t&	measured_interval_usec,
	const uint32_t&	threshold_packets,
	const uint32_t&	threshold_bytes,
	const uint32_t&	measured_packets,
	const uint32_t&	measured_bytes,
	const bool&	is_threshold_in_packets,
	const bool&	is_threshold_in_bytes,
	const bool&	is_geq_upcall,
	const bool&	is_leq_upcall) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    MfeaClient01RecvDataflowSignal6RF;

    class MfeaClient01RecvDataflowSignal6CB {
        MfeaClient01RecvDataflowSignal6RF cb;

    public:
        operator const MfeaClient01RecvDataflowSignal6RF& () const { return cb; }
        const MfeaClient01RecvDataflowSignal6RF& operator ->() const { return cb; }
        MfeaClient01RecvDataflowSignal6CB(const MfeaClient01RecvDataflowSignal6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct MfeaClient01RecvDataflowSignal6Rsp :
      public MfeaClient01RecvDataflowSignal6CB {
        MfeaClient01RecvDataflowSignal6Rsp(const MfeaClient01RecvDataflowSignal6RF& cb)
          : MfeaClient01RecvDataflowSignal6CB(cb) { }

    };

    virtual void async_mfea_client_0_1_recv_dataflow_signal6
       (
	const string&	xrl_sender_name,
	const IPv6&	source_address,
	const IPv6&	group_address,
	const uint32_t&	threshold_interval_sec,
	const uint32_t&	threshold_interval_usec,
	const uint32_t&	measured_interval_sec,
	const uint32_t&	measured_interval_usec,
	const uint32_t&	threshold_packets,
	const uint32_t&	threshold_bytes,
	const uint32_t&	measured_packets,
	const uint32_t&	measured_bytes,
	const bool&	is_threshold_in_packets,
	const bool&	is_threshold_in_bytes,
	const bool&	is_geq_upcall,
	const bool&	is_leq_upcall,
	MfeaClient01RecvDataflowSignal6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start transaction.
     *
     *  @param tid the transaction ID to use for this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    RedistTransaction401StartTransactionRF;

    class RedistTransaction401StartTransactionCB {
        RedistTransaction401StartTransactionRF cb;

    public:
        operator const RedistTransaction401StartTransactionRF& () const { return cb; }
        const RedistTransaction401StartTransactionRF& operator ->() const { return cb; }
        RedistTransaction401StartTransactionCB(const RedistTransaction401StartTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_tid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tid);
        }
    };

    struct RedistTransaction401StartTransactionRsp :
      public RedistTransaction401StartTransactionCB {
        struct args_str {
            uint32_t tid;
        };

    private:
        args_str args;

    public:
        RedistTransaction401StartTransactionRsp(const RedistTransaction401StartTransactionRF& cb)
          : RedistTransaction401StartTransactionCB(cb) { }

        void respond() const {
            RedistTransaction401StartTransactionCB::
            respond(args.tid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_redist_transaction4_0_1_start_transaction
       (
	RedistTransaction401StartTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401CommitTransactionRF;

    class RedistTransaction401CommitTransactionCB {
        RedistTransaction401CommitTransactionRF cb;

    public:
        operator const RedistTransaction401CommitTransactionRF& () const { return cb; }
        const RedistTransaction401CommitTransactionRF& operator ->() const { return cb; }
        RedistTransaction401CommitTransactionCB(const RedistTransaction401CommitTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401CommitTransactionRsp :
      public RedistTransaction401CommitTransactionCB {
        RedistTransaction401CommitTransactionRsp(const RedistTransaction401CommitTransactionRF& cb)
          : RedistTransaction401CommitTransactionCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_commit_transaction
       (
	const uint32_t&	tid,
	RedistTransaction401CommitTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401AbortTransactionRF;

    class RedistTransaction401AbortTransactionCB {
        RedistTransaction401AbortTransactionRF cb;

    public:
        operator const RedistTransaction401AbortTransactionRF& () const { return cb; }
        const RedistTransaction401AbortTransactionRF& operator ->() const { return cb; }
        RedistTransaction401AbortTransactionCB(const RedistTransaction401AbortTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401AbortTransactionRsp :
      public RedistTransaction401AbortTransactionCB {
        RedistTransaction401AbortTransactionRsp(const RedistTransaction401AbortTransactionRF& cb)
          : RedistTransaction401AbortTransactionCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_abort_transaction
       (
	const uint32_t&	tid,
	RedistTransaction401AbortTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete a routing entry.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param dst destination network.
     *
     *  @param nexthop nexthop router address.
     *
     *  @param ifname interface name associated with nexthop.
     *
     *  @param vifname virtual interface name with nexthop.
     *
     *  @param metric origin routing protocol metric for route.
     *
     *  @param admin_distance administrative distance of origin routing
     *  protocol.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError redist_transaction4_0_1_add_route(
	// Input values,
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401AddRouteRF;

    class RedistTransaction401AddRouteCB {
        RedistTransaction401AddRouteRF cb;

    public:
        operator const RedistTransaction401AddRouteRF& () const { return cb; }
        const RedistTransaction401AddRouteRF& operator ->() const { return cb; }
        RedistTransaction401AddRouteCB(const RedistTransaction401AddRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401AddRouteRsp :
      public RedistTransaction401AddRouteCB {
        RedistTransaction401AddRouteRsp(const RedistTransaction401AddRouteRF& cb)
          : RedistTransaction401AddRouteCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_add_route
       (
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction401AddRouteCB);
#endif

    virtual XrlCmdError redist_transaction4_0_1_delete_route(
	// Input values,
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401DeleteRouteRF;

    class RedistTransaction401DeleteRouteCB {
        RedistTransaction401DeleteRouteRF cb;

    public:
        operator const RedistTransaction401DeleteRouteRF& () const { return cb; }
        const RedistTransaction401DeleteRouteRF& operator ->() const { return cb; }
        RedistTransaction401DeleteRouteCB(const RedistTransaction401DeleteRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401DeleteRouteRsp :
      public RedistTransaction401DeleteRouteCB {
        RedistTransaction401DeleteRouteRsp(const RedistTransaction401DeleteRouteRF& cb)
          : RedistTransaction401DeleteRouteCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_delete_route
       (
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction401DeleteRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all routing entries.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     */
    virtual XrlCmdError redist_transaction4_0_1_delete_all_routes(
	// Input values,
	const uint32_t&	tid,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401DeleteAllRoutesRF;

    class RedistTransaction401DeleteAllRoutesCB {
        RedistTransaction401DeleteAllRoutesRF cb;

    public:
        operator const RedistTransaction401DeleteAllRoutesRF& () const { return cb; }
        const RedistTransaction401DeleteAllRoutesRF& operator ->() const { return cb; }
        RedistTransaction401DeleteAllRoutesCB(const RedistTransaction401DeleteAllRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401DeleteAllRoutesRsp :
      public RedistTransaction401DeleteAllRoutesCB {
        RedistTransaction401DeleteAllRoutesRsp(const RedistTransaction401DeleteAllRoutesRF& cb)
          : RedistTransaction401DeleteAllRoutesCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_delete_all_routes
       (
	const uint32_t&	tid,
	const string&	cookie,
	RedistTransaction401DeleteAllRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete membership information.
     *
     *  @param xrl_sender_name the XRL name of the originator of this XRL.
     *
     *  @param vif_name the name of the new vif.
     *
     *  @param vif_index the index of the new vif.
     *
     *  @param source the source address that has been joined/left.
     *
     *  @param group the group address that has been joined/left.
     */
    virtual XrlCmdError mld6igmp_client_0_1_add_membership4(
	// Input values,
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv4&	source,
	const IPv4&	group) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Mld6IgmpClient01AddMembership4RF;

    class Mld6IgmpClient01AddMembership4CB {
        Mld6IgmpClient01AddMembership4RF cb;

    public:
        operator const Mld6IgmpClient01AddMembership4RF& () const { return cb; }
        const Mld6IgmpClient01AddMembership4RF& operator ->() const { return cb; }
        Mld6IgmpClient01AddMembership4CB(const Mld6IgmpClient01AddMembership4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Mld6IgmpClient01AddMembership4Rsp :
      public Mld6IgmpClient01AddMembership4CB {
        Mld6IgmpClient01AddMembership4Rsp(const Mld6IgmpClient01AddMembership4RF& cb)
          : Mld6IgmpClient01AddMembership4CB(cb) { }

    };

    virtual void async_mld6igmp_client_0_1_add_membership4
       (
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv4&	source,
	const IPv4&	group,
	Mld6IgmpClient01AddMembership4CB);
#endif

    virtual XrlCmdError mld6igmp_client_0_1_add_membership6(
	// Input values,
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv6&	source,
	const IPv6&	group) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Mld6IgmpClient01AddMembership6RF;

    class Mld6IgmpClient01AddMembership6CB {
        Mld6IgmpClient01AddMembership6RF cb;

    public:
        operator const Mld6IgmpClient01AddMembership6RF& () const { return cb; }
        const Mld6IgmpClient01AddMembership6RF& operator ->() const { return cb; }
        Mld6IgmpClient01AddMembership6CB(const Mld6IgmpClient01AddMembership6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Mld6IgmpClient01AddMembership6Rsp :
      public Mld6IgmpClient01AddMembership6CB {
        Mld6IgmpClient01AddMembership6Rsp(const Mld6IgmpClient01AddMembership6RF& cb)
          : Mld6IgmpClient01AddMembership6CB(cb) { }

    };

    virtual void async_mld6igmp_client_0_1_add_membership6
       (
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv6&	source,
	const IPv6&	group,
	Mld6IgmpClient01AddMembership6CB);
#endif

    virtual XrlCmdError mld6igmp_client_0_1_delete_membership4(
	// Input values,
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv4&	source,
	const IPv4&	group) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Mld6IgmpClient01DeleteMembership4RF;

    class Mld6IgmpClient01DeleteMembership4CB {
        Mld6IgmpClient01DeleteMembership4RF cb;

    public:
        operator const Mld6IgmpClient01DeleteMembership4RF& () const { return cb; }
        const Mld6IgmpClient01DeleteMembership4RF& operator ->() const { return cb; }
        Mld6IgmpClient01DeleteMembership4CB(const Mld6IgmpClient01DeleteMembership4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Mld6IgmpClient01DeleteMembership4Rsp :
      public Mld6IgmpClient01DeleteMembership4CB {
        Mld6IgmpClient01DeleteMembership4Rsp(const Mld6IgmpClient01DeleteMembership4RF& cb)
          : Mld6IgmpClient01DeleteMembership4CB(cb) { }

    };

    virtual void async_mld6igmp_client_0_1_delete_membership4
       (
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv4&	source,
	const IPv4&	group,
	Mld6IgmpClient01DeleteMembership4CB);
#endif

    virtual XrlCmdError mld6igmp_client_0_1_delete_membership6(
	// Input values,
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv6&	source,
	const IPv6&	group) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Mld6IgmpClient01DeleteMembership6RF;

    class Mld6IgmpClient01DeleteMembership6CB {
        Mld6IgmpClient01DeleteMembership6RF cb;

    public:
        operator const Mld6IgmpClient01DeleteMembership6RF& () const { return cb; }
        const Mld6IgmpClient01DeleteMembership6RF& operator ->() const { return cb; }
        Mld6IgmpClient01DeleteMembership6CB(const Mld6IgmpClient01DeleteMembership6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Mld6IgmpClient01DeleteMembership6Rsp :
      public Mld6IgmpClient01DeleteMembership6CB {
        Mld6IgmpClient01DeleteMembership6Rsp(const Mld6IgmpClient01DeleteMembership6RF& cb)
          : Mld6IgmpClient01DeleteMembership6CB(cb) { }

    };

    virtual void async_mld6igmp_client_0_1_delete_membership6
       (
	const string&	xrl_sender_name,
	const string&	vif_name,
	const uint32_t&	vif_index,
	const IPv6&	source,
	const IPv6&	group,
	Mld6IgmpClient01DeleteMembership6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop a PIM vif interface.
     *
     *  @param vif_name the name of the vif to enable/disable/start/stop.
     *
     *  @param enable if true, then enable the vif, otherwise disable it.
     */
    virtual XrlCmdError pim_0_1_enable_vif(
	// Input values,
	const string&	vif_name,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01EnableVifRF;

    class Pim01EnableVifCB {
        Pim01EnableVifRF cb;

    public:
        operator const Pim01EnableVifRF& () const { return cb; }
        const Pim01EnableVifRF& operator ->() const { return cb; }
        Pim01EnableVifCB(const Pim01EnableVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01EnableVifRsp :
      public Pim01EnableVifCB {
        Pim01EnableVifRsp(const Pim01EnableVifRF& cb)
          : Pim01EnableVifCB(cb) { }

    };

    virtual void async_pim_0_1_enable_vif
       (
	const string&	vif_name,
	const bool&	enable,
	Pim01EnableVifCB);
#endif

    virtual XrlCmdError pim_0_1_start_vif(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StartVifRF;

    class Pim01StartVifCB {
        Pim01StartVifRF cb;

    public:
        operator const Pim01StartVifRF& () const { return cb; }
        const Pim01StartVifRF& operator ->() const { return cb; }
        Pim01StartVifCB(const Pim01StartVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StartVifRsp :
      public Pim01StartVifCB {
        Pim01StartVifRsp(const Pim01StartVifRF& cb)
          : Pim01StartVifCB(cb) { }

    };

    virtual void async_pim_0_1_start_vif
       (
	const string&	vif_name,
	Pim01StartVifCB);
#endif

    virtual XrlCmdError pim_0_1_stop_vif(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StopVifRF;

    class Pim01StopVifCB {
        Pim01StopVifRF cb;

    public:
        operator const Pim01StopVifRF& () const { return cb; }
        const Pim01StopVifRF& operator ->() const { return cb; }
        Pim01StopVifCB(const Pim01StopVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StopVifRsp :
      public Pim01StopVifCB {
        Pim01StopVifRsp(const Pim01StopVifRF& cb)
          : Pim01StopVifCB(cb) { }

    };

    virtual void async_pim_0_1_stop_vif
       (
	const string&	vif_name,
	Pim01StopVifCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop all PIM vif interfaces.
     *
     *  @param enable if true, then enable the vifs, otherwise disable them.
     */
    virtual XrlCmdError pim_0_1_enable_all_vifs(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01EnableAllVifsRF;

    class Pim01EnableAllVifsCB {
        Pim01EnableAllVifsRF cb;

    public:
        operator const Pim01EnableAllVifsRF& () const { return cb; }
        const Pim01EnableAllVifsRF& operator ->() const { return cb; }
        Pim01EnableAllVifsCB(const Pim01EnableAllVifsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01EnableAllVifsRsp :
      public Pim01EnableAllVifsCB {
        Pim01EnableAllVifsRsp(const Pim01EnableAllVifsRF& cb)
          : Pim01EnableAllVifsCB(cb) { }

    };

    virtual void async_pim_0_1_enable_all_vifs
       (
	const bool&	enable,
	Pim01EnableAllVifsCB);
#endif

    virtual XrlCmdError pim_0_1_start_all_vifs() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StartAllVifsRF;

    class Pim01StartAllVifsCB {
        Pim01StartAllVifsRF cb;

    public:
        operator const Pim01StartAllVifsRF& () const { return cb; }
        const Pim01StartAllVifsRF& operator ->() const { return cb; }
        Pim01StartAllVifsCB(const Pim01StartAllVifsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StartAllVifsRsp :
      public Pim01StartAllVifsCB {
        Pim01StartAllVifsRsp(const Pim01StartAllVifsRF& cb)
          : Pim01StartAllVifsCB(cb) { }

    };

    virtual void async_pim_0_1_start_all_vifs
       (
	Pim01StartAllVifsCB);
#endif

    virtual XrlCmdError pim_0_1_stop_all_vifs() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StopAllVifsRF;

    class Pim01StopAllVifsCB {
        Pim01StopAllVifsRF cb;

    public:
        operator const Pim01StopAllVifsRF& () const { return cb; }
        const Pim01StopAllVifsRF& operator ->() const { return cb; }
        Pim01StopAllVifsCB(const Pim01StopAllVifsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StopAllVifsRsp :
      public Pim01StopAllVifsCB {
        Pim01StopAllVifsRsp(const Pim01StopAllVifsRF& cb)
          : Pim01StopAllVifsCB(cb) { }

    };

    virtual void async_pim_0_1_stop_all_vifs
       (
	Pim01StopAllVifsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop the PIM protocol.
     *
     *  @param enable if true, then enable the PIM protocol, otherwise disable
     *  it.
     */
    virtual XrlCmdError pim_0_1_enable_pim(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01EnablePimRF;

    class Pim01EnablePimCB {
        Pim01EnablePimRF cb;

    public:
        operator const Pim01EnablePimRF& () const { return cb; }
        const Pim01EnablePimRF& operator ->() const { return cb; }
        Pim01EnablePimCB(const Pim01EnablePimRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01EnablePimRsp :
      public Pim01EnablePimCB {
        Pim01EnablePimRsp(const Pim01EnablePimRF& cb)
          : Pim01EnablePimCB(cb) { }

    };

    virtual void async_pim_0_1_enable_pim
       (
	const bool&	enable,
	Pim01EnablePimCB);
#endif

    virtual XrlCmdError pim_0_1_start_pim() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StartPimRF;

    class Pim01StartPimCB {
        Pim01StartPimRF cb;

    public:
        operator const Pim01StartPimRF& () const { return cb; }
        const Pim01StartPimRF& operator ->() const { return cb; }
        Pim01StartPimCB(const Pim01StartPimRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StartPimRsp :
      public Pim01StartPimCB {
        Pim01StartPimRsp(const Pim01StartPimRF& cb)
          : Pim01StartPimCB(cb) { }

    };

    virtual void async_pim_0_1_start_pim
       (
	Pim01StartPimCB);
#endif

    virtual XrlCmdError pim_0_1_stop_pim() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StopPimRF;

    class Pim01StopPimCB {
        Pim01StopPimRF cb;

    public:
        operator const Pim01StopPimRF& () const { return cb; }
        const Pim01StopPimRF& operator ->() const { return cb; }
        Pim01StopPimCB(const Pim01StopPimRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StopPimRsp :
      public Pim01StopPimCB {
        Pim01StopPimRsp(const Pim01StopPimRF& cb)
          : Pim01StopPimCB(cb) { }

    };

    virtual void async_pim_0_1_stop_pim
       (
	Pim01StopPimCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop the PIM CLI access.
     *
     *  @param enable if true, then enable the PIM CLI access, otherwise
     *  disable it.
     */
    virtual XrlCmdError pim_0_1_enable_cli(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01EnableCliRF;

    class Pim01EnableCliCB {
        Pim01EnableCliRF cb;

    public:
        operator const Pim01EnableCliRF& () const { return cb; }
        const Pim01EnableCliRF& operator ->() const { return cb; }
        Pim01EnableCliCB(const Pim01EnableCliRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01EnableCliRsp :
      public Pim01EnableCliCB {
        Pim01EnableCliRsp(const Pim01EnableCliRF& cb)
          : Pim01EnableCliCB(cb) { }

    };

    virtual void async_pim_0_1_enable_cli
       (
	const bool&	enable,
	Pim01EnableCliCB);
#endif

    virtual XrlCmdError pim_0_1_start_cli() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StartCliRF;

    class Pim01StartCliCB {
        Pim01StartCliRF cb;

    public:
        operator const Pim01StartCliRF& () const { return cb; }
        const Pim01StartCliRF& operator ->() const { return cb; }
        Pim01StartCliCB(const Pim01StartCliRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StartCliRsp :
      public Pim01StartCliCB {
        Pim01StartCliRsp(const Pim01StartCliRF& cb)
          : Pim01StartCliCB(cb) { }

    };

    virtual void async_pim_0_1_start_cli
       (
	Pim01StartCliCB);
#endif

    virtual XrlCmdError pim_0_1_stop_cli() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StopCliRF;

    class Pim01StopCliCB {
        Pim01StopCliRF cb;

    public:
        operator const Pim01StopCliRF& () const { return cb; }
        const Pim01StopCliRF& operator ->() const { return cb; }
        Pim01StopCliCB(const Pim01StopCliRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StopCliRsp :
      public Pim01StopCliCB {
        Pim01StopCliRsp(const Pim01StopCliRF& cb)
          : Pim01StopCliCB(cb) { }

    };

    virtual void async_pim_0_1_stop_cli
       (
	Pim01StopCliCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop BSR.
     *
     *  @param enable if true, then enable the BSR, otherwise disable it.
     */
    virtual XrlCmdError pim_0_1_enable_bsr(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01EnableBsrRF;

    class Pim01EnableBsrCB {
        Pim01EnableBsrRF cb;

    public:
        operator const Pim01EnableBsrRF& () const { return cb; }
        const Pim01EnableBsrRF& operator ->() const { return cb; }
        Pim01EnableBsrCB(const Pim01EnableBsrRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01EnableBsrRsp :
      public Pim01EnableBsrCB {
        Pim01EnableBsrRsp(const Pim01EnableBsrRF& cb)
          : Pim01EnableBsrCB(cb) { }

    };

    virtual void async_pim_0_1_enable_bsr
       (
	const bool&	enable,
	Pim01EnableBsrCB);
#endif

    virtual XrlCmdError pim_0_1_start_bsr() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StartBsrRF;

    class Pim01StartBsrCB {
        Pim01StartBsrRF cb;

    public:
        operator const Pim01StartBsrRF& () const { return cb; }
        const Pim01StartBsrRF& operator ->() const { return cb; }
        Pim01StartBsrCB(const Pim01StartBsrRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StartBsrRsp :
      public Pim01StartBsrCB {
        Pim01StartBsrRsp(const Pim01StartBsrRF& cb)
          : Pim01StartBsrCB(cb) { }

    };

    virtual void async_pim_0_1_start_bsr
       (
	Pim01StartBsrCB);
#endif

    virtual XrlCmdError pim_0_1_stop_bsr() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01StopBsrRF;

    class Pim01StopBsrCB {
        Pim01StopBsrRF cb;

    public:
        operator const Pim01StopBsrRF& () const { return cb; }
        const Pim01StopBsrRF& operator ->() const { return cb; }
        Pim01StopBsrCB(const Pim01StopBsrRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01StopBsrRsp :
      public Pim01StopBsrCB {
        Pim01StopBsrRsp(const Pim01StopBsrRF& cb)
          : Pim01StopBsrCB(cb) { }

    };

    virtual void async_pim_0_1_stop_bsr
       (
	Pim01StopBsrCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Apply BSR configuration changes.
     */
    virtual XrlCmdError pim_0_1_apply_bsr_changes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ApplyBsrChangesRF;

    class Pim01ApplyBsrChangesCB {
        Pim01ApplyBsrChangesRF cb;

    public:
        operator const Pim01ApplyBsrChangesRF& () const { return cb; }
        const Pim01ApplyBsrChangesRF& operator ->() const { return cb; }
        Pim01ApplyBsrChangesCB(const Pim01ApplyBsrChangesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ApplyBsrChangesRsp :
      public Pim01ApplyBsrChangesCB {
        Pim01ApplyBsrChangesRsp(const Pim01ApplyBsrChangesRF& cb)
          : Pim01ApplyBsrChangesCB(cb) { }

    };

    virtual void async_pim_0_1_apply_bsr_changes
       (
	Pim01ApplyBsrChangesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete scope zone.
     *
     *  @param scope_zone_id the ID of the configured zone.
     *
     *  @param vif_name the name of the vif to use as a bondary of the scope
     *  zone.
     */
    virtual XrlCmdError pim_0_1_add_config_scope_zone_by_vif_name4(
	// Input values,
	const IPv4Net&	scope_zone_id,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigScopeZoneByVifName4RF;

    class Pim01AddConfigScopeZoneByVifName4CB {
        Pim01AddConfigScopeZoneByVifName4RF cb;

    public:
        operator const Pim01AddConfigScopeZoneByVifName4RF& () const { return cb; }
        const Pim01AddConfigScopeZoneByVifName4RF& operator ->() const { return cb; }
        Pim01AddConfigScopeZoneByVifName4CB(const Pim01AddConfigScopeZoneByVifName4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigScopeZoneByVifName4Rsp :
      public Pim01AddConfigScopeZoneByVifName4CB {
        Pim01AddConfigScopeZoneByVifName4Rsp(const Pim01AddConfigScopeZoneByVifName4RF& cb)
          : Pim01AddConfigScopeZoneByVifName4CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_scope_zone_by_vif_name4
       (
	const IPv4Net&	scope_zone_id,
	const string&	vif_name,
	Pim01AddConfigScopeZoneByVifName4CB);
#endif

    virtual XrlCmdError pim_0_1_add_config_scope_zone_by_vif_name6(
	// Input values,
	const IPv6Net&	scope_zone_id,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigScopeZoneByVifName6RF;

    class Pim01AddConfigScopeZoneByVifName6CB {
        Pim01AddConfigScopeZoneByVifName6RF cb;

    public:
        operator const Pim01AddConfigScopeZoneByVifName6RF& () const { return cb; }
        const Pim01AddConfigScopeZoneByVifName6RF& operator ->() const { return cb; }
        Pim01AddConfigScopeZoneByVifName6CB(const Pim01AddConfigScopeZoneByVifName6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigScopeZoneByVifName6Rsp :
      public Pim01AddConfigScopeZoneByVifName6CB {
        Pim01AddConfigScopeZoneByVifName6Rsp(const Pim01AddConfigScopeZoneByVifName6RF& cb)
          : Pim01AddConfigScopeZoneByVifName6CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_scope_zone_by_vif_name6
       (
	const IPv6Net&	scope_zone_id,
	const string&	vif_name,
	Pim01AddConfigScopeZoneByVifName6CB);
#endif

    virtual XrlCmdError pim_0_1_add_config_scope_zone_by_vif_addr6(
	// Input values,
	const IPv6Net&	scope_zone_id,
	const IPv6&	vif_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigScopeZoneByVifAddr6RF;

    class Pim01AddConfigScopeZoneByVifAddr6CB {
        Pim01AddConfigScopeZoneByVifAddr6RF cb;

    public:
        operator const Pim01AddConfigScopeZoneByVifAddr6RF& () const { return cb; }
        const Pim01AddConfigScopeZoneByVifAddr6RF& operator ->() const { return cb; }
        Pim01AddConfigScopeZoneByVifAddr6CB(const Pim01AddConfigScopeZoneByVifAddr6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigScopeZoneByVifAddr6Rsp :
      public Pim01AddConfigScopeZoneByVifAddr6CB {
        Pim01AddConfigScopeZoneByVifAddr6Rsp(const Pim01AddConfigScopeZoneByVifAddr6RF& cb)
          : Pim01AddConfigScopeZoneByVifAddr6CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_scope_zone_by_vif_addr6
       (
	const IPv6Net&	scope_zone_id,
	const IPv6&	vif_addr,
	Pim01AddConfigScopeZoneByVifAddr6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_scope_zone_by_vif_name6(
	// Input values,
	const IPv6Net&	scope_zone_id,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigScopeZoneByVifName6RF;

    class Pim01DeleteConfigScopeZoneByVifName6CB {
        Pim01DeleteConfigScopeZoneByVifName6RF cb;

    public:
        operator const Pim01DeleteConfigScopeZoneByVifName6RF& () const { return cb; }
        const Pim01DeleteConfigScopeZoneByVifName6RF& operator ->() const { return cb; }
        Pim01DeleteConfigScopeZoneByVifName6CB(const Pim01DeleteConfigScopeZoneByVifName6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigScopeZoneByVifName6Rsp :
      public Pim01DeleteConfigScopeZoneByVifName6CB {
        Pim01DeleteConfigScopeZoneByVifName6Rsp(const Pim01DeleteConfigScopeZoneByVifName6RF& cb)
          : Pim01DeleteConfigScopeZoneByVifName6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_scope_zone_by_vif_name6
       (
	const IPv6Net&	scope_zone_id,
	const string&	vif_name,
	Pim01DeleteConfigScopeZoneByVifName6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_scope_zone_by_vif_addr6(
	// Input values,
	const IPv6Net&	scope_zone_id,
	const IPv6&	vif_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigScopeZoneByVifAddr6RF;

    class Pim01DeleteConfigScopeZoneByVifAddr6CB {
        Pim01DeleteConfigScopeZoneByVifAddr6RF cb;

    public:
        operator const Pim01DeleteConfigScopeZoneByVifAddr6RF& () const { return cb; }
        const Pim01DeleteConfigScopeZoneByVifAddr6RF& operator ->() const { return cb; }
        Pim01DeleteConfigScopeZoneByVifAddr6CB(const Pim01DeleteConfigScopeZoneByVifAddr6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigScopeZoneByVifAddr6Rsp :
      public Pim01DeleteConfigScopeZoneByVifAddr6CB {
        Pim01DeleteConfigScopeZoneByVifAddr6Rsp(const Pim01DeleteConfigScopeZoneByVifAddr6RF& cb)
          : Pim01DeleteConfigScopeZoneByVifAddr6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_scope_zone_by_vif_addr6
       (
	const IPv6Net&	scope_zone_id,
	const IPv6&	vif_addr,
	Pim01DeleteConfigScopeZoneByVifAddr6CB);
#endif

    virtual XrlCmdError pim_0_1_add_config_scope_zone_by_vif_addr4(
	// Input values,
	const IPv4Net&	scope_zone_id,
	const IPv4&	vif_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigScopeZoneByVifAddr4RF;

    class Pim01AddConfigScopeZoneByVifAddr4CB {
        Pim01AddConfigScopeZoneByVifAddr4RF cb;

    public:
        operator const Pim01AddConfigScopeZoneByVifAddr4RF& () const { return cb; }
        const Pim01AddConfigScopeZoneByVifAddr4RF& operator ->() const { return cb; }
        Pim01AddConfigScopeZoneByVifAddr4CB(const Pim01AddConfigScopeZoneByVifAddr4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigScopeZoneByVifAddr4Rsp :
      public Pim01AddConfigScopeZoneByVifAddr4CB {
        Pim01AddConfigScopeZoneByVifAddr4Rsp(const Pim01AddConfigScopeZoneByVifAddr4RF& cb)
          : Pim01AddConfigScopeZoneByVifAddr4CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_scope_zone_by_vif_addr4
       (
	const IPv4Net&	scope_zone_id,
	const IPv4&	vif_addr,
	Pim01AddConfigScopeZoneByVifAddr4CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_scope_zone_by_vif_name4(
	// Input values,
	const IPv4Net&	scope_zone_id,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigScopeZoneByVifName4RF;

    class Pim01DeleteConfigScopeZoneByVifName4CB {
        Pim01DeleteConfigScopeZoneByVifName4RF cb;

    public:
        operator const Pim01DeleteConfigScopeZoneByVifName4RF& () const { return cb; }
        const Pim01DeleteConfigScopeZoneByVifName4RF& operator ->() const { return cb; }
        Pim01DeleteConfigScopeZoneByVifName4CB(const Pim01DeleteConfigScopeZoneByVifName4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigScopeZoneByVifName4Rsp :
      public Pim01DeleteConfigScopeZoneByVifName4CB {
        Pim01DeleteConfigScopeZoneByVifName4Rsp(const Pim01DeleteConfigScopeZoneByVifName4RF& cb)
          : Pim01DeleteConfigScopeZoneByVifName4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_scope_zone_by_vif_name4
       (
	const IPv4Net&	scope_zone_id,
	const string&	vif_name,
	Pim01DeleteConfigScopeZoneByVifName4CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_scope_zone_by_vif_addr4(
	// Input values,
	const IPv4Net&	scope_zone_id,
	const IPv4&	vif_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigScopeZoneByVifAddr4RF;

    class Pim01DeleteConfigScopeZoneByVifAddr4CB {
        Pim01DeleteConfigScopeZoneByVifAddr4RF cb;

    public:
        operator const Pim01DeleteConfigScopeZoneByVifAddr4RF& () const { return cb; }
        const Pim01DeleteConfigScopeZoneByVifAddr4RF& operator ->() const { return cb; }
        Pim01DeleteConfigScopeZoneByVifAddr4CB(const Pim01DeleteConfigScopeZoneByVifAddr4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigScopeZoneByVifAddr4Rsp :
      public Pim01DeleteConfigScopeZoneByVifAddr4CB {
        Pim01DeleteConfigScopeZoneByVifAddr4Rsp(const Pim01DeleteConfigScopeZoneByVifAddr4RF& cb)
          : Pim01DeleteConfigScopeZoneByVifAddr4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_scope_zone_by_vif_addr4
       (
	const IPv4Net&	scope_zone_id,
	const IPv4&	vif_addr,
	Pim01DeleteConfigScopeZoneByVifAddr4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete candidate-BSR configuration.
     *
     *  @param scope_zone_id the ID of the configured zone.
     *
     *  @param is_scope_zone true if configuring administratively scoped zone.
     *
     *  @param vif_name the name of the vif to use its address as a
     *  candidate-BSR.
     *
     *  @param vif_addr the address of the vif to use as a candidate-BSR.
     *
     *  @param bsr_priority the BSR priority (larger is better).
     *
     *  @param hash_mask_len the hash mask length.
     */
    virtual XrlCmdError pim_0_1_add_config_cand_bsr4(
	// Input values,
	const IPv4Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigCandBsr4RF;

    class Pim01AddConfigCandBsr4CB {
        Pim01AddConfigCandBsr4RF cb;

    public:
        operator const Pim01AddConfigCandBsr4RF& () const { return cb; }
        const Pim01AddConfigCandBsr4RF& operator ->() const { return cb; }
        Pim01AddConfigCandBsr4CB(const Pim01AddConfigCandBsr4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigCandBsr4Rsp :
      public Pim01AddConfigCandBsr4CB {
        Pim01AddConfigCandBsr4Rsp(const Pim01AddConfigCandBsr4RF& cb)
          : Pim01AddConfigCandBsr4CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_cand_bsr4
       (
	const IPv4Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	Pim01AddConfigCandBsr4CB);
#endif

    virtual XrlCmdError pim_0_1_add_config_cand_bsr6(
	// Input values,
	const IPv6Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigCandBsr6RF;

    class Pim01AddConfigCandBsr6CB {
        Pim01AddConfigCandBsr6RF cb;

    public:
        operator const Pim01AddConfigCandBsr6RF& () const { return cb; }
        const Pim01AddConfigCandBsr6RF& operator ->() const { return cb; }
        Pim01AddConfigCandBsr6CB(const Pim01AddConfigCandBsr6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigCandBsr6Rsp :
      public Pim01AddConfigCandBsr6CB {
        Pim01AddConfigCandBsr6Rsp(const Pim01AddConfigCandBsr6RF& cb)
          : Pim01AddConfigCandBsr6CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_cand_bsr6
       (
	const IPv6Net&	scope_zone_id,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	Pim01AddConfigCandBsr6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_cand_bsr6(
	// Input values,
	const IPv6Net&	scope_zone_id,
	const bool&	is_scope_zone) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigCandBsr6RF;

    class Pim01DeleteConfigCandBsr6CB {
        Pim01DeleteConfigCandBsr6RF cb;

    public:
        operator const Pim01DeleteConfigCandBsr6RF& () const { return cb; }
        const Pim01DeleteConfigCandBsr6RF& operator ->() const { return cb; }
        Pim01DeleteConfigCandBsr6CB(const Pim01DeleteConfigCandBsr6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigCandBsr6Rsp :
      public Pim01DeleteConfigCandBsr6CB {
        Pim01DeleteConfigCandBsr6Rsp(const Pim01DeleteConfigCandBsr6RF& cb)
          : Pim01DeleteConfigCandBsr6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_cand_bsr6
       (
	const IPv6Net&	scope_zone_id,
	const bool&	is_scope_zone,
	Pim01DeleteConfigCandBsr6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_cand_bsr4(
	// Input values,
	const IPv4Net&	scope_zone_id,
	const bool&	is_scope_zone) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigCandBsr4RF;

    class Pim01DeleteConfigCandBsr4CB {
        Pim01DeleteConfigCandBsr4RF cb;

    public:
        operator const Pim01DeleteConfigCandBsr4RF& () const { return cb; }
        const Pim01DeleteConfigCandBsr4RF& operator ->() const { return cb; }
        Pim01DeleteConfigCandBsr4CB(const Pim01DeleteConfigCandBsr4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigCandBsr4Rsp :
      public Pim01DeleteConfigCandBsr4CB {
        Pim01DeleteConfigCandBsr4Rsp(const Pim01DeleteConfigCandBsr4RF& cb)
          : Pim01DeleteConfigCandBsr4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_cand_bsr4
       (
	const IPv4Net&	scope_zone_id,
	const bool&	is_scope_zone,
	Pim01DeleteConfigCandBsr4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete Candidate-RP configuration.
     *
     *  @param group_prefix the group prefix of the configured zone.
     *
     *  @param is_scope_zone true if configuring administratively scoped zone.
     *
     *  @param vif_name the name of the vif to use its address as a
     *  candidate-RP.
     *
     *  @param vif_addr the address of the vif to use as a candidate-RP.
     *
     *  @param rp_priority the Cand-RP priority (smaller is better).
     *
     *  @param rp_holdtime the Cand-RP holdtime (in seconds).
     */
    virtual XrlCmdError pim_0_1_add_config_cand_rp4(
	// Input values,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigCandRp4RF;

    class Pim01AddConfigCandRp4CB {
        Pim01AddConfigCandRp4RF cb;

    public:
        operator const Pim01AddConfigCandRp4RF& () const { return cb; }
        const Pim01AddConfigCandRp4RF& operator ->() const { return cb; }
        Pim01AddConfigCandRp4CB(const Pim01AddConfigCandRp4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigCandRp4Rsp :
      public Pim01AddConfigCandRp4CB {
        Pim01AddConfigCandRp4Rsp(const Pim01AddConfigCandRp4RF& cb)
          : Pim01AddConfigCandRp4CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_cand_rp4
       (
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	Pim01AddConfigCandRp4CB);
#endif

    virtual XrlCmdError pim_0_1_add_config_cand_rp6(
	// Input values,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigCandRp6RF;

    class Pim01AddConfigCandRp6CB {
        Pim01AddConfigCandRp6RF cb;

    public:
        operator const Pim01AddConfigCandRp6RF& () const { return cb; }
        const Pim01AddConfigCandRp6RF& operator ->() const { return cb; }
        Pim01AddConfigCandRp6CB(const Pim01AddConfigCandRp6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigCandRp6Rsp :
      public Pim01AddConfigCandRp6CB {
        Pim01AddConfigCandRp6Rsp(const Pim01AddConfigCandRp6RF& cb)
          : Pim01AddConfigCandRp6CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_cand_rp6
       (
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	Pim01AddConfigCandRp6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_cand_rp6(
	// Input values,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigCandRp6RF;

    class Pim01DeleteConfigCandRp6CB {
        Pim01DeleteConfigCandRp6RF cb;

    public:
        operator const Pim01DeleteConfigCandRp6RF& () const { return cb; }
        const Pim01DeleteConfigCandRp6RF& operator ->() const { return cb; }
        Pim01DeleteConfigCandRp6CB(const Pim01DeleteConfigCandRp6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigCandRp6Rsp :
      public Pim01DeleteConfigCandRp6CB {
        Pim01DeleteConfigCandRp6Rsp(const Pim01DeleteConfigCandRp6RF& cb)
          : Pim01DeleteConfigCandRp6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_cand_rp6
       (
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv6&	vif_addr,
	Pim01DeleteConfigCandRp6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_cand_rp4(
	// Input values,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigCandRp4RF;

    class Pim01DeleteConfigCandRp4CB {
        Pim01DeleteConfigCandRp4RF cb;

    public:
        operator const Pim01DeleteConfigCandRp4RF& () const { return cb; }
        const Pim01DeleteConfigCandRp4RF& operator ->() const { return cb; }
        Pim01DeleteConfigCandRp4CB(const Pim01DeleteConfigCandRp4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigCandRp4Rsp :
      public Pim01DeleteConfigCandRp4CB {
        Pim01DeleteConfigCandRp4Rsp(const Pim01DeleteConfigCandRp4RF& cb)
          : Pim01DeleteConfigCandRp4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_cand_rp4
       (
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const string&	vif_name,
	const IPv4&	vif_addr,
	Pim01DeleteConfigCandRp4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete/complete static RP configuration.
     *
     *  @param group_prefix the group prefix for the RP.
     *
     *  @param rp_addr the RP address.
     *
     *  @param rp_priority the RP priority (smaller is better).
     *
     *  @param hash_mask_len the hash mask length used in computing an RP for a
     *  group. It should be same across all RPs. If set to zero, the default
     *  one will be used.
     */
    virtual XrlCmdError pim_0_1_add_config_static_rp4(
	// Input values,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	hash_mask_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigStaticRp4RF;

    class Pim01AddConfigStaticRp4CB {
        Pim01AddConfigStaticRp4RF cb;

    public:
        operator const Pim01AddConfigStaticRp4RF& () const { return cb; }
        const Pim01AddConfigStaticRp4RF& operator ->() const { return cb; }
        Pim01AddConfigStaticRp4CB(const Pim01AddConfigStaticRp4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigStaticRp4Rsp :
      public Pim01AddConfigStaticRp4CB {
        Pim01AddConfigStaticRp4Rsp(const Pim01AddConfigStaticRp4RF& cb)
          : Pim01AddConfigStaticRp4CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_static_rp4
       (
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	hash_mask_len,
	Pim01AddConfigStaticRp4CB);
#endif

    virtual XrlCmdError pim_0_1_add_config_static_rp6(
	// Input values,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	hash_mask_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddConfigStaticRp6RF;

    class Pim01AddConfigStaticRp6CB {
        Pim01AddConfigStaticRp6RF cb;

    public:
        operator const Pim01AddConfigStaticRp6RF& () const { return cb; }
        const Pim01AddConfigStaticRp6RF& operator ->() const { return cb; }
        Pim01AddConfigStaticRp6CB(const Pim01AddConfigStaticRp6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddConfigStaticRp6Rsp :
      public Pim01AddConfigStaticRp6CB {
        Pim01AddConfigStaticRp6Rsp(const Pim01AddConfigStaticRp6RF& cb)
          : Pim01AddConfigStaticRp6CB(cb) { }

    };

    virtual void async_pim_0_1_add_config_static_rp6
       (
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	hash_mask_len,
	Pim01AddConfigStaticRp6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_static_rp6(
	// Input values,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigStaticRp6RF;

    class Pim01DeleteConfigStaticRp6CB {
        Pim01DeleteConfigStaticRp6RF cb;

    public:
        operator const Pim01DeleteConfigStaticRp6RF& () const { return cb; }
        const Pim01DeleteConfigStaticRp6RF& operator ->() const { return cb; }
        Pim01DeleteConfigStaticRp6CB(const Pim01DeleteConfigStaticRp6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigStaticRp6Rsp :
      public Pim01DeleteConfigStaticRp6CB {
        Pim01DeleteConfigStaticRp6Rsp(const Pim01DeleteConfigStaticRp6RF& cb)
          : Pim01DeleteConfigStaticRp6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_static_rp6
       (
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	Pim01DeleteConfigStaticRp6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_all_static_group_prefixes_rp6(
	// Input values,
	const IPv6&	rp_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigAllStaticGroupPrefixesRp6RF;

    class Pim01DeleteConfigAllStaticGroupPrefixesRp6CB {
        Pim01DeleteConfigAllStaticGroupPrefixesRp6RF cb;

    public:
        operator const Pim01DeleteConfigAllStaticGroupPrefixesRp6RF& () const { return cb; }
        const Pim01DeleteConfigAllStaticGroupPrefixesRp6RF& operator ->() const { return cb; }
        Pim01DeleteConfigAllStaticGroupPrefixesRp6CB(const Pim01DeleteConfigAllStaticGroupPrefixesRp6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigAllStaticGroupPrefixesRp6Rsp :
      public Pim01DeleteConfigAllStaticGroupPrefixesRp6CB {
        Pim01DeleteConfigAllStaticGroupPrefixesRp6Rsp(const Pim01DeleteConfigAllStaticGroupPrefixesRp6RF& cb)
          : Pim01DeleteConfigAllStaticGroupPrefixesRp6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_all_static_group_prefixes_rp6
       (
	const IPv6&	rp_addr,
	Pim01DeleteConfigAllStaticGroupPrefixesRp6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_static_rp4(
	// Input values,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigStaticRp4RF;

    class Pim01DeleteConfigStaticRp4CB {
        Pim01DeleteConfigStaticRp4RF cb;

    public:
        operator const Pim01DeleteConfigStaticRp4RF& () const { return cb; }
        const Pim01DeleteConfigStaticRp4RF& operator ->() const { return cb; }
        Pim01DeleteConfigStaticRp4CB(const Pim01DeleteConfigStaticRp4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigStaticRp4Rsp :
      public Pim01DeleteConfigStaticRp4CB {
        Pim01DeleteConfigStaticRp4Rsp(const Pim01DeleteConfigStaticRp4RF& cb)
          : Pim01DeleteConfigStaticRp4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_static_rp4
       (
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	Pim01DeleteConfigStaticRp4CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_all_static_group_prefixes_rp4(
	// Input values,
	const IPv4&	rp_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigAllStaticGroupPrefixesRp4RF;

    class Pim01DeleteConfigAllStaticGroupPrefixesRp4CB {
        Pim01DeleteConfigAllStaticGroupPrefixesRp4RF cb;

    public:
        operator const Pim01DeleteConfigAllStaticGroupPrefixesRp4RF& () const { return cb; }
        const Pim01DeleteConfigAllStaticGroupPrefixesRp4RF& operator ->() const { return cb; }
        Pim01DeleteConfigAllStaticGroupPrefixesRp4CB(const Pim01DeleteConfigAllStaticGroupPrefixesRp4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigAllStaticGroupPrefixesRp4Rsp :
      public Pim01DeleteConfigAllStaticGroupPrefixesRp4CB {
        Pim01DeleteConfigAllStaticGroupPrefixesRp4Rsp(const Pim01DeleteConfigAllStaticGroupPrefixesRp4RF& cb)
          : Pim01DeleteConfigAllStaticGroupPrefixesRp4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_all_static_group_prefixes_rp4
       (
	const IPv4&	rp_addr,
	Pim01DeleteConfigAllStaticGroupPrefixesRp4CB);
#endif

    virtual XrlCmdError pim_0_1_delete_config_all_static_rps() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteConfigAllStaticRpsRF;

    class Pim01DeleteConfigAllStaticRpsCB {
        Pim01DeleteConfigAllStaticRpsRF cb;

    public:
        operator const Pim01DeleteConfigAllStaticRpsRF& () const { return cb; }
        const Pim01DeleteConfigAllStaticRpsRF& operator ->() const { return cb; }
        Pim01DeleteConfigAllStaticRpsCB(const Pim01DeleteConfigAllStaticRpsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteConfigAllStaticRpsRsp :
      public Pim01DeleteConfigAllStaticRpsCB {
        Pim01DeleteConfigAllStaticRpsRsp(const Pim01DeleteConfigAllStaticRpsRF& cb)
          : Pim01DeleteConfigAllStaticRpsCB(cb) { }

    };

    virtual void async_pim_0_1_delete_config_all_static_rps
       (
	Pim01DeleteConfigAllStaticRpsCB);
#endif

    virtual XrlCmdError pim_0_1_config_static_rp_done() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ConfigStaticRpDoneRF;

    class Pim01ConfigStaticRpDoneCB {
        Pim01ConfigStaticRpDoneRF cb;

    public:
        operator const Pim01ConfigStaticRpDoneRF& () const { return cb; }
        const Pim01ConfigStaticRpDoneRF& operator ->() const { return cb; }
        Pim01ConfigStaticRpDoneCB(const Pim01ConfigStaticRpDoneRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ConfigStaticRpDoneRsp :
      public Pim01ConfigStaticRpDoneCB {
        Pim01ConfigStaticRpDoneRsp(const Pim01ConfigStaticRpDoneRF& cb)
          : Pim01ConfigStaticRpDoneCB(cb) { }

    };

    virtual void async_pim_0_1_config_static_rp_done
       (
	Pim01ConfigStaticRpDoneCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the configured protocol version per interface.
     *
     *  @param vif_name the name of the vif to apply to.
     *
     *  @param proto_version the protocol version.
     */
    virtual XrlCmdError pim_0_1_get_vif_proto_version(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	proto_version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifProtoVersionRF;

    class Pim01GetVifProtoVersionCB {
        Pim01GetVifProtoVersionRF cb;

    public:
        operator const Pim01GetVifProtoVersionRF& () const { return cb; }
        const Pim01GetVifProtoVersionRF& operator ->() const { return cb; }
        Pim01GetVifProtoVersionCB(const Pim01GetVifProtoVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_proto_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_proto_version);
        }
    };

    struct Pim01GetVifProtoVersionRsp :
      public Pim01GetVifProtoVersionCB {
        struct args_str {
            uint32_t proto_version;
        };

    private:
        args_str args;

    public:
        Pim01GetVifProtoVersionRsp(const Pim01GetVifProtoVersionRF& cb)
          : Pim01GetVifProtoVersionCB(cb) { }

        void respond() const {
            Pim01GetVifProtoVersionCB::
            respond(args.proto_version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_proto_version
       (
	const string&	vif_name,
	Pim01GetVifProtoVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the protocol version per interface.
     *
     *  @param vif_name the name of the vif to apply to.
     *
     *  @param proto_version the protocol version.
     */
    virtual XrlCmdError pim_0_1_set_vif_proto_version(
	// Input values,
	const string&	vif_name,
	const uint32_t&	proto_version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifProtoVersionRF;

    class Pim01SetVifProtoVersionCB {
        Pim01SetVifProtoVersionRF cb;

    public:
        operator const Pim01SetVifProtoVersionRF& () const { return cb; }
        const Pim01SetVifProtoVersionRF& operator ->() const { return cb; }
        Pim01SetVifProtoVersionCB(const Pim01SetVifProtoVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifProtoVersionRsp :
      public Pim01SetVifProtoVersionCB {
        Pim01SetVifProtoVersionRsp(const Pim01SetVifProtoVersionRF& cb)
          : Pim01SetVifProtoVersionCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_proto_version
       (
	const string&	vif_name,
	const uint32_t&	proto_version,
	Pim01SetVifProtoVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset the protocol version per interface to its default value.
     *
     *  @param vif_name the name of the vif to apply to.
     */
    virtual XrlCmdError pim_0_1_reset_vif_proto_version(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifProtoVersionRF;

    class Pim01ResetVifProtoVersionCB {
        Pim01ResetVifProtoVersionRF cb;

    public:
        operator const Pim01ResetVifProtoVersionRF& () const { return cb; }
        const Pim01ResetVifProtoVersionRF& operator ->() const { return cb; }
        Pim01ResetVifProtoVersionCB(const Pim01ResetVifProtoVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifProtoVersionRsp :
      public Pim01ResetVifProtoVersionCB {
        Pim01ResetVifProtoVersionRsp(const Pim01ResetVifProtoVersionRF& cb)
          : Pim01ResetVifProtoVersionCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_proto_version
       (
	const string&	vif_name,
	Pim01ResetVifProtoVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure PIM Hello-related metrics. The 'set_foo' XRLs set the
     *  particular values. The 'reset_foo' XRLs reset the metrics to their
     *  default values.
     *
     *  @param vif_name the name of the vif to configure.
     *
     *  @param hello_triggered_delay the Triggered_Hello_Delay (in seconds).
     */
    virtual XrlCmdError pim_0_1_get_vif_hello_triggered_delay(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	hello_triggered_delay) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifHelloTriggeredDelayRF;

    class Pim01GetVifHelloTriggeredDelayCB {
        Pim01GetVifHelloTriggeredDelayRF cb;

    public:
        operator const Pim01GetVifHelloTriggeredDelayRF& () const { return cb; }
        const Pim01GetVifHelloTriggeredDelayRF& operator ->() const { return cb; }
        Pim01GetVifHelloTriggeredDelayCB(const Pim01GetVifHelloTriggeredDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_hello_triggered_delay) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_hello_triggered_delay);
        }
    };

    struct Pim01GetVifHelloTriggeredDelayRsp :
      public Pim01GetVifHelloTriggeredDelayCB {
        struct args_str {
            uint32_t hello_triggered_delay;
        };

    private:
        args_str args;

    public:
        Pim01GetVifHelloTriggeredDelayRsp(const Pim01GetVifHelloTriggeredDelayRF& cb)
          : Pim01GetVifHelloTriggeredDelayCB(cb) { }

        void respond() const {
            Pim01GetVifHelloTriggeredDelayCB::
            respond(args.hello_triggered_delay);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_hello_triggered_delay
       (
	const string&	vif_name,
	Pim01GetVifHelloTriggeredDelayCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_hello_triggered_delay(
	// Input values,
	const string&	vif_name,
	const uint32_t&	hello_triggered_delay) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifHelloTriggeredDelayRF;

    class Pim01SetVifHelloTriggeredDelayCB {
        Pim01SetVifHelloTriggeredDelayRF cb;

    public:
        operator const Pim01SetVifHelloTriggeredDelayRF& () const { return cb; }
        const Pim01SetVifHelloTriggeredDelayRF& operator ->() const { return cb; }
        Pim01SetVifHelloTriggeredDelayCB(const Pim01SetVifHelloTriggeredDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifHelloTriggeredDelayRsp :
      public Pim01SetVifHelloTriggeredDelayCB {
        Pim01SetVifHelloTriggeredDelayRsp(const Pim01SetVifHelloTriggeredDelayRF& cb)
          : Pim01SetVifHelloTriggeredDelayCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_hello_triggered_delay
       (
	const string&	vif_name,
	const uint32_t&	hello_triggered_delay,
	Pim01SetVifHelloTriggeredDelayCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_hello_triggered_delay(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifHelloTriggeredDelayRF;

    class Pim01ResetVifHelloTriggeredDelayCB {
        Pim01ResetVifHelloTriggeredDelayRF cb;

    public:
        operator const Pim01ResetVifHelloTriggeredDelayRF& () const { return cb; }
        const Pim01ResetVifHelloTriggeredDelayRF& operator ->() const { return cb; }
        Pim01ResetVifHelloTriggeredDelayCB(const Pim01ResetVifHelloTriggeredDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifHelloTriggeredDelayRsp :
      public Pim01ResetVifHelloTriggeredDelayCB {
        Pim01ResetVifHelloTriggeredDelayRsp(const Pim01ResetVifHelloTriggeredDelayRF& cb)
          : Pim01ResetVifHelloTriggeredDelayCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_hello_triggered_delay
       (
	const string&	vif_name,
	Pim01ResetVifHelloTriggeredDelayCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_hello_period(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	hello_period) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifHelloPeriodRF;

    class Pim01GetVifHelloPeriodCB {
        Pim01GetVifHelloPeriodRF cb;

    public:
        operator const Pim01GetVifHelloPeriodRF& () const { return cb; }
        const Pim01GetVifHelloPeriodRF& operator ->() const { return cb; }
        Pim01GetVifHelloPeriodCB(const Pim01GetVifHelloPeriodRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_hello_period) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_hello_period);
        }
    };

    struct Pim01GetVifHelloPeriodRsp :
      public Pim01GetVifHelloPeriodCB {
        struct args_str {
            uint32_t hello_period;
        };

    private:
        args_str args;

    public:
        Pim01GetVifHelloPeriodRsp(const Pim01GetVifHelloPeriodRF& cb)
          : Pim01GetVifHelloPeriodCB(cb) { }

        void respond() const {
            Pim01GetVifHelloPeriodCB::
            respond(args.hello_period);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_hello_period
       (
	const string&	vif_name,
	Pim01GetVifHelloPeriodCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_hello_period(
	// Input values,
	const string&	vif_name,
	const uint32_t&	hello_period) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifHelloPeriodRF;

    class Pim01SetVifHelloPeriodCB {
        Pim01SetVifHelloPeriodRF cb;

    public:
        operator const Pim01SetVifHelloPeriodRF& () const { return cb; }
        const Pim01SetVifHelloPeriodRF& operator ->() const { return cb; }
        Pim01SetVifHelloPeriodCB(const Pim01SetVifHelloPeriodRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifHelloPeriodRsp :
      public Pim01SetVifHelloPeriodCB {
        Pim01SetVifHelloPeriodRsp(const Pim01SetVifHelloPeriodRF& cb)
          : Pim01SetVifHelloPeriodCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_hello_period
       (
	const string&	vif_name,
	const uint32_t&	hello_period,
	Pim01SetVifHelloPeriodCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_hello_period(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifHelloPeriodRF;

    class Pim01ResetVifHelloPeriodCB {
        Pim01ResetVifHelloPeriodRF cb;

    public:
        operator const Pim01ResetVifHelloPeriodRF& () const { return cb; }
        const Pim01ResetVifHelloPeriodRF& operator ->() const { return cb; }
        Pim01ResetVifHelloPeriodCB(const Pim01ResetVifHelloPeriodRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifHelloPeriodRsp :
      public Pim01ResetVifHelloPeriodCB {
        Pim01ResetVifHelloPeriodRsp(const Pim01ResetVifHelloPeriodRF& cb)
          : Pim01ResetVifHelloPeriodCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_hello_period
       (
	const string&	vif_name,
	Pim01ResetVifHelloPeriodCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_hello_holdtime(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	hello_holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifHelloHoldtimeRF;

    class Pim01GetVifHelloHoldtimeCB {
        Pim01GetVifHelloHoldtimeRF cb;

    public:
        operator const Pim01GetVifHelloHoldtimeRF& () const { return cb; }
        const Pim01GetVifHelloHoldtimeRF& operator ->() const { return cb; }
        Pim01GetVifHelloHoldtimeCB(const Pim01GetVifHelloHoldtimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_hello_holdtime) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_hello_holdtime);
        }
    };

    struct Pim01GetVifHelloHoldtimeRsp :
      public Pim01GetVifHelloHoldtimeCB {
        struct args_str {
            uint32_t hello_holdtime;
        };

    private:
        args_str args;

    public:
        Pim01GetVifHelloHoldtimeRsp(const Pim01GetVifHelloHoldtimeRF& cb)
          : Pim01GetVifHelloHoldtimeCB(cb) { }

        void respond() const {
            Pim01GetVifHelloHoldtimeCB::
            respond(args.hello_holdtime);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_hello_holdtime
       (
	const string&	vif_name,
	Pim01GetVifHelloHoldtimeCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_hello_holdtime(
	// Input values,
	const string&	vif_name,
	const uint32_t&	hello_holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifHelloHoldtimeRF;

    class Pim01SetVifHelloHoldtimeCB {
        Pim01SetVifHelloHoldtimeRF cb;

    public:
        operator const Pim01SetVifHelloHoldtimeRF& () const { return cb; }
        const Pim01SetVifHelloHoldtimeRF& operator ->() const { return cb; }
        Pim01SetVifHelloHoldtimeCB(const Pim01SetVifHelloHoldtimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifHelloHoldtimeRsp :
      public Pim01SetVifHelloHoldtimeCB {
        Pim01SetVifHelloHoldtimeRsp(const Pim01SetVifHelloHoldtimeRF& cb)
          : Pim01SetVifHelloHoldtimeCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_hello_holdtime
       (
	const string&	vif_name,
	const uint32_t&	hello_holdtime,
	Pim01SetVifHelloHoldtimeCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_hello_holdtime(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifHelloHoldtimeRF;

    class Pim01ResetVifHelloHoldtimeCB {
        Pim01ResetVifHelloHoldtimeRF cb;

    public:
        operator const Pim01ResetVifHelloHoldtimeRF& () const { return cb; }
        const Pim01ResetVifHelloHoldtimeRF& operator ->() const { return cb; }
        Pim01ResetVifHelloHoldtimeCB(const Pim01ResetVifHelloHoldtimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifHelloHoldtimeRsp :
      public Pim01ResetVifHelloHoldtimeCB {
        Pim01ResetVifHelloHoldtimeRsp(const Pim01ResetVifHelloHoldtimeRF& cb)
          : Pim01ResetVifHelloHoldtimeCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_hello_holdtime
       (
	const string&	vif_name,
	Pim01ResetVifHelloHoldtimeCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_dr_priority(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	dr_priority) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifDrPriorityRF;

    class Pim01GetVifDrPriorityCB {
        Pim01GetVifDrPriorityRF cb;

    public:
        operator const Pim01GetVifDrPriorityRF& () const { return cb; }
        const Pim01GetVifDrPriorityRF& operator ->() const { return cb; }
        Pim01GetVifDrPriorityCB(const Pim01GetVifDrPriorityRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_dr_priority) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_dr_priority);
        }
    };

    struct Pim01GetVifDrPriorityRsp :
      public Pim01GetVifDrPriorityCB {
        struct args_str {
            uint32_t dr_priority;
        };

    private:
        args_str args;

    public:
        Pim01GetVifDrPriorityRsp(const Pim01GetVifDrPriorityRF& cb)
          : Pim01GetVifDrPriorityCB(cb) { }

        void respond() const {
            Pim01GetVifDrPriorityCB::
            respond(args.dr_priority);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_dr_priority
       (
	const string&	vif_name,
	Pim01GetVifDrPriorityCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_dr_priority(
	// Input values,
	const string&	vif_name,
	const uint32_t&	dr_priority) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifDrPriorityRF;

    class Pim01SetVifDrPriorityCB {
        Pim01SetVifDrPriorityRF cb;

    public:
        operator const Pim01SetVifDrPriorityRF& () const { return cb; }
        const Pim01SetVifDrPriorityRF& operator ->() const { return cb; }
        Pim01SetVifDrPriorityCB(const Pim01SetVifDrPriorityRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifDrPriorityRsp :
      public Pim01SetVifDrPriorityCB {
        Pim01SetVifDrPriorityRsp(const Pim01SetVifDrPriorityRF& cb)
          : Pim01SetVifDrPriorityCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_dr_priority
       (
	const string&	vif_name,
	const uint32_t&	dr_priority,
	Pim01SetVifDrPriorityCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_dr_priority(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifDrPriorityRF;

    class Pim01ResetVifDrPriorityCB {
        Pim01ResetVifDrPriorityRF cb;

    public:
        operator const Pim01ResetVifDrPriorityRF& () const { return cb; }
        const Pim01ResetVifDrPriorityRF& operator ->() const { return cb; }
        Pim01ResetVifDrPriorityCB(const Pim01ResetVifDrPriorityRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifDrPriorityRsp :
      public Pim01ResetVifDrPriorityCB {
        Pim01ResetVifDrPriorityRsp(const Pim01ResetVifDrPriorityRF& cb)
          : Pim01ResetVifDrPriorityCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_dr_priority
       (
	const string&	vif_name,
	Pim01ResetVifDrPriorityCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_propagation_delay(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	propagation_delay) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifPropagationDelayRF;

    class Pim01GetVifPropagationDelayCB {
        Pim01GetVifPropagationDelayRF cb;

    public:
        operator const Pim01GetVifPropagationDelayRF& () const { return cb; }
        const Pim01GetVifPropagationDelayRF& operator ->() const { return cb; }
        Pim01GetVifPropagationDelayCB(const Pim01GetVifPropagationDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_propagation_delay) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_propagation_delay);
        }
    };

    struct Pim01GetVifPropagationDelayRsp :
      public Pim01GetVifPropagationDelayCB {
        struct args_str {
            uint32_t propagation_delay;
        };

    private:
        args_str args;

    public:
        Pim01GetVifPropagationDelayRsp(const Pim01GetVifPropagationDelayRF& cb)
          : Pim01GetVifPropagationDelayCB(cb) { }

        void respond() const {
            Pim01GetVifPropagationDelayCB::
            respond(args.propagation_delay);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_propagation_delay
       (
	const string&	vif_name,
	Pim01GetVifPropagationDelayCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_propagation_delay(
	// Input values,
	const string&	vif_name,
	const uint32_t&	propagation_delay) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifPropagationDelayRF;

    class Pim01SetVifPropagationDelayCB {
        Pim01SetVifPropagationDelayRF cb;

    public:
        operator const Pim01SetVifPropagationDelayRF& () const { return cb; }
        const Pim01SetVifPropagationDelayRF& operator ->() const { return cb; }
        Pim01SetVifPropagationDelayCB(const Pim01SetVifPropagationDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifPropagationDelayRsp :
      public Pim01SetVifPropagationDelayCB {
        Pim01SetVifPropagationDelayRsp(const Pim01SetVifPropagationDelayRF& cb)
          : Pim01SetVifPropagationDelayCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_propagation_delay
       (
	const string&	vif_name,
	const uint32_t&	propagation_delay,
	Pim01SetVifPropagationDelayCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_propagation_delay(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifPropagationDelayRF;

    class Pim01ResetVifPropagationDelayCB {
        Pim01ResetVifPropagationDelayRF cb;

    public:
        operator const Pim01ResetVifPropagationDelayRF& () const { return cb; }
        const Pim01ResetVifPropagationDelayRF& operator ->() const { return cb; }
        Pim01ResetVifPropagationDelayCB(const Pim01ResetVifPropagationDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifPropagationDelayRsp :
      public Pim01ResetVifPropagationDelayCB {
        Pim01ResetVifPropagationDelayRsp(const Pim01ResetVifPropagationDelayRF& cb)
          : Pim01ResetVifPropagationDelayCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_propagation_delay
       (
	const string&	vif_name,
	Pim01ResetVifPropagationDelayCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_override_interval(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	override_interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifOverrideIntervalRF;

    class Pim01GetVifOverrideIntervalCB {
        Pim01GetVifOverrideIntervalRF cb;

    public:
        operator const Pim01GetVifOverrideIntervalRF& () const { return cb; }
        const Pim01GetVifOverrideIntervalRF& operator ->() const { return cb; }
        Pim01GetVifOverrideIntervalCB(const Pim01GetVifOverrideIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_override_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_override_interval);
        }
    };

    struct Pim01GetVifOverrideIntervalRsp :
      public Pim01GetVifOverrideIntervalCB {
        struct args_str {
            uint32_t override_interval;
        };

    private:
        args_str args;

    public:
        Pim01GetVifOverrideIntervalRsp(const Pim01GetVifOverrideIntervalRF& cb)
          : Pim01GetVifOverrideIntervalCB(cb) { }

        void respond() const {
            Pim01GetVifOverrideIntervalCB::
            respond(args.override_interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_override_interval
       (
	const string&	vif_name,
	Pim01GetVifOverrideIntervalCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_override_interval(
	// Input values,
	const string&	vif_name,
	const uint32_t&	override_interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifOverrideIntervalRF;

    class Pim01SetVifOverrideIntervalCB {
        Pim01SetVifOverrideIntervalRF cb;

    public:
        operator const Pim01SetVifOverrideIntervalRF& () const { return cb; }
        const Pim01SetVifOverrideIntervalRF& operator ->() const { return cb; }
        Pim01SetVifOverrideIntervalCB(const Pim01SetVifOverrideIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifOverrideIntervalRsp :
      public Pim01SetVifOverrideIntervalCB {
        Pim01SetVifOverrideIntervalRsp(const Pim01SetVifOverrideIntervalRF& cb)
          : Pim01SetVifOverrideIntervalCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_override_interval
       (
	const string&	vif_name,
	const uint32_t&	override_interval,
	Pim01SetVifOverrideIntervalCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_override_interval(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifOverrideIntervalRF;

    class Pim01ResetVifOverrideIntervalCB {
        Pim01ResetVifOverrideIntervalRF cb;

    public:
        operator const Pim01ResetVifOverrideIntervalRF& () const { return cb; }
        const Pim01ResetVifOverrideIntervalRF& operator ->() const { return cb; }
        Pim01ResetVifOverrideIntervalCB(const Pim01ResetVifOverrideIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifOverrideIntervalRsp :
      public Pim01ResetVifOverrideIntervalCB {
        Pim01ResetVifOverrideIntervalRsp(const Pim01ResetVifOverrideIntervalRF& cb)
          : Pim01ResetVifOverrideIntervalCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_override_interval
       (
	const string&	vif_name,
	Pim01ResetVifOverrideIntervalCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_is_tracking_support_disabled(
	// Input values,
	const string&	vif_name,
	// Output values,
	bool&	is_tracking_support_disabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Pim01GetVifIsTrackingSupportDisabledRF;

    class Pim01GetVifIsTrackingSupportDisabledCB {
        Pim01GetVifIsTrackingSupportDisabledRF cb;

    public:
        operator const Pim01GetVifIsTrackingSupportDisabledRF& () const { return cb; }
        const Pim01GetVifIsTrackingSupportDisabledRF& operator ->() const { return cb; }
        Pim01GetVifIsTrackingSupportDisabledCB(const Pim01GetVifIsTrackingSupportDisabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_is_tracking_support_disabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_is_tracking_support_disabled);
        }
    };

    struct Pim01GetVifIsTrackingSupportDisabledRsp :
      public Pim01GetVifIsTrackingSupportDisabledCB {
        struct args_str {
            bool is_tracking_support_disabled;
        };

    private:
        args_str args;

    public:
        Pim01GetVifIsTrackingSupportDisabledRsp(const Pim01GetVifIsTrackingSupportDisabledRF& cb)
          : Pim01GetVifIsTrackingSupportDisabledCB(cb) { }

        void respond() const {
            Pim01GetVifIsTrackingSupportDisabledCB::
            respond(args.is_tracking_support_disabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_is_tracking_support_disabled
       (
	const string&	vif_name,
	Pim01GetVifIsTrackingSupportDisabledCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_is_tracking_support_disabled(
	// Input values,
	const string&	vif_name,
	const bool&	is_tracking_support_disabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifIsTrackingSupportDisabledRF;

    class Pim01SetVifIsTrackingSupportDisabledCB {
        Pim01SetVifIsTrackingSupportDisabledRF cb;

    public:
        operator const Pim01SetVifIsTrackingSupportDisabledRF& () const { return cb; }
        const Pim01SetVifIsTrackingSupportDisabledRF& operator ->() const { return cb; }
        Pim01SetVifIsTrackingSupportDisabledCB(const Pim01SetVifIsTrackingSupportDisabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifIsTrackingSupportDisabledRsp :
      public Pim01SetVifIsTrackingSupportDisabledCB {
        Pim01SetVifIsTrackingSupportDisabledRsp(const Pim01SetVifIsTrackingSupportDisabledRF& cb)
          : Pim01SetVifIsTrackingSupportDisabledCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_is_tracking_support_disabled
       (
	const string&	vif_name,
	const bool&	is_tracking_support_disabled,
	Pim01SetVifIsTrackingSupportDisabledCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_is_tracking_support_disabled(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifIsTrackingSupportDisabledRF;

    class Pim01ResetVifIsTrackingSupportDisabledCB {
        Pim01ResetVifIsTrackingSupportDisabledRF cb;

    public:
        operator const Pim01ResetVifIsTrackingSupportDisabledRF& () const { return cb; }
        const Pim01ResetVifIsTrackingSupportDisabledRF& operator ->() const { return cb; }
        Pim01ResetVifIsTrackingSupportDisabledCB(const Pim01ResetVifIsTrackingSupportDisabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifIsTrackingSupportDisabledRsp :
      public Pim01ResetVifIsTrackingSupportDisabledCB {
        Pim01ResetVifIsTrackingSupportDisabledRsp(const Pim01ResetVifIsTrackingSupportDisabledRF& cb)
          : Pim01ResetVifIsTrackingSupportDisabledCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_is_tracking_support_disabled
       (
	const string&	vif_name,
	Pim01ResetVifIsTrackingSupportDisabledCB);
#endif

    virtual XrlCmdError pim_0_1_get_vif_accept_nohello_neighbors(
	// Input values,
	const string&	vif_name,
	// Output values,
	bool&	accept_nohello_neighbors) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Pim01GetVifAcceptNohelloNeighborsRF;

    class Pim01GetVifAcceptNohelloNeighborsCB {
        Pim01GetVifAcceptNohelloNeighborsRF cb;

    public:
        operator const Pim01GetVifAcceptNohelloNeighborsRF& () const { return cb; }
        const Pim01GetVifAcceptNohelloNeighborsRF& operator ->() const { return cb; }
        Pim01GetVifAcceptNohelloNeighborsCB(const Pim01GetVifAcceptNohelloNeighborsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept_nohello_neighbors) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept_nohello_neighbors);
        }
    };

    struct Pim01GetVifAcceptNohelloNeighborsRsp :
      public Pim01GetVifAcceptNohelloNeighborsCB {
        struct args_str {
            bool accept_nohello_neighbors;
        };

    private:
        args_str args;

    public:
        Pim01GetVifAcceptNohelloNeighborsRsp(const Pim01GetVifAcceptNohelloNeighborsRF& cb)
          : Pim01GetVifAcceptNohelloNeighborsCB(cb) { }

        void respond() const {
            Pim01GetVifAcceptNohelloNeighborsCB::
            respond(args.accept_nohello_neighbors);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_accept_nohello_neighbors
       (
	const string&	vif_name,
	Pim01GetVifAcceptNohelloNeighborsCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_accept_nohello_neighbors(
	// Input values,
	const string&	vif_name,
	const bool&	accept_nohello_neighbors) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifAcceptNohelloNeighborsRF;

    class Pim01SetVifAcceptNohelloNeighborsCB {
        Pim01SetVifAcceptNohelloNeighborsRF cb;

    public:
        operator const Pim01SetVifAcceptNohelloNeighborsRF& () const { return cb; }
        const Pim01SetVifAcceptNohelloNeighborsRF& operator ->() const { return cb; }
        Pim01SetVifAcceptNohelloNeighborsCB(const Pim01SetVifAcceptNohelloNeighborsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifAcceptNohelloNeighborsRsp :
      public Pim01SetVifAcceptNohelloNeighborsCB {
        Pim01SetVifAcceptNohelloNeighborsRsp(const Pim01SetVifAcceptNohelloNeighborsRF& cb)
          : Pim01SetVifAcceptNohelloNeighborsCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_accept_nohello_neighbors
       (
	const string&	vif_name,
	const bool&	accept_nohello_neighbors,
	Pim01SetVifAcceptNohelloNeighborsCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_accept_nohello_neighbors(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifAcceptNohelloNeighborsRF;

    class Pim01ResetVifAcceptNohelloNeighborsCB {
        Pim01ResetVifAcceptNohelloNeighborsRF cb;

    public:
        operator const Pim01ResetVifAcceptNohelloNeighborsRF& () const { return cb; }
        const Pim01ResetVifAcceptNohelloNeighborsRF& operator ->() const { return cb; }
        Pim01ResetVifAcceptNohelloNeighborsCB(const Pim01ResetVifAcceptNohelloNeighborsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifAcceptNohelloNeighborsRsp :
      public Pim01ResetVifAcceptNohelloNeighborsCB {
        Pim01ResetVifAcceptNohelloNeighborsRsp(const Pim01ResetVifAcceptNohelloNeighborsRF& cb)
          : Pim01ResetVifAcceptNohelloNeighborsCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_accept_nohello_neighbors
       (
	const string&	vif_name,
	Pim01ResetVifAcceptNohelloNeighborsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure PIM Join/Prune-related metrics. The 'set_foo' XRLs set the
     *  particular values. The 'reset_foo' XRLs reset the metrics to their
     *  default values.
     *
     *  @param vif_name the name of the vif to configure.
     *
     *  @param join_prune_period the period between Join/Prune messages.
     */
    virtual XrlCmdError pim_0_1_get_vif_join_prune_period(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	join_prune_period) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01GetVifJoinPrunePeriodRF;

    class Pim01GetVifJoinPrunePeriodCB {
        Pim01GetVifJoinPrunePeriodRF cb;

    public:
        operator const Pim01GetVifJoinPrunePeriodRF& () const { return cb; }
        const Pim01GetVifJoinPrunePeriodRF& operator ->() const { return cb; }
        Pim01GetVifJoinPrunePeriodCB(const Pim01GetVifJoinPrunePeriodRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_join_prune_period) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_join_prune_period);
        }
    };

    struct Pim01GetVifJoinPrunePeriodRsp :
      public Pim01GetVifJoinPrunePeriodCB {
        struct args_str {
            uint32_t join_prune_period;
        };

    private:
        args_str args;

    public:
        Pim01GetVifJoinPrunePeriodRsp(const Pim01GetVifJoinPrunePeriodRF& cb)
          : Pim01GetVifJoinPrunePeriodCB(cb) { }

        void respond() const {
            Pim01GetVifJoinPrunePeriodCB::
            respond(args.join_prune_period);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_vif_join_prune_period
       (
	const string&	vif_name,
	Pim01GetVifJoinPrunePeriodCB);
#endif

    virtual XrlCmdError pim_0_1_set_vif_join_prune_period(
	// Input values,
	const string&	vif_name,
	const uint32_t&	join_prune_period) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetVifJoinPrunePeriodRF;

    class Pim01SetVifJoinPrunePeriodCB {
        Pim01SetVifJoinPrunePeriodRF cb;

    public:
        operator const Pim01SetVifJoinPrunePeriodRF& () const { return cb; }
        const Pim01SetVifJoinPrunePeriodRF& operator ->() const { return cb; }
        Pim01SetVifJoinPrunePeriodCB(const Pim01SetVifJoinPrunePeriodRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetVifJoinPrunePeriodRsp :
      public Pim01SetVifJoinPrunePeriodCB {
        Pim01SetVifJoinPrunePeriodRsp(const Pim01SetVifJoinPrunePeriodRF& cb)
          : Pim01SetVifJoinPrunePeriodCB(cb) { }

    };

    virtual void async_pim_0_1_set_vif_join_prune_period
       (
	const string&	vif_name,
	const uint32_t&	join_prune_period,
	Pim01SetVifJoinPrunePeriodCB);
#endif

    virtual XrlCmdError pim_0_1_reset_vif_join_prune_period(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetVifJoinPrunePeriodRF;

    class Pim01ResetVifJoinPrunePeriodCB {
        Pim01ResetVifJoinPrunePeriodRF cb;

    public:
        operator const Pim01ResetVifJoinPrunePeriodRF& () const { return cb; }
        const Pim01ResetVifJoinPrunePeriodRF& operator ->() const { return cb; }
        Pim01ResetVifJoinPrunePeriodCB(const Pim01ResetVifJoinPrunePeriodRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetVifJoinPrunePeriodRsp :
      public Pim01ResetVifJoinPrunePeriodCB {
        Pim01ResetVifJoinPrunePeriodRsp(const Pim01ResetVifJoinPrunePeriodRF& cb)
          : Pim01ResetVifJoinPrunePeriodCB(cb) { }

    };

    virtual void async_pim_0_1_reset_vif_join_prune_period
       (
	const string&	vif_name,
	Pim01ResetVifJoinPrunePeriodCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure SPT-switch threshold. The 'set_foo' XRLs set the particular
     *  values. The 'reset_foo' XRLs reset the metrics to their default values.
     *
     *  @param is_enabled if true, enable SPT-switch, otherwise disable it.
     *
     *  @param interval_sec if the SPT-switch is enabled, the interval (in
     *  number of seconds) to measure the bandwidth to consider whether to
     *  switch to the SPT.
     */
    virtual XrlCmdError pim_0_1_get_switch_to_spt_threshold(
	// Output values,
	bool&	is_enabled,
	uint32_t&	interval_sec,
	uint32_t&	bytes) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback4<void, const XrlCmdError &,
	const bool*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Pim01GetSwitchToSptThresholdRF;

    class Pim01GetSwitchToSptThresholdCB {
        Pim01GetSwitchToSptThresholdRF cb;

    public:
        operator const Pim01GetSwitchToSptThresholdRF& () const { return cb; }
        const Pim01GetSwitchToSptThresholdRF& operator ->() const { return cb; }
        Pim01GetSwitchToSptThresholdCB(const Pim01GetSwitchToSptThresholdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL); }

        void respond(const bool& arg_is_enabled,
                     const uint32_t& arg_interval_sec,
                     const uint32_t& arg_bytes) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_is_enabled,
                         &arg_interval_sec,
                         &arg_bytes);
        }
    };

    struct Pim01GetSwitchToSptThresholdRsp :
      public Pim01GetSwitchToSptThresholdCB {
        struct args_str {
            bool is_enabled;
            uint32_t interval_sec;
            uint32_t bytes;
        };

    private:
        args_str args;

    public:
        Pim01GetSwitchToSptThresholdRsp(const Pim01GetSwitchToSptThresholdRF& cb)
          : Pim01GetSwitchToSptThresholdCB(cb) { }

        void respond() const {
            Pim01GetSwitchToSptThresholdCB::
            respond(args.is_enabled,
                        args.interval_sec,
                        args.bytes);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_get_switch_to_spt_threshold
       (
	Pim01GetSwitchToSptThresholdCB);
#endif

    virtual XrlCmdError pim_0_1_set_switch_to_spt_threshold(
	// Input values,
	const bool&	is_enabled,
	const uint32_t&	interval_sec,
	const uint32_t&	bytes) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SetSwitchToSptThresholdRF;

    class Pim01SetSwitchToSptThresholdCB {
        Pim01SetSwitchToSptThresholdRF cb;

    public:
        operator const Pim01SetSwitchToSptThresholdRF& () const { return cb; }
        const Pim01SetSwitchToSptThresholdRF& operator ->() const { return cb; }
        Pim01SetSwitchToSptThresholdCB(const Pim01SetSwitchToSptThresholdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SetSwitchToSptThresholdRsp :
      public Pim01SetSwitchToSptThresholdCB {
        Pim01SetSwitchToSptThresholdRsp(const Pim01SetSwitchToSptThresholdRF& cb)
          : Pim01SetSwitchToSptThresholdCB(cb) { }

    };

    virtual void async_pim_0_1_set_switch_to_spt_threshold
       (
	const bool&	is_enabled,
	const uint32_t&	interval_sec,
	const uint32_t&	bytes,
	Pim01SetSwitchToSptThresholdCB);
#endif

    virtual XrlCmdError pim_0_1_reset_switch_to_spt_threshold() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ResetSwitchToSptThresholdRF;

    class Pim01ResetSwitchToSptThresholdCB {
        Pim01ResetSwitchToSptThresholdRF cb;

    public:
        operator const Pim01ResetSwitchToSptThresholdRF& () const { return cb; }
        const Pim01ResetSwitchToSptThresholdRF& operator ->() const { return cb; }
        Pim01ResetSwitchToSptThresholdCB(const Pim01ResetSwitchToSptThresholdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ResetSwitchToSptThresholdRsp :
      public Pim01ResetSwitchToSptThresholdCB {
        Pim01ResetSwitchToSptThresholdRsp(const Pim01ResetSwitchToSptThresholdRF& cb)
          : Pim01ResetSwitchToSptThresholdCB(cb) { }

    };

    virtual void async_pim_0_1_reset_switch_to_spt_threshold
       (
	Pim01ResetSwitchToSptThresholdCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add or delete an alternative subnet on a PIM vif. An alternative subnet
     *  is used to make incoming traffic with a non-local source address appear
     *  as it is coming from a local subnet. Note: add alternative subnets with
     *  extreme care, only if you know what you are really doing!
     *
     *  @param vif_name the name of the vif to add or delete an alternative
     *  subnet.
     *
     *  @param subnet the subnet address to add or delete.
     */
    virtual XrlCmdError pim_0_1_add_alternative_subnet4(
	// Input values,
	const string&	vif_name,
	const IPv4Net&	subnet) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddAlternativeSubnet4RF;

    class Pim01AddAlternativeSubnet4CB {
        Pim01AddAlternativeSubnet4RF cb;

    public:
        operator const Pim01AddAlternativeSubnet4RF& () const { return cb; }
        const Pim01AddAlternativeSubnet4RF& operator ->() const { return cb; }
        Pim01AddAlternativeSubnet4CB(const Pim01AddAlternativeSubnet4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddAlternativeSubnet4Rsp :
      public Pim01AddAlternativeSubnet4CB {
        Pim01AddAlternativeSubnet4Rsp(const Pim01AddAlternativeSubnet4RF& cb)
          : Pim01AddAlternativeSubnet4CB(cb) { }

    };

    virtual void async_pim_0_1_add_alternative_subnet4
       (
	const string&	vif_name,
	const IPv4Net&	subnet,
	Pim01AddAlternativeSubnet4CB);
#endif

    virtual XrlCmdError pim_0_1_add_alternative_subnet6(
	// Input values,
	const string&	vif_name,
	const IPv6Net&	subnet) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddAlternativeSubnet6RF;

    class Pim01AddAlternativeSubnet6CB {
        Pim01AddAlternativeSubnet6RF cb;

    public:
        operator const Pim01AddAlternativeSubnet6RF& () const { return cb; }
        const Pim01AddAlternativeSubnet6RF& operator ->() const { return cb; }
        Pim01AddAlternativeSubnet6CB(const Pim01AddAlternativeSubnet6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddAlternativeSubnet6Rsp :
      public Pim01AddAlternativeSubnet6CB {
        Pim01AddAlternativeSubnet6Rsp(const Pim01AddAlternativeSubnet6RF& cb)
          : Pim01AddAlternativeSubnet6CB(cb) { }

    };

    virtual void async_pim_0_1_add_alternative_subnet6
       (
	const string&	vif_name,
	const IPv6Net&	subnet,
	Pim01AddAlternativeSubnet6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_alternative_subnet6(
	// Input values,
	const string&	vif_name,
	const IPv6Net&	subnet) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteAlternativeSubnet6RF;

    class Pim01DeleteAlternativeSubnet6CB {
        Pim01DeleteAlternativeSubnet6RF cb;

    public:
        operator const Pim01DeleteAlternativeSubnet6RF& () const { return cb; }
        const Pim01DeleteAlternativeSubnet6RF& operator ->() const { return cb; }
        Pim01DeleteAlternativeSubnet6CB(const Pim01DeleteAlternativeSubnet6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteAlternativeSubnet6Rsp :
      public Pim01DeleteAlternativeSubnet6CB {
        Pim01DeleteAlternativeSubnet6Rsp(const Pim01DeleteAlternativeSubnet6RF& cb)
          : Pim01DeleteAlternativeSubnet6CB(cb) { }

    };

    virtual void async_pim_0_1_delete_alternative_subnet6
       (
	const string&	vif_name,
	const IPv6Net&	subnet,
	Pim01DeleteAlternativeSubnet6CB);
#endif

    virtual XrlCmdError pim_0_1_delete_alternative_subnet4(
	// Input values,
	const string&	vif_name,
	const IPv4Net&	subnet) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01DeleteAlternativeSubnet4RF;

    class Pim01DeleteAlternativeSubnet4CB {
        Pim01DeleteAlternativeSubnet4RF cb;

    public:
        operator const Pim01DeleteAlternativeSubnet4RF& () const { return cb; }
        const Pim01DeleteAlternativeSubnet4RF& operator ->() const { return cb; }
        Pim01DeleteAlternativeSubnet4CB(const Pim01DeleteAlternativeSubnet4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01DeleteAlternativeSubnet4Rsp :
      public Pim01DeleteAlternativeSubnet4CB {
        Pim01DeleteAlternativeSubnet4Rsp(const Pim01DeleteAlternativeSubnet4RF& cb)
          : Pim01DeleteAlternativeSubnet4CB(cb) { }

    };

    virtual void async_pim_0_1_delete_alternative_subnet4
       (
	const string&	vif_name,
	const IPv4Net&	subnet,
	Pim01DeleteAlternativeSubnet4CB);
#endif

    virtual XrlCmdError pim_0_1_remove_all_alternative_subnets(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01RemoveAllAlternativeSubnetsRF;

    class Pim01RemoveAllAlternativeSubnetsCB {
        Pim01RemoveAllAlternativeSubnetsRF cb;

    public:
        operator const Pim01RemoveAllAlternativeSubnetsRF& () const { return cb; }
        const Pim01RemoveAllAlternativeSubnetsRF& operator ->() const { return cb; }
        Pim01RemoveAllAlternativeSubnetsCB(const Pim01RemoveAllAlternativeSubnetsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01RemoveAllAlternativeSubnetsRsp :
      public Pim01RemoveAllAlternativeSubnetsCB {
        Pim01RemoveAllAlternativeSubnetsRsp(const Pim01RemoveAllAlternativeSubnetsRF& cb)
          : Pim01RemoveAllAlternativeSubnetsCB(cb) { }

    };

    virtual void async_pim_0_1_remove_all_alternative_subnets
       (
	const string&	vif_name,
	Pim01RemoveAllAlternativeSubnetsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable the PIM trace log for all operations.
     *
     *  @param enable if true, then enable the trace log, otherwise disable it.
     */
    virtual XrlCmdError pim_0_1_log_trace_all(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01LogTraceAllRF;

    class Pim01LogTraceAllCB {
        Pim01LogTraceAllRF cb;

    public:
        operator const Pim01LogTraceAllRF& () const { return cb; }
        const Pim01LogTraceAllRF& operator ->() const { return cb; }
        Pim01LogTraceAllCB(const Pim01LogTraceAllRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01LogTraceAllRsp :
      public Pim01LogTraceAllCB {
        Pim01LogTraceAllRsp(const Pim01LogTraceAllRF& cb)
          : Pim01LogTraceAllCB(cb) { }

    };

    virtual void async_pim_0_1_log_trace_all
       (
	const bool&	enable,
	Pim01LogTraceAllCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test-related methods: add Join/Prune entries, and send them to a
     *  neighbor.
     */
    virtual XrlCmdError pim_0_1_add_test_jp_entry4(
	// Input values,
	const IPv4&	source_addr,
	const IPv4&	group_addr,
	const uint32_t&	group_mask_len,
	const string&	mrt_entry_type,
	const string&	action_jp,
	const uint32_t&	holdtime,
	const bool&	is_new_group) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestJpEntry4RF;

    class Pim01AddTestJpEntry4CB {
        Pim01AddTestJpEntry4RF cb;

    public:
        operator const Pim01AddTestJpEntry4RF& () const { return cb; }
        const Pim01AddTestJpEntry4RF& operator ->() const { return cb; }
        Pim01AddTestJpEntry4CB(const Pim01AddTestJpEntry4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestJpEntry4Rsp :
      public Pim01AddTestJpEntry4CB {
        Pim01AddTestJpEntry4Rsp(const Pim01AddTestJpEntry4RF& cb)
          : Pim01AddTestJpEntry4CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_jp_entry4
       (
	const IPv4&	source_addr,
	const IPv4&	group_addr,
	const uint32_t&	group_mask_len,
	const string&	mrt_entry_type,
	const string&	action_jp,
	const uint32_t&	holdtime,
	const bool&	is_new_group,
	Pim01AddTestJpEntry4CB);
#endif

    virtual XrlCmdError pim_0_1_add_test_jp_entry6(
	// Input values,
	const IPv6&	source_addr,
	const IPv6&	group_addr,
	const uint32_t&	group_mask_len,
	const string&	mrt_entry_type,
	const string&	action_jp,
	const uint32_t&	holdtime,
	const bool&	is_new_group) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestJpEntry6RF;

    class Pim01AddTestJpEntry6CB {
        Pim01AddTestJpEntry6RF cb;

    public:
        operator const Pim01AddTestJpEntry6RF& () const { return cb; }
        const Pim01AddTestJpEntry6RF& operator ->() const { return cb; }
        Pim01AddTestJpEntry6CB(const Pim01AddTestJpEntry6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestJpEntry6Rsp :
      public Pim01AddTestJpEntry6CB {
        Pim01AddTestJpEntry6Rsp(const Pim01AddTestJpEntry6RF& cb)
          : Pim01AddTestJpEntry6CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_jp_entry6
       (
	const IPv6&	source_addr,
	const IPv6&	group_addr,
	const uint32_t&	group_mask_len,
	const string&	mrt_entry_type,
	const string&	action_jp,
	const uint32_t&	holdtime,
	const bool&	is_new_group,
	Pim01AddTestJpEntry6CB);
#endif

    virtual XrlCmdError pim_0_1_send_test_jp_entry6(
	// Input values,
	const string&	vif_name,
	const IPv6&	nbr_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestJpEntry6RF;

    class Pim01SendTestJpEntry6CB {
        Pim01SendTestJpEntry6RF cb;

    public:
        operator const Pim01SendTestJpEntry6RF& () const { return cb; }
        const Pim01SendTestJpEntry6RF& operator ->() const { return cb; }
        Pim01SendTestJpEntry6CB(const Pim01SendTestJpEntry6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestJpEntry6Rsp :
      public Pim01SendTestJpEntry6CB {
        Pim01SendTestJpEntry6Rsp(const Pim01SendTestJpEntry6RF& cb)
          : Pim01SendTestJpEntry6CB(cb) { }

    };

    virtual void async_pim_0_1_send_test_jp_entry6
       (
	const string&	vif_name,
	const IPv6&	nbr_addr,
	Pim01SendTestJpEntry6CB);
#endif

    virtual XrlCmdError pim_0_1_send_test_jp_entry4(
	// Input values,
	const string&	vif_name,
	const IPv4&	nbr_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestJpEntry4RF;

    class Pim01SendTestJpEntry4CB {
        Pim01SendTestJpEntry4RF cb;

    public:
        operator const Pim01SendTestJpEntry4RF& () const { return cb; }
        const Pim01SendTestJpEntry4RF& operator ->() const { return cb; }
        Pim01SendTestJpEntry4CB(const Pim01SendTestJpEntry4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestJpEntry4Rsp :
      public Pim01SendTestJpEntry4CB {
        Pim01SendTestJpEntry4Rsp(const Pim01SendTestJpEntry4RF& cb)
          : Pim01SendTestJpEntry4CB(cb) { }

    };

    virtual void async_pim_0_1_send_test_jp_entry4
       (
	const string&	vif_name,
	const IPv4&	nbr_addr,
	Pim01SendTestJpEntry4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test-related methods: send an Assert message on an interface.
     *
     *  @param vif_name the name of the vif to send the Assert on.
     *
     *  @param source_addr the source address inside the Assert message.
     *
     *  @param group_addr the group address inside the Assert message.
     *
     *  @param rpt_bit the RPT-bit inside the Assert message.
     *
     *  @param metric_preference the metric preference inside the Assert
     *  message.
     *
     *  @param metric the metric inside the Assert message.
     */
    virtual XrlCmdError pim_0_1_send_test_assert4(
	// Input values,
	const string&	vif_name,
	const IPv4&	source_addr,
	const IPv4&	group_addr,
	const bool&	rpt_bit,
	const uint32_t&	metric_preference,
	const uint32_t&	metric) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestAssert4RF;

    class Pim01SendTestAssert4CB {
        Pim01SendTestAssert4RF cb;

    public:
        operator const Pim01SendTestAssert4RF& () const { return cb; }
        const Pim01SendTestAssert4RF& operator ->() const { return cb; }
        Pim01SendTestAssert4CB(const Pim01SendTestAssert4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestAssert4Rsp :
      public Pim01SendTestAssert4CB {
        Pim01SendTestAssert4Rsp(const Pim01SendTestAssert4RF& cb)
          : Pim01SendTestAssert4CB(cb) { }

    };

    virtual void async_pim_0_1_send_test_assert4
       (
	const string&	vif_name,
	const IPv4&	source_addr,
	const IPv4&	group_addr,
	const bool&	rpt_bit,
	const uint32_t&	metric_preference,
	const uint32_t&	metric,
	Pim01SendTestAssert4CB);
#endif

    virtual XrlCmdError pim_0_1_send_test_assert6(
	// Input values,
	const string&	vif_name,
	const IPv6&	source_addr,
	const IPv6&	group_addr,
	const bool&	rpt_bit,
	const uint32_t&	metric_preference,
	const uint32_t&	metric) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestAssert6RF;

    class Pim01SendTestAssert6CB {
        Pim01SendTestAssert6RF cb;

    public:
        operator const Pim01SendTestAssert6RF& () const { return cb; }
        const Pim01SendTestAssert6RF& operator ->() const { return cb; }
        Pim01SendTestAssert6CB(const Pim01SendTestAssert6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestAssert6Rsp :
      public Pim01SendTestAssert6CB {
        Pim01SendTestAssert6Rsp(const Pim01SendTestAssert6RF& cb)
          : Pim01SendTestAssert6CB(cb) { }

    };

    virtual void async_pim_0_1_send_test_assert6
       (
	const string&	vif_name,
	const IPv6&	source_addr,
	const IPv6&	group_addr,
	const bool&	rpt_bit,
	const uint32_t&	metric_preference,
	const uint32_t&	metric,
	Pim01SendTestAssert6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test-related methods: send Bootstrap and Cand-RP-Adv messages.
     *
     *  @param zone_id_scope_zone_prefix the zone prefix of the zone ID.
     *
     *  @param zone_id_is_scope_zone true if the zone is scoped.
     *
     *  @param bsr_addr the address of the Bootstrap router.
     *
     *  @param bsr_priority the priority of the Bootstrap router.
     *
     *  @param hash_mask_len the hash mask length inside the Bootstrap
     *  messages.
     *
     *  @param fragment_tag the fragment tag inside the Bootstrap messages.
     */
    virtual XrlCmdError pim_0_1_add_test_bsr_zone4(
	// Input values,
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4&	bsr_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const uint32_t&	fragment_tag) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestBsrZone4RF;

    class Pim01AddTestBsrZone4CB {
        Pim01AddTestBsrZone4RF cb;

    public:
        operator const Pim01AddTestBsrZone4RF& () const { return cb; }
        const Pim01AddTestBsrZone4RF& operator ->() const { return cb; }
        Pim01AddTestBsrZone4CB(const Pim01AddTestBsrZone4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestBsrZone4Rsp :
      public Pim01AddTestBsrZone4CB {
        Pim01AddTestBsrZone4Rsp(const Pim01AddTestBsrZone4RF& cb)
          : Pim01AddTestBsrZone4CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_bsr_zone4
       (
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4&	bsr_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const uint32_t&	fragment_tag,
	Pim01AddTestBsrZone4CB);
#endif

    virtual XrlCmdError pim_0_1_add_test_bsr_zone6(
	// Input values,
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6&	bsr_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const uint32_t&	fragment_tag) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestBsrZone6RF;

    class Pim01AddTestBsrZone6CB {
        Pim01AddTestBsrZone6RF cb;

    public:
        operator const Pim01AddTestBsrZone6RF& () const { return cb; }
        const Pim01AddTestBsrZone6RF& operator ->() const { return cb; }
        Pim01AddTestBsrZone6CB(const Pim01AddTestBsrZone6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestBsrZone6Rsp :
      public Pim01AddTestBsrZone6CB {
        Pim01AddTestBsrZone6Rsp(const Pim01AddTestBsrZone6RF& cb)
          : Pim01AddTestBsrZone6CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_bsr_zone6
       (
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6&	bsr_addr,
	const uint32_t&	bsr_priority,
	const uint32_t&	hash_mask_len,
	const uint32_t&	fragment_tag,
	Pim01AddTestBsrZone6CB);
#endif

    virtual XrlCmdError pim_0_1_add_test_bsr_group_prefix6(
	// Input values,
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const uint32_t&	expected_rp_count) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestBsrGroupPrefix6RF;

    class Pim01AddTestBsrGroupPrefix6CB {
        Pim01AddTestBsrGroupPrefix6RF cb;

    public:
        operator const Pim01AddTestBsrGroupPrefix6RF& () const { return cb; }
        const Pim01AddTestBsrGroupPrefix6RF& operator ->() const { return cb; }
        Pim01AddTestBsrGroupPrefix6CB(const Pim01AddTestBsrGroupPrefix6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestBsrGroupPrefix6Rsp :
      public Pim01AddTestBsrGroupPrefix6CB {
        Pim01AddTestBsrGroupPrefix6Rsp(const Pim01AddTestBsrGroupPrefix6RF& cb)
          : Pim01AddTestBsrGroupPrefix6CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_bsr_group_prefix6
       (
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6Net&	group_prefix,
	const bool&	is_scope_zone,
	const uint32_t&	expected_rp_count,
	Pim01AddTestBsrGroupPrefix6CB);
#endif

    virtual XrlCmdError pim_0_1_add_test_bsr_rp6(
	// Input values,
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestBsrRp6RF;

    class Pim01AddTestBsrRp6CB {
        Pim01AddTestBsrRp6RF cb;

    public:
        operator const Pim01AddTestBsrRp6RF& () const { return cb; }
        const Pim01AddTestBsrRp6RF& operator ->() const { return cb; }
        Pim01AddTestBsrRp6CB(const Pim01AddTestBsrRp6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestBsrRp6Rsp :
      public Pim01AddTestBsrRp6CB {
        Pim01AddTestBsrRp6Rsp(const Pim01AddTestBsrRp6RF& cb)
          : Pim01AddTestBsrRp6CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_bsr_rp6
       (
	const IPv6Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv6Net&	group_prefix,
	const IPv6&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	Pim01AddTestBsrRp6CB);
#endif

    virtual XrlCmdError pim_0_1_send_test_bootstrap_by_dest6(
	// Input values,
	const string&	vif_name,
	const IPv6&	dest_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestBootstrapByDest6RF;

    class Pim01SendTestBootstrapByDest6CB {
        Pim01SendTestBootstrapByDest6RF cb;

    public:
        operator const Pim01SendTestBootstrapByDest6RF& () const { return cb; }
        const Pim01SendTestBootstrapByDest6RF& operator ->() const { return cb; }
        Pim01SendTestBootstrapByDest6CB(const Pim01SendTestBootstrapByDest6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestBootstrapByDest6Rsp :
      public Pim01SendTestBootstrapByDest6CB {
        Pim01SendTestBootstrapByDest6Rsp(const Pim01SendTestBootstrapByDest6RF& cb)
          : Pim01SendTestBootstrapByDest6CB(cb) { }

    };

    virtual void async_pim_0_1_send_test_bootstrap_by_dest6
       (
	const string&	vif_name,
	const IPv6&	dest_addr,
	Pim01SendTestBootstrapByDest6CB);
#endif

    virtual XrlCmdError pim_0_1_add_test_bsr_group_prefix4(
	// Input values,
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const uint32_t&	expected_rp_count) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestBsrGroupPrefix4RF;

    class Pim01AddTestBsrGroupPrefix4CB {
        Pim01AddTestBsrGroupPrefix4RF cb;

    public:
        operator const Pim01AddTestBsrGroupPrefix4RF& () const { return cb; }
        const Pim01AddTestBsrGroupPrefix4RF& operator ->() const { return cb; }
        Pim01AddTestBsrGroupPrefix4CB(const Pim01AddTestBsrGroupPrefix4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestBsrGroupPrefix4Rsp :
      public Pim01AddTestBsrGroupPrefix4CB {
        Pim01AddTestBsrGroupPrefix4Rsp(const Pim01AddTestBsrGroupPrefix4RF& cb)
          : Pim01AddTestBsrGroupPrefix4CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_bsr_group_prefix4
       (
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4Net&	group_prefix,
	const bool&	is_scope_zone,
	const uint32_t&	expected_rp_count,
	Pim01AddTestBsrGroupPrefix4CB);
#endif

    virtual XrlCmdError pim_0_1_add_test_bsr_rp4(
	// Input values,
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01AddTestBsrRp4RF;

    class Pim01AddTestBsrRp4CB {
        Pim01AddTestBsrRp4RF cb;

    public:
        operator const Pim01AddTestBsrRp4RF& () const { return cb; }
        const Pim01AddTestBsrRp4RF& operator ->() const { return cb; }
        Pim01AddTestBsrRp4CB(const Pim01AddTestBsrRp4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01AddTestBsrRp4Rsp :
      public Pim01AddTestBsrRp4CB {
        Pim01AddTestBsrRp4Rsp(const Pim01AddTestBsrRp4RF& cb)
          : Pim01AddTestBsrRp4CB(cb) { }

    };

    virtual void async_pim_0_1_add_test_bsr_rp4
       (
	const IPv4Net&	zone_id_scope_zone_prefix,
	const bool&	zone_id_is_scope_zone,
	const IPv4Net&	group_prefix,
	const IPv4&	rp_addr,
	const uint32_t&	rp_priority,
	const uint32_t&	rp_holdtime,
	Pim01AddTestBsrRp4CB);
#endif

    virtual XrlCmdError pim_0_1_send_test_bootstrap(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestBootstrapRF;

    class Pim01SendTestBootstrapCB {
        Pim01SendTestBootstrapRF cb;

    public:
        operator const Pim01SendTestBootstrapRF& () const { return cb; }
        const Pim01SendTestBootstrapRF& operator ->() const { return cb; }
        Pim01SendTestBootstrapCB(const Pim01SendTestBootstrapRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestBootstrapRsp :
      public Pim01SendTestBootstrapCB {
        Pim01SendTestBootstrapRsp(const Pim01SendTestBootstrapRF& cb)
          : Pim01SendTestBootstrapCB(cb) { }

    };

    virtual void async_pim_0_1_send_test_bootstrap
       (
	const string&	vif_name,
	Pim01SendTestBootstrapCB);
#endif

    virtual XrlCmdError pim_0_1_send_test_bootstrap_by_dest4(
	// Input values,
	const string&	vif_name,
	const IPv4&	dest_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestBootstrapByDest4RF;

    class Pim01SendTestBootstrapByDest4CB {
        Pim01SendTestBootstrapByDest4RF cb;

    public:
        operator const Pim01SendTestBootstrapByDest4RF& () const { return cb; }
        const Pim01SendTestBootstrapByDest4RF& operator ->() const { return cb; }
        Pim01SendTestBootstrapByDest4CB(const Pim01SendTestBootstrapByDest4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestBootstrapByDest4Rsp :
      public Pim01SendTestBootstrapByDest4CB {
        Pim01SendTestBootstrapByDest4Rsp(const Pim01SendTestBootstrapByDest4RF& cb)
          : Pim01SendTestBootstrapByDest4CB(cb) { }

    };

    virtual void async_pim_0_1_send_test_bootstrap_by_dest4
       (
	const string&	vif_name,
	const IPv4&	dest_addr,
	Pim01SendTestBootstrapByDest4CB);
#endif

    virtual XrlCmdError pim_0_1_send_test_cand_rp_adv() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01SendTestCandRpAdvRF;

    class Pim01SendTestCandRpAdvCB {
        Pim01SendTestCandRpAdvRF cb;

    public:
        operator const Pim01SendTestCandRpAdvRF& () const { return cb; }
        const Pim01SendTestCandRpAdvRF& operator ->() const { return cb; }
        Pim01SendTestCandRpAdvCB(const Pim01SendTestCandRpAdvRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01SendTestCandRpAdvRsp :
      public Pim01SendTestCandRpAdvCB {
        Pim01SendTestCandRpAdvRsp(const Pim01SendTestCandRpAdvRF& cb)
          : Pim01SendTestCandRpAdvCB(cb) { }

    };

    virtual void async_pim_0_1_send_test_cand_rp_adv
       (
	Pim01SendTestCandRpAdvCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Retrieve information about all PIM neighbors.
     *
     *  @param nbrs_number the number of PIM neighbors
     *
     *  @param vifs the list of vif names for all neighbors (one vif name per
     *  neighbor).
     *
     *  @param pim_versions the list of PIM protocol versions for all neighbors
     *  (one number per neighbor).
     *
     *  @param dr_priorities the list of DR priorities of all neighbors (one
     *  number per neighbor).
     *
     *  @param holdtimes the list of configured holdtimes (in seconds) of all
     *  neighbors (one number per neighbor).
     *
     *  @param timeouts the list of timeout values (in seconds) of all
     *  neighbors (one number per neighbor).
     *
     *  @param uptimes the list of uptime values (in seconds) of all neighbors
     *  (one number per neighbor).
     */
    virtual XrlCmdError pim_0_1_pimstat_neighbors4(
	// Output values,
	uint32_t&	nbrs_number,
	XrlAtomList&	vifs,
	XrlAtomList&	addresses,
	XrlAtomList&	pim_versions,
	XrlAtomList&	dr_priorities,
	XrlAtomList&	holdtimes,
	XrlAtomList&	timeouts,
	XrlAtomList&	uptimes) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback9<void, const XrlCmdError &,
	const uint32_t*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Pim01PimstatNeighbors4RF;

    class Pim01PimstatNeighbors4CB {
        Pim01PimstatNeighbors4RF cb;

    public:
        operator const Pim01PimstatNeighbors4RF& () const { return cb; }
        const Pim01PimstatNeighbors4RF& operator ->() const { return cb; }
        Pim01PimstatNeighbors4CB(const Pim01PimstatNeighbors4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_nbrs_number,
                     const XrlAtomList& arg_vifs,
                     const XrlAtomList& arg_addresses,
                     const XrlAtomList& arg_pim_versions,
                     const XrlAtomList& arg_dr_priorities,
                     const XrlAtomList& arg_holdtimes,
                     const XrlAtomList& arg_timeouts,
                     const XrlAtomList& arg_uptimes) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_nbrs_number,
                         &arg_vifs,
                         &arg_addresses,
                         &arg_pim_versions,
                         &arg_dr_priorities,
                         &arg_holdtimes,
                         &arg_timeouts,
                         &arg_uptimes);
        }
    };

    struct Pim01PimstatNeighbors4Rsp :
      public Pim01PimstatNeighbors4CB {
        struct args_str {
            uint32_t nbrs_number;
            XrlAtomList vifs;
            XrlAtomList addresses;
            XrlAtomList pim_versions;
            XrlAtomList dr_priorities;
            XrlAtomList holdtimes;
            XrlAtomList timeouts;
            XrlAtomList uptimes;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNeighbors4Rsp(const Pim01PimstatNeighbors4RF& cb)
          : Pim01PimstatNeighbors4CB(cb) { }

        void respond() const {
            Pim01PimstatNeighbors4CB::
            respond(args.nbrs_number,
                        args.vifs,
                        args.addresses,
                        args.pim_versions,
                        args.dr_priorities,
                        args.holdtimes,
                        args.timeouts,
                        args.uptimes);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_neighbors4
       (
	Pim01PimstatNeighbors4CB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_neighbors6(
	// Output values,
	uint32_t&	nbrs_number,
	XrlAtomList&	vifs,
	XrlAtomList&	addresses,
	XrlAtomList&	pim_versions,
	XrlAtomList&	dr_priorities,
	XrlAtomList&	holdtimes,
	XrlAtomList&	timeouts,
	XrlAtomList&	uptimes) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback9<void, const XrlCmdError &,
	const uint32_t*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Pim01PimstatNeighbors6RF;

    class Pim01PimstatNeighbors6CB {
        Pim01PimstatNeighbors6RF cb;

    public:
        operator const Pim01PimstatNeighbors6RF& () const { return cb; }
        const Pim01PimstatNeighbors6RF& operator ->() const { return cb; }
        Pim01PimstatNeighbors6CB(const Pim01PimstatNeighbors6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_nbrs_number,
                     const XrlAtomList& arg_vifs,
                     const XrlAtomList& arg_addresses,
                     const XrlAtomList& arg_pim_versions,
                     const XrlAtomList& arg_dr_priorities,
                     const XrlAtomList& arg_holdtimes,
                     const XrlAtomList& arg_timeouts,
                     const XrlAtomList& arg_uptimes) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_nbrs_number,
                         &arg_vifs,
                         &arg_addresses,
                         &arg_pim_versions,
                         &arg_dr_priorities,
                         &arg_holdtimes,
                         &arg_timeouts,
                         &arg_uptimes);
        }
    };

    struct Pim01PimstatNeighbors6Rsp :
      public Pim01PimstatNeighbors6CB {
        struct args_str {
            uint32_t nbrs_number;
            XrlAtomList vifs;
            XrlAtomList addresses;
            XrlAtomList pim_versions;
            XrlAtomList dr_priorities;
            XrlAtomList holdtimes;
            XrlAtomList timeouts;
            XrlAtomList uptimes;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNeighbors6Rsp(const Pim01PimstatNeighbors6RF& cb)
          : Pim01PimstatNeighbors6CB(cb) { }

        void respond() const {
            Pim01PimstatNeighbors6CB::
            respond(args.nbrs_number,
                        args.vifs,
                        args.addresses,
                        args.pim_versions,
                        args.dr_priorities,
                        args.holdtimes,
                        args.timeouts,
                        args.uptimes);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_neighbors6
       (
	Pim01PimstatNeighbors6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Retrieve information about PIM interfaces.
     *
     *  @param vif_name the name of the vif to retrieve information about.
     *
     *  @param pim_version the PIM protocol version on that vif.
     *
     *  @param is_dr true if this router is the DR for the subnet the vif is
     *  connected to.
     *
     *  @param dr_priority the DR priority configured on that vif.
     *
     *  @param dr_address the address of the DR for the subnet the vif is
     *  connected to.
     *
     *  @param pim_nbrs_number the number of PIM neighbors on the subnet the
     *  vif is connected to.
     */
    virtual XrlCmdError pim_0_1_pimstat_interface4(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	pim_version,
	bool&	is_dr,
	uint32_t&	dr_priority,
	IPv4&	dr_address,
	uint32_t&	pim_nbrs_number) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const uint32_t*,
	const bool*,
	const uint32_t*,
	const IPv4*,
	const uint32_t*>::RefPtr
    Pim01PimstatInterface4RF;

    class Pim01PimstatInterface4CB {
        Pim01PimstatInterface4RF cb;

    public:
        operator const Pim01PimstatInterface4RF& () const { return cb; }
        const Pim01PimstatInterface4RF& operator ->() const { return cb; }
        Pim01PimstatInterface4CB(const Pim01PimstatInterface4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_pim_version,
                     const bool& arg_is_dr,
                     const uint32_t& arg_dr_priority,
                     const IPv4& arg_dr_address,
                     const uint32_t& arg_pim_nbrs_number) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_pim_version,
                         &arg_is_dr,
                         &arg_dr_priority,
                         &arg_dr_address,
                         &arg_pim_nbrs_number);
        }
    };

    struct Pim01PimstatInterface4Rsp :
      public Pim01PimstatInterface4CB {
        struct args_str {
            uint32_t pim_version;
            bool is_dr;
            uint32_t dr_priority;
            IPv4 dr_address;
            uint32_t pim_nbrs_number;
        };

    private:
        args_str args;

    public:
        Pim01PimstatInterface4Rsp(const Pim01PimstatInterface4RF& cb)
          : Pim01PimstatInterface4CB(cb) { }

        void respond() const {
            Pim01PimstatInterface4CB::
            respond(args.pim_version,
                        args.is_dr,
                        args.dr_priority,
                        args.dr_address,
                        args.pim_nbrs_number);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_interface4
       (
	const string&	vif_name,
	Pim01PimstatInterface4CB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_interface6(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	pim_version,
	bool&	is_dr,
	uint32_t&	dr_priority,
	IPv6&	dr_address,
	uint32_t&	pim_nbrs_number) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const uint32_t*,
	const bool*,
	const uint32_t*,
	const IPv6*,
	const uint32_t*>::RefPtr
    Pim01PimstatInterface6RF;

    class Pim01PimstatInterface6CB {
        Pim01PimstatInterface6RF cb;

    public:
        operator const Pim01PimstatInterface6RF& () const { return cb; }
        const Pim01PimstatInterface6RF& operator ->() const { return cb; }
        Pim01PimstatInterface6CB(const Pim01PimstatInterface6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_pim_version,
                     const bool& arg_is_dr,
                     const uint32_t& arg_dr_priority,
                     const IPv6& arg_dr_address,
                     const uint32_t& arg_pim_nbrs_number) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_pim_version,
                         &arg_is_dr,
                         &arg_dr_priority,
                         &arg_dr_address,
                         &arg_pim_nbrs_number);
        }
    };

    struct Pim01PimstatInterface6Rsp :
      public Pim01PimstatInterface6CB {
        struct args_str {
            uint32_t pim_version;
            bool is_dr;
            uint32_t dr_priority;
            IPv6 dr_address;
            uint32_t pim_nbrs_number;
        };

    private:
        args_str args;

    public:
        Pim01PimstatInterface6Rsp(const Pim01PimstatInterface6RF& cb)
          : Pim01PimstatInterface6CB(cb) { }

        void respond() const {
            Pim01PimstatInterface6CB::
            respond(args.pim_version,
                        args.is_dr,
                        args.dr_priority,
                        args.dr_address,
                        args.pim_nbrs_number);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_interface6
       (
	const string&	vif_name,
	Pim01PimstatInterface6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Retrieve information about the RP-Set.
     *
     *  @param rps_number the number of RPs in the RP-Set.
     *
     *  @param addresses the list of addresses of all RPs (one IPv4 or IPv6
     *  address per RP).
     *
     *  @param types the list of textual description about the origin of each
     *  RP (one keyword per RP: "bootstrap", "static" or "unknown").
     *
     *  @param priorities the list of RP priorities of all RPs (one number per
     *  RP).
     *
     *  @param holdtimes the list of configured holdtimes (in seconds) of all
     *  RPs (one number per RP).
     *
     *  @param timeouts the list of timeout values (in seconds) of all RPs (one
     *  number per RP).
     *
     *  @param group_prefixes the list of all group prefixes (one network
     *  IPv4Net or IPv6Net address per RP). Note that if an RP is configured
     *  for more than one group prefixes, there will be a number of entries for
     *  that RP: one per group prefix.
     */
    virtual XrlCmdError pim_0_1_pimstat_rps4(
	// Output values,
	uint32_t&	rps_number,
	XrlAtomList&	addresses,
	XrlAtomList&	types,
	XrlAtomList&	priorities,
	XrlAtomList&	holdtimes,
	XrlAtomList&	timeouts,
	XrlAtomList&	group_prefixes) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback8<void, const XrlCmdError &,
	const uint32_t*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Pim01PimstatRps4RF;

    class Pim01PimstatRps4CB {
        Pim01PimstatRps4RF cb;

    public:
        operator const Pim01PimstatRps4RF& () const { return cb; }
        const Pim01PimstatRps4RF& operator ->() const { return cb; }
        Pim01PimstatRps4CB(const Pim01PimstatRps4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_rps_number,
                     const XrlAtomList& arg_addresses,
                     const XrlAtomList& arg_types,
                     const XrlAtomList& arg_priorities,
                     const XrlAtomList& arg_holdtimes,
                     const XrlAtomList& arg_timeouts,
                     const XrlAtomList& arg_group_prefixes) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_rps_number,
                         &arg_addresses,
                         &arg_types,
                         &arg_priorities,
                         &arg_holdtimes,
                         &arg_timeouts,
                         &arg_group_prefixes);
        }
    };

    struct Pim01PimstatRps4Rsp :
      public Pim01PimstatRps4CB {
        struct args_str {
            uint32_t rps_number;
            XrlAtomList addresses;
            XrlAtomList types;
            XrlAtomList priorities;
            XrlAtomList holdtimes;
            XrlAtomList timeouts;
            XrlAtomList group_prefixes;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRps4Rsp(const Pim01PimstatRps4RF& cb)
          : Pim01PimstatRps4CB(cb) { }

        void respond() const {
            Pim01PimstatRps4CB::
            respond(args.rps_number,
                        args.addresses,
                        args.types,
                        args.priorities,
                        args.holdtimes,
                        args.timeouts,
                        args.group_prefixes);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rps4
       (
	Pim01PimstatRps4CB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rps6(
	// Output values,
	uint32_t&	rps_number,
	XrlAtomList&	addresses,
	XrlAtomList&	types,
	XrlAtomList&	priorities,
	XrlAtomList&	holdtimes,
	XrlAtomList&	timeouts,
	XrlAtomList&	group_prefixes) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback8<void, const XrlCmdError &,
	const uint32_t*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Pim01PimstatRps6RF;

    class Pim01PimstatRps6CB {
        Pim01PimstatRps6RF cb;

    public:
        operator const Pim01PimstatRps6RF& () const { return cb; }
        const Pim01PimstatRps6RF& operator ->() const { return cb; }
        Pim01PimstatRps6CB(const Pim01PimstatRps6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_rps_number,
                     const XrlAtomList& arg_addresses,
                     const XrlAtomList& arg_types,
                     const XrlAtomList& arg_priorities,
                     const XrlAtomList& arg_holdtimes,
                     const XrlAtomList& arg_timeouts,
                     const XrlAtomList& arg_group_prefixes) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_rps_number,
                         &arg_addresses,
                         &arg_types,
                         &arg_priorities,
                         &arg_holdtimes,
                         &arg_timeouts,
                         &arg_group_prefixes);
        }
    };

    struct Pim01PimstatRps6Rsp :
      public Pim01PimstatRps6CB {
        struct args_str {
            uint32_t rps_number;
            XrlAtomList addresses;
            XrlAtomList types;
            XrlAtomList priorities;
            XrlAtomList holdtimes;
            XrlAtomList timeouts;
            XrlAtomList group_prefixes;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRps6Rsp(const Pim01PimstatRps6RF& cb)
          : Pim01PimstatRps6CB(cb) { }

        void respond() const {
            Pim01PimstatRps6CB::
            respond(args.rps_number,
                        args.addresses,
                        args.types,
                        args.priorities,
                        args.holdtimes,
                        args.timeouts,
                        args.group_prefixes);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rps6
       (
	Pim01PimstatRps6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear all statistics
     */
    virtual XrlCmdError pim_0_1_clear_pim_statistics() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ClearPimStatisticsRF;

    class Pim01ClearPimStatisticsCB {
        Pim01ClearPimStatisticsRF cb;

    public:
        operator const Pim01ClearPimStatisticsRF& () const { return cb; }
        const Pim01ClearPimStatisticsRF& operator ->() const { return cb; }
        Pim01ClearPimStatisticsCB(const Pim01ClearPimStatisticsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ClearPimStatisticsRsp :
      public Pim01ClearPimStatisticsCB {
        Pim01ClearPimStatisticsRsp(const Pim01ClearPimStatisticsRF& cb)
          : Pim01ClearPimStatisticsCB(cb) { }

    };

    virtual void async_pim_0_1_clear_pim_statistics
       (
	Pim01ClearPimStatisticsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear all statistics on a specific interface.
     *
     *  @param vif_name the interface to clear the statistics of.
     */
    virtual XrlCmdError pim_0_1_clear_pim_statistics_per_vif(
	// Input values,
	const string&	vif_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Pim01ClearPimStatisticsPerVifRF;

    class Pim01ClearPimStatisticsPerVifCB {
        Pim01ClearPimStatisticsPerVifRF cb;

    public:
        operator const Pim01ClearPimStatisticsPerVifRF& () const { return cb; }
        const Pim01ClearPimStatisticsPerVifRF& operator ->() const { return cb; }
        Pim01ClearPimStatisticsPerVifCB(const Pim01ClearPimStatisticsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Pim01ClearPimStatisticsPerVifRsp :
      public Pim01ClearPimStatisticsPerVifCB {
        Pim01ClearPimStatisticsPerVifRsp(const Pim01ClearPimStatisticsPerVifRF& cb)
          : Pim01ClearPimStatisticsPerVifCB(cb) { }

    };

    virtual void async_pim_0_1_clear_pim_statistics_per_vif
       (
	const string&	vif_name,
	Pim01ClearPimStatisticsPerVifCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Statistics-related counters and values
     */
    virtual XrlCmdError pim_0_1_pimstat_hello_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatHelloMessagesReceivedRF;

    class Pim01PimstatHelloMessagesReceivedCB {
        Pim01PimstatHelloMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatHelloMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatHelloMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatHelloMessagesReceivedCB(const Pim01PimstatHelloMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatHelloMessagesReceivedRsp :
      public Pim01PimstatHelloMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatHelloMessagesReceivedRsp(const Pim01PimstatHelloMessagesReceivedRF& cb)
          : Pim01PimstatHelloMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatHelloMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_hello_messages_received
       (
	Pim01PimstatHelloMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_hello_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatHelloMessagesSentRF;

    class Pim01PimstatHelloMessagesSentCB {
        Pim01PimstatHelloMessagesSentRF cb;

    public:
        operator const Pim01PimstatHelloMessagesSentRF& () const { return cb; }
        const Pim01PimstatHelloMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatHelloMessagesSentCB(const Pim01PimstatHelloMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatHelloMessagesSentRsp :
      public Pim01PimstatHelloMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatHelloMessagesSentRsp(const Pim01PimstatHelloMessagesSentRF& cb)
          : Pim01PimstatHelloMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatHelloMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_hello_messages_sent
       (
	Pim01PimstatHelloMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_hello_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatHelloMessagesRxErrorsRF;

    class Pim01PimstatHelloMessagesRxErrorsCB {
        Pim01PimstatHelloMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatHelloMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatHelloMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatHelloMessagesRxErrorsCB(const Pim01PimstatHelloMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatHelloMessagesRxErrorsRsp :
      public Pim01PimstatHelloMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatHelloMessagesRxErrorsRsp(const Pim01PimstatHelloMessagesRxErrorsRF& cb)
          : Pim01PimstatHelloMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatHelloMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_hello_messages_rx_errors
       (
	Pim01PimstatHelloMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterMessagesReceivedRF;

    class Pim01PimstatRegisterMessagesReceivedCB {
        Pim01PimstatRegisterMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatRegisterMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatRegisterMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatRegisterMessagesReceivedCB(const Pim01PimstatRegisterMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterMessagesReceivedRsp :
      public Pim01PimstatRegisterMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterMessagesReceivedRsp(const Pim01PimstatRegisterMessagesReceivedRF& cb)
          : Pim01PimstatRegisterMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_messages_received
       (
	Pim01PimstatRegisterMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterMessagesSentRF;

    class Pim01PimstatRegisterMessagesSentCB {
        Pim01PimstatRegisterMessagesSentRF cb;

    public:
        operator const Pim01PimstatRegisterMessagesSentRF& () const { return cb; }
        const Pim01PimstatRegisterMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatRegisterMessagesSentCB(const Pim01PimstatRegisterMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterMessagesSentRsp :
      public Pim01PimstatRegisterMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterMessagesSentRsp(const Pim01PimstatRegisterMessagesSentRF& cb)
          : Pim01PimstatRegisterMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_messages_sent
       (
	Pim01PimstatRegisterMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterMessagesRxErrorsRF;

    class Pim01PimstatRegisterMessagesRxErrorsCB {
        Pim01PimstatRegisterMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatRegisterMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatRegisterMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatRegisterMessagesRxErrorsCB(const Pim01PimstatRegisterMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterMessagesRxErrorsRsp :
      public Pim01PimstatRegisterMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterMessagesRxErrorsRsp(const Pim01PimstatRegisterMessagesRxErrorsRF& cb)
          : Pim01PimstatRegisterMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_messages_rx_errors
       (
	Pim01PimstatRegisterMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_stop_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterStopMessagesReceivedRF;

    class Pim01PimstatRegisterStopMessagesReceivedCB {
        Pim01PimstatRegisterStopMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatRegisterStopMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatRegisterStopMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatRegisterStopMessagesReceivedCB(const Pim01PimstatRegisterStopMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterStopMessagesReceivedRsp :
      public Pim01PimstatRegisterStopMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterStopMessagesReceivedRsp(const Pim01PimstatRegisterStopMessagesReceivedRF& cb)
          : Pim01PimstatRegisterStopMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterStopMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_stop_messages_received
       (
	Pim01PimstatRegisterStopMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_stop_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterStopMessagesSentRF;

    class Pim01PimstatRegisterStopMessagesSentCB {
        Pim01PimstatRegisterStopMessagesSentRF cb;

    public:
        operator const Pim01PimstatRegisterStopMessagesSentRF& () const { return cb; }
        const Pim01PimstatRegisterStopMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatRegisterStopMessagesSentCB(const Pim01PimstatRegisterStopMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterStopMessagesSentRsp :
      public Pim01PimstatRegisterStopMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterStopMessagesSentRsp(const Pim01PimstatRegisterStopMessagesSentRF& cb)
          : Pim01PimstatRegisterStopMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterStopMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_stop_messages_sent
       (
	Pim01PimstatRegisterStopMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_stop_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterStopMessagesRxErrorsRF;

    class Pim01PimstatRegisterStopMessagesRxErrorsCB {
        Pim01PimstatRegisterStopMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatRegisterStopMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatRegisterStopMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatRegisterStopMessagesRxErrorsCB(const Pim01PimstatRegisterStopMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterStopMessagesRxErrorsRsp :
      public Pim01PimstatRegisterStopMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterStopMessagesRxErrorsRsp(const Pim01PimstatRegisterStopMessagesRxErrorsRF& cb)
          : Pim01PimstatRegisterStopMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterStopMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_stop_messages_rx_errors
       (
	Pim01PimstatRegisterStopMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_join_prune_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatJoinPruneMessagesReceivedRF;

    class Pim01PimstatJoinPruneMessagesReceivedCB {
        Pim01PimstatJoinPruneMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatJoinPruneMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatJoinPruneMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatJoinPruneMessagesReceivedCB(const Pim01PimstatJoinPruneMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatJoinPruneMessagesReceivedRsp :
      public Pim01PimstatJoinPruneMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatJoinPruneMessagesReceivedRsp(const Pim01PimstatJoinPruneMessagesReceivedRF& cb)
          : Pim01PimstatJoinPruneMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatJoinPruneMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_join_prune_messages_received
       (
	Pim01PimstatJoinPruneMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_join_prune_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatJoinPruneMessagesSentRF;

    class Pim01PimstatJoinPruneMessagesSentCB {
        Pim01PimstatJoinPruneMessagesSentRF cb;

    public:
        operator const Pim01PimstatJoinPruneMessagesSentRF& () const { return cb; }
        const Pim01PimstatJoinPruneMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatJoinPruneMessagesSentCB(const Pim01PimstatJoinPruneMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatJoinPruneMessagesSentRsp :
      public Pim01PimstatJoinPruneMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatJoinPruneMessagesSentRsp(const Pim01PimstatJoinPruneMessagesSentRF& cb)
          : Pim01PimstatJoinPruneMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatJoinPruneMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_join_prune_messages_sent
       (
	Pim01PimstatJoinPruneMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_join_prune_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatJoinPruneMessagesRxErrorsRF;

    class Pim01PimstatJoinPruneMessagesRxErrorsCB {
        Pim01PimstatJoinPruneMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatJoinPruneMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatJoinPruneMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatJoinPruneMessagesRxErrorsCB(const Pim01PimstatJoinPruneMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatJoinPruneMessagesRxErrorsRsp :
      public Pim01PimstatJoinPruneMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatJoinPruneMessagesRxErrorsRsp(const Pim01PimstatJoinPruneMessagesRxErrorsRF& cb)
          : Pim01PimstatJoinPruneMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatJoinPruneMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_join_prune_messages_rx_errors
       (
	Pim01PimstatJoinPruneMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bootstrap_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBootstrapMessagesReceivedRF;

    class Pim01PimstatBootstrapMessagesReceivedCB {
        Pim01PimstatBootstrapMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatBootstrapMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatBootstrapMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatBootstrapMessagesReceivedCB(const Pim01PimstatBootstrapMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBootstrapMessagesReceivedRsp :
      public Pim01PimstatBootstrapMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBootstrapMessagesReceivedRsp(const Pim01PimstatBootstrapMessagesReceivedRF& cb)
          : Pim01PimstatBootstrapMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatBootstrapMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bootstrap_messages_received
       (
	Pim01PimstatBootstrapMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bootstrap_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBootstrapMessagesSentRF;

    class Pim01PimstatBootstrapMessagesSentCB {
        Pim01PimstatBootstrapMessagesSentRF cb;

    public:
        operator const Pim01PimstatBootstrapMessagesSentRF& () const { return cb; }
        const Pim01PimstatBootstrapMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatBootstrapMessagesSentCB(const Pim01PimstatBootstrapMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBootstrapMessagesSentRsp :
      public Pim01PimstatBootstrapMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBootstrapMessagesSentRsp(const Pim01PimstatBootstrapMessagesSentRF& cb)
          : Pim01PimstatBootstrapMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatBootstrapMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bootstrap_messages_sent
       (
	Pim01PimstatBootstrapMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bootstrap_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBootstrapMessagesRxErrorsRF;

    class Pim01PimstatBootstrapMessagesRxErrorsCB {
        Pim01PimstatBootstrapMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatBootstrapMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatBootstrapMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatBootstrapMessagesRxErrorsCB(const Pim01PimstatBootstrapMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBootstrapMessagesRxErrorsRsp :
      public Pim01PimstatBootstrapMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBootstrapMessagesRxErrorsRsp(const Pim01PimstatBootstrapMessagesRxErrorsRF& cb)
          : Pim01PimstatBootstrapMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatBootstrapMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bootstrap_messages_rx_errors
       (
	Pim01PimstatBootstrapMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_assert_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatAssertMessagesReceivedRF;

    class Pim01PimstatAssertMessagesReceivedCB {
        Pim01PimstatAssertMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatAssertMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatAssertMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatAssertMessagesReceivedCB(const Pim01PimstatAssertMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatAssertMessagesReceivedRsp :
      public Pim01PimstatAssertMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatAssertMessagesReceivedRsp(const Pim01PimstatAssertMessagesReceivedRF& cb)
          : Pim01PimstatAssertMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatAssertMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_assert_messages_received
       (
	Pim01PimstatAssertMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_assert_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatAssertMessagesSentRF;

    class Pim01PimstatAssertMessagesSentCB {
        Pim01PimstatAssertMessagesSentRF cb;

    public:
        operator const Pim01PimstatAssertMessagesSentRF& () const { return cb; }
        const Pim01PimstatAssertMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatAssertMessagesSentCB(const Pim01PimstatAssertMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatAssertMessagesSentRsp :
      public Pim01PimstatAssertMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatAssertMessagesSentRsp(const Pim01PimstatAssertMessagesSentRF& cb)
          : Pim01PimstatAssertMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatAssertMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_assert_messages_sent
       (
	Pim01PimstatAssertMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_assert_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatAssertMessagesRxErrorsRF;

    class Pim01PimstatAssertMessagesRxErrorsCB {
        Pim01PimstatAssertMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatAssertMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatAssertMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatAssertMessagesRxErrorsCB(const Pim01PimstatAssertMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatAssertMessagesRxErrorsRsp :
      public Pim01PimstatAssertMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatAssertMessagesRxErrorsRsp(const Pim01PimstatAssertMessagesRxErrorsRF& cb)
          : Pim01PimstatAssertMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatAssertMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_assert_messages_rx_errors
       (
	Pim01PimstatAssertMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftMessagesReceivedRF;

    class Pim01PimstatGraftMessagesReceivedCB {
        Pim01PimstatGraftMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatGraftMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatGraftMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatGraftMessagesReceivedCB(const Pim01PimstatGraftMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftMessagesReceivedRsp :
      public Pim01PimstatGraftMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftMessagesReceivedRsp(const Pim01PimstatGraftMessagesReceivedRF& cb)
          : Pim01PimstatGraftMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatGraftMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_messages_received
       (
	Pim01PimstatGraftMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftMessagesSentRF;

    class Pim01PimstatGraftMessagesSentCB {
        Pim01PimstatGraftMessagesSentRF cb;

    public:
        operator const Pim01PimstatGraftMessagesSentRF& () const { return cb; }
        const Pim01PimstatGraftMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatGraftMessagesSentCB(const Pim01PimstatGraftMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftMessagesSentRsp :
      public Pim01PimstatGraftMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftMessagesSentRsp(const Pim01PimstatGraftMessagesSentRF& cb)
          : Pim01PimstatGraftMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatGraftMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_messages_sent
       (
	Pim01PimstatGraftMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftMessagesRxErrorsRF;

    class Pim01PimstatGraftMessagesRxErrorsCB {
        Pim01PimstatGraftMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatGraftMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatGraftMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatGraftMessagesRxErrorsCB(const Pim01PimstatGraftMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftMessagesRxErrorsRsp :
      public Pim01PimstatGraftMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftMessagesRxErrorsRsp(const Pim01PimstatGraftMessagesRxErrorsRF& cb)
          : Pim01PimstatGraftMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatGraftMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_messages_rx_errors
       (
	Pim01PimstatGraftMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_ack_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftAckMessagesReceivedRF;

    class Pim01PimstatGraftAckMessagesReceivedCB {
        Pim01PimstatGraftAckMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatGraftAckMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatGraftAckMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatGraftAckMessagesReceivedCB(const Pim01PimstatGraftAckMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftAckMessagesReceivedRsp :
      public Pim01PimstatGraftAckMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftAckMessagesReceivedRsp(const Pim01PimstatGraftAckMessagesReceivedRF& cb)
          : Pim01PimstatGraftAckMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatGraftAckMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_ack_messages_received
       (
	Pim01PimstatGraftAckMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_ack_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftAckMessagesSentRF;

    class Pim01PimstatGraftAckMessagesSentCB {
        Pim01PimstatGraftAckMessagesSentRF cb;

    public:
        operator const Pim01PimstatGraftAckMessagesSentRF& () const { return cb; }
        const Pim01PimstatGraftAckMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatGraftAckMessagesSentCB(const Pim01PimstatGraftAckMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftAckMessagesSentRsp :
      public Pim01PimstatGraftAckMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftAckMessagesSentRsp(const Pim01PimstatGraftAckMessagesSentRF& cb)
          : Pim01PimstatGraftAckMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatGraftAckMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_ack_messages_sent
       (
	Pim01PimstatGraftAckMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_ack_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftAckMessagesRxErrorsRF;

    class Pim01PimstatGraftAckMessagesRxErrorsCB {
        Pim01PimstatGraftAckMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatGraftAckMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatGraftAckMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatGraftAckMessagesRxErrorsCB(const Pim01PimstatGraftAckMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftAckMessagesRxErrorsRsp :
      public Pim01PimstatGraftAckMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftAckMessagesRxErrorsRsp(const Pim01PimstatGraftAckMessagesRxErrorsRF& cb)
          : Pim01PimstatGraftAckMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatGraftAckMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_ack_messages_rx_errors
       (
	Pim01PimstatGraftAckMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_candidate_rp_messages_received(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatCandidateRpMessagesReceivedRF;

    class Pim01PimstatCandidateRpMessagesReceivedCB {
        Pim01PimstatCandidateRpMessagesReceivedRF cb;

    public:
        operator const Pim01PimstatCandidateRpMessagesReceivedRF& () const { return cb; }
        const Pim01PimstatCandidateRpMessagesReceivedRF& operator ->() const { return cb; }
        Pim01PimstatCandidateRpMessagesReceivedCB(const Pim01PimstatCandidateRpMessagesReceivedRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatCandidateRpMessagesReceivedRsp :
      public Pim01PimstatCandidateRpMessagesReceivedCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatCandidateRpMessagesReceivedRsp(const Pim01PimstatCandidateRpMessagesReceivedRF& cb)
          : Pim01PimstatCandidateRpMessagesReceivedCB(cb) { }

        void respond() const {
            Pim01PimstatCandidateRpMessagesReceivedCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_candidate_rp_messages_received
       (
	Pim01PimstatCandidateRpMessagesReceivedCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_candidate_rp_messages_sent(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatCandidateRpMessagesSentRF;

    class Pim01PimstatCandidateRpMessagesSentCB {
        Pim01PimstatCandidateRpMessagesSentRF cb;

    public:
        operator const Pim01PimstatCandidateRpMessagesSentRF& () const { return cb; }
        const Pim01PimstatCandidateRpMessagesSentRF& operator ->() const { return cb; }
        Pim01PimstatCandidateRpMessagesSentCB(const Pim01PimstatCandidateRpMessagesSentRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatCandidateRpMessagesSentRsp :
      public Pim01PimstatCandidateRpMessagesSentCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatCandidateRpMessagesSentRsp(const Pim01PimstatCandidateRpMessagesSentRF& cb)
          : Pim01PimstatCandidateRpMessagesSentCB(cb) { }

        void respond() const {
            Pim01PimstatCandidateRpMessagesSentCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_candidate_rp_messages_sent
       (
	Pim01PimstatCandidateRpMessagesSentCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_candidate_rp_messages_rx_errors(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatCandidateRpMessagesRxErrorsRF;

    class Pim01PimstatCandidateRpMessagesRxErrorsCB {
        Pim01PimstatCandidateRpMessagesRxErrorsRF cb;

    public:
        operator const Pim01PimstatCandidateRpMessagesRxErrorsRF& () const { return cb; }
        const Pim01PimstatCandidateRpMessagesRxErrorsRF& operator ->() const { return cb; }
        Pim01PimstatCandidateRpMessagesRxErrorsCB(const Pim01PimstatCandidateRpMessagesRxErrorsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatCandidateRpMessagesRxErrorsRsp :
      public Pim01PimstatCandidateRpMessagesRxErrorsCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatCandidateRpMessagesRxErrorsRsp(const Pim01PimstatCandidateRpMessagesRxErrorsRF& cb)
          : Pim01PimstatCandidateRpMessagesRxErrorsCB(cb) { }

        void respond() const {
            Pim01PimstatCandidateRpMessagesRxErrorsCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_candidate_rp_messages_rx_errors
       (
	Pim01PimstatCandidateRpMessagesRxErrorsCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_unknown_type_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatUnknownTypeMessagesRF;

    class Pim01PimstatUnknownTypeMessagesCB {
        Pim01PimstatUnknownTypeMessagesRF cb;

    public:
        operator const Pim01PimstatUnknownTypeMessagesRF& () const { return cb; }
        const Pim01PimstatUnknownTypeMessagesRF& operator ->() const { return cb; }
        Pim01PimstatUnknownTypeMessagesCB(const Pim01PimstatUnknownTypeMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatUnknownTypeMessagesRsp :
      public Pim01PimstatUnknownTypeMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatUnknownTypeMessagesRsp(const Pim01PimstatUnknownTypeMessagesRF& cb)
          : Pim01PimstatUnknownTypeMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatUnknownTypeMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_unknown_type_messages
       (
	Pim01PimstatUnknownTypeMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_unknown_version_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatUnknownVersionMessagesRF;

    class Pim01PimstatUnknownVersionMessagesCB {
        Pim01PimstatUnknownVersionMessagesRF cb;

    public:
        operator const Pim01PimstatUnknownVersionMessagesRF& () const { return cb; }
        const Pim01PimstatUnknownVersionMessagesRF& operator ->() const { return cb; }
        Pim01PimstatUnknownVersionMessagesCB(const Pim01PimstatUnknownVersionMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatUnknownVersionMessagesRsp :
      public Pim01PimstatUnknownVersionMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatUnknownVersionMessagesRsp(const Pim01PimstatUnknownVersionMessagesRF& cb)
          : Pim01PimstatUnknownVersionMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatUnknownVersionMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_unknown_version_messages
       (
	Pim01PimstatUnknownVersionMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_neighbor_unknown_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatNeighborUnknownMessagesRF;

    class Pim01PimstatNeighborUnknownMessagesCB {
        Pim01PimstatNeighborUnknownMessagesRF cb;

    public:
        operator const Pim01PimstatNeighborUnknownMessagesRF& () const { return cb; }
        const Pim01PimstatNeighborUnknownMessagesRF& operator ->() const { return cb; }
        Pim01PimstatNeighborUnknownMessagesCB(const Pim01PimstatNeighborUnknownMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatNeighborUnknownMessagesRsp :
      public Pim01PimstatNeighborUnknownMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNeighborUnknownMessagesRsp(const Pim01PimstatNeighborUnknownMessagesRF& cb)
          : Pim01PimstatNeighborUnknownMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatNeighborUnknownMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_neighbor_unknown_messages
       (
	Pim01PimstatNeighborUnknownMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bad_length_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBadLengthMessagesRF;

    class Pim01PimstatBadLengthMessagesCB {
        Pim01PimstatBadLengthMessagesRF cb;

    public:
        operator const Pim01PimstatBadLengthMessagesRF& () const { return cb; }
        const Pim01PimstatBadLengthMessagesRF& operator ->() const { return cb; }
        Pim01PimstatBadLengthMessagesCB(const Pim01PimstatBadLengthMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBadLengthMessagesRsp :
      public Pim01PimstatBadLengthMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBadLengthMessagesRsp(const Pim01PimstatBadLengthMessagesRF& cb)
          : Pim01PimstatBadLengthMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatBadLengthMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bad_length_messages
       (
	Pim01PimstatBadLengthMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bad_checksum_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBadChecksumMessagesRF;

    class Pim01PimstatBadChecksumMessagesCB {
        Pim01PimstatBadChecksumMessagesRF cb;

    public:
        operator const Pim01PimstatBadChecksumMessagesRF& () const { return cb; }
        const Pim01PimstatBadChecksumMessagesRF& operator ->() const { return cb; }
        Pim01PimstatBadChecksumMessagesCB(const Pim01PimstatBadChecksumMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBadChecksumMessagesRsp :
      public Pim01PimstatBadChecksumMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBadChecksumMessagesRsp(const Pim01PimstatBadChecksumMessagesRF& cb)
          : Pim01PimstatBadChecksumMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatBadChecksumMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bad_checksum_messages
       (
	Pim01PimstatBadChecksumMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bad_receive_interface_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBadReceiveInterfaceMessagesRF;

    class Pim01PimstatBadReceiveInterfaceMessagesCB {
        Pim01PimstatBadReceiveInterfaceMessagesRF cb;

    public:
        operator const Pim01PimstatBadReceiveInterfaceMessagesRF& () const { return cb; }
        const Pim01PimstatBadReceiveInterfaceMessagesRF& operator ->() const { return cb; }
        Pim01PimstatBadReceiveInterfaceMessagesCB(const Pim01PimstatBadReceiveInterfaceMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBadReceiveInterfaceMessagesRsp :
      public Pim01PimstatBadReceiveInterfaceMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBadReceiveInterfaceMessagesRsp(const Pim01PimstatBadReceiveInterfaceMessagesRF& cb)
          : Pim01PimstatBadReceiveInterfaceMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatBadReceiveInterfaceMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bad_receive_interface_messages
       (
	Pim01PimstatBadReceiveInterfaceMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_interface_disabled_messages(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxInterfaceDisabledMessagesRF;

    class Pim01PimstatRxInterfaceDisabledMessagesCB {
        Pim01PimstatRxInterfaceDisabledMessagesRF cb;

    public:
        operator const Pim01PimstatRxInterfaceDisabledMessagesRF& () const { return cb; }
        const Pim01PimstatRxInterfaceDisabledMessagesRF& operator ->() const { return cb; }
        Pim01PimstatRxInterfaceDisabledMessagesCB(const Pim01PimstatRxInterfaceDisabledMessagesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxInterfaceDisabledMessagesRsp :
      public Pim01PimstatRxInterfaceDisabledMessagesCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxInterfaceDisabledMessagesRsp(const Pim01PimstatRxInterfaceDisabledMessagesRF& cb)
          : Pim01PimstatRxInterfaceDisabledMessagesCB(cb) { }

        void respond() const {
            Pim01PimstatRxInterfaceDisabledMessagesCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_interface_disabled_messages
       (
	Pim01PimstatRxInterfaceDisabledMessagesCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_register_not_rp(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxRegisterNotRpRF;

    class Pim01PimstatRxRegisterNotRpCB {
        Pim01PimstatRxRegisterNotRpRF cb;

    public:
        operator const Pim01PimstatRxRegisterNotRpRF& () const { return cb; }
        const Pim01PimstatRxRegisterNotRpRF& operator ->() const { return cb; }
        Pim01PimstatRxRegisterNotRpCB(const Pim01PimstatRxRegisterNotRpRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxRegisterNotRpRsp :
      public Pim01PimstatRxRegisterNotRpCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxRegisterNotRpRsp(const Pim01PimstatRxRegisterNotRpRF& cb)
          : Pim01PimstatRxRegisterNotRpCB(cb) { }

        void respond() const {
            Pim01PimstatRxRegisterNotRpCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_register_not_rp
       (
	Pim01PimstatRxRegisterNotRpCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rp_filtered_source(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRpFilteredSourceRF;

    class Pim01PimstatRpFilteredSourceCB {
        Pim01PimstatRpFilteredSourceRF cb;

    public:
        operator const Pim01PimstatRpFilteredSourceRF& () const { return cb; }
        const Pim01PimstatRpFilteredSourceRF& operator ->() const { return cb; }
        Pim01PimstatRpFilteredSourceCB(const Pim01PimstatRpFilteredSourceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRpFilteredSourceRsp :
      public Pim01PimstatRpFilteredSourceCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRpFilteredSourceRsp(const Pim01PimstatRpFilteredSourceRF& cb)
          : Pim01PimstatRpFilteredSourceCB(cb) { }

        void respond() const {
            Pim01PimstatRpFilteredSourceCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rp_filtered_source
       (
	Pim01PimstatRpFilteredSourceCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_unknown_register_stop(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatUnknownRegisterStopRF;

    class Pim01PimstatUnknownRegisterStopCB {
        Pim01PimstatUnknownRegisterStopRF cb;

    public:
        operator const Pim01PimstatUnknownRegisterStopRF& () const { return cb; }
        const Pim01PimstatUnknownRegisterStopRF& operator ->() const { return cb; }
        Pim01PimstatUnknownRegisterStopCB(const Pim01PimstatUnknownRegisterStopRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatUnknownRegisterStopRsp :
      public Pim01PimstatUnknownRegisterStopCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatUnknownRegisterStopRsp(const Pim01PimstatUnknownRegisterStopRF& cb)
          : Pim01PimstatUnknownRegisterStopCB(cb) { }

        void respond() const {
            Pim01PimstatUnknownRegisterStopCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_unknown_register_stop
       (
	Pim01PimstatUnknownRegisterStopCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_prune_no_state(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinPruneNoStateRF;

    class Pim01PimstatRxJoinPruneNoStateCB {
        Pim01PimstatRxJoinPruneNoStateRF cb;

    public:
        operator const Pim01PimstatRxJoinPruneNoStateRF& () const { return cb; }
        const Pim01PimstatRxJoinPruneNoStateRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinPruneNoStateCB(const Pim01PimstatRxJoinPruneNoStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinPruneNoStateRsp :
      public Pim01PimstatRxJoinPruneNoStateCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinPruneNoStateRsp(const Pim01PimstatRxJoinPruneNoStateRF& cb)
          : Pim01PimstatRxJoinPruneNoStateCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinPruneNoStateCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_prune_no_state
       (
	Pim01PimstatRxJoinPruneNoStateCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_graft_graft_ack_no_state(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxGraftGraftAckNoStateRF;

    class Pim01PimstatRxGraftGraftAckNoStateCB {
        Pim01PimstatRxGraftGraftAckNoStateRF cb;

    public:
        operator const Pim01PimstatRxGraftGraftAckNoStateRF& () const { return cb; }
        const Pim01PimstatRxGraftGraftAckNoStateRF& operator ->() const { return cb; }
        Pim01PimstatRxGraftGraftAckNoStateCB(const Pim01PimstatRxGraftGraftAckNoStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxGraftGraftAckNoStateRsp :
      public Pim01PimstatRxGraftGraftAckNoStateCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxGraftGraftAckNoStateRsp(const Pim01PimstatRxGraftGraftAckNoStateRF& cb)
          : Pim01PimstatRxGraftGraftAckNoStateCB(cb) { }

        void respond() const {
            Pim01PimstatRxGraftGraftAckNoStateCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_graft_graft_ack_no_state
       (
	Pim01PimstatRxGraftGraftAckNoStateCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_graft_on_upstream_interface(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxGraftOnUpstreamInterfaceRF;

    class Pim01PimstatRxGraftOnUpstreamInterfaceCB {
        Pim01PimstatRxGraftOnUpstreamInterfaceRF cb;

    public:
        operator const Pim01PimstatRxGraftOnUpstreamInterfaceRF& () const { return cb; }
        const Pim01PimstatRxGraftOnUpstreamInterfaceRF& operator ->() const { return cb; }
        Pim01PimstatRxGraftOnUpstreamInterfaceCB(const Pim01PimstatRxGraftOnUpstreamInterfaceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxGraftOnUpstreamInterfaceRsp :
      public Pim01PimstatRxGraftOnUpstreamInterfaceCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxGraftOnUpstreamInterfaceRsp(const Pim01PimstatRxGraftOnUpstreamInterfaceRF& cb)
          : Pim01PimstatRxGraftOnUpstreamInterfaceCB(cb) { }

        void respond() const {
            Pim01PimstatRxGraftOnUpstreamInterfaceCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_graft_on_upstream_interface
       (
	Pim01PimstatRxGraftOnUpstreamInterfaceCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_candidate_rp_not_bsr(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxCandidateRpNotBsrRF;

    class Pim01PimstatRxCandidateRpNotBsrCB {
        Pim01PimstatRxCandidateRpNotBsrRF cb;

    public:
        operator const Pim01PimstatRxCandidateRpNotBsrRF& () const { return cb; }
        const Pim01PimstatRxCandidateRpNotBsrRF& operator ->() const { return cb; }
        Pim01PimstatRxCandidateRpNotBsrCB(const Pim01PimstatRxCandidateRpNotBsrRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxCandidateRpNotBsrRsp :
      public Pim01PimstatRxCandidateRpNotBsrCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxCandidateRpNotBsrRsp(const Pim01PimstatRxCandidateRpNotBsrRF& cb)
          : Pim01PimstatRxCandidateRpNotBsrCB(cb) { }

        void respond() const {
            Pim01PimstatRxCandidateRpNotBsrCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_candidate_rp_not_bsr
       (
	Pim01PimstatRxCandidateRpNotBsrCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_bsr_when_bsr(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxBsrWhenBsrRF;

    class Pim01PimstatRxBsrWhenBsrCB {
        Pim01PimstatRxBsrWhenBsrRF cb;

    public:
        operator const Pim01PimstatRxBsrWhenBsrRF& () const { return cb; }
        const Pim01PimstatRxBsrWhenBsrRF& operator ->() const { return cb; }
        Pim01PimstatRxBsrWhenBsrCB(const Pim01PimstatRxBsrWhenBsrRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxBsrWhenBsrRsp :
      public Pim01PimstatRxBsrWhenBsrCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxBsrWhenBsrRsp(const Pim01PimstatRxBsrWhenBsrRF& cb)
          : Pim01PimstatRxBsrWhenBsrCB(cb) { }

        void respond() const {
            Pim01PimstatRxBsrWhenBsrCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_bsr_when_bsr
       (
	Pim01PimstatRxBsrWhenBsrCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_bsr_not_rpf_interface(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxBsrNotRpfInterfaceRF;

    class Pim01PimstatRxBsrNotRpfInterfaceCB {
        Pim01PimstatRxBsrNotRpfInterfaceRF cb;

    public:
        operator const Pim01PimstatRxBsrNotRpfInterfaceRF& () const { return cb; }
        const Pim01PimstatRxBsrNotRpfInterfaceRF& operator ->() const { return cb; }
        Pim01PimstatRxBsrNotRpfInterfaceCB(const Pim01PimstatRxBsrNotRpfInterfaceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxBsrNotRpfInterfaceRsp :
      public Pim01PimstatRxBsrNotRpfInterfaceCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxBsrNotRpfInterfaceRsp(const Pim01PimstatRxBsrNotRpfInterfaceRF& cb)
          : Pim01PimstatRxBsrNotRpfInterfaceCB(cb) { }

        void respond() const {
            Pim01PimstatRxBsrNotRpfInterfaceCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_bsr_not_rpf_interface
       (
	Pim01PimstatRxBsrNotRpfInterfaceCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_unknown_hello_option(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxUnknownHelloOptionRF;

    class Pim01PimstatRxUnknownHelloOptionCB {
        Pim01PimstatRxUnknownHelloOptionRF cb;

    public:
        operator const Pim01PimstatRxUnknownHelloOptionRF& () const { return cb; }
        const Pim01PimstatRxUnknownHelloOptionRF& operator ->() const { return cb; }
        Pim01PimstatRxUnknownHelloOptionCB(const Pim01PimstatRxUnknownHelloOptionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxUnknownHelloOptionRsp :
      public Pim01PimstatRxUnknownHelloOptionCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxUnknownHelloOptionRsp(const Pim01PimstatRxUnknownHelloOptionRF& cb)
          : Pim01PimstatRxUnknownHelloOptionCB(cb) { }

        void respond() const {
            Pim01PimstatRxUnknownHelloOptionCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_unknown_hello_option
       (
	Pim01PimstatRxUnknownHelloOptionCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_data_no_state(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxDataNoStateRF;

    class Pim01PimstatRxDataNoStateCB {
        Pim01PimstatRxDataNoStateRF cb;

    public:
        operator const Pim01PimstatRxDataNoStateRF& () const { return cb; }
        const Pim01PimstatRxDataNoStateRF& operator ->() const { return cb; }
        Pim01PimstatRxDataNoStateCB(const Pim01PimstatRxDataNoStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxDataNoStateRsp :
      public Pim01PimstatRxDataNoStateCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxDataNoStateRsp(const Pim01PimstatRxDataNoStateRF& cb)
          : Pim01PimstatRxDataNoStateCB(cb) { }

        void respond() const {
            Pim01PimstatRxDataNoStateCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_data_no_state
       (
	Pim01PimstatRxDataNoStateCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_rp_no_state(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxRpNoStateRF;

    class Pim01PimstatRxRpNoStateCB {
        Pim01PimstatRxRpNoStateRF cb;

    public:
        operator const Pim01PimstatRxRpNoStateRF& () const { return cb; }
        const Pim01PimstatRxRpNoStateRF& operator ->() const { return cb; }
        Pim01PimstatRxRpNoStateCB(const Pim01PimstatRxRpNoStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxRpNoStateRsp :
      public Pim01PimstatRxRpNoStateCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxRpNoStateRsp(const Pim01PimstatRxRpNoStateRF& cb)
          : Pim01PimstatRxRpNoStateCB(cb) { }

        void respond() const {
            Pim01PimstatRxRpNoStateCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_rp_no_state
       (
	Pim01PimstatRxRpNoStateCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_aggregate(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxAggregateRF;

    class Pim01PimstatRxAggregateCB {
        Pim01PimstatRxAggregateRF cb;

    public:
        operator const Pim01PimstatRxAggregateRF& () const { return cb; }
        const Pim01PimstatRxAggregateRF& operator ->() const { return cb; }
        Pim01PimstatRxAggregateCB(const Pim01PimstatRxAggregateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxAggregateRsp :
      public Pim01PimstatRxAggregateCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxAggregateRsp(const Pim01PimstatRxAggregateRF& cb)
          : Pim01PimstatRxAggregateCB(cb) { }

        void respond() const {
            Pim01PimstatRxAggregateCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_aggregate
       (
	Pim01PimstatRxAggregateCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_malformed_packet(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxMalformedPacketRF;

    class Pim01PimstatRxMalformedPacketCB {
        Pim01PimstatRxMalformedPacketRF cb;

    public:
        operator const Pim01PimstatRxMalformedPacketRF& () const { return cb; }
        const Pim01PimstatRxMalformedPacketRF& operator ->() const { return cb; }
        Pim01PimstatRxMalformedPacketCB(const Pim01PimstatRxMalformedPacketRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxMalformedPacketRsp :
      public Pim01PimstatRxMalformedPacketCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxMalformedPacketRsp(const Pim01PimstatRxMalformedPacketRF& cb)
          : Pim01PimstatRxMalformedPacketCB(cb) { }

        void respond() const {
            Pim01PimstatRxMalformedPacketCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_malformed_packet
       (
	Pim01PimstatRxMalformedPacketCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_no_rp(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatNoRpRF;

    class Pim01PimstatNoRpCB {
        Pim01PimstatNoRpRF cb;

    public:
        operator const Pim01PimstatNoRpRF& () const { return cb; }
        const Pim01PimstatNoRpRF& operator ->() const { return cb; }
        Pim01PimstatNoRpCB(const Pim01PimstatNoRpRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatNoRpRsp :
      public Pim01PimstatNoRpCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNoRpRsp(const Pim01PimstatNoRpRF& cb)
          : Pim01PimstatNoRpCB(cb) { }

        void respond() const {
            Pim01PimstatNoRpCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_no_rp
       (
	Pim01PimstatNoRpCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_no_route_upstream(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatNoRouteUpstreamRF;

    class Pim01PimstatNoRouteUpstreamCB {
        Pim01PimstatNoRouteUpstreamRF cb;

    public:
        operator const Pim01PimstatNoRouteUpstreamRF& () const { return cb; }
        const Pim01PimstatNoRouteUpstreamRF& operator ->() const { return cb; }
        Pim01PimstatNoRouteUpstreamCB(const Pim01PimstatNoRouteUpstreamRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatNoRouteUpstreamRsp :
      public Pim01PimstatNoRouteUpstreamCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNoRouteUpstreamRsp(const Pim01PimstatNoRouteUpstreamRF& cb)
          : Pim01PimstatNoRouteUpstreamCB(cb) { }

        void respond() const {
            Pim01PimstatNoRouteUpstreamCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_no_route_upstream
       (
	Pim01PimstatNoRouteUpstreamCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rp_mismatch(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRpMismatchRF;

    class Pim01PimstatRpMismatchCB {
        Pim01PimstatRpMismatchRF cb;

    public:
        operator const Pim01PimstatRpMismatchRF& () const { return cb; }
        const Pim01PimstatRpMismatchRF& operator ->() const { return cb; }
        Pim01PimstatRpMismatchCB(const Pim01PimstatRpMismatchRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRpMismatchRsp :
      public Pim01PimstatRpMismatchCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRpMismatchRsp(const Pim01PimstatRpMismatchRF& cb)
          : Pim01PimstatRpMismatchCB(cb) { }

        void respond() const {
            Pim01PimstatRpMismatchCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rp_mismatch
       (
	Pim01PimstatRpMismatchCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rpf_neighbor_unknown(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRpfNeighborUnknownRF;

    class Pim01PimstatRpfNeighborUnknownCB {
        Pim01PimstatRpfNeighborUnknownRF cb;

    public:
        operator const Pim01PimstatRpfNeighborUnknownRF& () const { return cb; }
        const Pim01PimstatRpfNeighborUnknownRF& operator ->() const { return cb; }
        Pim01PimstatRpfNeighborUnknownCB(const Pim01PimstatRpfNeighborUnknownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRpfNeighborUnknownRsp :
      public Pim01PimstatRpfNeighborUnknownCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRpfNeighborUnknownRsp(const Pim01PimstatRpfNeighborUnknownRF& cb)
          : Pim01PimstatRpfNeighborUnknownCB(cb) { }

        void respond() const {
            Pim01PimstatRpfNeighborUnknownCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rpf_neighbor_unknown
       (
	Pim01PimstatRpfNeighborUnknownCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_rp(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinRpRF;

    class Pim01PimstatRxJoinRpCB {
        Pim01PimstatRxJoinRpRF cb;

    public:
        operator const Pim01PimstatRxJoinRpRF& () const { return cb; }
        const Pim01PimstatRxJoinRpRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinRpCB(const Pim01PimstatRxJoinRpRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinRpRsp :
      public Pim01PimstatRxJoinRpCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinRpRsp(const Pim01PimstatRxJoinRpRF& cb)
          : Pim01PimstatRxJoinRpCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinRpCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_rp
       (
	Pim01PimstatRxJoinRpCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_rp(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneRpRF;

    class Pim01PimstatRxPruneRpCB {
        Pim01PimstatRxPruneRpRF cb;

    public:
        operator const Pim01PimstatRxPruneRpRF& () const { return cb; }
        const Pim01PimstatRxPruneRpRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneRpCB(const Pim01PimstatRxPruneRpRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneRpRsp :
      public Pim01PimstatRxPruneRpCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneRpRsp(const Pim01PimstatRxPruneRpRF& cb)
          : Pim01PimstatRxPruneRpCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneRpCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_rp
       (
	Pim01PimstatRxPruneRpCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_wc(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinWcRF;

    class Pim01PimstatRxJoinWcCB {
        Pim01PimstatRxJoinWcRF cb;

    public:
        operator const Pim01PimstatRxJoinWcRF& () const { return cb; }
        const Pim01PimstatRxJoinWcRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinWcCB(const Pim01PimstatRxJoinWcRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinWcRsp :
      public Pim01PimstatRxJoinWcCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinWcRsp(const Pim01PimstatRxJoinWcRF& cb)
          : Pim01PimstatRxJoinWcCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinWcCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_wc
       (
	Pim01PimstatRxJoinWcCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_wc(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneWcRF;

    class Pim01PimstatRxPruneWcCB {
        Pim01PimstatRxPruneWcRF cb;

    public:
        operator const Pim01PimstatRxPruneWcRF& () const { return cb; }
        const Pim01PimstatRxPruneWcRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneWcCB(const Pim01PimstatRxPruneWcRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneWcRsp :
      public Pim01PimstatRxPruneWcCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneWcRsp(const Pim01PimstatRxPruneWcRF& cb)
          : Pim01PimstatRxPruneWcCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneWcCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_wc
       (
	Pim01PimstatRxPruneWcCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_sg(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinSgRF;

    class Pim01PimstatRxJoinSgCB {
        Pim01PimstatRxJoinSgRF cb;

    public:
        operator const Pim01PimstatRxJoinSgRF& () const { return cb; }
        const Pim01PimstatRxJoinSgRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinSgCB(const Pim01PimstatRxJoinSgRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinSgRsp :
      public Pim01PimstatRxJoinSgCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinSgRsp(const Pim01PimstatRxJoinSgRF& cb)
          : Pim01PimstatRxJoinSgCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinSgCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_sg
       (
	Pim01PimstatRxJoinSgCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_sg(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneSgRF;

    class Pim01PimstatRxPruneSgCB {
        Pim01PimstatRxPruneSgRF cb;

    public:
        operator const Pim01PimstatRxPruneSgRF& () const { return cb; }
        const Pim01PimstatRxPruneSgRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneSgCB(const Pim01PimstatRxPruneSgRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneSgRsp :
      public Pim01PimstatRxPruneSgCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneSgRsp(const Pim01PimstatRxPruneSgRF& cb)
          : Pim01PimstatRxPruneSgCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneSgCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_sg
       (
	Pim01PimstatRxPruneSgCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_sg_rpt(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinSgRptRF;

    class Pim01PimstatRxJoinSgRptCB {
        Pim01PimstatRxJoinSgRptRF cb;

    public:
        operator const Pim01PimstatRxJoinSgRptRF& () const { return cb; }
        const Pim01PimstatRxJoinSgRptRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinSgRptCB(const Pim01PimstatRxJoinSgRptRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinSgRptRsp :
      public Pim01PimstatRxJoinSgRptCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinSgRptRsp(const Pim01PimstatRxJoinSgRptRF& cb)
          : Pim01PimstatRxJoinSgRptCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinSgRptCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_sg_rpt
       (
	Pim01PimstatRxJoinSgRptCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_sg_rpt(
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneSgRptRF;

    class Pim01PimstatRxPruneSgRptCB {
        Pim01PimstatRxPruneSgRptRF cb;

    public:
        operator const Pim01PimstatRxPruneSgRptRF& () const { return cb; }
        const Pim01PimstatRxPruneSgRptRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneSgRptCB(const Pim01PimstatRxPruneSgRptRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneSgRptRsp :
      public Pim01PimstatRxPruneSgRptCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneSgRptRsp(const Pim01PimstatRxPruneSgRptRF& cb)
          : Pim01PimstatRxPruneSgRptCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneSgRptCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_sg_rpt
       (
	Pim01PimstatRxPruneSgRptCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_hello_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatHelloMessagesReceivedPerVifRF;

    class Pim01PimstatHelloMessagesReceivedPerVifCB {
        Pim01PimstatHelloMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatHelloMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatHelloMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatHelloMessagesReceivedPerVifCB(const Pim01PimstatHelloMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatHelloMessagesReceivedPerVifRsp :
      public Pim01PimstatHelloMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatHelloMessagesReceivedPerVifRsp(const Pim01PimstatHelloMessagesReceivedPerVifRF& cb)
          : Pim01PimstatHelloMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatHelloMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_hello_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatHelloMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_hello_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatHelloMessagesSentPerVifRF;

    class Pim01PimstatHelloMessagesSentPerVifCB {
        Pim01PimstatHelloMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatHelloMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatHelloMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatHelloMessagesSentPerVifCB(const Pim01PimstatHelloMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatHelloMessagesSentPerVifRsp :
      public Pim01PimstatHelloMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatHelloMessagesSentPerVifRsp(const Pim01PimstatHelloMessagesSentPerVifRF& cb)
          : Pim01PimstatHelloMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatHelloMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_hello_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatHelloMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_hello_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatHelloMessagesRxErrorsPerVifRF;

    class Pim01PimstatHelloMessagesRxErrorsPerVifCB {
        Pim01PimstatHelloMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatHelloMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatHelloMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatHelloMessagesRxErrorsPerVifCB(const Pim01PimstatHelloMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatHelloMessagesRxErrorsPerVifRsp :
      public Pim01PimstatHelloMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatHelloMessagesRxErrorsPerVifRsp(const Pim01PimstatHelloMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatHelloMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatHelloMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_hello_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatHelloMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterMessagesReceivedPerVifRF;

    class Pim01PimstatRegisterMessagesReceivedPerVifCB {
        Pim01PimstatRegisterMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatRegisterMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatRegisterMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRegisterMessagesReceivedPerVifCB(const Pim01PimstatRegisterMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterMessagesReceivedPerVifRsp :
      public Pim01PimstatRegisterMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterMessagesReceivedPerVifRsp(const Pim01PimstatRegisterMessagesReceivedPerVifRF& cb)
          : Pim01PimstatRegisterMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRegisterMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterMessagesSentPerVifRF;

    class Pim01PimstatRegisterMessagesSentPerVifCB {
        Pim01PimstatRegisterMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatRegisterMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatRegisterMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRegisterMessagesSentPerVifCB(const Pim01PimstatRegisterMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterMessagesSentPerVifRsp :
      public Pim01PimstatRegisterMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterMessagesSentPerVifRsp(const Pim01PimstatRegisterMessagesSentPerVifRF& cb)
          : Pim01PimstatRegisterMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRegisterMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterMessagesRxErrorsPerVifRF;

    class Pim01PimstatRegisterMessagesRxErrorsPerVifCB {
        Pim01PimstatRegisterMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatRegisterMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatRegisterMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRegisterMessagesRxErrorsPerVifCB(const Pim01PimstatRegisterMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterMessagesRxErrorsPerVifRsp :
      public Pim01PimstatRegisterMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterMessagesRxErrorsPerVifRsp(const Pim01PimstatRegisterMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatRegisterMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRegisterMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_stop_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterStopMessagesReceivedPerVifRF;

    class Pim01PimstatRegisterStopMessagesReceivedPerVifCB {
        Pim01PimstatRegisterStopMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatRegisterStopMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatRegisterStopMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRegisterStopMessagesReceivedPerVifCB(const Pim01PimstatRegisterStopMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterStopMessagesReceivedPerVifRsp :
      public Pim01PimstatRegisterStopMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterStopMessagesReceivedPerVifRsp(const Pim01PimstatRegisterStopMessagesReceivedPerVifRF& cb)
          : Pim01PimstatRegisterStopMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterStopMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_stop_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRegisterStopMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_stop_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterStopMessagesSentPerVifRF;

    class Pim01PimstatRegisterStopMessagesSentPerVifCB {
        Pim01PimstatRegisterStopMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatRegisterStopMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatRegisterStopMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRegisterStopMessagesSentPerVifCB(const Pim01PimstatRegisterStopMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterStopMessagesSentPerVifRsp :
      public Pim01PimstatRegisterStopMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterStopMessagesSentPerVifRsp(const Pim01PimstatRegisterStopMessagesSentPerVifRF& cb)
          : Pim01PimstatRegisterStopMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterStopMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_stop_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRegisterStopMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF;

    class Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB {
        Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB(const Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRegisterStopMessagesRxErrorsPerVifRsp :
      public Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRegisterStopMessagesRxErrorsPerVifRsp(const Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_join_prune_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatJoinPruneMessagesReceivedPerVifRF;

    class Pim01PimstatJoinPruneMessagesReceivedPerVifCB {
        Pim01PimstatJoinPruneMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatJoinPruneMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatJoinPruneMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatJoinPruneMessagesReceivedPerVifCB(const Pim01PimstatJoinPruneMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatJoinPruneMessagesReceivedPerVifRsp :
      public Pim01PimstatJoinPruneMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatJoinPruneMessagesReceivedPerVifRsp(const Pim01PimstatJoinPruneMessagesReceivedPerVifRF& cb)
          : Pim01PimstatJoinPruneMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatJoinPruneMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_join_prune_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatJoinPruneMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_join_prune_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatJoinPruneMessagesSentPerVifRF;

    class Pim01PimstatJoinPruneMessagesSentPerVifCB {
        Pim01PimstatJoinPruneMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatJoinPruneMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatJoinPruneMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatJoinPruneMessagesSentPerVifCB(const Pim01PimstatJoinPruneMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatJoinPruneMessagesSentPerVifRsp :
      public Pim01PimstatJoinPruneMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatJoinPruneMessagesSentPerVifRsp(const Pim01PimstatJoinPruneMessagesSentPerVifRF& cb)
          : Pim01PimstatJoinPruneMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatJoinPruneMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_join_prune_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatJoinPruneMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF;

    class Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB {
        Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB(const Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatJoinPruneMessagesRxErrorsPerVifRsp :
      public Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatJoinPruneMessagesRxErrorsPerVifRsp(const Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bootstrap_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBootstrapMessagesReceivedPerVifRF;

    class Pim01PimstatBootstrapMessagesReceivedPerVifCB {
        Pim01PimstatBootstrapMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatBootstrapMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatBootstrapMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatBootstrapMessagesReceivedPerVifCB(const Pim01PimstatBootstrapMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBootstrapMessagesReceivedPerVifRsp :
      public Pim01PimstatBootstrapMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBootstrapMessagesReceivedPerVifRsp(const Pim01PimstatBootstrapMessagesReceivedPerVifRF& cb)
          : Pim01PimstatBootstrapMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatBootstrapMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bootstrap_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatBootstrapMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bootstrap_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBootstrapMessagesSentPerVifRF;

    class Pim01PimstatBootstrapMessagesSentPerVifCB {
        Pim01PimstatBootstrapMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatBootstrapMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatBootstrapMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatBootstrapMessagesSentPerVifCB(const Pim01PimstatBootstrapMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBootstrapMessagesSentPerVifRsp :
      public Pim01PimstatBootstrapMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBootstrapMessagesSentPerVifRsp(const Pim01PimstatBootstrapMessagesSentPerVifRF& cb)
          : Pim01PimstatBootstrapMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatBootstrapMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bootstrap_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatBootstrapMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBootstrapMessagesRxErrorsPerVifRF;

    class Pim01PimstatBootstrapMessagesRxErrorsPerVifCB {
        Pim01PimstatBootstrapMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatBootstrapMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatBootstrapMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatBootstrapMessagesRxErrorsPerVifCB(const Pim01PimstatBootstrapMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBootstrapMessagesRxErrorsPerVifRsp :
      public Pim01PimstatBootstrapMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBootstrapMessagesRxErrorsPerVifRsp(const Pim01PimstatBootstrapMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatBootstrapMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatBootstrapMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatBootstrapMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_assert_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatAssertMessagesReceivedPerVifRF;

    class Pim01PimstatAssertMessagesReceivedPerVifCB {
        Pim01PimstatAssertMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatAssertMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatAssertMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatAssertMessagesReceivedPerVifCB(const Pim01PimstatAssertMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatAssertMessagesReceivedPerVifRsp :
      public Pim01PimstatAssertMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatAssertMessagesReceivedPerVifRsp(const Pim01PimstatAssertMessagesReceivedPerVifRF& cb)
          : Pim01PimstatAssertMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatAssertMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_assert_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatAssertMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_assert_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatAssertMessagesSentPerVifRF;

    class Pim01PimstatAssertMessagesSentPerVifCB {
        Pim01PimstatAssertMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatAssertMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatAssertMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatAssertMessagesSentPerVifCB(const Pim01PimstatAssertMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatAssertMessagesSentPerVifRsp :
      public Pim01PimstatAssertMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatAssertMessagesSentPerVifRsp(const Pim01PimstatAssertMessagesSentPerVifRF& cb)
          : Pim01PimstatAssertMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatAssertMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_assert_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatAssertMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_assert_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatAssertMessagesRxErrorsPerVifRF;

    class Pim01PimstatAssertMessagesRxErrorsPerVifCB {
        Pim01PimstatAssertMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatAssertMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatAssertMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatAssertMessagesRxErrorsPerVifCB(const Pim01PimstatAssertMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatAssertMessagesRxErrorsPerVifRsp :
      public Pim01PimstatAssertMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatAssertMessagesRxErrorsPerVifRsp(const Pim01PimstatAssertMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatAssertMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatAssertMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_assert_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatAssertMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftMessagesReceivedPerVifRF;

    class Pim01PimstatGraftMessagesReceivedPerVifCB {
        Pim01PimstatGraftMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatGraftMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatGraftMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatGraftMessagesReceivedPerVifCB(const Pim01PimstatGraftMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftMessagesReceivedPerVifRsp :
      public Pim01PimstatGraftMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftMessagesReceivedPerVifRsp(const Pim01PimstatGraftMessagesReceivedPerVifRF& cb)
          : Pim01PimstatGraftMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatGraftMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatGraftMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftMessagesSentPerVifRF;

    class Pim01PimstatGraftMessagesSentPerVifCB {
        Pim01PimstatGraftMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatGraftMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatGraftMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatGraftMessagesSentPerVifCB(const Pim01PimstatGraftMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftMessagesSentPerVifRsp :
      public Pim01PimstatGraftMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftMessagesSentPerVifRsp(const Pim01PimstatGraftMessagesSentPerVifRF& cb)
          : Pim01PimstatGraftMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatGraftMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatGraftMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftMessagesRxErrorsPerVifRF;

    class Pim01PimstatGraftMessagesRxErrorsPerVifCB {
        Pim01PimstatGraftMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatGraftMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatGraftMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatGraftMessagesRxErrorsPerVifCB(const Pim01PimstatGraftMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftMessagesRxErrorsPerVifRsp :
      public Pim01PimstatGraftMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftMessagesRxErrorsPerVifRsp(const Pim01PimstatGraftMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatGraftMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatGraftMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatGraftMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_ack_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftAckMessagesReceivedPerVifRF;

    class Pim01PimstatGraftAckMessagesReceivedPerVifCB {
        Pim01PimstatGraftAckMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatGraftAckMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatGraftAckMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatGraftAckMessagesReceivedPerVifCB(const Pim01PimstatGraftAckMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftAckMessagesReceivedPerVifRsp :
      public Pim01PimstatGraftAckMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftAckMessagesReceivedPerVifRsp(const Pim01PimstatGraftAckMessagesReceivedPerVifRF& cb)
          : Pim01PimstatGraftAckMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatGraftAckMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_ack_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatGraftAckMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_ack_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftAckMessagesSentPerVifRF;

    class Pim01PimstatGraftAckMessagesSentPerVifCB {
        Pim01PimstatGraftAckMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatGraftAckMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatGraftAckMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatGraftAckMessagesSentPerVifCB(const Pim01PimstatGraftAckMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftAckMessagesSentPerVifRsp :
      public Pim01PimstatGraftAckMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftAckMessagesSentPerVifRsp(const Pim01PimstatGraftAckMessagesSentPerVifRF& cb)
          : Pim01PimstatGraftAckMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatGraftAckMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_ack_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatGraftAckMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatGraftAckMessagesRxErrorsPerVifRF;

    class Pim01PimstatGraftAckMessagesRxErrorsPerVifCB {
        Pim01PimstatGraftAckMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatGraftAckMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatGraftAckMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatGraftAckMessagesRxErrorsPerVifCB(const Pim01PimstatGraftAckMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatGraftAckMessagesRxErrorsPerVifRsp :
      public Pim01PimstatGraftAckMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatGraftAckMessagesRxErrorsPerVifRsp(const Pim01PimstatGraftAckMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatGraftAckMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatGraftAckMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatGraftAckMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_candidate_rp_messages_received_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatCandidateRpMessagesReceivedPerVifRF;

    class Pim01PimstatCandidateRpMessagesReceivedPerVifCB {
        Pim01PimstatCandidateRpMessagesReceivedPerVifRF cb;

    public:
        operator const Pim01PimstatCandidateRpMessagesReceivedPerVifRF& () const { return cb; }
        const Pim01PimstatCandidateRpMessagesReceivedPerVifRF& operator ->() const { return cb; }
        Pim01PimstatCandidateRpMessagesReceivedPerVifCB(const Pim01PimstatCandidateRpMessagesReceivedPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatCandidateRpMessagesReceivedPerVifRsp :
      public Pim01PimstatCandidateRpMessagesReceivedPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatCandidateRpMessagesReceivedPerVifRsp(const Pim01PimstatCandidateRpMessagesReceivedPerVifRF& cb)
          : Pim01PimstatCandidateRpMessagesReceivedPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatCandidateRpMessagesReceivedPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_candidate_rp_messages_received_per_vif
       (
	const string&	vif_name,
	Pim01PimstatCandidateRpMessagesReceivedPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatCandidateRpMessagesSentPerVifRF;

    class Pim01PimstatCandidateRpMessagesSentPerVifCB {
        Pim01PimstatCandidateRpMessagesSentPerVifRF cb;

    public:
        operator const Pim01PimstatCandidateRpMessagesSentPerVifRF& () const { return cb; }
        const Pim01PimstatCandidateRpMessagesSentPerVifRF& operator ->() const { return cb; }
        Pim01PimstatCandidateRpMessagesSentPerVifCB(const Pim01PimstatCandidateRpMessagesSentPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatCandidateRpMessagesSentPerVifRsp :
      public Pim01PimstatCandidateRpMessagesSentPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatCandidateRpMessagesSentPerVifRsp(const Pim01PimstatCandidateRpMessagesSentPerVifRF& cb)
          : Pim01PimstatCandidateRpMessagesSentPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatCandidateRpMessagesSentPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif
       (
	const string&	vif_name,
	Pim01PimstatCandidateRpMessagesSentPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF;

    class Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB {
        Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF cb;

    public:
        operator const Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF& () const { return cb; }
        const Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF& operator ->() const { return cb; }
        Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB(const Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatCandidateRpMessagesRxErrorsPerVifRsp :
      public Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatCandidateRpMessagesRxErrorsPerVifRsp(const Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF& cb)
          : Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif
       (
	const string&	vif_name,
	Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_unknown_type_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatUnknownTypeMessagesPerVifRF;

    class Pim01PimstatUnknownTypeMessagesPerVifCB {
        Pim01PimstatUnknownTypeMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatUnknownTypeMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatUnknownTypeMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatUnknownTypeMessagesPerVifCB(const Pim01PimstatUnknownTypeMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatUnknownTypeMessagesPerVifRsp :
      public Pim01PimstatUnknownTypeMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatUnknownTypeMessagesPerVifRsp(const Pim01PimstatUnknownTypeMessagesPerVifRF& cb)
          : Pim01PimstatUnknownTypeMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatUnknownTypeMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_unknown_type_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatUnknownTypeMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_unknown_version_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatUnknownVersionMessagesPerVifRF;

    class Pim01PimstatUnknownVersionMessagesPerVifCB {
        Pim01PimstatUnknownVersionMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatUnknownVersionMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatUnknownVersionMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatUnknownVersionMessagesPerVifCB(const Pim01PimstatUnknownVersionMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatUnknownVersionMessagesPerVifRsp :
      public Pim01PimstatUnknownVersionMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatUnknownVersionMessagesPerVifRsp(const Pim01PimstatUnknownVersionMessagesPerVifRF& cb)
          : Pim01PimstatUnknownVersionMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatUnknownVersionMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_unknown_version_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatUnknownVersionMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_neighbor_unknown_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatNeighborUnknownMessagesPerVifRF;

    class Pim01PimstatNeighborUnknownMessagesPerVifCB {
        Pim01PimstatNeighborUnknownMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatNeighborUnknownMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatNeighborUnknownMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatNeighborUnknownMessagesPerVifCB(const Pim01PimstatNeighborUnknownMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatNeighborUnknownMessagesPerVifRsp :
      public Pim01PimstatNeighborUnknownMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNeighborUnknownMessagesPerVifRsp(const Pim01PimstatNeighborUnknownMessagesPerVifRF& cb)
          : Pim01PimstatNeighborUnknownMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatNeighborUnknownMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_neighbor_unknown_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatNeighborUnknownMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bad_length_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBadLengthMessagesPerVifRF;

    class Pim01PimstatBadLengthMessagesPerVifCB {
        Pim01PimstatBadLengthMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatBadLengthMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatBadLengthMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatBadLengthMessagesPerVifCB(const Pim01PimstatBadLengthMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBadLengthMessagesPerVifRsp :
      public Pim01PimstatBadLengthMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBadLengthMessagesPerVifRsp(const Pim01PimstatBadLengthMessagesPerVifRF& cb)
          : Pim01PimstatBadLengthMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatBadLengthMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bad_length_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatBadLengthMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bad_checksum_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBadChecksumMessagesPerVifRF;

    class Pim01PimstatBadChecksumMessagesPerVifCB {
        Pim01PimstatBadChecksumMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatBadChecksumMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatBadChecksumMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatBadChecksumMessagesPerVifCB(const Pim01PimstatBadChecksumMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBadChecksumMessagesPerVifRsp :
      public Pim01PimstatBadChecksumMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBadChecksumMessagesPerVifRsp(const Pim01PimstatBadChecksumMessagesPerVifRF& cb)
          : Pim01PimstatBadChecksumMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatBadChecksumMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bad_checksum_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatBadChecksumMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_bad_receive_interface_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatBadReceiveInterfaceMessagesPerVifRF;

    class Pim01PimstatBadReceiveInterfaceMessagesPerVifCB {
        Pim01PimstatBadReceiveInterfaceMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatBadReceiveInterfaceMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatBadReceiveInterfaceMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatBadReceiveInterfaceMessagesPerVifCB(const Pim01PimstatBadReceiveInterfaceMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatBadReceiveInterfaceMessagesPerVifRsp :
      public Pim01PimstatBadReceiveInterfaceMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatBadReceiveInterfaceMessagesPerVifRsp(const Pim01PimstatBadReceiveInterfaceMessagesPerVifRF& cb)
          : Pim01PimstatBadReceiveInterfaceMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatBadReceiveInterfaceMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_bad_receive_interface_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatBadReceiveInterfaceMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxInterfaceDisabledMessagesPerVifRF;

    class Pim01PimstatRxInterfaceDisabledMessagesPerVifCB {
        Pim01PimstatRxInterfaceDisabledMessagesPerVifRF cb;

    public:
        operator const Pim01PimstatRxInterfaceDisabledMessagesPerVifRF& () const { return cb; }
        const Pim01PimstatRxInterfaceDisabledMessagesPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxInterfaceDisabledMessagesPerVifCB(const Pim01PimstatRxInterfaceDisabledMessagesPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxInterfaceDisabledMessagesPerVifRsp :
      public Pim01PimstatRxInterfaceDisabledMessagesPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxInterfaceDisabledMessagesPerVifRsp(const Pim01PimstatRxInterfaceDisabledMessagesPerVifRF& cb)
          : Pim01PimstatRxInterfaceDisabledMessagesPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxInterfaceDisabledMessagesPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxInterfaceDisabledMessagesPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_register_not_rp_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxRegisterNotRpPerVifRF;

    class Pim01PimstatRxRegisterNotRpPerVifCB {
        Pim01PimstatRxRegisterNotRpPerVifRF cb;

    public:
        operator const Pim01PimstatRxRegisterNotRpPerVifRF& () const { return cb; }
        const Pim01PimstatRxRegisterNotRpPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxRegisterNotRpPerVifCB(const Pim01PimstatRxRegisterNotRpPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxRegisterNotRpPerVifRsp :
      public Pim01PimstatRxRegisterNotRpPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxRegisterNotRpPerVifRsp(const Pim01PimstatRxRegisterNotRpPerVifRF& cb)
          : Pim01PimstatRxRegisterNotRpPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxRegisterNotRpPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_register_not_rp_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxRegisterNotRpPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rp_filtered_source_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRpFilteredSourcePerVifRF;

    class Pim01PimstatRpFilteredSourcePerVifCB {
        Pim01PimstatRpFilteredSourcePerVifRF cb;

    public:
        operator const Pim01PimstatRpFilteredSourcePerVifRF& () const { return cb; }
        const Pim01PimstatRpFilteredSourcePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRpFilteredSourcePerVifCB(const Pim01PimstatRpFilteredSourcePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRpFilteredSourcePerVifRsp :
      public Pim01PimstatRpFilteredSourcePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRpFilteredSourcePerVifRsp(const Pim01PimstatRpFilteredSourcePerVifRF& cb)
          : Pim01PimstatRpFilteredSourcePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRpFilteredSourcePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rp_filtered_source_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRpFilteredSourcePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_unknown_register_stop_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatUnknownRegisterStopPerVifRF;

    class Pim01PimstatUnknownRegisterStopPerVifCB {
        Pim01PimstatUnknownRegisterStopPerVifRF cb;

    public:
        operator const Pim01PimstatUnknownRegisterStopPerVifRF& () const { return cb; }
        const Pim01PimstatUnknownRegisterStopPerVifRF& operator ->() const { return cb; }
        Pim01PimstatUnknownRegisterStopPerVifCB(const Pim01PimstatUnknownRegisterStopPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatUnknownRegisterStopPerVifRsp :
      public Pim01PimstatUnknownRegisterStopPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatUnknownRegisterStopPerVifRsp(const Pim01PimstatUnknownRegisterStopPerVifRF& cb)
          : Pim01PimstatUnknownRegisterStopPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatUnknownRegisterStopPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_unknown_register_stop_per_vif
       (
	const string&	vif_name,
	Pim01PimstatUnknownRegisterStopPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_prune_no_state_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinPruneNoStatePerVifRF;

    class Pim01PimstatRxJoinPruneNoStatePerVifCB {
        Pim01PimstatRxJoinPruneNoStatePerVifRF cb;

    public:
        operator const Pim01PimstatRxJoinPruneNoStatePerVifRF& () const { return cb; }
        const Pim01PimstatRxJoinPruneNoStatePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinPruneNoStatePerVifCB(const Pim01PimstatRxJoinPruneNoStatePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinPruneNoStatePerVifRsp :
      public Pim01PimstatRxJoinPruneNoStatePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinPruneNoStatePerVifRsp(const Pim01PimstatRxJoinPruneNoStatePerVifRF& cb)
          : Pim01PimstatRxJoinPruneNoStatePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinPruneNoStatePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_prune_no_state_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxJoinPruneNoStatePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxGraftGraftAckNoStatePerVifRF;

    class Pim01PimstatRxGraftGraftAckNoStatePerVifCB {
        Pim01PimstatRxGraftGraftAckNoStatePerVifRF cb;

    public:
        operator const Pim01PimstatRxGraftGraftAckNoStatePerVifRF& () const { return cb; }
        const Pim01PimstatRxGraftGraftAckNoStatePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxGraftGraftAckNoStatePerVifCB(const Pim01PimstatRxGraftGraftAckNoStatePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxGraftGraftAckNoStatePerVifRsp :
      public Pim01PimstatRxGraftGraftAckNoStatePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxGraftGraftAckNoStatePerVifRsp(const Pim01PimstatRxGraftGraftAckNoStatePerVifRF& cb)
          : Pim01PimstatRxGraftGraftAckNoStatePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxGraftGraftAckNoStatePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxGraftGraftAckNoStatePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF;

    class Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB {
        Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF cb;

    public:
        operator const Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF& () const { return cb; }
        const Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB(const Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxGraftOnUpstreamInterfacePerVifRsp :
      public Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxGraftOnUpstreamInterfacePerVifRsp(const Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF& cb)
          : Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxCandidateRpNotBsrPerVifRF;

    class Pim01PimstatRxCandidateRpNotBsrPerVifCB {
        Pim01PimstatRxCandidateRpNotBsrPerVifRF cb;

    public:
        operator const Pim01PimstatRxCandidateRpNotBsrPerVifRF& () const { return cb; }
        const Pim01PimstatRxCandidateRpNotBsrPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxCandidateRpNotBsrPerVifCB(const Pim01PimstatRxCandidateRpNotBsrPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxCandidateRpNotBsrPerVifRsp :
      public Pim01PimstatRxCandidateRpNotBsrPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxCandidateRpNotBsrPerVifRsp(const Pim01PimstatRxCandidateRpNotBsrPerVifRF& cb)
          : Pim01PimstatRxCandidateRpNotBsrPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxCandidateRpNotBsrPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxCandidateRpNotBsrPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxBsrWhenBsrPerVifRF;

    class Pim01PimstatRxBsrWhenBsrPerVifCB {
        Pim01PimstatRxBsrWhenBsrPerVifRF cb;

    public:
        operator const Pim01PimstatRxBsrWhenBsrPerVifRF& () const { return cb; }
        const Pim01PimstatRxBsrWhenBsrPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxBsrWhenBsrPerVifCB(const Pim01PimstatRxBsrWhenBsrPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxBsrWhenBsrPerVifRsp :
      public Pim01PimstatRxBsrWhenBsrPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxBsrWhenBsrPerVifRsp(const Pim01PimstatRxBsrWhenBsrPerVifRF& cb)
          : Pim01PimstatRxBsrWhenBsrPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxBsrWhenBsrPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxBsrWhenBsrPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxBsrNotRpfInterfacePerVifRF;

    class Pim01PimstatRxBsrNotRpfInterfacePerVifCB {
        Pim01PimstatRxBsrNotRpfInterfacePerVifRF cb;

    public:
        operator const Pim01PimstatRxBsrNotRpfInterfacePerVifRF& () const { return cb; }
        const Pim01PimstatRxBsrNotRpfInterfacePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxBsrNotRpfInterfacePerVifCB(const Pim01PimstatRxBsrNotRpfInterfacePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxBsrNotRpfInterfacePerVifRsp :
      public Pim01PimstatRxBsrNotRpfInterfacePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxBsrNotRpfInterfacePerVifRsp(const Pim01PimstatRxBsrNotRpfInterfacePerVifRF& cb)
          : Pim01PimstatRxBsrNotRpfInterfacePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxBsrNotRpfInterfacePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxBsrNotRpfInterfacePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_unknown_hello_option_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxUnknownHelloOptionPerVifRF;

    class Pim01PimstatRxUnknownHelloOptionPerVifCB {
        Pim01PimstatRxUnknownHelloOptionPerVifRF cb;

    public:
        operator const Pim01PimstatRxUnknownHelloOptionPerVifRF& () const { return cb; }
        const Pim01PimstatRxUnknownHelloOptionPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxUnknownHelloOptionPerVifCB(const Pim01PimstatRxUnknownHelloOptionPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxUnknownHelloOptionPerVifRsp :
      public Pim01PimstatRxUnknownHelloOptionPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxUnknownHelloOptionPerVifRsp(const Pim01PimstatRxUnknownHelloOptionPerVifRF& cb)
          : Pim01PimstatRxUnknownHelloOptionPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxUnknownHelloOptionPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_unknown_hello_option_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxUnknownHelloOptionPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_data_no_state_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxDataNoStatePerVifRF;

    class Pim01PimstatRxDataNoStatePerVifCB {
        Pim01PimstatRxDataNoStatePerVifRF cb;

    public:
        operator const Pim01PimstatRxDataNoStatePerVifRF& () const { return cb; }
        const Pim01PimstatRxDataNoStatePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxDataNoStatePerVifCB(const Pim01PimstatRxDataNoStatePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxDataNoStatePerVifRsp :
      public Pim01PimstatRxDataNoStatePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxDataNoStatePerVifRsp(const Pim01PimstatRxDataNoStatePerVifRF& cb)
          : Pim01PimstatRxDataNoStatePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxDataNoStatePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_data_no_state_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxDataNoStatePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_rp_no_state_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxRpNoStatePerVifRF;

    class Pim01PimstatRxRpNoStatePerVifCB {
        Pim01PimstatRxRpNoStatePerVifRF cb;

    public:
        operator const Pim01PimstatRxRpNoStatePerVifRF& () const { return cb; }
        const Pim01PimstatRxRpNoStatePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxRpNoStatePerVifCB(const Pim01PimstatRxRpNoStatePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxRpNoStatePerVifRsp :
      public Pim01PimstatRxRpNoStatePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxRpNoStatePerVifRsp(const Pim01PimstatRxRpNoStatePerVifRF& cb)
          : Pim01PimstatRxRpNoStatePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxRpNoStatePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_rp_no_state_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxRpNoStatePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_aggregate_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxAggregatePerVifRF;

    class Pim01PimstatRxAggregatePerVifCB {
        Pim01PimstatRxAggregatePerVifRF cb;

    public:
        operator const Pim01PimstatRxAggregatePerVifRF& () const { return cb; }
        const Pim01PimstatRxAggregatePerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxAggregatePerVifCB(const Pim01PimstatRxAggregatePerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxAggregatePerVifRsp :
      public Pim01PimstatRxAggregatePerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxAggregatePerVifRsp(const Pim01PimstatRxAggregatePerVifRF& cb)
          : Pim01PimstatRxAggregatePerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxAggregatePerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_aggregate_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxAggregatePerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_malformed_packet_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxMalformedPacketPerVifRF;

    class Pim01PimstatRxMalformedPacketPerVifCB {
        Pim01PimstatRxMalformedPacketPerVifRF cb;

    public:
        operator const Pim01PimstatRxMalformedPacketPerVifRF& () const { return cb; }
        const Pim01PimstatRxMalformedPacketPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxMalformedPacketPerVifCB(const Pim01PimstatRxMalformedPacketPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxMalformedPacketPerVifRsp :
      public Pim01PimstatRxMalformedPacketPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxMalformedPacketPerVifRsp(const Pim01PimstatRxMalformedPacketPerVifRF& cb)
          : Pim01PimstatRxMalformedPacketPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxMalformedPacketPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_malformed_packet_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxMalformedPacketPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_no_rp_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatNoRpPerVifRF;

    class Pim01PimstatNoRpPerVifCB {
        Pim01PimstatNoRpPerVifRF cb;

    public:
        operator const Pim01PimstatNoRpPerVifRF& () const { return cb; }
        const Pim01PimstatNoRpPerVifRF& operator ->() const { return cb; }
        Pim01PimstatNoRpPerVifCB(const Pim01PimstatNoRpPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatNoRpPerVifRsp :
      public Pim01PimstatNoRpPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNoRpPerVifRsp(const Pim01PimstatNoRpPerVifRF& cb)
          : Pim01PimstatNoRpPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatNoRpPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_no_rp_per_vif
       (
	const string&	vif_name,
	Pim01PimstatNoRpPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_no_route_upstream_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatNoRouteUpstreamPerVifRF;

    class Pim01PimstatNoRouteUpstreamPerVifCB {
        Pim01PimstatNoRouteUpstreamPerVifRF cb;

    public:
        operator const Pim01PimstatNoRouteUpstreamPerVifRF& () const { return cb; }
        const Pim01PimstatNoRouteUpstreamPerVifRF& operator ->() const { return cb; }
        Pim01PimstatNoRouteUpstreamPerVifCB(const Pim01PimstatNoRouteUpstreamPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatNoRouteUpstreamPerVifRsp :
      public Pim01PimstatNoRouteUpstreamPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatNoRouteUpstreamPerVifRsp(const Pim01PimstatNoRouteUpstreamPerVifRF& cb)
          : Pim01PimstatNoRouteUpstreamPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatNoRouteUpstreamPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_no_route_upstream_per_vif
       (
	const string&	vif_name,
	Pim01PimstatNoRouteUpstreamPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rp_mismatch_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRpMismatchPerVifRF;

    class Pim01PimstatRpMismatchPerVifCB {
        Pim01PimstatRpMismatchPerVifRF cb;

    public:
        operator const Pim01PimstatRpMismatchPerVifRF& () const { return cb; }
        const Pim01PimstatRpMismatchPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRpMismatchPerVifCB(const Pim01PimstatRpMismatchPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRpMismatchPerVifRsp :
      public Pim01PimstatRpMismatchPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRpMismatchPerVifRsp(const Pim01PimstatRpMismatchPerVifRF& cb)
          : Pim01PimstatRpMismatchPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRpMismatchPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rp_mismatch_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRpMismatchPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRpfNeighborUnknownPerVifRF;

    class Pim01PimstatRpfNeighborUnknownPerVifCB {
        Pim01PimstatRpfNeighborUnknownPerVifRF cb;

    public:
        operator const Pim01PimstatRpfNeighborUnknownPerVifRF& () const { return cb; }
        const Pim01PimstatRpfNeighborUnknownPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRpfNeighborUnknownPerVifCB(const Pim01PimstatRpfNeighborUnknownPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRpfNeighborUnknownPerVifRsp :
      public Pim01PimstatRpfNeighborUnknownPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRpfNeighborUnknownPerVifRsp(const Pim01PimstatRpfNeighborUnknownPerVifRF& cb)
          : Pim01PimstatRpfNeighborUnknownPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRpfNeighborUnknownPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRpfNeighborUnknownPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_rp_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinRpPerVifRF;

    class Pim01PimstatRxJoinRpPerVifCB {
        Pim01PimstatRxJoinRpPerVifRF cb;

    public:
        operator const Pim01PimstatRxJoinRpPerVifRF& () const { return cb; }
        const Pim01PimstatRxJoinRpPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinRpPerVifCB(const Pim01PimstatRxJoinRpPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinRpPerVifRsp :
      public Pim01PimstatRxJoinRpPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinRpPerVifRsp(const Pim01PimstatRxJoinRpPerVifRF& cb)
          : Pim01PimstatRxJoinRpPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinRpPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_rp_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxJoinRpPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_rp_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneRpPerVifRF;

    class Pim01PimstatRxPruneRpPerVifCB {
        Pim01PimstatRxPruneRpPerVifRF cb;

    public:
        operator const Pim01PimstatRxPruneRpPerVifRF& () const { return cb; }
        const Pim01PimstatRxPruneRpPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneRpPerVifCB(const Pim01PimstatRxPruneRpPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneRpPerVifRsp :
      public Pim01PimstatRxPruneRpPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneRpPerVifRsp(const Pim01PimstatRxPruneRpPerVifRF& cb)
          : Pim01PimstatRxPruneRpPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneRpPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_rp_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxPruneRpPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_wc_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinWcPerVifRF;

    class Pim01PimstatRxJoinWcPerVifCB {
        Pim01PimstatRxJoinWcPerVifRF cb;

    public:
        operator const Pim01PimstatRxJoinWcPerVifRF& () const { return cb; }
        const Pim01PimstatRxJoinWcPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinWcPerVifCB(const Pim01PimstatRxJoinWcPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinWcPerVifRsp :
      public Pim01PimstatRxJoinWcPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinWcPerVifRsp(const Pim01PimstatRxJoinWcPerVifRF& cb)
          : Pim01PimstatRxJoinWcPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinWcPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_wc_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxJoinWcPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_wc_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneWcPerVifRF;

    class Pim01PimstatRxPruneWcPerVifCB {
        Pim01PimstatRxPruneWcPerVifRF cb;

    public:
        operator const Pim01PimstatRxPruneWcPerVifRF& () const { return cb; }
        const Pim01PimstatRxPruneWcPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneWcPerVifCB(const Pim01PimstatRxPruneWcPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneWcPerVifRsp :
      public Pim01PimstatRxPruneWcPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneWcPerVifRsp(const Pim01PimstatRxPruneWcPerVifRF& cb)
          : Pim01PimstatRxPruneWcPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneWcPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_wc_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxPruneWcPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_sg_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinSgPerVifRF;

    class Pim01PimstatRxJoinSgPerVifCB {
        Pim01PimstatRxJoinSgPerVifRF cb;

    public:
        operator const Pim01PimstatRxJoinSgPerVifRF& () const { return cb; }
        const Pim01PimstatRxJoinSgPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinSgPerVifCB(const Pim01PimstatRxJoinSgPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinSgPerVifRsp :
      public Pim01PimstatRxJoinSgPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinSgPerVifRsp(const Pim01PimstatRxJoinSgPerVifRF& cb)
          : Pim01PimstatRxJoinSgPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinSgPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_sg_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxJoinSgPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_sg_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneSgPerVifRF;

    class Pim01PimstatRxPruneSgPerVifCB {
        Pim01PimstatRxPruneSgPerVifRF cb;

    public:
        operator const Pim01PimstatRxPruneSgPerVifRF& () const { return cb; }
        const Pim01PimstatRxPruneSgPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneSgPerVifCB(const Pim01PimstatRxPruneSgPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneSgPerVifRsp :
      public Pim01PimstatRxPruneSgPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneSgPerVifRsp(const Pim01PimstatRxPruneSgPerVifRF& cb)
          : Pim01PimstatRxPruneSgPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneSgPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_sg_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxPruneSgPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_join_sg_rpt_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxJoinSgRptPerVifRF;

    class Pim01PimstatRxJoinSgRptPerVifCB {
        Pim01PimstatRxJoinSgRptPerVifRF cb;

    public:
        operator const Pim01PimstatRxJoinSgRptPerVifRF& () const { return cb; }
        const Pim01PimstatRxJoinSgRptPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxJoinSgRptPerVifCB(const Pim01PimstatRxJoinSgRptPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxJoinSgRptPerVifRsp :
      public Pim01PimstatRxJoinSgRptPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxJoinSgRptPerVifRsp(const Pim01PimstatRxJoinSgRptPerVifRF& cb)
          : Pim01PimstatRxJoinSgRptPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxJoinSgRptPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_join_sg_rpt_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxJoinSgRptPerVifCB);
#endif

    virtual XrlCmdError pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(
	// Input values,
	const string&	vif_name,
	// Output values,
	uint32_t&	value) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Pim01PimstatRxPruneSgRptPerVifRF;

    class Pim01PimstatRxPruneSgRptPerVifCB {
        Pim01PimstatRxPruneSgRptPerVifRF cb;

    public:
        operator const Pim01PimstatRxPruneSgRptPerVifRF& () const { return cb; }
        const Pim01PimstatRxPruneSgRptPerVifRF& operator ->() const { return cb; }
        Pim01PimstatRxPruneSgRptPerVifCB(const Pim01PimstatRxPruneSgRptPerVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_value) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_value);
        }
    };

    struct Pim01PimstatRxPruneSgRptPerVifRsp :
      public Pim01PimstatRxPruneSgRptPerVifCB {
        struct args_str {
            uint32_t value;
        };

    private:
        args_str args;

    public:
        Pim01PimstatRxPruneSgRptPerVifRsp(const Pim01PimstatRxPruneSgRptPerVifRF& cb)
          : Pim01PimstatRxPruneSgRptPerVifCB(cb) { }

        void respond() const {
            Pim01PimstatRxPruneSgRptPerVifCB::
            respond(args.value);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif
       (
	const string&	vif_name,
	Pim01PimstatRxPruneSgRptPerVifCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_cli_processor_0_1_process_command(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_cli_processor_0_1_process_command
       (const XrlCmdError &e,
	const string* arg_ret_processor_name,
	const string* arg_ret_cli_term_name,
	const uint32_t* arg_ret_cli_session_id,
	const string* arg_ret_command_output,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_client_0_1_recv(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_client_0_1_recv
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_client_0_1_recv(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_client_0_1_recv
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_start_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_start_transaction
       (const XrlCmdError &e,
	const uint32_t* arg_tid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_commit_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_commit_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_abort_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_abort_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_add_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_add_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_delete_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_delete_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_delete_all_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_delete_all_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mfea_client_0_1_recv_kernel_signal_message4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mfea_client_0_1_recv_kernel_signal_message4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mfea_client_0_1_recv_dataflow_signal4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mfea_client_0_1_recv_dataflow_signal4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mfea_client_0_1_recv_kernel_signal_message6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mfea_client_0_1_recv_kernel_signal_message6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mfea_client_0_1_recv_dataflow_signal6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mfea_client_0_1_recv_dataflow_signal6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_start_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_start_transaction
       (const XrlCmdError &e,
	const uint32_t* arg_tid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_commit_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_commit_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_abort_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_abort_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_add_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_add_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_delete_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_delete_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_delete_all_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_delete_all_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mld6igmp_client_0_1_add_membership4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mld6igmp_client_0_1_add_membership4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mld6igmp_client_0_1_add_membership6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mld6igmp_client_0_1_add_membership6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mld6igmp_client_0_1_delete_membership4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mld6igmp_client_0_1_delete_membership4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_mld6igmp_client_0_1_delete_membership6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_mld6igmp_client_0_1_delete_membership6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_enable_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_enable_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_start_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_start_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_stop_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_stop_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_enable_all_vifs(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_enable_all_vifs
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_start_all_vifs(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_start_all_vifs
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_stop_all_vifs(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_stop_all_vifs
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_enable_pim(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_enable_pim
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_start_pim(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_start_pim
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_stop_pim(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_stop_pim
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_enable_cli(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_enable_cli
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_start_cli(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_start_cli
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_stop_cli(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_stop_cli
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_enable_bsr(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_enable_bsr
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_start_bsr(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_start_bsr
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_stop_bsr(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_stop_bsr
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_apply_bsr_changes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_apply_bsr_changes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_scope_zone_by_vif_name4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_scope_zone_by_vif_name4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_scope_zone_by_vif_name6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_scope_zone_by_vif_name6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_scope_zone_by_vif_addr6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_scope_zone_by_vif_addr6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_scope_zone_by_vif_name6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_scope_zone_by_vif_name6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_scope_zone_by_vif_addr6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_scope_zone_by_vif_addr6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_scope_zone_by_vif_addr4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_scope_zone_by_vif_addr4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_scope_zone_by_vif_name4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_scope_zone_by_vif_name4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_scope_zone_by_vif_addr4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_scope_zone_by_vif_addr4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_cand_bsr4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_cand_bsr4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_cand_bsr6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_cand_bsr6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_cand_bsr6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_cand_bsr6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_cand_bsr4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_cand_bsr4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_cand_rp4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_cand_rp4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_cand_rp6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_cand_rp6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_cand_rp6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_cand_rp6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_cand_rp4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_cand_rp4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_static_rp4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_static_rp4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_config_static_rp6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_config_static_rp6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_static_rp6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_static_rp6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_all_static_group_prefixes_rp6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_all_static_group_prefixes_rp6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_static_rp4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_static_rp4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_all_static_group_prefixes_rp4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_all_static_group_prefixes_rp4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_config_all_static_rps(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_config_all_static_rps
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_config_static_rp_done(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_config_static_rp_done
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_proto_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_proto_version
       (const XrlCmdError &e,
	const uint32_t* arg_proto_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_proto_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_proto_version
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_proto_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_proto_version
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_hello_triggered_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_hello_triggered_delay
       (const XrlCmdError &e,
	const uint32_t* arg_hello_triggered_delay,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_hello_triggered_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_hello_triggered_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_hello_triggered_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_hello_triggered_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_hello_period(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_hello_period
       (const XrlCmdError &e,
	const uint32_t* arg_hello_period,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_hello_period(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_hello_period
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_hello_period(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_hello_period
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_hello_holdtime(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_hello_holdtime
       (const XrlCmdError &e,
	const uint32_t* arg_hello_holdtime,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_hello_holdtime(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_hello_holdtime
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_hello_holdtime(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_hello_holdtime
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_dr_priority(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_dr_priority
       (const XrlCmdError &e,
	const uint32_t* arg_dr_priority,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_dr_priority(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_dr_priority
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_dr_priority(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_dr_priority
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_propagation_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_propagation_delay
       (const XrlCmdError &e,
	const uint32_t* arg_propagation_delay,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_propagation_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_propagation_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_propagation_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_propagation_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_override_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_override_interval
       (const XrlCmdError &e,
	const uint32_t* arg_override_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_override_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_override_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_override_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_override_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_is_tracking_support_disabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_is_tracking_support_disabled
       (const XrlCmdError &e,
	const bool* arg_is_tracking_support_disabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_is_tracking_support_disabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_is_tracking_support_disabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_is_tracking_support_disabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_is_tracking_support_disabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_accept_nohello_neighbors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_accept_nohello_neighbors
       (const XrlCmdError &e,
	const bool* arg_accept_nohello_neighbors,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_accept_nohello_neighbors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_accept_nohello_neighbors
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_accept_nohello_neighbors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_accept_nohello_neighbors
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_vif_join_prune_period(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_vif_join_prune_period
       (const XrlCmdError &e,
	const uint32_t* arg_join_prune_period,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_vif_join_prune_period(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_vif_join_prune_period
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_vif_join_prune_period(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_vif_join_prune_period
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_get_switch_to_spt_threshold(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_get_switch_to_spt_threshold
       (const XrlCmdError &e,
	const bool* arg_is_enabled,
	const uint32_t* arg_interval_sec,
	const uint32_t* arg_bytes,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_set_switch_to_spt_threshold(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_set_switch_to_spt_threshold
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_reset_switch_to_spt_threshold(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_reset_switch_to_spt_threshold
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_alternative_subnet4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_alternative_subnet4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_alternative_subnet6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_alternative_subnet6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_alternative_subnet6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_alternative_subnet6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_delete_alternative_subnet4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_delete_alternative_subnet4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_remove_all_alternative_subnets(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_remove_all_alternative_subnets
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_log_trace_all(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_log_trace_all
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_jp_entry4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_jp_entry4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_jp_entry6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_jp_entry6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_jp_entry6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_jp_entry6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_jp_entry4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_jp_entry4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_assert4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_assert4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_assert6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_assert6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_bsr_zone4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_bsr_zone4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_bsr_zone6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_bsr_zone6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_bsr_group_prefix6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_bsr_group_prefix6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_bsr_rp6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_bsr_rp6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_bootstrap_by_dest6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_bootstrap_by_dest6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_bsr_group_prefix4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_bsr_group_prefix4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_add_test_bsr_rp4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_add_test_bsr_rp4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_bootstrap(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_bootstrap
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_bootstrap_by_dest4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_bootstrap_by_dest4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_send_test_cand_rp_adv(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_send_test_cand_rp_adv
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_neighbors4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_neighbors4
       (const XrlCmdError &e,
	const uint32_t* arg_nbrs_number,
	const XrlAtomList* arg_vifs,
	const XrlAtomList* arg_addresses,
	const XrlAtomList* arg_pim_versions,
	const XrlAtomList* arg_dr_priorities,
	const XrlAtomList* arg_holdtimes,
	const XrlAtomList* arg_timeouts,
	const XrlAtomList* arg_uptimes,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_neighbors6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_neighbors6
       (const XrlCmdError &e,
	const uint32_t* arg_nbrs_number,
	const XrlAtomList* arg_vifs,
	const XrlAtomList* arg_addresses,
	const XrlAtomList* arg_pim_versions,
	const XrlAtomList* arg_dr_priorities,
	const XrlAtomList* arg_holdtimes,
	const XrlAtomList* arg_timeouts,
	const XrlAtomList* arg_uptimes,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_interface4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_interface4
       (const XrlCmdError &e,
	const uint32_t* arg_pim_version,
	const bool* arg_is_dr,
	const uint32_t* arg_dr_priority,
	const IPv4* arg_dr_address,
	const uint32_t* arg_pim_nbrs_number,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_interface6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_interface6
       (const XrlCmdError &e,
	const uint32_t* arg_pim_version,
	const bool* arg_is_dr,
	const uint32_t* arg_dr_priority,
	const IPv6* arg_dr_address,
	const uint32_t* arg_pim_nbrs_number,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rps4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rps4
       (const XrlCmdError &e,
	const uint32_t* arg_rps_number,
	const XrlAtomList* arg_addresses,
	const XrlAtomList* arg_types,
	const XrlAtomList* arg_priorities,
	const XrlAtomList* arg_holdtimes,
	const XrlAtomList* arg_timeouts,
	const XrlAtomList* arg_group_prefixes,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rps6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rps6
       (const XrlCmdError &e,
	const uint32_t* arg_rps_number,
	const XrlAtomList* arg_addresses,
	const XrlAtomList* arg_types,
	const XrlAtomList* arg_priorities,
	const XrlAtomList* arg_holdtimes,
	const XrlAtomList* arg_timeouts,
	const XrlAtomList* arg_group_prefixes,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_clear_pim_statistics(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_clear_pim_statistics
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_clear_pim_statistics_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_clear_pim_statistics_per_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_hello_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_hello_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_hello_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_hello_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_hello_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_hello_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_stop_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_stop_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_stop_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_stop_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_stop_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_stop_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_join_prune_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_join_prune_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_join_prune_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_join_prune_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_join_prune_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_join_prune_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bootstrap_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bootstrap_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bootstrap_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bootstrap_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bootstrap_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bootstrap_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_assert_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_assert_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_assert_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_assert_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_assert_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_assert_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_ack_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_ack_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_ack_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_ack_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_ack_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_ack_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_candidate_rp_messages_received(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_candidate_rp_messages_received
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_candidate_rp_messages_sent(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_candidate_rp_messages_sent
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_candidate_rp_messages_rx_errors(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_candidate_rp_messages_rx_errors
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_unknown_type_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_unknown_type_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_unknown_version_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_unknown_version_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_neighbor_unknown_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_neighbor_unknown_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bad_length_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bad_length_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bad_checksum_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bad_checksum_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bad_receive_interface_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bad_receive_interface_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_interface_disabled_messages(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_interface_disabled_messages
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_register_not_rp(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_register_not_rp
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rp_filtered_source(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rp_filtered_source
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_unknown_register_stop(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_unknown_register_stop
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_prune_no_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_prune_no_state
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_graft_graft_ack_no_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_graft_graft_ack_no_state
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_graft_on_upstream_interface(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_graft_on_upstream_interface
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_candidate_rp_not_bsr(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_candidate_rp_not_bsr
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_bsr_when_bsr(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_bsr_when_bsr
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_bsr_not_rpf_interface(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_bsr_not_rpf_interface
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_unknown_hello_option(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_unknown_hello_option
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_data_no_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_data_no_state
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_rp_no_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_rp_no_state
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_aggregate(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_aggregate
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_malformed_packet(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_malformed_packet
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_no_rp(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_no_rp
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_no_route_upstream(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_no_route_upstream
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rp_mismatch(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rp_mismatch
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rpf_neighbor_unknown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rpf_neighbor_unknown
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_rp(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_rp
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_rp(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_rp
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_wc(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_wc
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_wc(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_wc
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_sg(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_sg
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_sg(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_sg
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_sg_rpt(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_sg_rpt
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_sg_rpt(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_sg_rpt
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_hello_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_hello_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_hello_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_hello_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_hello_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_hello_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_stop_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_stop_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_stop_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_stop_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_join_prune_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_join_prune_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_join_prune_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_join_prune_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bootstrap_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bootstrap_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bootstrap_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bootstrap_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_assert_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_assert_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_assert_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_assert_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_assert_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_assert_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_ack_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_ack_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_ack_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_ack_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_candidate_rp_messages_received_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_candidate_rp_messages_received_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_unknown_type_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_unknown_type_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_unknown_version_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_unknown_version_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_neighbor_unknown_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_neighbor_unknown_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bad_length_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bad_length_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bad_checksum_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bad_checksum_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_bad_receive_interface_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_bad_receive_interface_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_register_not_rp_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_register_not_rp_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rp_filtered_source_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rp_filtered_source_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_unknown_register_stop_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_unknown_register_stop_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_prune_no_state_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_prune_no_state_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_unknown_hello_option_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_unknown_hello_option_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_data_no_state_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_data_no_state_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_rp_no_state_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_rp_no_state_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_aggregate_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_aggregate_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_malformed_packet_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_malformed_packet_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_no_rp_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_no_rp_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_no_route_upstream_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_no_route_upstream_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rp_mismatch_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rp_mismatch_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_rp_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_rp_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_rp_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_rp_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_wc_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_wc_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_wc_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_wc_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_sg_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_sg_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_sg_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_sg_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_join_sg_rpt_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_join_sg_rpt_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    XrlCmdRT handle_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif
       (const XrlCmdError &e,
	const uint32_t* arg_value,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlPimTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_PIM_BASE_HH__
