/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/rip_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_RIP_BASE_HH__
#define __XRL_TARGETS_RIP_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlRipTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlRipTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlRipTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlRipTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "rip/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv4 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist4_0_1_add_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401AddRoute4RF;

    class PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4RF cb;

    public:
        operator const PolicyRedist401AddRoute4RF& () const { return cb; }
        const PolicyRedist401AddRoute4RF& operator ->() const { return cb; }
        PolicyRedist401AddRoute4CB(const PolicyRedist401AddRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401AddRoute4Rsp :
      public PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4Rsp(const PolicyRedist401AddRoute4RF& cb)
          : PolicyRedist401AddRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_add_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist401AddRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv4 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist4_0_1_delete_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401DeleteRoute4RF;

    class PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4RF cb;

    public:
        operator const PolicyRedist401DeleteRoute4RF& () const { return cb; }
        const PolicyRedist401DeleteRoute4RF& operator ->() const { return cb; }
        PolicyRedist401DeleteRoute4CB(const PolicyRedist401DeleteRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401DeleteRoute4Rsp :
      public PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4Rsp(const PolicyRedist401DeleteRoute4RF& cb)
          : PolicyRedist401DeleteRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_delete_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist401DeleteRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add an address to run RIP process on. The addition of address is not
     *  instantaneous, RIP has to instantiate state in the FEA to send and
     *  receive packets. Once instantiated the address must be explicitly
     *  enabled with set_rip_address_enabled.
     *
     *  @param ifname the interface that owns vif that has address.
     *
     *  @param vifname virtual interface owning address.
     *
     *  @param addr the address to be added.
     */
    virtual XrlCmdError rip_0_1_add_rip_address(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01AddRipAddressRF;

    class Rip01AddRipAddressCB {
        Rip01AddRipAddressRF cb;

    public:
        operator const Rip01AddRipAddressRF& () const { return cb; }
        const Rip01AddRipAddressRF& operator ->() const { return cb; }
        Rip01AddRipAddressCB(const Rip01AddRipAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01AddRipAddressRsp :
      public Rip01AddRipAddressCB {
        Rip01AddRipAddressRsp(const Rip01AddRipAddressRF& cb)
          : Rip01AddRipAddressCB(cb) { }

    };

    virtual void async_rip_0_1_add_rip_address
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01AddRipAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Remove an address RIP process is running on.
     *
     *  @param ifname the interface that owns vif that has address.
     *
     *  @param vifname virtual interface owning address.
     *
     *  @param addr the address to be removed.
     */
    virtual XrlCmdError rip_0_1_remove_rip_address(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01RemoveRipAddressRF;

    class Rip01RemoveRipAddressCB {
        Rip01RemoveRipAddressRF cb;

    public:
        operator const Rip01RemoveRipAddressRF& () const { return cb; }
        const Rip01RemoveRipAddressRF& operator ->() const { return cb; }
        Rip01RemoveRipAddressCB(const Rip01RemoveRipAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01RemoveRipAddressRsp :
      public Rip01RemoveRipAddressCB {
        Rip01RemoveRipAddressRsp(const Rip01RemoveRipAddressRF& cb)
          : Rip01RemoveRipAddressCB(cb) { }

    };

    virtual void async_rip_0_1_remove_rip_address
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01RemoveRipAddressCB);
#endif

    virtual XrlCmdError rip_0_1_set_rip_address_enabled(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetRipAddressEnabledRF;

    class Rip01SetRipAddressEnabledCB {
        Rip01SetRipAddressEnabledRF cb;

    public:
        operator const Rip01SetRipAddressEnabledRF& () const { return cb; }
        const Rip01SetRipAddressEnabledRF& operator ->() const { return cb; }
        Rip01SetRipAddressEnabledCB(const Rip01SetRipAddressEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetRipAddressEnabledRsp :
      public Rip01SetRipAddressEnabledCB {
        Rip01SetRipAddressEnabledRsp(const Rip01SetRipAddressEnabledRF& cb)
          : Rip01SetRipAddressEnabledCB(cb) { }

    };

    virtual void async_rip_0_1_set_rip_address_enabled
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	enabled,
	Rip01SetRipAddressEnabledCB);
#endif

    virtual XrlCmdError rip_0_1_rip_address_enabled(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Rip01RipAddressEnabledRF;

    class Rip01RipAddressEnabledCB {
        Rip01RipAddressEnabledRF cb;

    public:
        operator const Rip01RipAddressEnabledRF& () const { return cb; }
        const Rip01RipAddressEnabledRF& operator ->() const { return cb; }
        Rip01RipAddressEnabledCB(const Rip01RipAddressEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Rip01RipAddressEnabledRsp :
      public Rip01RipAddressEnabledCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Rip01RipAddressEnabledRsp(const Rip01RipAddressEnabledRF& cb)
          : Rip01RipAddressEnabledCB(cb) { }

        void respond() const {
            Rip01RipAddressEnabledCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_rip_address_enabled
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01RipAddressEnabledCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set cost metric associated with address.
     */
    virtual XrlCmdError rip_0_1_set_cost(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetCostRF;

    class Rip01SetCostCB {
        Rip01SetCostRF cb;

    public:
        operator const Rip01SetCostRF& () const { return cb; }
        const Rip01SetCostRF& operator ->() const { return cb; }
        Rip01SetCostCB(const Rip01SetCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetCostRsp :
      public Rip01SetCostCB {
        Rip01SetCostRsp(const Rip01SetCostRF& cb)
          : Rip01SetCostCB(cb) { }

    };

    virtual void async_rip_0_1_set_cost
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	cost,
	Rip01SetCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get cost metric associated with address.
     */
    virtual XrlCmdError rip_0_1_cost(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01CostRF;

    class Rip01CostCB {
        Rip01CostRF cb;

    public:
        operator const Rip01CostRF& () const { return cb; }
        const Rip01CostRF& operator ->() const { return cb; }
        Rip01CostCB(const Rip01CostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_cost) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_cost);
        }
    };

    struct Rip01CostRsp :
      public Rip01CostCB {
        struct args_str {
            uint32_t cost;
        };

    private:
        args_str args;

    public:
        Rip01CostRsp(const Rip01CostRF& cb)
          : Rip01CostCB(cb) { }

        void respond() const {
            Rip01CostCB::
            respond(args.cost);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_cost
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01CostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set horizon type applied to routes advertised from address.
     *
     *  @param horizon name of horizon type. Permitted values: "none",
     *  "poison-reverse" "split-horizon-poison-reverse"
     */
    virtual XrlCmdError rip_0_1_set_horizon(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const string&	horizon) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetHorizonRF;

    class Rip01SetHorizonCB {
        Rip01SetHorizonRF cb;

    public:
        operator const Rip01SetHorizonRF& () const { return cb; }
        const Rip01SetHorizonRF& operator ->() const { return cb; }
        Rip01SetHorizonCB(const Rip01SetHorizonRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetHorizonRsp :
      public Rip01SetHorizonCB {
        Rip01SetHorizonRsp(const Rip01SetHorizonRF& cb)
          : Rip01SetHorizonCB(cb) { }

    };

    virtual void async_rip_0_1_set_horizon
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const string&	horizon,
	Rip01SetHorizonCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get horizon type applied to routes advertised from address.
     */
    virtual XrlCmdError rip_0_1_horizon(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	string&	horizon) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Rip01HorizonRF;

    class Rip01HorizonCB {
        Rip01HorizonRF cb;

    public:
        operator const Rip01HorizonRF& () const { return cb; }
        const Rip01HorizonRF& operator ->() const { return cb; }
        Rip01HorizonCB(const Rip01HorizonRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_horizon) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_horizon);
        }
    };

    struct Rip01HorizonRsp :
      public Rip01HorizonCB {
        struct args_str {
            string horizon;
        };

    private:
        args_str args;

    public:
        Rip01HorizonRsp(const Rip01HorizonRF& cb)
          : Rip01HorizonCB(cb) { }

        void respond() const {
            Rip01HorizonCB::
            respond(args.horizon);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_horizon
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01HorizonCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Make RIP passive (receive only) on interface/vif/address.
     */
    virtual XrlCmdError rip_0_1_set_passive(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	passive) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetPassiveRF;

    class Rip01SetPassiveCB {
        Rip01SetPassiveRF cb;

    public:
        operator const Rip01SetPassiveRF& () const { return cb; }
        const Rip01SetPassiveRF& operator ->() const { return cb; }
        Rip01SetPassiveCB(const Rip01SetPassiveRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetPassiveRsp :
      public Rip01SetPassiveCB {
        Rip01SetPassiveRsp(const Rip01SetPassiveRF& cb)
          : Rip01SetPassiveCB(cb) { }

    };

    virtual void async_rip_0_1_set_passive
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	passive,
	Rip01SetPassiveCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get value indicating whether RIP is passive (receive only) on
     *  interface/vif/address.
     */
    virtual XrlCmdError rip_0_1_passive(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	bool&	passive) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Rip01PassiveRF;

    class Rip01PassiveCB {
        Rip01PassiveRF cb;

    public:
        operator const Rip01PassiveRF& () const { return cb; }
        const Rip01PassiveRF& operator ->() const { return cb; }
        Rip01PassiveCB(const Rip01PassiveRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_passive) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_passive);
        }
    };

    struct Rip01PassiveRsp :
      public Rip01PassiveCB {
        struct args_str {
            bool passive;
        };

    private:
        args_str args;

    public:
        Rip01PassiveRsp(const Rip01PassiveRF& cb)
          : Rip01PassiveCB(cb) { }

        void respond() const {
            Rip01PassiveCB::
            respond(args.passive);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_passive
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01PassiveCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accept and respond to non-RIP requests.
     */
    virtual XrlCmdError rip_0_1_set_accept_non_rip_requests(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetAcceptNonRipRequestsRF;

    class Rip01SetAcceptNonRipRequestsCB {
        Rip01SetAcceptNonRipRequestsRF cb;

    public:
        operator const Rip01SetAcceptNonRipRequestsRF& () const { return cb; }
        const Rip01SetAcceptNonRipRequestsRF& operator ->() const { return cb; }
        Rip01SetAcceptNonRipRequestsCB(const Rip01SetAcceptNonRipRequestsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetAcceptNonRipRequestsRsp :
      public Rip01SetAcceptNonRipRequestsCB {
        Rip01SetAcceptNonRipRequestsRsp(const Rip01SetAcceptNonRipRequestsRF& cb)
          : Rip01SetAcceptNonRipRequestsCB(cb) { }

    };

    virtual void async_rip_0_1_set_accept_non_rip_requests
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	accept,
	Rip01SetAcceptNonRipRequestsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get value indicating whether non-RIP requests are accepted and
     *  responded to on interface/vif/address.
     */
    virtual XrlCmdError rip_0_1_accept_non_rip_requests(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Rip01AcceptNonRipRequestsRF;

    class Rip01AcceptNonRipRequestsCB {
        Rip01AcceptNonRipRequestsRF cb;

    public:
        operator const Rip01AcceptNonRipRequestsRF& () const { return cb; }
        const Rip01AcceptNonRipRequestsRF& operator ->() const { return cb; }
        Rip01AcceptNonRipRequestsCB(const Rip01AcceptNonRipRequestsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Rip01AcceptNonRipRequestsRsp :
      public Rip01AcceptNonRipRequestsCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Rip01AcceptNonRipRequestsRsp(const Rip01AcceptNonRipRequestsRF& cb)
          : Rip01AcceptNonRipRequestsCB(cb) { }

        void respond() const {
            Rip01AcceptNonRipRequestsCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_accept_non_rip_requests
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01AcceptNonRipRequestsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accept default route from peers.
     */
    virtual XrlCmdError rip_0_1_set_accept_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetAcceptDefaultRouteRF;

    class Rip01SetAcceptDefaultRouteCB {
        Rip01SetAcceptDefaultRouteRF cb;

    public:
        operator const Rip01SetAcceptDefaultRouteRF& () const { return cb; }
        const Rip01SetAcceptDefaultRouteRF& operator ->() const { return cb; }
        Rip01SetAcceptDefaultRouteCB(const Rip01SetAcceptDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetAcceptDefaultRouteRsp :
      public Rip01SetAcceptDefaultRouteCB {
        Rip01SetAcceptDefaultRouteRsp(const Rip01SetAcceptDefaultRouteRF& cb)
          : Rip01SetAcceptDefaultRouteCB(cb) { }

    };

    virtual void async_rip_0_1_set_accept_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	accept,
	Rip01SetAcceptDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accessor for whether default route is accepted from peers.
     */
    virtual XrlCmdError rip_0_1_accept_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Rip01AcceptDefaultRouteRF;

    class Rip01AcceptDefaultRouteCB {
        Rip01AcceptDefaultRouteRF cb;

    public:
        operator const Rip01AcceptDefaultRouteRF& () const { return cb; }
        const Rip01AcceptDefaultRouteRF& operator ->() const { return cb; }
        Rip01AcceptDefaultRouteCB(const Rip01AcceptDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Rip01AcceptDefaultRouteRsp :
      public Rip01AcceptDefaultRouteCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Rip01AcceptDefaultRouteRsp(const Rip01AcceptDefaultRouteRF& cb)
          : Rip01AcceptDefaultRouteCB(cb) { }

        void respond() const {
            Rip01AcceptDefaultRouteCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_accept_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01AcceptDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Advertise default route (if present).
     */
    virtual XrlCmdError rip_0_1_set_advertise_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	advertise) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetAdvertiseDefaultRouteRF;

    class Rip01SetAdvertiseDefaultRouteCB {
        Rip01SetAdvertiseDefaultRouteRF cb;

    public:
        operator const Rip01SetAdvertiseDefaultRouteRF& () const { return cb; }
        const Rip01SetAdvertiseDefaultRouteRF& operator ->() const { return cb; }
        Rip01SetAdvertiseDefaultRouteCB(const Rip01SetAdvertiseDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetAdvertiseDefaultRouteRsp :
      public Rip01SetAdvertiseDefaultRouteCB {
        Rip01SetAdvertiseDefaultRouteRsp(const Rip01SetAdvertiseDefaultRouteRF& cb)
          : Rip01SetAdvertiseDefaultRouteCB(cb) { }

    };

    virtual void async_rip_0_1_set_advertise_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const bool&	advertise,
	Rip01SetAdvertiseDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accessor for whether default route is advertised.
     */
    virtual XrlCmdError rip_0_1_advertise_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	bool&	advertise) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Rip01AdvertiseDefaultRouteRF;

    class Rip01AdvertiseDefaultRouteCB {
        Rip01AdvertiseDefaultRouteRF cb;

    public:
        operator const Rip01AdvertiseDefaultRouteRF& () const { return cb; }
        const Rip01AdvertiseDefaultRouteRF& operator ->() const { return cb; }
        Rip01AdvertiseDefaultRouteCB(const Rip01AdvertiseDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_advertise) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_advertise);
        }
    };

    struct Rip01AdvertiseDefaultRouteRsp :
      public Rip01AdvertiseDefaultRouteCB {
        struct args_str {
            bool advertise;
        };

    private:
        args_str args;

    public:
        Rip01AdvertiseDefaultRouteRsp(const Rip01AdvertiseDefaultRouteRF& cb)
          : Rip01AdvertiseDefaultRouteCB(cb) { }

        void respond() const {
            Rip01AdvertiseDefaultRouteCB::
            respond(args.advertise);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_advertise_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01AdvertiseDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that routes associated with reception address will expire in
     *  the absence of updates.
     */
    virtual XrlCmdError rip_0_1_set_route_timeout(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetRouteTimeoutRF;

    class Rip01SetRouteTimeoutCB {
        Rip01SetRouteTimeoutRF cb;

    public:
        operator const Rip01SetRouteTimeoutRF& () const { return cb; }
        const Rip01SetRouteTimeoutRF& operator ->() const { return cb; }
        Rip01SetRouteTimeoutCB(const Rip01SetRouteTimeoutRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetRouteTimeoutRsp :
      public Rip01SetRouteTimeoutCB {
        Rip01SetRouteTimeoutRsp(const Rip01SetRouteTimeoutRF& cb)
          : Rip01SetRouteTimeoutCB(cb) { }

    };

    virtual void async_rip_0_1_set_route_timeout
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs,
	Rip01SetRouteTimeoutCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period that routes associated with reception address will expire in
     *  the absence of updates.
     */
    virtual XrlCmdError rip_0_1_route_timeout(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01RouteTimeoutRF;

    class Rip01RouteTimeoutCB {
        Rip01RouteTimeoutRF cb;

    public:
        operator const Rip01RouteTimeoutRF& () const { return cb; }
        const Rip01RouteTimeoutRF& operator ->() const { return cb; }
        Rip01RouteTimeoutCB(const Rip01RouteTimeoutRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Rip01RouteTimeoutRsp :
      public Rip01RouteTimeoutCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Rip01RouteTimeoutRsp(const Rip01RouteTimeoutRF& cb)
          : Rip01RouteTimeoutCB(cb) { }

        void respond() const {
            Rip01RouteTimeoutCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_route_timeout
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01RouteTimeoutCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that routes associated with reception address will be
     *  deleted after they've expired.
     */
    virtual XrlCmdError rip_0_1_set_deletion_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetDeletionDelayRF;

    class Rip01SetDeletionDelayCB {
        Rip01SetDeletionDelayRF cb;

    public:
        operator const Rip01SetDeletionDelayRF& () const { return cb; }
        const Rip01SetDeletionDelayRF& operator ->() const { return cb; }
        Rip01SetDeletionDelayCB(const Rip01SetDeletionDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetDeletionDelayRsp :
      public Rip01SetDeletionDelayCB {
        Rip01SetDeletionDelayRsp(const Rip01SetDeletionDelayRF& cb)
          : Rip01SetDeletionDelayCB(cb) { }

    };

    virtual void async_rip_0_1_set_deletion_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs,
	Rip01SetDeletionDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period that routes associated with reception address will be
     *  deleted after they've expired.
     */
    virtual XrlCmdError rip_0_1_deletion_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01DeletionDelayRF;

    class Rip01DeletionDelayCB {
        Rip01DeletionDelayRF cb;

    public:
        operator const Rip01DeletionDelayRF& () const { return cb; }
        const Rip01DeletionDelayRF& operator ->() const { return cb; }
        Rip01DeletionDelayCB(const Rip01DeletionDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Rip01DeletionDelayRsp :
      public Rip01DeletionDelayCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Rip01DeletionDelayRsp(const Rip01DeletionDelayRF& cb)
          : Rip01DeletionDelayCB(cb) { }

        void respond() const {
            Rip01DeletionDelayCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_deletion_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01DeletionDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that route table requests should be sent from address when
     *  no peers are associated with it.
     */
    virtual XrlCmdError rip_0_1_set_request_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetRequestIntervalRF;

    class Rip01SetRequestIntervalCB {
        Rip01SetRequestIntervalRF cb;

    public:
        operator const Rip01SetRequestIntervalRF& () const { return cb; }
        const Rip01SetRequestIntervalRF& operator ->() const { return cb; }
        Rip01SetRequestIntervalCB(const Rip01SetRequestIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetRequestIntervalRsp :
      public Rip01SetRequestIntervalCB {
        Rip01SetRequestIntervalRsp(const Rip01SetRequestIntervalRF& cb)
          : Rip01SetRequestIntervalCB(cb) { }

    };

    virtual void async_rip_0_1_set_request_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs,
	Rip01SetRequestIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that route table requests should be sent from address when
     *  no peers are associated with it.
     */
    virtual XrlCmdError rip_0_1_request_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01RequestIntervalRF;

    class Rip01RequestIntervalCB {
        Rip01RequestIntervalRF cb;

    public:
        operator const Rip01RequestIntervalRF& () const { return cb; }
        const Rip01RequestIntervalRF& operator ->() const { return cb; }
        Rip01RequestIntervalCB(const Rip01RequestIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Rip01RequestIntervalRsp :
      public Rip01RequestIntervalCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Rip01RequestIntervalRsp(const Rip01RequestIntervalRF& cb)
          : Rip01RequestIntervalCB(cb) { }

        void respond() const {
            Rip01RequestIntervalCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_request_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01RequestIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period between the unsolicited sending of the routing table from
     *  address.
     */
    virtual XrlCmdError rip_0_1_set_update_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetUpdateIntervalRF;

    class Rip01SetUpdateIntervalCB {
        Rip01SetUpdateIntervalRF cb;

    public:
        operator const Rip01SetUpdateIntervalRF& () const { return cb; }
        const Rip01SetUpdateIntervalRF& operator ->() const { return cb; }
        Rip01SetUpdateIntervalCB(const Rip01SetUpdateIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetUpdateIntervalRsp :
      public Rip01SetUpdateIntervalCB {
        Rip01SetUpdateIntervalRsp(const Rip01SetUpdateIntervalRF& cb)
          : Rip01SetUpdateIntervalCB(cb) { }

    };

    virtual void async_rip_0_1_set_update_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs,
	Rip01SetUpdateIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period between the unsolicited sending of the routing table from
     *  address.
     */
    virtual XrlCmdError rip_0_1_update_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01UpdateIntervalRF;

    class Rip01UpdateIntervalCB {
        Rip01UpdateIntervalRF cb;

    public:
        operator const Rip01UpdateIntervalRF& () const { return cb; }
        const Rip01UpdateIntervalRF& operator ->() const { return cb; }
        Rip01UpdateIntervalCB(const Rip01UpdateIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Rip01UpdateIntervalRsp :
      public Rip01UpdateIntervalCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Rip01UpdateIntervalRsp(const Rip01UpdateIntervalRF& cb)
          : Rip01UpdateIntervalCB(cb) { }

        void respond() const {
            Rip01UpdateIntervalCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_update_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01UpdateIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set jitter between the unsolicited sending of the routing table from
     *  address (in percents of the period).
     */
    virtual XrlCmdError rip_0_1_set_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetUpdateJitterRF;

    class Rip01SetUpdateJitterCB {
        Rip01SetUpdateJitterRF cb;

    public:
        operator const Rip01SetUpdateJitterRF& () const { return cb; }
        const Rip01SetUpdateJitterRF& operator ->() const { return cb; }
        Rip01SetUpdateJitterCB(const Rip01SetUpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetUpdateJitterRsp :
      public Rip01SetUpdateJitterCB {
        Rip01SetUpdateJitterRsp(const Rip01SetUpdateJitterRF& cb)
          : Rip01SetUpdateJitterCB(cb) { }

    };

    virtual void async_rip_0_1_set_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_jitter,
	Rip01SetUpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get jitter between the unsolicited sending of the routing table from
     *  address (in percents of the period).
     */
    virtual XrlCmdError rip_0_1_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01UpdateJitterRF;

    class Rip01UpdateJitterCB {
        Rip01UpdateJitterRF cb;

    public:
        operator const Rip01UpdateJitterRF& () const { return cb; }
        const Rip01UpdateJitterRF& operator ->() const { return cb; }
        Rip01UpdateJitterCB(const Rip01UpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_jitter) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_jitter);
        }
    };

    struct Rip01UpdateJitterRsp :
      public Rip01UpdateJitterCB {
        struct args_str {
            uint32_t t_jitter;
        };

    private:
        args_str args;

    public:
        Rip01UpdateJitterRsp(const Rip01UpdateJitterRF& cb)
          : Rip01UpdateJitterCB(cb) { }

        void respond() const {
            Rip01UpdateJitterCB::
            respond(args.t_jitter);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01UpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period between sending triggered updates from address.
     */
    virtual XrlCmdError rip_0_1_set_triggered_update_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetTriggeredUpdateDelayRF;

    class Rip01SetTriggeredUpdateDelayCB {
        Rip01SetTriggeredUpdateDelayRF cb;

    public:
        operator const Rip01SetTriggeredUpdateDelayRF& () const { return cb; }
        const Rip01SetTriggeredUpdateDelayRF& operator ->() const { return cb; }
        Rip01SetTriggeredUpdateDelayCB(const Rip01SetTriggeredUpdateDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetTriggeredUpdateDelayRsp :
      public Rip01SetTriggeredUpdateDelayCB {
        Rip01SetTriggeredUpdateDelayRsp(const Rip01SetTriggeredUpdateDelayRF& cb)
          : Rip01SetTriggeredUpdateDelayCB(cb) { }

    };

    virtual void async_rip_0_1_set_triggered_update_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_secs,
	Rip01SetTriggeredUpdateDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period between sending triggered updates from address.
     */
    virtual XrlCmdError rip_0_1_triggered_update_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01TriggeredUpdateDelayRF;

    class Rip01TriggeredUpdateDelayCB {
        Rip01TriggeredUpdateDelayRF cb;

    public:
        operator const Rip01TriggeredUpdateDelayRF& () const { return cb; }
        const Rip01TriggeredUpdateDelayRF& operator ->() const { return cb; }
        Rip01TriggeredUpdateDelayCB(const Rip01TriggeredUpdateDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Rip01TriggeredUpdateDelayRsp :
      public Rip01TriggeredUpdateDelayCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Rip01TriggeredUpdateDelayRsp(const Rip01TriggeredUpdateDelayRF& cb)
          : Rip01TriggeredUpdateDelayCB(cb) { }

        void respond() const {
            Rip01TriggeredUpdateDelayCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_triggered_update_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01TriggeredUpdateDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set jitter between sending triggered updates from address (in percents
     *  of the period).
     */
    virtual XrlCmdError rip_0_1_set_triggered_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetTriggeredUpdateJitterRF;

    class Rip01SetTriggeredUpdateJitterCB {
        Rip01SetTriggeredUpdateJitterRF cb;

    public:
        operator const Rip01SetTriggeredUpdateJitterRF& () const { return cb; }
        const Rip01SetTriggeredUpdateJitterRF& operator ->() const { return cb; }
        Rip01SetTriggeredUpdateJitterCB(const Rip01SetTriggeredUpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetTriggeredUpdateJitterRsp :
      public Rip01SetTriggeredUpdateJitterCB {
        Rip01SetTriggeredUpdateJitterRsp(const Rip01SetTriggeredUpdateJitterRF& cb)
          : Rip01SetTriggeredUpdateJitterCB(cb) { }

    };

    virtual void async_rip_0_1_set_triggered_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_jitter,
	Rip01SetTriggeredUpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get jitter between sending triggered updates from address (in percents
     *  of the period).
     */
    virtual XrlCmdError rip_0_1_triggered_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01TriggeredUpdateJitterRF;

    class Rip01TriggeredUpdateJitterCB {
        Rip01TriggeredUpdateJitterRF cb;

    public:
        operator const Rip01TriggeredUpdateJitterRF& () const { return cb; }
        const Rip01TriggeredUpdateJitterRF& operator ->() const { return cb; }
        Rip01TriggeredUpdateJitterCB(const Rip01TriggeredUpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_jitter) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_jitter);
        }
    };

    struct Rip01TriggeredUpdateJitterRsp :
      public Rip01TriggeredUpdateJitterCB {
        struct args_str {
            uint32_t t_jitter;
        };

    private:
        args_str args;

    public:
        Rip01TriggeredUpdateJitterRsp(const Rip01TriggeredUpdateJitterRF& cb)
          : Rip01TriggeredUpdateJitterCB(cb) { }

        void respond() const {
            Rip01TriggeredUpdateJitterCB::
            respond(args.t_jitter);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_triggered_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01TriggeredUpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the inter-packet delay between the output of packets from address.
     */
    virtual XrlCmdError rip_0_1_set_interpacket_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_msecs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetInterpacketDelayRF;

    class Rip01SetInterpacketDelayCB {
        Rip01SetInterpacketDelayRF cb;

    public:
        operator const Rip01SetInterpacketDelayRF& () const { return cb; }
        const Rip01SetInterpacketDelayRF& operator ->() const { return cb; }
        Rip01SetInterpacketDelayCB(const Rip01SetInterpacketDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetInterpacketDelayRsp :
      public Rip01SetInterpacketDelayCB {
        Rip01SetInterpacketDelayRsp(const Rip01SetInterpacketDelayRF& cb)
          : Rip01SetInterpacketDelayCB(cb) { }

    };

    virtual void async_rip_0_1_set_interpacket_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	t_msecs,
	Rip01SetInterpacketDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the inter-packet delay between the output of packets from address.
     */
    virtual XrlCmdError rip_0_1_interpacket_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	uint32_t&	t_msecs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rip01InterpacketDelayRF;

    class Rip01InterpacketDelayCB {
        Rip01InterpacketDelayRF cb;

    public:
        operator const Rip01InterpacketDelayRF& () const { return cb; }
        const Rip01InterpacketDelayRF& operator ->() const { return cb; }
        Rip01InterpacketDelayCB(const Rip01InterpacketDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_msecs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_msecs);
        }
    };

    struct Rip01InterpacketDelayRsp :
      public Rip01InterpacketDelayCB {
        struct args_str {
            uint32_t t_msecs;
        };

    private:
        args_str args;

    public:
        Rip01InterpacketDelayRsp(const Rip01InterpacketDelayRF& cb)
          : Rip01InterpacketDelayCB(cb) { }

        void respond() const {
            Rip01InterpacketDelayCB::
            respond(args.t_msecs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_interpacket_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01InterpacketDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set simple password authentication key.
     *
     *  @param ifname the interface name.
     *
     *  @param vifname the vif name.
     *
     *  @param addr the address.
     *
     *  @param password the authentication password.
     */
    virtual XrlCmdError rip_0_1_set_simple_authentication_key(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const string&	password) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetSimpleAuthenticationKeyRF;

    class Rip01SetSimpleAuthenticationKeyCB {
        Rip01SetSimpleAuthenticationKeyRF cb;

    public:
        operator const Rip01SetSimpleAuthenticationKeyRF& () const { return cb; }
        const Rip01SetSimpleAuthenticationKeyRF& operator ->() const { return cb; }
        Rip01SetSimpleAuthenticationKeyCB(const Rip01SetSimpleAuthenticationKeyRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetSimpleAuthenticationKeyRsp :
      public Rip01SetSimpleAuthenticationKeyCB {
        Rip01SetSimpleAuthenticationKeyRsp(const Rip01SetSimpleAuthenticationKeyRF& cb)
          : Rip01SetSimpleAuthenticationKeyCB(cb) { }

    };

    virtual void async_rip_0_1_set_simple_authentication_key
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const string&	password,
	Rip01SetSimpleAuthenticationKeyCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete simple password authentication key.
     *
     *  @param ifname the interface name.
     *
     *  @param vifname the vif name.
     *
     *  @param addr the address.
     */
    virtual XrlCmdError rip_0_1_delete_simple_authentication_key(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01DeleteSimpleAuthenticationKeyRF;

    class Rip01DeleteSimpleAuthenticationKeyCB {
        Rip01DeleteSimpleAuthenticationKeyRF cb;

    public:
        operator const Rip01DeleteSimpleAuthenticationKeyRF& () const { return cb; }
        const Rip01DeleteSimpleAuthenticationKeyRF& operator ->() const { return cb; }
        Rip01DeleteSimpleAuthenticationKeyCB(const Rip01DeleteSimpleAuthenticationKeyRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01DeleteSimpleAuthenticationKeyRsp :
      public Rip01DeleteSimpleAuthenticationKeyCB {
        Rip01DeleteSimpleAuthenticationKeyRsp(const Rip01DeleteSimpleAuthenticationKeyRF& cb)
          : Rip01DeleteSimpleAuthenticationKeyCB(cb) { }

    };

    virtual void async_rip_0_1_delete_simple_authentication_key
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01DeleteSimpleAuthenticationKeyCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set MD5 authentication key.
     *
     *  @param ifname the interface name.
     *
     *  @param vifname the vif name.
     *
     *  @param addr the address.
     *
     *  @param key_id the key ID (must be an integer in the interval [0, 255]).
     *
     *  @param password the authentication password.
     *
     *  @param start_time the authentication start time (YYYY-MM-DD.HH:MM).
     *
     *  @param end_time the authentication end time (YYYY-MM-DD.HH:MM).
     */
    virtual XrlCmdError rip_0_1_set_md5_authentication_key(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	key_id,
	const string&	password,
	const string&	start_time,
	const string&	end_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01SetMd5AuthenticationKeyRF;

    class Rip01SetMd5AuthenticationKeyCB {
        Rip01SetMd5AuthenticationKeyRF cb;

    public:
        operator const Rip01SetMd5AuthenticationKeyRF& () const { return cb; }
        const Rip01SetMd5AuthenticationKeyRF& operator ->() const { return cb; }
        Rip01SetMd5AuthenticationKeyCB(const Rip01SetMd5AuthenticationKeyRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01SetMd5AuthenticationKeyRsp :
      public Rip01SetMd5AuthenticationKeyCB {
        Rip01SetMd5AuthenticationKeyRsp(const Rip01SetMd5AuthenticationKeyRF& cb)
          : Rip01SetMd5AuthenticationKeyCB(cb) { }

    };

    virtual void async_rip_0_1_set_md5_authentication_key
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	key_id,
	const string&	password,
	const string&	start_time,
	const string&	end_time,
	Rip01SetMd5AuthenticationKeyCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete MD5 authentication key.
     *
     *  @param ifname the interface name.
     *
     *  @param vifname the vif name.
     *
     *  @param addr the address.
     *
     *  @param key_id the key ID (must be an integer in the interval [0, 255]).
     */
    virtual XrlCmdError rip_0_1_delete_md5_authentication_key(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	key_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01DeleteMd5AuthenticationKeyRF;

    class Rip01DeleteMd5AuthenticationKeyCB {
        Rip01DeleteMd5AuthenticationKeyRF cb;

    public:
        operator const Rip01DeleteMd5AuthenticationKeyRF& () const { return cb; }
        const Rip01DeleteMd5AuthenticationKeyRF& operator ->() const { return cb; }
        Rip01DeleteMd5AuthenticationKeyCB(const Rip01DeleteMd5AuthenticationKeyRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01DeleteMd5AuthenticationKeyRsp :
      public Rip01DeleteMd5AuthenticationKeyCB {
        Rip01DeleteMd5AuthenticationKeyRsp(const Rip01DeleteMd5AuthenticationKeyRF& cb)
          : Rip01DeleteMd5AuthenticationKeyCB(cb) { }

    };

    virtual void async_rip_0_1_delete_md5_authentication_key
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const uint32_t&	key_id,
	Rip01DeleteMd5AuthenticationKeyCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get a textual description of the status of address RIP is running upon.
     *
     *  @param ifname the interface that owns vif that has the address.
     *
     *  @param vifname virtual interface owns the address.
     *
     *  @param addr the address to query.
     */
    virtual XrlCmdError rip_0_1_rip_address_status(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	string&	status) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Rip01RipAddressStatusRF;

    class Rip01RipAddressStatusCB {
        Rip01RipAddressStatusRF cb;

    public:
        operator const Rip01RipAddressStatusRF& () const { return cb; }
        const Rip01RipAddressStatusRF& operator ->() const { return cb; }
        Rip01RipAddressStatusCB(const Rip01RipAddressStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_status) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status);
        }
    };

    struct Rip01RipAddressStatusRsp :
      public Rip01RipAddressStatusCB {
        struct args_str {
            string status;
        };

    private:
        args_str args;

    public:
        Rip01RipAddressStatusRsp(const Rip01RipAddressStatusRF& cb)
          : Rip01RipAddressStatusCB(cb) { }

        void respond() const {
            Rip01RipAddressStatusCB::
            respond(args.status);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_rip_address_status
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01RipAddressStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get addresses running RIP.
     */
    virtual XrlCmdError rip_0_1_get_all_addresses(
	// Output values,
	XrlAtomList&	ifnames,
	XrlAtomList&	vifnames,
	XrlAtomList&	addrs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback4<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Rip01GetAllAddressesRF;

    class Rip01GetAllAddressesCB {
        Rip01GetAllAddressesRF cb;

    public:
        operator const Rip01GetAllAddressesRF& () const { return cb; }
        const Rip01GetAllAddressesRF& operator ->() const { return cb; }
        Rip01GetAllAddressesCB(const Rip01GetAllAddressesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_ifnames,
                     const XrlAtomList& arg_vifnames,
                     const XrlAtomList& arg_addrs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ifnames,
                         &arg_vifnames,
                         &arg_addrs);
        }
    };

    struct Rip01GetAllAddressesRsp :
      public Rip01GetAllAddressesCB {
        struct args_str {
            XrlAtomList ifnames;
            XrlAtomList vifnames;
            XrlAtomList addrs;
        };

    private:
        args_str args;

    public:
        Rip01GetAllAddressesRsp(const Rip01GetAllAddressesRF& cb)
          : Rip01GetAllAddressesCB(cb) { }

        void respond() const {
            Rip01GetAllAddressesCB::
            respond(args.ifnames,
                        args.vifnames,
                        args.addrs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_get_all_addresses
       (
	Rip01GetAllAddressesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get counters associated with interface / vif /address.
     */
    virtual XrlCmdError rip_0_1_get_counters(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	XrlAtomList&	counter_descriptions,
	XrlAtomList&	counter_values) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Rip01GetCountersRF;

    class Rip01GetCountersCB {
        Rip01GetCountersRF cb;

    public:
        operator const Rip01GetCountersRF& () const { return cb; }
        const Rip01GetCountersRF& operator ->() const { return cb; }
        Rip01GetCountersCB(const Rip01GetCountersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const XrlAtomList& arg_counter_descriptions,
                     const XrlAtomList& arg_counter_values) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_counter_descriptions,
                         &arg_counter_values);
        }
    };

    struct Rip01GetCountersRsp :
      public Rip01GetCountersCB {
        struct args_str {
            XrlAtomList counter_descriptions;
            XrlAtomList counter_values;
        };

    private:
        args_str args;

    public:
        Rip01GetCountersRsp(const Rip01GetCountersRF& cb)
          : Rip01GetCountersCB(cb) { }

        void respond() const {
            Rip01GetCountersCB::
            respond(args.counter_descriptions,
                        args.counter_values);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_get_counters
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01GetCountersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of peers associated with interface / vif / address.
     */
    virtual XrlCmdError rip_0_1_get_peers(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	// Output values,
	XrlAtomList&	peers) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Rip01GetPeersRF;

    class Rip01GetPeersCB {
        Rip01GetPeersRF cb;

    public:
        operator const Rip01GetPeersRF& () const { return cb; }
        const Rip01GetPeersRF& operator ->() const { return cb; }
        Rip01GetPeersCB(const Rip01GetPeersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_peers) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peers);
        }
    };

    struct Rip01GetPeersRsp :
      public Rip01GetPeersCB {
        struct args_str {
            XrlAtomList peers;
        };

    private:
        args_str args;

    public:
        Rip01GetPeersRsp(const Rip01GetPeersRF& cb)
          : Rip01GetPeersCB(cb) { }

        void respond() const {
            Rip01GetPeersCB::
            respond(args.peers);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_get_peers
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	Rip01GetPeersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of all peers known to RIP. There is a 1-to-1 correspondence
     *  between the items in the lists of peers, ifnames, vifnames, addrs.
     */
    virtual XrlCmdError rip_0_1_get_all_peers(
	// Output values,
	XrlAtomList&	peers,
	XrlAtomList&	ifnames,
	XrlAtomList&	vifnames,
	XrlAtomList&	addrs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Rip01GetAllPeersRF;

    class Rip01GetAllPeersCB {
        Rip01GetAllPeersRF cb;

    public:
        operator const Rip01GetAllPeersRF& () const { return cb; }
        const Rip01GetAllPeersRF& operator ->() const { return cb; }
        Rip01GetAllPeersCB(const Rip01GetAllPeersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_peers,
                     const XrlAtomList& arg_ifnames,
                     const XrlAtomList& arg_vifnames,
                     const XrlAtomList& arg_addrs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peers,
                         &arg_ifnames,
                         &arg_vifnames,
                         &arg_addrs);
        }
    };

    struct Rip01GetAllPeersRsp :
      public Rip01GetAllPeersCB {
        struct args_str {
            XrlAtomList peers;
            XrlAtomList ifnames;
            XrlAtomList vifnames;
            XrlAtomList addrs;
        };

    private:
        args_str args;

    public:
        Rip01GetAllPeersRsp(const Rip01GetAllPeersRF& cb)
          : Rip01GetAllPeersCB(cb) { }

        void respond() const {
            Rip01GetAllPeersCB::
            respond(args.peers,
                        args.ifnames,
                        args.vifnames,
                        args.addrs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_get_all_peers
       (
	Rip01GetAllPeersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get counters associated with peer of interface / vif /address.
     *
     *  @param counter_descriptions textual descriptions of counters.
     *
     *  @param counter_values values associated with counters.
     *
     *  @param peer_last_active is the number of seconds since TimeVal(0,0).
     */
    virtual XrlCmdError rip_0_1_get_peer_counters(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const IPv4&	peer,
	// Output values,
	XrlAtomList&	counter_descriptions,
	XrlAtomList&	counter_values,
	uint32_t&	peer_last_active) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback4<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const uint32_t*>::RefPtr
    Rip01GetPeerCountersRF;

    class Rip01GetPeerCountersCB {
        Rip01GetPeerCountersRF cb;

    public:
        operator const Rip01GetPeerCountersRF& () const { return cb; }
        const Rip01GetPeerCountersRF& operator ->() const { return cb; }
        Rip01GetPeerCountersCB(const Rip01GetPeerCountersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_counter_descriptions,
                     const XrlAtomList& arg_counter_values,
                     const uint32_t& arg_peer_last_active) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_counter_descriptions,
                         &arg_counter_values,
                         &arg_peer_last_active);
        }
    };

    struct Rip01GetPeerCountersRsp :
      public Rip01GetPeerCountersCB {
        struct args_str {
            XrlAtomList counter_descriptions;
            XrlAtomList counter_values;
            uint32_t peer_last_active;
        };

    private:
        args_str args;

    public:
        Rip01GetPeerCountersRsp(const Rip01GetPeerCountersRF& cb)
          : Rip01GetPeerCountersCB(cb) { }

        void respond() const {
            Rip01GetPeerCountersCB::
            respond(args.counter_descriptions,
                        args.counter_values,
                        args.peer_last_active);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rip_0_1_get_peer_counters
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	addr,
	const IPv4&	peer,
	Rip01GetPeerCountersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/Disable tracing.
     *
     *  @param tvar trace variable.
     *
     *  @param enable set to true to enable false to disable.
     */
    virtual XrlCmdError rip_0_1_trace(
	// Input values,
	const string&	tvar,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rip01TraceRF;

    class Rip01TraceCB {
        Rip01TraceRF cb;

    public:
        operator const Rip01TraceRF& () const { return cb; }
        const Rip01TraceRF& operator ->() const { return cb; }
        Rip01TraceCB(const Rip01TraceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rip01TraceRsp :
      public Rip01TraceCB {
        Rip01TraceRsp(const Rip01TraceRF& cb)
          : Rip01TraceCB(cb) { }

    };

    virtual void async_rip_0_1_trace
       (
	const string&	tvar,
	const bool&	enable,
	Rip01TraceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when a packet arrives
     *  from an IPv4 source.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param if_name the interface name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param vif_name the vif name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param src_host the originating host.
     *
     *  @param src_port the originating IP port.
     *
     *  @param data the data received.
     */
    virtual XrlCmdError socket4_user_0_1_recv_event(
	// Input values,
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01RecvEventRF;

    class Socket4User01RecvEventCB {
        Socket4User01RecvEventRF cb;

    public:
        operator const Socket4User01RecvEventRF& () const { return cb; }
        const Socket4User01RecvEventRF& operator ->() const { return cb; }
        Socket4User01RecvEventCB(const Socket4User01RecvEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01RecvEventRsp :
      public Socket4User01RecvEventCB {
        Socket4User01RecvEventRsp(const Socket4User01RecvEventRF& cb)
          : Socket4User01RecvEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_recv_event
       (
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data,
	Socket4User01RecvEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when a connection
     *  request is received from an IPv4 source. It applies only to TCP
     *  sockets.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param src_host the connecting host.
     *
     *  @param src_port the connecting IP port.
     *
     *  @param new_sockid the identifier associated with the new socket that
     *  has been created to handle the new connection.
     *
     *  @param accept if true, the connection request has been accepted,
     *  otherwise it has been rejected.
     */
    virtual XrlCmdError socket4_user_0_1_inbound_connect_event(
	// Input values,
	const string&	sockid,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Socket4User01InboundConnectEventRF;

    class Socket4User01InboundConnectEventCB {
        Socket4User01InboundConnectEventRF cb;

    public:
        operator const Socket4User01InboundConnectEventRF& () const { return cb; }
        const Socket4User01InboundConnectEventRF& operator ->() const { return cb; }
        Socket4User01InboundConnectEventCB(const Socket4User01InboundConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Socket4User01InboundConnectEventRsp :
      public Socket4User01InboundConnectEventCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Socket4User01InboundConnectEventRsp(const Socket4User01InboundConnectEventRF& cb)
          : Socket4User01InboundConnectEventCB(cb) { }

        void respond() const {
            Socket4User01InboundConnectEventCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_user_0_1_inbound_connect_event
       (
	const string&	sockid,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	Socket4User01InboundConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when an outgoing
     *  connection request originated by the local host is completed. It
     *  applies only to TCP sockets. Note that if the connection failed, the
     *  error_event will be dispatched instead.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket4_user_0_1_outgoing_connect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01OutgoingConnectEventRF;

    class Socket4User01OutgoingConnectEventCB {
        Socket4User01OutgoingConnectEventRF cb;

    public:
        operator const Socket4User01OutgoingConnectEventRF& () const { return cb; }
        const Socket4User01OutgoingConnectEventRF& operator ->() const { return cb; }
        Socket4User01OutgoingConnectEventCB(const Socket4User01OutgoingConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01OutgoingConnectEventRsp :
      public Socket4User01OutgoingConnectEventCB {
        Socket4User01OutgoingConnectEventRsp(const Socket4User01OutgoingConnectEventRF& cb)
          : Socket4User01OutgoingConnectEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_outgoing_connect_event
       (
	const string&	sockid,
	Socket4User01OutgoingConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when an error occurs.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param error a textual description of the error.
     *
     *  @param fatal indication of whether socket is shutdown because of error.
     */
    virtual XrlCmdError socket4_user_0_1_error_event(
	// Input values,
	const string&	sockid,
	const string&	error,
	const bool&	fatal) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01ErrorEventRF;

    class Socket4User01ErrorEventCB {
        Socket4User01ErrorEventRF cb;

    public:
        operator const Socket4User01ErrorEventRF& () const { return cb; }
        const Socket4User01ErrorEventRF& operator ->() const { return cb; }
        Socket4User01ErrorEventCB(const Socket4User01ErrorEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01ErrorEventRsp :
      public Socket4User01ErrorEventCB {
        Socket4User01ErrorEventRsp(const Socket4User01ErrorEventRF& cb)
          : Socket4User01ErrorEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_error_event
       (
	const string&	sockid,
	const string&	error,
	const bool&	fatal,
	Socket4User01ErrorEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when the peer has
     *  closed the connection. It applies only to TCP sockets. Note that the
     *  socket itself is left open and must be explicitly closed.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket4_user_0_1_disconnect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01DisconnectEventRF;

    class Socket4User01DisconnectEventCB {
        Socket4User01DisconnectEventRF cb;

    public:
        operator const Socket4User01DisconnectEventRF& () const { return cb; }
        const Socket4User01DisconnectEventRF& operator ->() const { return cb; }
        Socket4User01DisconnectEventCB(const Socket4User01DisconnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01DisconnectEventRsp :
      public Socket4User01DisconnectEventCB {
        Socket4User01DisconnectEventRsp(const Socket4User01DisconnectEventRF& cb)
          : Socket4User01DisconnectEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_disconnect_event
       (
	const string&	sockid,
	Socket4User01DisconnectEventCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_add_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_add_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_delete_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_delete_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_add_rip_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_add_rip_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_remove_rip_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_remove_rip_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_rip_address_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_rip_address_enabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_rip_address_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_rip_address_enabled
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_cost
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_cost
       (const XrlCmdError &e,
	const uint32_t* arg_cost,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_horizon(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_horizon
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_horizon(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_horizon
       (const XrlCmdError &e,
	const string* arg_horizon,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_passive(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_passive
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_passive(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_passive
       (const XrlCmdError &e,
	const bool* arg_passive,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_accept_non_rip_requests(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_accept_non_rip_requests
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_accept_non_rip_requests(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_accept_non_rip_requests
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_accept_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_accept_default_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_accept_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_accept_default_route
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_advertise_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_advertise_default_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_advertise_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_advertise_default_route
       (const XrlCmdError &e,
	const bool* arg_advertise,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_route_timeout(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_route_timeout
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_route_timeout(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_route_timeout
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_deletion_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_deletion_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_deletion_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_deletion_delay
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_request_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_request_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_request_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_request_interval
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_update_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_update_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_update_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_update_interval
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_update_jitter
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_update_jitter
       (const XrlCmdError &e,
	const uint32_t* arg_t_jitter,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_triggered_update_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_triggered_update_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_triggered_update_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_triggered_update_delay
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_triggered_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_triggered_update_jitter
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_triggered_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_triggered_update_jitter
       (const XrlCmdError &e,
	const uint32_t* arg_t_jitter,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_interpacket_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_interpacket_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_interpacket_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_interpacket_delay
       (const XrlCmdError &e,
	const uint32_t* arg_t_msecs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_simple_authentication_key(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_simple_authentication_key
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_delete_simple_authentication_key(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_delete_simple_authentication_key
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_set_md5_authentication_key(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_set_md5_authentication_key
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_delete_md5_authentication_key(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_delete_md5_authentication_key
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_rip_address_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_rip_address_status
       (const XrlCmdError &e,
	const string* arg_status,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_get_all_addresses(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_get_all_addresses
       (const XrlCmdError &e,
	const XrlAtomList* arg_ifnames,
	const XrlAtomList* arg_vifnames,
	const XrlAtomList* arg_addrs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_get_counters(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_get_counters
       (const XrlCmdError &e,
	const XrlAtomList* arg_counter_descriptions,
	const XrlAtomList* arg_counter_values,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_get_peers(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_get_peers
       (const XrlCmdError &e,
	const XrlAtomList* arg_peers,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_get_all_peers(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_get_all_peers
       (const XrlCmdError &e,
	const XrlAtomList* arg_peers,
	const XrlAtomList* arg_ifnames,
	const XrlAtomList* arg_vifnames,
	const XrlAtomList* arg_addrs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_get_peer_counters(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_get_peer_counters
       (const XrlCmdError &e,
	const XrlAtomList* arg_counter_descriptions,
	const XrlAtomList* arg_counter_values,
	const uint32_t* arg_peer_last_active,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rip_0_1_trace(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rip_0_1_trace
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_recv_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_recv_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_inbound_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_inbound_connect_event
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_outgoing_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_outgoing_connect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_error_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_error_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_disconnect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_disconnect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlRipTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_RIP_BASE_HH__
