/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/rib_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_RIB_BASE_HH__
#define __XRL_TARGETS_RIB_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlRibTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlRibTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlRibTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlRibTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "rib/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable/start/stop RIB.
     */
    virtual XrlCmdError rib_0_1_enable_rib() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01EnableRibRF;

    class Rib01EnableRibCB {
        Rib01EnableRibRF cb;

    public:
        operator const Rib01EnableRibRF& () const { return cb; }
        const Rib01EnableRibRF& operator ->() const { return cb; }
        Rib01EnableRibCB(const Rib01EnableRibRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01EnableRibRsp :
      public Rib01EnableRibCB {
        Rib01EnableRibRsp(const Rib01EnableRibRF& cb)
          : Rib01EnableRibCB(cb) { }

    };

    virtual void async_rib_0_1_enable_rib
       (
	Rib01EnableRibCB);
#endif

    virtual XrlCmdError rib_0_1_disable_rib() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DisableRibRF;

    class Rib01DisableRibCB {
        Rib01DisableRibRF cb;

    public:
        operator const Rib01DisableRibRF& () const { return cb; }
        const Rib01DisableRibRF& operator ->() const { return cb; }
        Rib01DisableRibCB(const Rib01DisableRibRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DisableRibRsp :
      public Rib01DisableRibCB {
        Rib01DisableRibRsp(const Rib01DisableRibRF& cb)
          : Rib01DisableRibCB(cb) { }

    };

    virtual void async_rib_0_1_disable_rib
       (
	Rib01DisableRibCB);
#endif

    virtual XrlCmdError rib_0_1_start_rib() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01StartRibRF;

    class Rib01StartRibCB {
        Rib01StartRibRF cb;

    public:
        operator const Rib01StartRibRF& () const { return cb; }
        const Rib01StartRibRF& operator ->() const { return cb; }
        Rib01StartRibCB(const Rib01StartRibRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01StartRibRsp :
      public Rib01StartRibCB {
        Rib01StartRibRsp(const Rib01StartRibRF& cb)
          : Rib01StartRibCB(cb) { }

    };

    virtual void async_rib_0_1_start_rib
       (
	Rib01StartRibCB);
#endif

    virtual XrlCmdError rib_0_1_stop_rib() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01StopRibRF;

    class Rib01StopRibCB {
        Rib01StopRibRF cb;

    public:
        operator const Rib01StopRibRF& () const { return cb; }
        const Rib01StopRibRF& operator ->() const { return cb; }
        Rib01StopRibCB(const Rib01StopRibRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01StopRibRsp :
      public Rib01StopRibCB {
        Rib01StopRibRsp(const Rib01StopRibRF& cb)
          : Rib01StopRibCB(cb) { }

    };

    virtual void async_rib_0_1_stop_rib
       (
	Rib01StopRibCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Make errors fatal; used to detect errors we'd normally mask
     */
    virtual XrlCmdError rib_0_1_make_errors_fatal() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01MakeErrorsFatalRF;

    class Rib01MakeErrorsFatalCB {
        Rib01MakeErrorsFatalRF cb;

    public:
        operator const Rib01MakeErrorsFatalRF& () const { return cb; }
        const Rib01MakeErrorsFatalRF& operator ->() const { return cb; }
        Rib01MakeErrorsFatalCB(const Rib01MakeErrorsFatalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01MakeErrorsFatalRsp :
      public Rib01MakeErrorsFatalCB {
        Rib01MakeErrorsFatalRsp(const Rib01MakeErrorsFatalRF& cb)
          : Rib01MakeErrorsFatalCB(cb) { }

    };

    virtual void async_rib_0_1_make_errors_fatal
       (
	Rib01MakeErrorsFatalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of registered protocols.
     *
     *  @param ipv4 if true, then include the IPv4 protocols.
     *
     *  @param ipv6 if true, then include the IPv6 protocols.
     *
     *  @param unicast if true, then include the protocols registered with the
     *  unicast RIB.
     *
     *  @param multicast if true, then include the protocols registered with
     *  the multicast RIB.
     *
     *  @param ipv4_unicast_protocols the list of IPv4 protocols registered
     *  with the unicast RIB.
     *
     *  @param ipv6_unicast_protocols the list of IPv6 protocols registered
     *  with the unicast RIB.
     *
     *  @param ipv4_multicast_protocols the list of IPv4 protocols registered
     *  with the multicast RIB.
     *
     *  @param ipv6_multicast_protocols the list of IPv6 protocols registered
     *  with the multicast RIB.
     */
    virtual XrlCmdError rib_0_1_get_registered_protocols(
	// Input values,
	const bool&	ipv4,
	const bool&	ipv6,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	XrlAtomList&	ipv4_unicast_protocols,
	XrlAtomList&	ipv6_unicast_protocols,
	XrlAtomList&	ipv4_multicast_protocols,
	XrlAtomList&	ipv6_multicast_protocols) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Rib01GetRegisteredProtocolsRF;

    class Rib01GetRegisteredProtocolsCB {
        Rib01GetRegisteredProtocolsRF cb;

    public:
        operator const Rib01GetRegisteredProtocolsRF& () const { return cb; }
        const Rib01GetRegisteredProtocolsRF& operator ->() const { return cb; }
        Rib01GetRegisteredProtocolsCB(const Rib01GetRegisteredProtocolsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_ipv4_unicast_protocols,
                     const XrlAtomList& arg_ipv6_unicast_protocols,
                     const XrlAtomList& arg_ipv4_multicast_protocols,
                     const XrlAtomList& arg_ipv6_multicast_protocols) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ipv4_unicast_protocols,
                         &arg_ipv6_unicast_protocols,
                         &arg_ipv4_multicast_protocols,
                         &arg_ipv6_multicast_protocols);
        }
    };

    struct Rib01GetRegisteredProtocolsRsp :
      public Rib01GetRegisteredProtocolsCB {
        struct args_str {
            XrlAtomList ipv4_unicast_protocols;
            XrlAtomList ipv6_unicast_protocols;
            XrlAtomList ipv4_multicast_protocols;
            XrlAtomList ipv6_multicast_protocols;
        };

    private:
        args_str args;

    public:
        Rib01GetRegisteredProtocolsRsp(const Rib01GetRegisteredProtocolsRF& cb)
          : Rib01GetRegisteredProtocolsCB(cb) { }

        void respond() const {
            Rib01GetRegisteredProtocolsCB::
            respond(args.ipv4_unicast_protocols,
                        args.ipv6_unicast_protocols,
                        args.ipv4_multicast_protocols,
                        args.ipv6_multicast_protocols);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_get_registered_protocols
       (
	const bool&	ipv4,
	const bool&	ipv6,
	const bool&	unicast,
	const bool&	multicast,
	Rib01GetRegisteredProtocolsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete an IGP or EGP table.
     *
     *  @param protocol the name of the protocol.
     *
     *  @param target_class the target class of the protocol.
     *
     *  @param target_instance the target instance of the protocol.
     *
     *  @param unicast true if the table is for the unicast RIB.
     *
     *  @param multicast true if the table is for the multicast RIB.
     */
    virtual XrlCmdError rib_0_1_add_igp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddIgpTable4RF;

    class Rib01AddIgpTable4CB {
        Rib01AddIgpTable4RF cb;

    public:
        operator const Rib01AddIgpTable4RF& () const { return cb; }
        const Rib01AddIgpTable4RF& operator ->() const { return cb; }
        Rib01AddIgpTable4CB(const Rib01AddIgpTable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddIgpTable4Rsp :
      public Rib01AddIgpTable4CB {
        Rib01AddIgpTable4Rsp(const Rib01AddIgpTable4RF& cb)
          : Rib01AddIgpTable4CB(cb) { }

    };

    virtual void async_rib_0_1_add_igp_table4
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01AddIgpTable4CB);
#endif

    virtual XrlCmdError rib_0_1_delete_igp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeleteIgpTable4RF;

    class Rib01DeleteIgpTable4CB {
        Rib01DeleteIgpTable4RF cb;

    public:
        operator const Rib01DeleteIgpTable4RF& () const { return cb; }
        const Rib01DeleteIgpTable4RF& operator ->() const { return cb; }
        Rib01DeleteIgpTable4CB(const Rib01DeleteIgpTable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeleteIgpTable4Rsp :
      public Rib01DeleteIgpTable4CB {
        Rib01DeleteIgpTable4Rsp(const Rib01DeleteIgpTable4RF& cb)
          : Rib01DeleteIgpTable4CB(cb) { }

    };

    virtual void async_rib_0_1_delete_igp_table4
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01DeleteIgpTable4CB);
#endif

    virtual XrlCmdError rib_0_1_add_egp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddEgpTable4RF;

    class Rib01AddEgpTable4CB {
        Rib01AddEgpTable4RF cb;

    public:
        operator const Rib01AddEgpTable4RF& () const { return cb; }
        const Rib01AddEgpTable4RF& operator ->() const { return cb; }
        Rib01AddEgpTable4CB(const Rib01AddEgpTable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddEgpTable4Rsp :
      public Rib01AddEgpTable4CB {
        Rib01AddEgpTable4Rsp(const Rib01AddEgpTable4RF& cb)
          : Rib01AddEgpTable4CB(cb) { }

    };

    virtual void async_rib_0_1_add_egp_table4
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01AddEgpTable4CB);
#endif

    virtual XrlCmdError rib_0_1_delete_egp_table4(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeleteEgpTable4RF;

    class Rib01DeleteEgpTable4CB {
        Rib01DeleteEgpTable4RF cb;

    public:
        operator const Rib01DeleteEgpTable4RF& () const { return cb; }
        const Rib01DeleteEgpTable4RF& operator ->() const { return cb; }
        Rib01DeleteEgpTable4CB(const Rib01DeleteEgpTable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeleteEgpTable4Rsp :
      public Rib01DeleteEgpTable4CB {
        Rib01DeleteEgpTable4Rsp(const Rib01DeleteEgpTable4RF& cb)
          : Rib01DeleteEgpTable4CB(cb) { }

    };

    virtual void async_rib_0_1_delete_egp_table4
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01DeleteEgpTable4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/replace/delete a route.
     *
     *  @param protocol the name of the protocol this route comes from.
     *
     *  @param unicast true if the route is for the unicast RIB.
     *
     *  @param multicast true if the route is for the multicast RIB.
     *
     *  @param network the network address prefix of the route.
     *
     *  @param nexthop the address of the next-hop router toward the
     *  destination.
     *
     *  @param metric the routing metric.
     *
     *  @param policytags a set of policy tags used for redistribution.
     */
    virtual XrlCmdError rib_0_1_add_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddRoute4RF;

    class Rib01AddRoute4CB {
        Rib01AddRoute4RF cb;

    public:
        operator const Rib01AddRoute4RF& () const { return cb; }
        const Rib01AddRoute4RF& operator ->() const { return cb; }
        Rib01AddRoute4CB(const Rib01AddRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddRoute4Rsp :
      public Rib01AddRoute4CB {
        Rib01AddRoute4Rsp(const Rib01AddRoute4RF& cb)
          : Rib01AddRoute4CB(cb) { }

    };

    virtual void async_rib_0_1_add_route4
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01AddRoute4CB);
#endif

    virtual XrlCmdError rib_0_1_replace_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01ReplaceRoute4RF;

    class Rib01ReplaceRoute4CB {
        Rib01ReplaceRoute4RF cb;

    public:
        operator const Rib01ReplaceRoute4RF& () const { return cb; }
        const Rib01ReplaceRoute4RF& operator ->() const { return cb; }
        Rib01ReplaceRoute4CB(const Rib01ReplaceRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01ReplaceRoute4Rsp :
      public Rib01ReplaceRoute4CB {
        Rib01ReplaceRoute4Rsp(const Rib01ReplaceRoute4RF& cb)
          : Rib01ReplaceRoute4CB(cb) { }

    };

    virtual void async_rib_0_1_replace_route4
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01ReplaceRoute4CB);
#endif

    virtual XrlCmdError rib_0_1_delete_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeleteRoute4RF;

    class Rib01DeleteRoute4CB {
        Rib01DeleteRoute4RF cb;

    public:
        operator const Rib01DeleteRoute4RF& () const { return cb; }
        const Rib01DeleteRoute4RF& operator ->() const { return cb; }
        Rib01DeleteRoute4CB(const Rib01DeleteRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeleteRoute4Rsp :
      public Rib01DeleteRoute4CB {
        Rib01DeleteRoute4Rsp(const Rib01DeleteRoute4RF& cb)
          : Rib01DeleteRoute4CB(cb) { }

    };

    virtual void async_rib_0_1_delete_route4
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	Rib01DeleteRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/replace a route by explicitly specifying the network interface
     *  toward the destination.
     *
     *  @param protocol the name of the protocol this route comes from.
     *
     *  @param unicast true if the route is for the unicast RIB.
     *
     *  @param multicast true if the route is for the multicast RIB.
     *
     *  @param network the network address prefix of the route.
     *
     *  @param nexthop the address of the next-hop router toward the
     *  destination.
     *
     *  @param ifname of the name of the physical interface toward the
     *  destination.
     *
     *  @param vifname of the name of the virtual interface toward the
     *  destination.
     *
     *  @param metric the routing metric.
     *
     *  @param policytags a set of policy tags used for redistribution.
     */
    virtual XrlCmdError rib_0_1_add_interface_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddInterfaceRoute4RF;

    class Rib01AddInterfaceRoute4CB {
        Rib01AddInterfaceRoute4RF cb;

    public:
        operator const Rib01AddInterfaceRoute4RF& () const { return cb; }
        const Rib01AddInterfaceRoute4RF& operator ->() const { return cb; }
        Rib01AddInterfaceRoute4CB(const Rib01AddInterfaceRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddInterfaceRoute4Rsp :
      public Rib01AddInterfaceRoute4CB {
        Rib01AddInterfaceRoute4Rsp(const Rib01AddInterfaceRoute4RF& cb)
          : Rib01AddInterfaceRoute4CB(cb) { }

    };

    virtual void async_rib_0_1_add_interface_route4
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01AddInterfaceRoute4CB);
#endif

    virtual XrlCmdError rib_0_1_replace_interface_route4(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01ReplaceInterfaceRoute4RF;

    class Rib01ReplaceInterfaceRoute4CB {
        Rib01ReplaceInterfaceRoute4RF cb;

    public:
        operator const Rib01ReplaceInterfaceRoute4RF& () const { return cb; }
        const Rib01ReplaceInterfaceRoute4RF& operator ->() const { return cb; }
        Rib01ReplaceInterfaceRoute4CB(const Rib01ReplaceInterfaceRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01ReplaceInterfaceRoute4Rsp :
      public Rib01ReplaceInterfaceRoute4CB {
        Rib01ReplaceInterfaceRoute4Rsp(const Rib01ReplaceInterfaceRoute4RF& cb)
          : Rib01ReplaceInterfaceRoute4CB(cb) { }

    };

    virtual void async_rib_0_1_replace_interface_route4
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01ReplaceInterfaceRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup nexthop.
     *
     *  @param addr address to lookup.
     *
     *  @param unicast look in unicast RIB.
     *
     *  @param multicast look in multicast RIB.
     *
     *  @param nexthop contains the resolved nexthop if successful, IPv4::ZERO
     *  otherwise. It is an error for the unicast and multicast fields to both
     *  be true or both false.
     */
    virtual XrlCmdError rib_0_1_lookup_route_by_dest4(
	// Input values,
	const IPv4&	addr,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	IPv4&	nexthop) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Rib01LookupRouteByDest4RF;

    class Rib01LookupRouteByDest4CB {
        Rib01LookupRouteByDest4RF cb;

    public:
        operator const Rib01LookupRouteByDest4RF& () const { return cb; }
        const Rib01LookupRouteByDest4RF& operator ->() const { return cb; }
        Rib01LookupRouteByDest4CB(const Rib01LookupRouteByDest4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_nexthop) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_nexthop);
        }
    };

    struct Rib01LookupRouteByDest4Rsp :
      public Rib01LookupRouteByDest4CB {
        struct args_str {
            IPv4 nexthop;
        };

    private:
        args_str args;

    public:
        Rib01LookupRouteByDest4Rsp(const Rib01LookupRouteByDest4RF& cb)
          : Rib01LookupRouteByDest4CB(cb) { }

        void respond() const {
            Rib01LookupRouteByDest4CB::
            respond(args.nexthop);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_lookup_route_by_dest4
       (
	const IPv4&	addr,
	const bool&	unicast,
	const bool&	multicast,
	Rib01LookupRouteByDest4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add a vif or a vif address to the RIB. This interface should be used
     *  only for testing purpose.
     *
     *  @param name the name of the vif.
     */
    virtual XrlCmdError rib_0_1_new_vif(
	// Input values,
	const string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01NewVifRF;

    class Rib01NewVifCB {
        Rib01NewVifRF cb;

    public:
        operator const Rib01NewVifRF& () const { return cb; }
        const Rib01NewVifRF& operator ->() const { return cb; }
        Rib01NewVifCB(const Rib01NewVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01NewVifRsp :
      public Rib01NewVifCB {
        Rib01NewVifRsp(const Rib01NewVifRF& cb)
          : Rib01NewVifCB(cb) { }

    };

    virtual void async_rib_0_1_new_vif
       (
	const string&	name,
	Rib01NewVifCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add a vif address to the RIB. This interface should be used only for
     *  testing purpose.
     *
     *  @param name the name of the vif.
     *
     *  @param addr the address to add.
     *
     *  @param subnet the subnet address to add.
     */
    virtual XrlCmdError rib_0_1_add_vif_addr4(
	// Input values,
	const string&	name,
	const IPv4&	addr,
	const IPv4Net&	subnet) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddVifAddr4RF;

    class Rib01AddVifAddr4CB {
        Rib01AddVifAddr4RF cb;

    public:
        operator const Rib01AddVifAddr4RF& () const { return cb; }
        const Rib01AddVifAddr4RF& operator ->() const { return cb; }
        Rib01AddVifAddr4CB(const Rib01AddVifAddr4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddVifAddr4Rsp :
      public Rib01AddVifAddr4CB {
        Rib01AddVifAddr4Rsp(const Rib01AddVifAddr4RF& cb)
          : Rib01AddVifAddr4CB(cb) { }

    };

    virtual void async_rib_0_1_add_vif_addr4
       (
	const string&	name,
	const IPv4&	addr,
	const IPv4Net&	subnet,
	Rib01AddVifAddr4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist4/0.1.
     *
     *  @param from_protocol the name of the routing process routes are to be
     *  redistributed from.
     *
     *  @param unicast enable for unicast RIBs matching from and to.
     *
     *  @param multicast enable for multicast RIBs matching from and to.
     *
     *  @param network_prefix redistribite only the routes that fall into this
     *  prefix address.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist4/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_enable4(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network_prefix,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistEnable4RF;

    class Rib01RedistEnable4CB {
        Rib01RedistEnable4RF cb;

    public:
        operator const Rib01RedistEnable4RF& () const { return cb; }
        const Rib01RedistEnable4RF& operator ->() const { return cb; }
        Rib01RedistEnable4CB(const Rib01RedistEnable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistEnable4Rsp :
      public Rib01RedistEnable4CB {
        Rib01RedistEnable4Rsp(const Rib01RedistEnable4RF& cb)
          : Rib01RedistEnable4CB(cb) { }

    };

    virtual void async_rib_0_1_redist_enable4
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network_prefix,
	const string&	cookie,
	Rib01RedistEnable4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist4/0.1 and previously called redist_enable4.
     *
     *  @param unicast disable for unicast RIBs matching from and to.
     *
     *  @param multicast disable for multicast RIBs matching from and to.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist4/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_disable4(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistDisable4RF;

    class Rib01RedistDisable4CB {
        Rib01RedistDisable4RF cb;

    public:
        operator const Rib01RedistDisable4RF& () const { return cb; }
        const Rib01RedistDisable4RF& operator ->() const { return cb; }
        Rib01RedistDisable4CB(const Rib01RedistDisable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistDisable4Rsp :
      public Rib01RedistDisable4CB {
        Rib01RedistDisable4Rsp(const Rib01RedistDisable4RF& cb)
          : Rib01RedistDisable4CB(cb) { }

    };

    virtual void async_rib_0_1_redist_disable4
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie,
	Rib01RedistDisable4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable transaction-based route redistribution from one routing protocol
     *  to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist_transaction4/0.1.
     *
     *  @param from_protocol the name of the routing process routes are to be
     *  redistributed from.
     *
     *  @param unicast enable for unicast RIBs matching from and to.
     *
     *  @param multicast enable for multicast RIBs matching from and to.
     *
     *  @param network_prefix redistribite only the routes that fall into this
     *  prefix address.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist_transaction4/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_transaction_enable4(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network_prefix,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistTransactionEnable4RF;

    class Rib01RedistTransactionEnable4CB {
        Rib01RedistTransactionEnable4RF cb;

    public:
        operator const Rib01RedistTransactionEnable4RF& () const { return cb; }
        const Rib01RedistTransactionEnable4RF& operator ->() const { return cb; }
        Rib01RedistTransactionEnable4CB(const Rib01RedistTransactionEnable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistTransactionEnable4Rsp :
      public Rib01RedistTransactionEnable4CB {
        Rib01RedistTransactionEnable4Rsp(const Rib01RedistTransactionEnable4RF& cb)
          : Rib01RedistTransactionEnable4CB(cb) { }

    };

    virtual void async_rib_0_1_redist_transaction_enable4
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4Net&	network_prefix,
	const string&	cookie,
	Rib01RedistTransactionEnable4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable transaction-based route redistribution from one routing
     *  protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist_transaction4/0.1 and previously called
     *  redist_transaction_enable4.
     *
     *  @param unicast disable for unicast RIBs matching from and to.
     *
     *  @param multicast disable for multicast RIBs matching from and to.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist_transaction4/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_transaction_disable4(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistTransactionDisable4RF;

    class Rib01RedistTransactionDisable4CB {
        Rib01RedistTransactionDisable4RF cb;

    public:
        operator const Rib01RedistTransactionDisable4RF& () const { return cb; }
        const Rib01RedistTransactionDisable4RF& operator ->() const { return cb; }
        Rib01RedistTransactionDisable4CB(const Rib01RedistTransactionDisable4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistTransactionDisable4Rsp :
      public Rib01RedistTransactionDisable4CB {
        Rib01RedistTransactionDisable4Rsp(const Rib01RedistTransactionDisable4RF& cb)
          : Rib01RedistTransactionDisable4CB(cb) { }

    };

    virtual void async_rib_0_1_redist_transaction_disable4
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie,
	Rib01RedistTransactionDisable4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register an interest in a route.
     *
     *  @param target the name of the XRL module to notify when the information
     *  returned by this call becomes invalid.
     *
     *  @param addr address of interest.
     *
     *  @param resolves returns whether or not the address resolves to a route
     *  that can be used for forwarding.
     *
     *  @param base_addr returns the address of interest (actually the base
     *  address of the subnet covered by addr/prefix_len).
     *
     *  @param prefix_len returns the prefix length that the registration
     *  covers. This response applies to all addresses in addr/prefix_len.
     *
     *  @param real_prefix_len returns the actual prefix length of the route
     *  that will be used to route addr. If real_prefix_len is not the same as
     *  prefix_len, this is because there are some more specific routes that
     *  overlap addr/real_prefix_len. real_prefix_len is primarily given for
     *  debugging reasons.
     *
     *  @param nexthop returns the address of the next hop for packets sent to
     *  addr.
     *
     *  @param metric returns the IGP metric for this route.
     */
    virtual XrlCmdError rib_0_1_register_interest4(
	// Input values,
	const string&	target,
	const IPv4&	addr,
	// Output values,
	bool&	resolves,
	IPv4&	base_addr,
	uint32_t&	prefix_len,
	uint32_t&	real_prefix_len,
	IPv4&	nexthop,
	uint32_t&	metric) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const bool*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*,
	const IPv4*,
	const uint32_t*>::RefPtr
    Rib01RegisterInterest4RF;

    class Rib01RegisterInterest4CB {
        Rib01RegisterInterest4RF cb;

    public:
        operator const Rib01RegisterInterest4RF& () const { return cb; }
        const Rib01RegisterInterest4RF& operator ->() const { return cb; }
        Rib01RegisterInterest4CB(const Rib01RegisterInterest4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const bool& arg_resolves,
                     const IPv4& arg_base_addr,
                     const uint32_t& arg_prefix_len,
                     const uint32_t& arg_real_prefix_len,
                     const IPv4& arg_nexthop,
                     const uint32_t& arg_metric) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_resolves,
                         &arg_base_addr,
                         &arg_prefix_len,
                         &arg_real_prefix_len,
                         &arg_nexthop,
                         &arg_metric);
        }
    };

    struct Rib01RegisterInterest4Rsp :
      public Rib01RegisterInterest4CB {
        struct args_str {
            bool resolves;
            IPv4 base_addr;
            uint32_t prefix_len;
            uint32_t real_prefix_len;
            IPv4 nexthop;
            uint32_t metric;
        };

    private:
        args_str args;

    public:
        Rib01RegisterInterest4Rsp(const Rib01RegisterInterest4RF& cb)
          : Rib01RegisterInterest4CB(cb) { }

        void respond() const {
            Rib01RegisterInterest4CB::
            respond(args.resolves,
                        args.base_addr,
                        args.prefix_len,
                        args.real_prefix_len,
                        args.nexthop,
                        args.metric);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_register_interest4
       (
	const string&	target,
	const IPv4&	addr,
	Rib01RegisterInterest4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  De-register an interest in a route.
     *
     *  @param target the name of the XRL module that registered the interest.
     *
     *  @param addr the address of the previous registered interest. addr
     *  should be the base address of the add/prefix_len subnet.
     *
     *  @param prefix_len the prefix length of the registered interest, as
     *  given in the response from register_interest.
     */
    virtual XrlCmdError rib_0_1_deregister_interest4(
	// Input values,
	const string&	target,
	const IPv4&	addr,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeregisterInterest4RF;

    class Rib01DeregisterInterest4CB {
        Rib01DeregisterInterest4RF cb;

    public:
        operator const Rib01DeregisterInterest4RF& () const { return cb; }
        const Rib01DeregisterInterest4RF& operator ->() const { return cb; }
        Rib01DeregisterInterest4CB(const Rib01DeregisterInterest4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeregisterInterest4Rsp :
      public Rib01DeregisterInterest4CB {
        Rib01DeregisterInterest4Rsp(const Rib01DeregisterInterest4RF& cb)
          : Rib01DeregisterInterest4CB(cb) { }

    };

    virtual void async_rib_0_1_deregister_interest4
       (
	const string&	target,
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	Rib01DeregisterInterest4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Remove protocol's redistribution tags
     */
    virtual XrlCmdError rib_0_1_remove_policy_redist_tags(
	// Input values,
	const string&	protocol) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RemovePolicyRedistTagsRF;

    class Rib01RemovePolicyRedistTagsCB {
        Rib01RemovePolicyRedistTagsRF cb;

    public:
        operator const Rib01RemovePolicyRedistTagsRF& () const { return cb; }
        const Rib01RemovePolicyRedistTagsRF& operator ->() const { return cb; }
        Rib01RemovePolicyRedistTagsCB(const Rib01RemovePolicyRedistTagsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RemovePolicyRedistTagsRsp :
      public Rib01RemovePolicyRedistTagsCB {
        Rib01RemovePolicyRedistTagsRsp(const Rib01RemovePolicyRedistTagsRF& cb)
          : Rib01RemovePolicyRedistTagsCB(cb) { }

    };

    virtual void async_rib_0_1_remove_policy_redist_tags
       (
	const string&	protocol,
	Rib01RemovePolicyRedistTagsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add policy tags for a specific protcol in the redistribution map.
     *
     *  @param protocol The destination protocol of the redistribution.
     *
     *  @param policytags The set of policytags of interest for the protocol.
     */
    virtual XrlCmdError rib_0_1_insert_policy_redist_tags(
	// Input values,
	const string&	protocol,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01InsertPolicyRedistTagsRF;

    class Rib01InsertPolicyRedistTagsCB {
        Rib01InsertPolicyRedistTagsRF cb;

    public:
        operator const Rib01InsertPolicyRedistTagsRF& () const { return cb; }
        const Rib01InsertPolicyRedistTagsRF& operator ->() const { return cb; }
        Rib01InsertPolicyRedistTagsCB(const Rib01InsertPolicyRedistTagsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01InsertPolicyRedistTagsRsp :
      public Rib01InsertPolicyRedistTagsCB {
        Rib01InsertPolicyRedistTagsRsp(const Rib01InsertPolicyRedistTagsRF& cb)
          : Rib01InsertPolicyRedistTagsCB(cb) { }

    };

    virtual void async_rib_0_1_insert_policy_redist_tags
       (
	const string&	protocol,
	const XrlAtomList&	policytags,
	Rib01InsertPolicyRedistTagsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset the policy redistribution map. No policy based route
     *  redistribution will be available at this point.
     */
    virtual XrlCmdError rib_0_1_reset_policy_redist_tags() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01ResetPolicyRedistTagsRF;

    class Rib01ResetPolicyRedistTagsCB {
        Rib01ResetPolicyRedistTagsRF cb;

    public:
        operator const Rib01ResetPolicyRedistTagsRF& () const { return cb; }
        const Rib01ResetPolicyRedistTagsRF& operator ->() const { return cb; }
        Rib01ResetPolicyRedistTagsCB(const Rib01ResetPolicyRedistTagsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01ResetPolicyRedistTagsRsp :
      public Rib01ResetPolicyRedistTagsCB {
        Rib01ResetPolicyRedistTagsRsp(const Rib01ResetPolicyRedistTagsRF& cb)
          : Rib01ResetPolicyRedistTagsCB(cb) { }

    };

    virtual void async_rib_0_1_reset_policy_redist_tags
       (
	Rib01ResetPolicyRedistTagsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get administrative distance for all protocols registered as having an
     *  admin distance in a selected RIB.
     *
     *  @param ipv4 true if getting admin distances from IPv4 RIB; false if
     *  getting admin distances from IPv6 RIB.
     *
     *  @param unicast true if getting admin distances from unicast RIB; false
     *  if getting admin distances from multicast RIB.
     *
     *  @param protocols the list of protocols registered as having an admin
     *  distance in the selected RIB.
     *
     *  @ref protocols list.
     */
    virtual XrlCmdError rib_0_1_get_protocol_admin_distances(
	// Input values,
	const bool&	ipv4,
	const bool&	unicast,
	// Output values,
	XrlAtomList&	protocols,
	XrlAtomList&	admin_distances) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Rib01GetProtocolAdminDistancesRF;

    class Rib01GetProtocolAdminDistancesCB {
        Rib01GetProtocolAdminDistancesRF cb;

    public:
        operator const Rib01GetProtocolAdminDistancesRF& () const { return cb; }
        const Rib01GetProtocolAdminDistancesRF& operator ->() const { return cb; }
        Rib01GetProtocolAdminDistancesCB(const Rib01GetProtocolAdminDistancesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const XrlAtomList& arg_protocols,
                     const XrlAtomList& arg_admin_distances) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_protocols,
                         &arg_admin_distances);
        }
    };

    struct Rib01GetProtocolAdminDistancesRsp :
      public Rib01GetProtocolAdminDistancesCB {
        struct args_str {
            XrlAtomList protocols;
            XrlAtomList admin_distances;
        };

    private:
        args_str args;

    public:
        Rib01GetProtocolAdminDistancesRsp(const Rib01GetProtocolAdminDistancesRF& cb)
          : Rib01GetProtocolAdminDistancesCB(cb) { }

        void respond() const {
            Rib01GetProtocolAdminDistancesCB::
            respond(args.protocols,
                        args.admin_distances);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_get_protocol_admin_distances
       (
	const bool&	ipv4,
	const bool&	unicast,
	Rib01GetProtocolAdminDistancesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get administrative distance for an individual protocol in a selected
     *  RIB.
     *
     *  @param protocol the name of the protocol.
     *
     *  @param ipv4 true if getting admin distance from IPv4 RIB; false if
     *  getting admin distance from IPv6 RIB.
     *
     *  @param unicast true if getting admin distance from unicast RIB; false
     *  if getting admin distance from multicast RIB.
     *
     *  @param admin_distance the administrative distance (1-255)
     */
    virtual XrlCmdError rib_0_1_get_protocol_admin_distance(
	// Input values,
	const string&	protocol,
	const bool&	ipv4,
	const bool&	unicast,
	// Output values,
	uint32_t&	admin_distance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Rib01GetProtocolAdminDistanceRF;

    class Rib01GetProtocolAdminDistanceCB {
        Rib01GetProtocolAdminDistanceRF cb;

    public:
        operator const Rib01GetProtocolAdminDistanceRF& () const { return cb; }
        const Rib01GetProtocolAdminDistanceRF& operator ->() const { return cb; }
        Rib01GetProtocolAdminDistanceCB(const Rib01GetProtocolAdminDistanceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_admin_distance) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_admin_distance);
        }
    };

    struct Rib01GetProtocolAdminDistanceRsp :
      public Rib01GetProtocolAdminDistanceCB {
        struct args_str {
            uint32_t admin_distance;
        };

    private:
        args_str args;

    public:
        Rib01GetProtocolAdminDistanceRsp(const Rib01GetProtocolAdminDistanceRF& cb)
          : Rib01GetProtocolAdminDistanceCB(cb) { }

        void respond() const {
            Rib01GetProtocolAdminDistanceCB::
            respond(args.admin_distance);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_get_protocol_admin_distance
       (
	const string&	protocol,
	const bool&	ipv4,
	const bool&	unicast,
	Rib01GetProtocolAdminDistanceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set administrative distance for an individual protocol.
     *
     *  @param protocol the name of the protocol.
     *
     *  @param ipv4 true if setting admin distance for IPv4 RIB.
     *
     *  @param ipv6 true if setting admin distance for IPv6 RIB.
     *
     *  @param unicast true if setting admin distance for unicast RIB.
     *
     *  @param multicast true if setting admin distance for multicast RIB.
     *
     *  @param admin_distance the administrative distance (1-255)
     */
    virtual XrlCmdError rib_0_1_set_protocol_admin_distance(
	// Input values,
	const string&	protocol,
	const bool&	ipv4,
	const bool&	ipv6,
	const bool&	unicast,
	const bool&	multicast,
	const uint32_t&	admin_distance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01SetProtocolAdminDistanceRF;

    class Rib01SetProtocolAdminDistanceCB {
        Rib01SetProtocolAdminDistanceRF cb;

    public:
        operator const Rib01SetProtocolAdminDistanceRF& () const { return cb; }
        const Rib01SetProtocolAdminDistanceRF& operator ->() const { return cb; }
        Rib01SetProtocolAdminDistanceCB(const Rib01SetProtocolAdminDistanceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01SetProtocolAdminDistanceRsp :
      public Rib01SetProtocolAdminDistanceCB {
        Rib01SetProtocolAdminDistanceRsp(const Rib01SetProtocolAdminDistanceRF& cb)
          : Rib01SetProtocolAdminDistanceCB(cb) { }

    };

    virtual void async_rib_0_1_set_protocol_admin_distance
       (
	const string&	protocol,
	const bool&	ipv4,
	const bool&	ipv6,
	const bool&	unicast,
	const bool&	multicast,
	const uint32_t&	admin_distance,
	Rib01SetProtocolAdminDistanceCB);
#endif

    virtual XrlCmdError rib_0_1_add_igp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddIgpTable6RF;

    class Rib01AddIgpTable6CB {
        Rib01AddIgpTable6RF cb;

    public:
        operator const Rib01AddIgpTable6RF& () const { return cb; }
        const Rib01AddIgpTable6RF& operator ->() const { return cb; }
        Rib01AddIgpTable6CB(const Rib01AddIgpTable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddIgpTable6Rsp :
      public Rib01AddIgpTable6CB {
        Rib01AddIgpTable6Rsp(const Rib01AddIgpTable6RF& cb)
          : Rib01AddIgpTable6CB(cb) { }

    };

    virtual void async_rib_0_1_add_igp_table6
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01AddIgpTable6CB);
#endif

    virtual XrlCmdError rib_0_1_delete_igp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeleteIgpTable6RF;

    class Rib01DeleteIgpTable6CB {
        Rib01DeleteIgpTable6RF cb;

    public:
        operator const Rib01DeleteIgpTable6RF& () const { return cb; }
        const Rib01DeleteIgpTable6RF& operator ->() const { return cb; }
        Rib01DeleteIgpTable6CB(const Rib01DeleteIgpTable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeleteIgpTable6Rsp :
      public Rib01DeleteIgpTable6CB {
        Rib01DeleteIgpTable6Rsp(const Rib01DeleteIgpTable6RF& cb)
          : Rib01DeleteIgpTable6CB(cb) { }

    };

    virtual void async_rib_0_1_delete_igp_table6
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01DeleteIgpTable6CB);
#endif

    virtual XrlCmdError rib_0_1_add_egp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddEgpTable6RF;

    class Rib01AddEgpTable6CB {
        Rib01AddEgpTable6RF cb;

    public:
        operator const Rib01AddEgpTable6RF& () const { return cb; }
        const Rib01AddEgpTable6RF& operator ->() const { return cb; }
        Rib01AddEgpTable6CB(const Rib01AddEgpTable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddEgpTable6Rsp :
      public Rib01AddEgpTable6CB {
        Rib01AddEgpTable6Rsp(const Rib01AddEgpTable6RF& cb)
          : Rib01AddEgpTable6CB(cb) { }

    };

    virtual void async_rib_0_1_add_egp_table6
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01AddEgpTable6CB);
#endif

    virtual XrlCmdError rib_0_1_delete_egp_table6(
	// Input values,
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeleteEgpTable6RF;

    class Rib01DeleteEgpTable6CB {
        Rib01DeleteEgpTable6RF cb;

    public:
        operator const Rib01DeleteEgpTable6RF& () const { return cb; }
        const Rib01DeleteEgpTable6RF& operator ->() const { return cb; }
        Rib01DeleteEgpTable6CB(const Rib01DeleteEgpTable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeleteEgpTable6Rsp :
      public Rib01DeleteEgpTable6CB {
        Rib01DeleteEgpTable6Rsp(const Rib01DeleteEgpTable6RF& cb)
          : Rib01DeleteEgpTable6CB(cb) { }

    };

    virtual void async_rib_0_1_delete_egp_table6
       (
	const string&	protocol,
	const string&	target_class,
	const string&	target_instance,
	const bool&	unicast,
	const bool&	multicast,
	Rib01DeleteEgpTable6CB);
#endif

    virtual XrlCmdError rib_0_1_add_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddRoute6RF;

    class Rib01AddRoute6CB {
        Rib01AddRoute6RF cb;

    public:
        operator const Rib01AddRoute6RF& () const { return cb; }
        const Rib01AddRoute6RF& operator ->() const { return cb; }
        Rib01AddRoute6CB(const Rib01AddRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddRoute6Rsp :
      public Rib01AddRoute6CB {
        Rib01AddRoute6Rsp(const Rib01AddRoute6RF& cb)
          : Rib01AddRoute6CB(cb) { }

    };

    virtual void async_rib_0_1_add_route6
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01AddRoute6CB);
#endif

    virtual XrlCmdError rib_0_1_replace_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01ReplaceRoute6RF;

    class Rib01ReplaceRoute6CB {
        Rib01ReplaceRoute6RF cb;

    public:
        operator const Rib01ReplaceRoute6RF& () const { return cb; }
        const Rib01ReplaceRoute6RF& operator ->() const { return cb; }
        Rib01ReplaceRoute6CB(const Rib01ReplaceRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01ReplaceRoute6Rsp :
      public Rib01ReplaceRoute6CB {
        Rib01ReplaceRoute6Rsp(const Rib01ReplaceRoute6RF& cb)
          : Rib01ReplaceRoute6CB(cb) { }

    };

    virtual void async_rib_0_1_replace_route6
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01ReplaceRoute6CB);
#endif

    virtual XrlCmdError rib_0_1_delete_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeleteRoute6RF;

    class Rib01DeleteRoute6CB {
        Rib01DeleteRoute6RF cb;

    public:
        operator const Rib01DeleteRoute6RF& () const { return cb; }
        const Rib01DeleteRoute6RF& operator ->() const { return cb; }
        Rib01DeleteRoute6CB(const Rib01DeleteRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeleteRoute6Rsp :
      public Rib01DeleteRoute6CB {
        Rib01DeleteRoute6Rsp(const Rib01DeleteRoute6RF& cb)
          : Rib01DeleteRoute6CB(cb) { }

    };

    virtual void async_rib_0_1_delete_route6
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	Rib01DeleteRoute6CB);
#endif

    virtual XrlCmdError rib_0_1_add_interface_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddInterfaceRoute6RF;

    class Rib01AddInterfaceRoute6CB {
        Rib01AddInterfaceRoute6RF cb;

    public:
        operator const Rib01AddInterfaceRoute6RF& () const { return cb; }
        const Rib01AddInterfaceRoute6RF& operator ->() const { return cb; }
        Rib01AddInterfaceRoute6CB(const Rib01AddInterfaceRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddInterfaceRoute6Rsp :
      public Rib01AddInterfaceRoute6CB {
        Rib01AddInterfaceRoute6Rsp(const Rib01AddInterfaceRoute6RF& cb)
          : Rib01AddInterfaceRoute6CB(cb) { }

    };

    virtual void async_rib_0_1_add_interface_route6
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01AddInterfaceRoute6CB);
#endif

    virtual XrlCmdError rib_0_1_replace_interface_route6(
	// Input values,
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01ReplaceInterfaceRoute6RF;

    class Rib01ReplaceInterfaceRoute6CB {
        Rib01ReplaceInterfaceRoute6RF cb;

    public:
        operator const Rib01ReplaceInterfaceRoute6RF& () const { return cb; }
        const Rib01ReplaceInterfaceRoute6RF& operator ->() const { return cb; }
        Rib01ReplaceInterfaceRoute6CB(const Rib01ReplaceInterfaceRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01ReplaceInterfaceRoute6Rsp :
      public Rib01ReplaceInterfaceRoute6CB {
        Rib01ReplaceInterfaceRoute6Rsp(const Rib01ReplaceInterfaceRoute6RF& cb)
          : Rib01ReplaceInterfaceRoute6CB(cb) { }

    };

    virtual void async_rib_0_1_replace_interface_route6
       (
	const string&	protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	Rib01ReplaceInterfaceRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup nexthop.
     *
     *  @param addr address to lookup.
     *
     *  @param unicast look in unicast RIB.
     *
     *  @param multicast look in multicast RIB.
     *
     *  @param nexthop contains the resolved nexthop if successful, IPv6::ZERO
     *  otherwise. It is an error for the unicast and multicast fields to both
     *  be true or both false.
     */
    virtual XrlCmdError rib_0_1_lookup_route_by_dest6(
	// Input values,
	const IPv6&	addr,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	IPv6&	nexthop) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv6*>::RefPtr
    Rib01LookupRouteByDest6RF;

    class Rib01LookupRouteByDest6CB {
        Rib01LookupRouteByDest6RF cb;

    public:
        operator const Rib01LookupRouteByDest6RF& () const { return cb; }
        const Rib01LookupRouteByDest6RF& operator ->() const { return cb; }
        Rib01LookupRouteByDest6CB(const Rib01LookupRouteByDest6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv6& arg_nexthop) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_nexthop);
        }
    };

    struct Rib01LookupRouteByDest6Rsp :
      public Rib01LookupRouteByDest6CB {
        struct args_str {
            IPv6 nexthop;
        };

    private:
        args_str args;

    public:
        Rib01LookupRouteByDest6Rsp(const Rib01LookupRouteByDest6RF& cb)
          : Rib01LookupRouteByDest6CB(cb) { }

        void respond() const {
            Rib01LookupRouteByDest6CB::
            respond(args.nexthop);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_lookup_route_by_dest6
       (
	const IPv6&	addr,
	const bool&	unicast,
	const bool&	multicast,
	Rib01LookupRouteByDest6CB);
#endif

    virtual XrlCmdError rib_0_1_add_vif_addr6(
	// Input values,
	const string&	name,
	const IPv6&	addr,
	const IPv6Net&	subnet) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01AddVifAddr6RF;

    class Rib01AddVifAddr6CB {
        Rib01AddVifAddr6RF cb;

    public:
        operator const Rib01AddVifAddr6RF& () const { return cb; }
        const Rib01AddVifAddr6RF& operator ->() const { return cb; }
        Rib01AddVifAddr6CB(const Rib01AddVifAddr6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01AddVifAddr6Rsp :
      public Rib01AddVifAddr6CB {
        Rib01AddVifAddr6Rsp(const Rib01AddVifAddr6RF& cb)
          : Rib01AddVifAddr6CB(cb) { }

    };

    virtual void async_rib_0_1_add_vif_addr6
       (
	const string&	name,
	const IPv6&	addr,
	const IPv6Net&	subnet,
	Rib01AddVifAddr6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist6/0.1.
     *
     *  @param from_protocol the name of the routing process routes are to be
     *  redistributed from.
     *
     *  @param unicast enable for unicast RIBs matching from and to.
     *
     *  @param multicast enable for multicast RIBs matching from and to.
     *
     *  @param network_prefix redistribite only the routes that fall into this
     *  prefix address.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist6/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_enable6(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network_prefix,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistEnable6RF;

    class Rib01RedistEnable6CB {
        Rib01RedistEnable6RF cb;

    public:
        operator const Rib01RedistEnable6RF& () const { return cb; }
        const Rib01RedistEnable6RF& operator ->() const { return cb; }
        Rib01RedistEnable6CB(const Rib01RedistEnable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistEnable6Rsp :
      public Rib01RedistEnable6CB {
        Rib01RedistEnable6Rsp(const Rib01RedistEnable6RF& cb)
          : Rib01RedistEnable6CB(cb) { }

    };

    virtual void async_rib_0_1_redist_enable6
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network_prefix,
	const string&	cookie,
	Rib01RedistEnable6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable route redistribution from one routing protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist6/0.1 and previously called redist_enable6.
     *
     *  @param unicast disable for unicast RIBs matching from and to.
     *
     *  @param multicast disable for multicast RIBs matching from and to.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist6/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_disable6(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistDisable6RF;

    class Rib01RedistDisable6CB {
        Rib01RedistDisable6RF cb;

    public:
        operator const Rib01RedistDisable6RF& () const { return cb; }
        const Rib01RedistDisable6RF& operator ->() const { return cb; }
        Rib01RedistDisable6CB(const Rib01RedistDisable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistDisable6Rsp :
      public Rib01RedistDisable6CB {
        Rib01RedistDisable6Rsp(const Rib01RedistDisable6RF& cb)
          : Rib01RedistDisable6CB(cb) { }

    };

    virtual void async_rib_0_1_redist_disable6
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie,
	Rib01RedistDisable6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable transaction-based route redistribution from one routing protocol
     *  to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist_transaction6/0.1.
     *
     *  @param from_protocol the name of the routing process routes are to be
     *  redistributed from.
     *
     *  @param unicast enable for unicast RIBs matching from and to.
     *
     *  @param multicast enable for multicast RIBs matching from and to.
     *
     *  @param network_prefix redistribite only the routes that fall into this
     *  prefix address.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist_transaction6/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_transaction_enable6(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network_prefix,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistTransactionEnable6RF;

    class Rib01RedistTransactionEnable6CB {
        Rib01RedistTransactionEnable6RF cb;

    public:
        operator const Rib01RedistTransactionEnable6RF& () const { return cb; }
        const Rib01RedistTransactionEnable6RF& operator ->() const { return cb; }
        Rib01RedistTransactionEnable6CB(const Rib01RedistTransactionEnable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistTransactionEnable6Rsp :
      public Rib01RedistTransactionEnable6CB {
        Rib01RedistTransactionEnable6Rsp(const Rib01RedistTransactionEnable6RF& cb)
          : Rib01RedistTransactionEnable6CB(cb) { }

    };

    virtual void async_rib_0_1_redist_transaction_enable6
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6Net&	network_prefix,
	const string&	cookie,
	Rib01RedistTransactionEnable6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable transaction-based route redistribution from one routing
     *  protocol to another.
     *
     *  @param to_xrl_target the XRL Target instance name of the caller. The
     *  caller must implement redist_transaction6/0.1 and previously called
     *  redist_transaction_enable6.
     *
     *  @param unicast disable for unicast RIBs matching from and to.
     *
     *  @param multicast disable for multicast RIBs matching from and to.
     *
     *  @param cookie a text value passed back to creator in each call from the
     *  RIB. This allows creators to identity the source of updates it receives
     *  through the redist_transaction6/0.1 interface.
     */
    virtual XrlCmdError rib_0_1_redist_transaction_disable6(
	// Input values,
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01RedistTransactionDisable6RF;

    class Rib01RedistTransactionDisable6CB {
        Rib01RedistTransactionDisable6RF cb;

    public:
        operator const Rib01RedistTransactionDisable6RF& () const { return cb; }
        const Rib01RedistTransactionDisable6RF& operator ->() const { return cb; }
        Rib01RedistTransactionDisable6CB(const Rib01RedistTransactionDisable6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01RedistTransactionDisable6Rsp :
      public Rib01RedistTransactionDisable6CB {
        Rib01RedistTransactionDisable6Rsp(const Rib01RedistTransactionDisable6RF& cb)
          : Rib01RedistTransactionDisable6CB(cb) { }

    };

    virtual void async_rib_0_1_redist_transaction_disable6
       (
	const string&	to_xrl_target,
	const string&	from_protocol,
	const bool&	unicast,
	const bool&	multicast,
	const string&	cookie,
	Rib01RedistTransactionDisable6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register an interest in a route.
     *
     *  @param target the name of the XRL module to notify when the information
     *  returned by this call becomes invalid.
     *
     *  @param addr address of interest.
     *
     *  @param resolves returns whether or not the address resolves to a route
     *  that can be used for forwarding.
     *
     *  @param base_addr returns the address of interest (actually the base
     *  address of the subnet covered by addr/prefix_len).
     *
     *  @param prefix_len returns the prefix length that the registration
     *  covers. This response applies to all addresses in addr/prefix_len.
     *
     *  @param real_prefix_len returns the actual prefix length of the route
     *  that will be used to route addr. If real_prefix_len is not the same as
     *  prefix_len, this is because there are some more specific routes that
     *  overlap addr/real_prefix_len. real_prefix_len is primarily given for
     *  debugging reasons.
     *
     *  @param nexthop returns the address of the next hop for packets sent to
     *  addr.
     *
     *  @param metric returns the IGP metric for this route.
     */
    virtual XrlCmdError rib_0_1_register_interest6(
	// Input values,
	const string&	target,
	const IPv6&	addr,
	// Output values,
	bool&	resolves,
	IPv6&	base_addr,
	uint32_t&	prefix_len,
	uint32_t&	real_prefix_len,
	IPv6&	nexthop,
	uint32_t&	metric) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const bool*,
	const IPv6*,
	const uint32_t*,
	const uint32_t*,
	const IPv6*,
	const uint32_t*>::RefPtr
    Rib01RegisterInterest6RF;

    class Rib01RegisterInterest6CB {
        Rib01RegisterInterest6RF cb;

    public:
        operator const Rib01RegisterInterest6RF& () const { return cb; }
        const Rib01RegisterInterest6RF& operator ->() const { return cb; }
        Rib01RegisterInterest6CB(const Rib01RegisterInterest6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const bool& arg_resolves,
                     const IPv6& arg_base_addr,
                     const uint32_t& arg_prefix_len,
                     const uint32_t& arg_real_prefix_len,
                     const IPv6& arg_nexthop,
                     const uint32_t& arg_metric) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_resolves,
                         &arg_base_addr,
                         &arg_prefix_len,
                         &arg_real_prefix_len,
                         &arg_nexthop,
                         &arg_metric);
        }
    };

    struct Rib01RegisterInterest6Rsp :
      public Rib01RegisterInterest6CB {
        struct args_str {
            bool resolves;
            IPv6 base_addr;
            uint32_t prefix_len;
            uint32_t real_prefix_len;
            IPv6 nexthop;
            uint32_t metric;
        };

    private:
        args_str args;

    public:
        Rib01RegisterInterest6Rsp(const Rib01RegisterInterest6RF& cb)
          : Rib01RegisterInterest6CB(cb) { }

        void respond() const {
            Rib01RegisterInterest6CB::
            respond(args.resolves,
                        args.base_addr,
                        args.prefix_len,
                        args.real_prefix_len,
                        args.nexthop,
                        args.metric);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_rib_0_1_register_interest6
       (
	const string&	target,
	const IPv6&	addr,
	Rib01RegisterInterest6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  De-register an interest in a route.
     *
     *  @param target the name of the XRL module that registered the interest.
     *
     *  @param addr the address of the previous registered interest. addr
     *  should be the base address of the add/prefix_len subnet.
     *
     *  @param prefix_len the prefix length of the registered interest, as
     *  given in the response from register_interest.
     */
    virtual XrlCmdError rib_0_1_deregister_interest6(
	// Input values,
	const string&	target,
	const IPv6&	addr,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Rib01DeregisterInterest6RF;

    class Rib01DeregisterInterest6CB {
        Rib01DeregisterInterest6RF cb;

    public:
        operator const Rib01DeregisterInterest6RF& () const { return cb; }
        const Rib01DeregisterInterest6RF& operator ->() const { return cb; }
        Rib01DeregisterInterest6CB(const Rib01DeregisterInterest6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Rib01DeregisterInterest6Rsp :
      public Rib01DeregisterInterest6CB {
        Rib01DeregisterInterest6Rsp(const Rib01DeregisterInterest6RF& cb)
          : Rib01DeregisterInterest6CB(cb) { }

    };

    virtual void async_rib_0_1_deregister_interest6
       (
	const string&	target,
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	Rib01DeregisterInterest6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_enable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01EnableRF;

    class Profile01EnableCB {
        Profile01EnableRF cb;

    public:
        operator const Profile01EnableRF& () const { return cb; }
        const Profile01EnableRF& operator ->() const { return cb; }
        Profile01EnableCB(const Profile01EnableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01EnableRsp :
      public Profile01EnableCB {
        Profile01EnableRsp(const Profile01EnableRF& cb)
          : Profile01EnableCB(cb) { }

    };

    virtual void async_profile_0_1_enable
       (
	const string&	pname,
	Profile01EnableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_disable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01DisableRF;

    class Profile01DisableCB {
        Profile01DisableRF cb;

    public:
        operator const Profile01DisableRF& () const { return cb; }
        const Profile01DisableRF& operator ->() const { return cb; }
        Profile01DisableCB(const Profile01DisableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01DisableRsp :
      public Profile01DisableCB {
        Profile01DisableRsp(const Profile01DisableRF& cb)
          : Profile01DisableCB(cb) { }

    };

    virtual void async_profile_0_1_disable
       (
	const string&	pname,
	Profile01DisableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get log entries.
     *
     *  @param pname profile variable
     *
     *  @param instance_name to send the profiling info to.
     */
    virtual XrlCmdError profile_0_1_get_entries(
	// Input values,
	const string&	pname,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01GetEntriesRF;

    class Profile01GetEntriesCB {
        Profile01GetEntriesRF cb;

    public:
        operator const Profile01GetEntriesRF& () const { return cb; }
        const Profile01GetEntriesRF& operator ->() const { return cb; }
        Profile01GetEntriesCB(const Profile01GetEntriesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01GetEntriesRsp :
      public Profile01GetEntriesCB {
        Profile01GetEntriesRsp(const Profile01GetEntriesRF& cb)
          : Profile01GetEntriesCB(cb) { }

    };

    virtual void async_profile_0_1_get_entries
       (
	const string&	pname,
	const string&	instance_name,
	Profile01GetEntriesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the profiling entries
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_clear(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01ClearRF;

    class Profile01ClearCB {
        Profile01ClearRF cb;

    public:
        operator const Profile01ClearRF& () const { return cb; }
        const Profile01ClearRF& operator ->() const { return cb; }
        Profile01ClearCB(const Profile01ClearRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01ClearRsp :
      public Profile01ClearCB {
        Profile01ClearRsp(const Profile01ClearRF& cb)
          : Profile01ClearCB(cb) { }

    };

    virtual void async_profile_0_1_clear
       (
	const string&	pname,
	Profile01ClearCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  List all the profiling variables registered with this target.
     */
    virtual XrlCmdError profile_0_1_list(
	// Output values,
	string&	info) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Profile01ListRF;

    class Profile01ListCB {
        Profile01ListRF cb;

    public:
        operator const Profile01ListRF& () const { return cb; }
        const Profile01ListRF& operator ->() const { return cb; }
        Profile01ListCB(const Profile01ListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_info) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_info);
        }
    };

    struct Profile01ListRsp :
      public Profile01ListCB {
        struct args_str {
            string info;
        };

    private:
        args_str args;

    public:
        Profile01ListRsp(const Profile01ListRF& cb)
          : Profile01ListCB(cb) { }

        void respond() const {
            Profile01ListCB::
            respond(args.info);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_profile_0_1_list
       (
	Profile01ListCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_enable_rib(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_enable_rib
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_disable_rib(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_disable_rib
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_start_rib(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_start_rib
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_stop_rib(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_stop_rib
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_make_errors_fatal(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_make_errors_fatal
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_get_registered_protocols(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_get_registered_protocols
       (const XrlCmdError &e,
	const XrlAtomList* arg_ipv4_unicast_protocols,
	const XrlAtomList* arg_ipv6_unicast_protocols,
	const XrlAtomList* arg_ipv4_multicast_protocols,
	const XrlAtomList* arg_ipv6_multicast_protocols,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_igp_table4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_igp_table4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_delete_igp_table4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_delete_igp_table4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_egp_table4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_egp_table4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_delete_egp_table4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_delete_egp_table4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_replace_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_replace_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_delete_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_delete_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_interface_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_interface_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_replace_interface_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_replace_interface_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_lookup_route_by_dest4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_lookup_route_by_dest4
       (const XrlCmdError &e,
	const IPv4* arg_nexthop,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_new_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_new_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_vif_addr4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_vif_addr4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_enable4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_enable4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_disable4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_disable4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_transaction_enable4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_transaction_enable4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_transaction_disable4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_transaction_disable4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_register_interest4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_register_interest4
       (const XrlCmdError &e,
	const bool* arg_resolves,
	const IPv4* arg_base_addr,
	const uint32_t* arg_prefix_len,
	const uint32_t* arg_real_prefix_len,
	const IPv4* arg_nexthop,
	const uint32_t* arg_metric,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_deregister_interest4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_deregister_interest4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_remove_policy_redist_tags(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_remove_policy_redist_tags
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_insert_policy_redist_tags(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_insert_policy_redist_tags
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_reset_policy_redist_tags(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_reset_policy_redist_tags
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_get_protocol_admin_distances(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_get_protocol_admin_distances
       (const XrlCmdError &e,
	const XrlAtomList* arg_protocols,
	const XrlAtomList* arg_admin_distances,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_get_protocol_admin_distance(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_get_protocol_admin_distance
       (const XrlCmdError &e,
	const uint32_t* arg_admin_distance,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_set_protocol_admin_distance(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_set_protocol_admin_distance
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_igp_table6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_igp_table6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_delete_igp_table6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_delete_igp_table6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_egp_table6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_egp_table6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_delete_egp_table6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_delete_egp_table6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_replace_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_replace_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_delete_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_delete_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_interface_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_interface_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_replace_interface_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_replace_interface_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_lookup_route_by_dest6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_lookup_route_by_dest6
       (const XrlCmdError &e,
	const IPv6* arg_nexthop,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_add_vif_addr6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_add_vif_addr6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_enable6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_enable6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_disable6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_disable6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_transaction_enable6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_transaction_enable6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_redist_transaction_disable6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_redist_transaction_disable6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_register_interest6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_register_interest6
       (const XrlCmdError &e,
	const bool* arg_resolves,
	const IPv6* arg_base_addr,
	const uint32_t* arg_prefix_len,
	const uint32_t* arg_real_prefix_len,
	const IPv6* arg_nexthop,
	const uint32_t* arg_metric,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_0_1_deregister_interest6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_0_1_deregister_interest6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_enable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_enable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_disable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_disable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_get_entries(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_get_entries
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_clear(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_clear
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_list
       (const XrlCmdError &e,
	const string* arg_info,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlRibTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_RIB_BASE_HH__
