/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/olsr4_base.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#include "olsr4_base.hh"


const struct XrlOlsr4TargetBase::handler_table XrlOlsr4TargetBase::handlers[] = {
    { "common/0.1/get_target_name",
      &XrlOlsr4TargetBase::handle_common_0_1_get_target_name },
    { "common/0.1/get_version",
      &XrlOlsr4TargetBase::handle_common_0_1_get_version },
    { "common/0.1/get_status",
      &XrlOlsr4TargetBase::handle_common_0_1_get_status },
    { "common/0.1/shutdown",
      &XrlOlsr4TargetBase::handle_common_0_1_shutdown },
    { "common/0.1/startup",
      &XrlOlsr4TargetBase::handle_common_0_1_startup },
    { "finder_event_observer/0.1/xrl_target_birth",
      &XrlOlsr4TargetBase::handle_finder_event_observer_0_1_xrl_target_birth },
    { "finder_event_observer/0.1/xrl_target_death",
      &XrlOlsr4TargetBase::handle_finder_event_observer_0_1_xrl_target_death },
    { "socket4_user/0.1/recv_event",
      &XrlOlsr4TargetBase::handle_socket4_user_0_1_recv_event },
    { "socket4_user/0.1/inbound_connect_event",
      &XrlOlsr4TargetBase::handle_socket4_user_0_1_inbound_connect_event },
    { "socket4_user/0.1/outgoing_connect_event",
      &XrlOlsr4TargetBase::handle_socket4_user_0_1_outgoing_connect_event },
    { "socket4_user/0.1/error_event",
      &XrlOlsr4TargetBase::handle_socket4_user_0_1_error_event },
    { "socket4_user/0.1/disconnect_event",
      &XrlOlsr4TargetBase::handle_socket4_user_0_1_disconnect_event },
    { "policy_backend/0.1/configure",
      &XrlOlsr4TargetBase::handle_policy_backend_0_1_configure },
    { "policy_backend/0.1/reset",
      &XrlOlsr4TargetBase::handle_policy_backend_0_1_reset },
    { "policy_backend/0.1/push_routes",
      &XrlOlsr4TargetBase::handle_policy_backend_0_1_push_routes },
    { "policy_redist4/0.1/add_route4",
      &XrlOlsr4TargetBase::handle_policy_redist4_0_1_add_route4 },
    { "policy_redist4/0.1/delete_route4",
      &XrlOlsr4TargetBase::handle_policy_redist4_0_1_delete_route4 },
    { "profile/0.1/enable",
      &XrlOlsr4TargetBase::handle_profile_0_1_enable },
    { "profile/0.1/disable",
      &XrlOlsr4TargetBase::handle_profile_0_1_disable },
    { "profile/0.1/get_entries",
      &XrlOlsr4TargetBase::handle_profile_0_1_get_entries },
    { "profile/0.1/clear",
      &XrlOlsr4TargetBase::handle_profile_0_1_clear },
    { "profile/0.1/list",
      &XrlOlsr4TargetBase::handle_profile_0_1_list },
    { "olsr4/0.1/trace",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_trace },
    { "olsr4/0.1/clear_database",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_clear_database },
    { "olsr4/0.1/set_willingness",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_willingness },
    { "olsr4/0.1/get_willingness",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_willingness },
    { "olsr4/0.1/set_mpr_coverage",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_mpr_coverage },
    { "olsr4/0.1/get_mpr_coverage",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_mpr_coverage },
    { "olsr4/0.1/set_tc_redundancy",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_tc_redundancy },
    { "olsr4/0.1/get_tc_redundancy",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_redundancy },
    { "olsr4/0.1/set_tc_fisheye",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_tc_fisheye },
    { "olsr4/0.1/get_tc_fisheye",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_fisheye },
    { "olsr4/0.1/set_hna_base_cost",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_hna_base_cost },
    { "olsr4/0.1/get_hna_base_cost",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_base_cost },
    { "olsr4/0.1/set_hello_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_hello_interval },
    { "olsr4/0.1/get_hello_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_hello_interval },
    { "olsr4/0.1/set_refresh_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_refresh_interval },
    { "olsr4/0.1/get_refresh_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_refresh_interval },
    { "olsr4/0.1/set_tc_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_tc_interval },
    { "olsr4/0.1/get_tc_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_interval },
    { "olsr4/0.1/set_mid_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_mid_interval },
    { "olsr4/0.1/get_mid_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_mid_interval },
    { "olsr4/0.1/set_hna_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_hna_interval },
    { "olsr4/0.1/get_hna_interval",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_interval },
    { "olsr4/0.1/set_dup_hold_time",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_dup_hold_time },
    { "olsr4/0.1/get_dup_hold_time",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_dup_hold_time },
    { "olsr4/0.1/set_main_address",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_main_address },
    { "olsr4/0.1/get_main_address",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_main_address },
    { "olsr4/0.1/bind_address",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_bind_address },
    { "olsr4/0.1/unbind_address",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_unbind_address },
    { "olsr4/0.1/set_binding_enabled",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_binding_enabled },
    { "olsr4/0.1/get_binding_enabled",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_binding_enabled },
    { "olsr4/0.1/change_local_addr_port",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_change_local_addr_port },
    { "olsr4/0.1/change_all_nodes_addr_port",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_change_all_nodes_addr_port },
    { "olsr4/0.1/get_interface_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_interface_list },
    { "olsr4/0.1/get_interface_info",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_interface_info },
    { "olsr4/0.1/set_interface_cost",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_set_interface_cost },
    { "olsr4/0.1/get_interface_stats",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_interface_stats },
    { "olsr4/0.1/get_link_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_link_list },
    { "olsr4/0.1/get_link_info",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_link_info },
    { "olsr4/0.1/get_neighbor_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_neighbor_list },
    { "olsr4/0.1/get_neighbor_info",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_neighbor_info },
    { "olsr4/0.1/get_twohop_link_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_link_list },
    { "olsr4/0.1/get_twohop_link_info",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_link_info },
    { "olsr4/0.1/get_twohop_neighbor_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_neighbor_list },
    { "olsr4/0.1/get_twohop_neighbor_info",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_neighbor_info },
    { "olsr4/0.1/get_mid_entry_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_mid_entry_list },
    { "olsr4/0.1/get_mid_entry",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_mid_entry },
    { "olsr4/0.1/get_tc_entry_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_entry_list },
    { "olsr4/0.1/get_tc_entry",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_entry },
    { "olsr4/0.1/get_hna_entry_list",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_entry_list },
    { "olsr4/0.1/get_hna_entry",
      &XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_entry },
};

const size_t XrlOlsr4TargetBase::num_handlers = (sizeof(XrlOlsr4TargetBase::handlers) / sizeof(XrlOlsr4TargetBase::handlers[0]));


XrlOlsr4TargetBase::XrlOlsr4TargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlOlsr4TargetBase::~XrlOlsr4TargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlOlsr4TargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_common_0_1_get_target_name
    (const XrlCmdError &e,
     const string* rarg_name,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_target_name", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("name", *rarg_name);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_common_0_1_get_target_name(
	Common01GetTargetNameCB c_b)
{

    /* Return value declarations */
    string rarg_name;
    XrlCmdError e = common_0_1_get_target_name(
        rarg_name);
    return c_b->dispatch(e,
        &rarg_name);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_common_0_1_get_target_name(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_target_name");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetTargetNameRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_common_0_1_get_target_name, pxa_outputs);
	async_common_0_1_get_target_name( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_name;
    try {
	XrlCmdError e = common_0_1_get_target_name(
	    r_name);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_target_name", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("name", r_name);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_common_0_1_get_version
    (const XrlCmdError &e,
     const string* rarg_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("version", *rarg_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_common_0_1_get_version(
	Common01GetVersionCB c_b)
{

    /* Return value declarations */
    string rarg_version;
    XrlCmdError e = common_0_1_get_version(
        rarg_version);
    return c_b->dispatch(e,
        &rarg_version);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_common_0_1_get_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetVersionRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_common_0_1_get_version, pxa_outputs);
	async_common_0_1_get_version( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_version;
    try {
	XrlCmdError e = common_0_1_get_version(
	    r_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", r_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_common_0_1_get_status
    (const XrlCmdError &e,
     const uint32_t* rarg_status,
     const string* rarg_reason,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_status", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("status", *rarg_status);
	    out.add("reason", *rarg_reason);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_common_0_1_get_status(
	Common01GetStatusCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_status;
    string rarg_reason;
    XrlCmdError e = common_0_1_get_status(
        rarg_status,
        rarg_reason);
    return c_b->dispatch(e,
        &rarg_status,
        &rarg_reason);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_common_0_1_get_status(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_status");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetStatusRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_common_0_1_get_status, pxa_outputs);
	async_common_0_1_get_status( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_status;
    string r_reason;
    try {
	XrlCmdError e = common_0_1_get_status(
	    r_status,
	    r_reason);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_status", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("status", r_status);
	pxa_outputs->add("reason", r_reason);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_common_0_1_shutdown
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/shutdown", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_common_0_1_shutdown(
	Common01ShutdownCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_shutdown();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_common_0_1_shutdown(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/shutdown");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01ShutdownRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_common_0_1_shutdown, pxa_outputs);
	async_common_0_1_shutdown( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_shutdown();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_common_0_1_startup
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/startup", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_common_0_1_startup(
	Common01StartupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_startup();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_common_0_1_startup(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/startup");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01StartupRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_common_0_1_startup, pxa_outputs);
	async_common_0_1_startup( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_startup();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/startup", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_finder_event_observer_0_1_xrl_target_birth
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_finder_event_observer_0_1_xrl_target_birth(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetBirthCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_birth");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetBirthRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_finder_event_observer_0_1_xrl_target_birth, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_finder_event_observer_0_1_xrl_target_death
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_finder_event_observer_0_1_xrl_target_death(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetDeathCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_death");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetDeathRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_finder_event_observer_0_1_xrl_target_death, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_socket4_user_0_1_recv_event
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4_user/0.1/recv_event", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_socket4_user_0_1_recv_event(
	const string&	arg_sockid,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const IPv4&	arg_src_host,
	const uint32_t&	arg_src_port,
	const vector<uint8_t>&	arg_data,
	Socket4User01RecvEventCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_user_0_1_recv_event(
        arg_sockid,
        arg_if_name,
        arg_vif_name,
        arg_src_host,
        arg_src_port,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_socket4_user_0_1_recv_event(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "socket4_user/0.1/recv_event");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket4User01RecvEventRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_socket4_user_0_1_recv_event, pxa_outputs);
	async_socket4_user_0_1_recv_event(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "src_host").ipv4(),
	    xa_inputs.get(4, "src_port").uint32(),
	    xa_inputs.get(5, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_user_0_1_recv_event(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "src_host").ipv4(),
	    xa_inputs.get(4, "src_port").uint32(),
	    xa_inputs.get(5, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4_user/0.1/recv_event", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_socket4_user_0_1_inbound_connect_event
    (const XrlCmdError &e,
     const bool* rarg_accept,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4_user/0.1/inbound_connect_event", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("accept", *rarg_accept);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_socket4_user_0_1_inbound_connect_event(
	const string&	arg_sockid,
	const IPv4&	arg_src_host,
	const uint32_t&	arg_src_port,
	const string&	arg_new_sockid,
	Socket4User01InboundConnectEventCB c_b)
{

    /* Return value declarations */
    bool rarg_accept;
    XrlCmdError e = socket4_user_0_1_inbound_connect_event(
        arg_sockid,
        arg_src_host,
        arg_src_port,
        arg_new_sockid,
        rarg_accept);
    return c_b->dispatch(e,
        &rarg_accept);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_socket4_user_0_1_inbound_connect_event(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "socket4_user/0.1/inbound_connect_event");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket4User01InboundConnectEventRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_socket4_user_0_1_inbound_connect_event, pxa_outputs);
	async_socket4_user_0_1_inbound_connect_event(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "src_host").ipv4(),
	    xa_inputs.get(2, "src_port").uint32(),
	    xa_inputs.get(3, "new_sockid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_accept;
    try {
	XrlCmdError e = socket4_user_0_1_inbound_connect_event(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "src_host").ipv4(),
	    xa_inputs.get(2, "src_port").uint32(),
	    xa_inputs.get(3, "new_sockid").text(),
	    r_accept);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4_user/0.1/inbound_connect_event", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("accept", r_accept);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_socket4_user_0_1_outgoing_connect_event
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4_user/0.1/outgoing_connect_event", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_socket4_user_0_1_outgoing_connect_event(
	const string&	arg_sockid,
	Socket4User01OutgoingConnectEventCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_user_0_1_outgoing_connect_event(
        arg_sockid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_socket4_user_0_1_outgoing_connect_event(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4_user/0.1/outgoing_connect_event");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket4User01OutgoingConnectEventRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_socket4_user_0_1_outgoing_connect_event, pxa_outputs);
	async_socket4_user_0_1_outgoing_connect_event(
	    xa_inputs.get(0, "sockid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_user_0_1_outgoing_connect_event(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4_user/0.1/outgoing_connect_event", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_socket4_user_0_1_error_event
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4_user/0.1/error_event", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_socket4_user_0_1_error_event(
	const string&	arg_sockid,
	const string&	arg_error,
	const bool&	arg_fatal,
	Socket4User01ErrorEventCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_user_0_1_error_event(
        arg_sockid,
        arg_error,
        arg_fatal);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_socket4_user_0_1_error_event(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4_user/0.1/error_event");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket4User01ErrorEventRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_socket4_user_0_1_error_event, pxa_outputs);
	async_socket4_user_0_1_error_event(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "error").text(),
	    xa_inputs.get(2, "fatal").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_user_0_1_error_event(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "error").text(),
	    xa_inputs.get(2, "fatal").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4_user/0.1/error_event", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_socket4_user_0_1_disconnect_event
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4_user/0.1/disconnect_event", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_socket4_user_0_1_disconnect_event(
	const string&	arg_sockid,
	Socket4User01DisconnectEventCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_user_0_1_disconnect_event(
        arg_sockid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_socket4_user_0_1_disconnect_event(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4_user/0.1/disconnect_event");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket4User01DisconnectEventRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_socket4_user_0_1_disconnect_event, pxa_outputs);
	async_socket4_user_0_1_disconnect_event(
	    xa_inputs.get(0, "sockid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_user_0_1_disconnect_event(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4_user/0.1/disconnect_event", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_policy_backend_0_1_configure
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_backend/0.1/configure", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_policy_backend_0_1_configure(
	const uint32_t&	arg_filter,
	const string&	arg_conf,
	PolicyBackend01ConfigureCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_backend_0_1_configure(
        arg_filter,
        arg_conf);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_policy_backend_0_1_configure(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "policy_backend/0.1/configure");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyBackend01ConfigureRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_policy_backend_0_1_configure, pxa_outputs);
	async_policy_backend_0_1_configure(
	    xa_inputs.get(0, "filter").uint32(),
	    xa_inputs.get(1, "conf").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_backend_0_1_configure(
	    xa_inputs.get(0, "filter").uint32(),
	    xa_inputs.get(1, "conf").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_backend/0.1/configure", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_policy_backend_0_1_reset
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_backend/0.1/reset", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_policy_backend_0_1_reset(
	const uint32_t&	arg_filter,
	PolicyBackend01ResetCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_backend_0_1_reset(
        arg_filter);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_policy_backend_0_1_reset(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "policy_backend/0.1/reset");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyBackend01ResetRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_policy_backend_0_1_reset, pxa_outputs);
	async_policy_backend_0_1_reset(
	    xa_inputs.get(0, "filter").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_backend_0_1_reset(
	    xa_inputs.get(0, "filter").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_backend/0.1/reset", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_policy_backend_0_1_push_routes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_backend/0.1/push_routes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_policy_backend_0_1_push_routes(
	PolicyBackend01PushRoutesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_backend_0_1_push_routes();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_policy_backend_0_1_push_routes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "policy_backend/0.1/push_routes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyBackend01PushRoutesRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_policy_backend_0_1_push_routes, pxa_outputs);
	async_policy_backend_0_1_push_routes( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_backend_0_1_push_routes();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_backend/0.1/push_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_policy_redist4_0_1_add_route4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_redist4/0.1/add_route4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_policy_redist4_0_1_add_route4(
	const IPv4Net&	arg_network,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	const IPv4&	arg_nexthop,
	const uint32_t&	arg_metric,
	const XrlAtomList&	arg_policytags,
	PolicyRedist401AddRoute4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_redist4_0_1_add_route4(
        arg_network,
        arg_unicast,
        arg_multicast,
        arg_nexthop,
        arg_metric,
        arg_policytags);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_policy_redist4_0_1_add_route4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "policy_redist4/0.1/add_route4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyRedist401AddRoute4RF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_policy_redist4_0_1_add_route4, pxa_outputs);
	async_policy_redist4_0_1_add_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    xa_inputs.get(3, "nexthop").ipv4(),
	    xa_inputs.get(4, "metric").uint32(),
	    xa_inputs.get(5, "policytags").list(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_redist4_0_1_add_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    xa_inputs.get(3, "nexthop").ipv4(),
	    xa_inputs.get(4, "metric").uint32(),
	    xa_inputs.get(5, "policytags").list());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_redist4/0.1/add_route4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_policy_redist4_0_1_delete_route4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_redist4/0.1/delete_route4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_policy_redist4_0_1_delete_route4(
	const IPv4Net&	arg_network,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	PolicyRedist401DeleteRoute4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_redist4_0_1_delete_route4(
        arg_network,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_policy_redist4_0_1_delete_route4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "policy_redist4/0.1/delete_route4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyRedist401DeleteRoute4RF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_policy_redist4_0_1_delete_route4, pxa_outputs);
	async_policy_redist4_0_1_delete_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_redist4_0_1_delete_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_redist4/0.1/delete_route4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_profile_0_1_enable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/enable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_profile_0_1_enable(
	const string&	arg_pname,
	Profile01EnableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_enable(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_profile_0_1_enable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/enable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01EnableRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_profile_0_1_enable, pxa_outputs);
	async_profile_0_1_enable(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_enable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/enable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_profile_0_1_disable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/disable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_profile_0_1_disable(
	const string&	arg_pname,
	Profile01DisableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_disable(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_profile_0_1_disable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/disable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01DisableRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_profile_0_1_disable, pxa_outputs);
	async_profile_0_1_disable(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_disable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/disable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_profile_0_1_get_entries
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/get_entries", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_profile_0_1_get_entries(
	const string&	arg_pname,
	const string&	arg_instance_name,
	Profile01GetEntriesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_get_entries(
        arg_pname,
        arg_instance_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_profile_0_1_get_entries(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/get_entries");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01GetEntriesRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_profile_0_1_get_entries, pxa_outputs);
	async_profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/get_entries", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_profile_0_1_clear
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/clear", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_profile_0_1_clear(
	const string&	arg_pname,
	Profile01ClearCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_clear(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_profile_0_1_clear(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/clear");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01ClearRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_profile_0_1_clear, pxa_outputs);
	async_profile_0_1_clear(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_clear(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/clear", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_profile_0_1_list
    (const XrlCmdError &e,
     const string* rarg_info,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("info", *rarg_info);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_profile_0_1_list(
	Profile01ListCB c_b)
{

    /* Return value declarations */
    string rarg_info;
    XrlCmdError e = profile_0_1_list(
        rarg_info);
    return c_b->dispatch(e,
        &rarg_info);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_profile_0_1_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01ListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_profile_0_1_list, pxa_outputs);
	async_profile_0_1_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_info;
    try {
	XrlCmdError e = profile_0_1_list(
	    r_info);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("info", r_info);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_trace
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/trace", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_trace(
	const string&	arg_tvar,
	const bool&	arg_enable,
	Olsr401TraceCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_trace(
        arg_tvar,
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_trace(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/trace");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401TraceRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_trace, pxa_outputs);
	async_olsr4_0_1_trace(
	    xa_inputs.get(0, "tvar").text(),
	    xa_inputs.get(1, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_trace(
	    xa_inputs.get(0, "tvar").text(),
	    xa_inputs.get(1, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/trace", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_clear_database
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/clear_database", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_clear_database(
	Olsr401ClearDatabaseCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_clear_database();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_clear_database(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/clear_database");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401ClearDatabaseRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_clear_database, pxa_outputs);
	async_olsr4_0_1_clear_database( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_clear_database();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/clear_database", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_willingness
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_willingness", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_willingness(
	const uint32_t&	arg_willingness,
	Olsr401SetWillingnessCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_willingness(
        arg_willingness);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_willingness(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_willingness");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetWillingnessRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_willingness, pxa_outputs);
	async_olsr4_0_1_set_willingness(
	    xa_inputs.get(0, "willingness").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_willingness(
	    xa_inputs.get(0, "willingness").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_willingness", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_willingness
    (const XrlCmdError &e,
     const uint32_t* rarg_willingness,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_willingness", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("willingness", *rarg_willingness);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_willingness(
	Olsr401GetWillingnessCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_willingness;
    XrlCmdError e = olsr4_0_1_get_willingness(
        rarg_willingness);
    return c_b->dispatch(e,
        &rarg_willingness);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_willingness(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_willingness");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetWillingnessRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_willingness, pxa_outputs);
	async_olsr4_0_1_get_willingness( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_willingness;
    try {
	XrlCmdError e = olsr4_0_1_get_willingness(
	    r_willingness);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_willingness", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("willingness", r_willingness);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_mpr_coverage
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_mpr_coverage", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_mpr_coverage(
	const uint32_t&	arg_coverage,
	Olsr401SetMprCoverageCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_mpr_coverage(
        arg_coverage);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_mpr_coverage(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_mpr_coverage");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetMprCoverageRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_mpr_coverage, pxa_outputs);
	async_olsr4_0_1_set_mpr_coverage(
	    xa_inputs.get(0, "coverage").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_mpr_coverage(
	    xa_inputs.get(0, "coverage").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_mpr_coverage", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_mpr_coverage
    (const XrlCmdError &e,
     const uint32_t* rarg_coverage,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_mpr_coverage", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("coverage", *rarg_coverage);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_mpr_coverage(
	Olsr401GetMprCoverageCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_coverage;
    XrlCmdError e = olsr4_0_1_get_mpr_coverage(
        rarg_coverage);
    return c_b->dispatch(e,
        &rarg_coverage);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_mpr_coverage(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_mpr_coverage");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetMprCoverageRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_mpr_coverage, pxa_outputs);
	async_olsr4_0_1_get_mpr_coverage( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_coverage;
    try {
	XrlCmdError e = olsr4_0_1_get_mpr_coverage(
	    r_coverage);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_mpr_coverage", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("coverage", r_coverage);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_tc_redundancy
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_tc_redundancy", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_tc_redundancy(
	const string&	arg_redundancy,
	Olsr401SetTcRedundancyCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_tc_redundancy(
        arg_redundancy);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_tc_redundancy(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_tc_redundancy");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetTcRedundancyRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_tc_redundancy, pxa_outputs);
	async_olsr4_0_1_set_tc_redundancy(
	    xa_inputs.get(0, "redundancy").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_tc_redundancy(
	    xa_inputs.get(0, "redundancy").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_tc_redundancy", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_redundancy
    (const XrlCmdError &e,
     const string* rarg_redundancy,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_tc_redundancy", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("redundancy", *rarg_redundancy);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_tc_redundancy(
	Olsr401GetTcRedundancyCB c_b)
{

    /* Return value declarations */
    string rarg_redundancy;
    XrlCmdError e = olsr4_0_1_get_tc_redundancy(
        rarg_redundancy);
    return c_b->dispatch(e,
        &rarg_redundancy);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_redundancy(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_tc_redundancy");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTcRedundancyRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_redundancy, pxa_outputs);
	async_olsr4_0_1_get_tc_redundancy( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_redundancy;
    try {
	XrlCmdError e = olsr4_0_1_get_tc_redundancy(
	    r_redundancy);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_tc_redundancy", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("redundancy", r_redundancy);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_tc_fisheye
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_tc_fisheye", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_tc_fisheye(
	const bool&	arg_enabled,
	Olsr401SetTcFisheyeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_tc_fisheye(
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_tc_fisheye(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_tc_fisheye");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetTcFisheyeRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_tc_fisheye, pxa_outputs);
	async_olsr4_0_1_set_tc_fisheye(
	    xa_inputs.get(0, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_tc_fisheye(
	    xa_inputs.get(0, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_tc_fisheye", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_fisheye
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_tc_fisheye", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_tc_fisheye(
	Olsr401GetTcFisheyeCB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = olsr4_0_1_get_tc_fisheye(
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_fisheye(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_tc_fisheye");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTcFisheyeRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_fisheye, pxa_outputs);
	async_olsr4_0_1_get_tc_fisheye( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = olsr4_0_1_get_tc_fisheye(
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_tc_fisheye", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_hna_base_cost
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_hna_base_cost", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_hna_base_cost(
	const uint32_t&	arg_metric,
	Olsr401SetHnaBaseCostCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_hna_base_cost(
        arg_metric);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_hna_base_cost(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_hna_base_cost");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetHnaBaseCostRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_hna_base_cost, pxa_outputs);
	async_olsr4_0_1_set_hna_base_cost(
	    xa_inputs.get(0, "metric").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_hna_base_cost(
	    xa_inputs.get(0, "metric").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_hna_base_cost", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_base_cost
    (const XrlCmdError &e,
     const uint32_t* rarg_metric,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_hna_base_cost", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("metric", *rarg_metric);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_hna_base_cost(
	Olsr401GetHnaBaseCostCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_metric;
    XrlCmdError e = olsr4_0_1_get_hna_base_cost(
        rarg_metric);
    return c_b->dispatch(e,
        &rarg_metric);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_base_cost(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_hna_base_cost");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetHnaBaseCostRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_base_cost, pxa_outputs);
	async_olsr4_0_1_get_hna_base_cost( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_metric;
    try {
	XrlCmdError e = olsr4_0_1_get_hna_base_cost(
	    r_metric);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_hna_base_cost", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("metric", r_metric);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_hello_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_hello_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_hello_interval(
	const uint32_t&	arg_interval,
	Olsr401SetHelloIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_hello_interval(
        arg_interval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_hello_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_hello_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetHelloIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_hello_interval, pxa_outputs);
	async_olsr4_0_1_set_hello_interval(
	    xa_inputs.get(0, "interval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_hello_interval(
	    xa_inputs.get(0, "interval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_hello_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_hello_interval
    (const XrlCmdError &e,
     const uint32_t* rarg_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_hello_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("interval", *rarg_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_hello_interval(
	Olsr401GetHelloIntervalCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_interval;
    XrlCmdError e = olsr4_0_1_get_hello_interval(
        rarg_interval);
    return c_b->dispatch(e,
        &rarg_interval);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_hello_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_hello_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetHelloIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_hello_interval, pxa_outputs);
	async_olsr4_0_1_get_hello_interval( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_interval;
    try {
	XrlCmdError e = olsr4_0_1_get_hello_interval(
	    r_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_hello_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval", r_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_refresh_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_refresh_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_refresh_interval(
	const uint32_t&	arg_interval,
	Olsr401SetRefreshIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_refresh_interval(
        arg_interval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_refresh_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_refresh_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetRefreshIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_refresh_interval, pxa_outputs);
	async_olsr4_0_1_set_refresh_interval(
	    xa_inputs.get(0, "interval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_refresh_interval(
	    xa_inputs.get(0, "interval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_refresh_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_refresh_interval
    (const XrlCmdError &e,
     const uint32_t* rarg_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_refresh_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("interval", *rarg_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_refresh_interval(
	Olsr401GetRefreshIntervalCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_interval;
    XrlCmdError e = olsr4_0_1_get_refresh_interval(
        rarg_interval);
    return c_b->dispatch(e,
        &rarg_interval);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_refresh_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_refresh_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetRefreshIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_refresh_interval, pxa_outputs);
	async_olsr4_0_1_get_refresh_interval( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_interval;
    try {
	XrlCmdError e = olsr4_0_1_get_refresh_interval(
	    r_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_refresh_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval", r_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_tc_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_tc_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_tc_interval(
	const uint32_t&	arg_interval,
	Olsr401SetTcIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_tc_interval(
        arg_interval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_tc_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_tc_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetTcIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_tc_interval, pxa_outputs);
	async_olsr4_0_1_set_tc_interval(
	    xa_inputs.get(0, "interval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_tc_interval(
	    xa_inputs.get(0, "interval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_tc_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_interval
    (const XrlCmdError &e,
     const uint32_t* rarg_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_tc_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("interval", *rarg_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_tc_interval(
	Olsr401GetTcIntervalCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_interval;
    XrlCmdError e = olsr4_0_1_get_tc_interval(
        rarg_interval);
    return c_b->dispatch(e,
        &rarg_interval);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_tc_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTcIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_interval, pxa_outputs);
	async_olsr4_0_1_get_tc_interval( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_interval;
    try {
	XrlCmdError e = olsr4_0_1_get_tc_interval(
	    r_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_tc_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval", r_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_mid_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_mid_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_mid_interval(
	const uint32_t&	arg_interval,
	Olsr401SetMidIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_mid_interval(
        arg_interval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_mid_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_mid_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetMidIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_mid_interval, pxa_outputs);
	async_olsr4_0_1_set_mid_interval(
	    xa_inputs.get(0, "interval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_mid_interval(
	    xa_inputs.get(0, "interval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_mid_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_mid_interval
    (const XrlCmdError &e,
     const uint32_t* rarg_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_mid_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("interval", *rarg_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_mid_interval(
	Olsr401GetMidIntervalCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_interval;
    XrlCmdError e = olsr4_0_1_get_mid_interval(
        rarg_interval);
    return c_b->dispatch(e,
        &rarg_interval);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_mid_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_mid_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetMidIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_mid_interval, pxa_outputs);
	async_olsr4_0_1_get_mid_interval( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_interval;
    try {
	XrlCmdError e = olsr4_0_1_get_mid_interval(
	    r_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_mid_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval", r_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_hna_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_hna_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_hna_interval(
	const uint32_t&	arg_interval,
	Olsr401SetHnaIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_hna_interval(
        arg_interval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_hna_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_hna_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetHnaIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_hna_interval, pxa_outputs);
	async_olsr4_0_1_set_hna_interval(
	    xa_inputs.get(0, "interval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_hna_interval(
	    xa_inputs.get(0, "interval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_hna_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_interval
    (const XrlCmdError &e,
     const uint32_t* rarg_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_hna_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("interval", *rarg_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_hna_interval(
	Olsr401GetHnaIntervalCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_interval;
    XrlCmdError e = olsr4_0_1_get_hna_interval(
        rarg_interval);
    return c_b->dispatch(e,
        &rarg_interval);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_hna_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetHnaIntervalRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_interval, pxa_outputs);
	async_olsr4_0_1_get_hna_interval( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_interval;
    try {
	XrlCmdError e = olsr4_0_1_get_hna_interval(
	    r_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_hna_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interval", r_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_dup_hold_time
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_dup_hold_time", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_dup_hold_time(
	const uint32_t&	arg_dup_hold_time,
	Olsr401SetDupHoldTimeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_dup_hold_time(
        arg_dup_hold_time);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_dup_hold_time(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_dup_hold_time");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetDupHoldTimeRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_dup_hold_time, pxa_outputs);
	async_olsr4_0_1_set_dup_hold_time(
	    xa_inputs.get(0, "dup_hold_time").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_dup_hold_time(
	    xa_inputs.get(0, "dup_hold_time").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_dup_hold_time", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_dup_hold_time
    (const XrlCmdError &e,
     const uint32_t* rarg_dup_hold_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_dup_hold_time", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("dup_hold_time", *rarg_dup_hold_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_dup_hold_time(
	Olsr401GetDupHoldTimeCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_dup_hold_time;
    XrlCmdError e = olsr4_0_1_get_dup_hold_time(
        rarg_dup_hold_time);
    return c_b->dispatch(e,
        &rarg_dup_hold_time);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_dup_hold_time(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_dup_hold_time");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetDupHoldTimeRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_dup_hold_time, pxa_outputs);
	async_olsr4_0_1_get_dup_hold_time( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_dup_hold_time;
    try {
	XrlCmdError e = olsr4_0_1_get_dup_hold_time(
	    r_dup_hold_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_dup_hold_time", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("dup_hold_time", r_dup_hold_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_main_address
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_main_address", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_main_address(
	const IPv4&	arg_addr,
	Olsr401SetMainAddressCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_main_address(
        arg_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_main_address(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_main_address");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetMainAddressRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_main_address, pxa_outputs);
	async_olsr4_0_1_set_main_address(
	    xa_inputs.get(0, "addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_main_address(
	    xa_inputs.get(0, "addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_main_address", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_main_address
    (const XrlCmdError &e,
     const IPv4* rarg_addr,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_main_address", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("addr", *rarg_addr);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_main_address(
	Olsr401GetMainAddressCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_addr;
    XrlCmdError e = olsr4_0_1_get_main_address(
        rarg_addr);
    return c_b->dispatch(e,
        &rarg_addr);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_main_address(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_main_address");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetMainAddressRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_main_address, pxa_outputs);
	async_olsr4_0_1_get_main_address( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_addr;
    try {
	XrlCmdError e = olsr4_0_1_get_main_address(
	    r_addr);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_main_address", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("addr", r_addr);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_bind_address
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/bind_address", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_bind_address(
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv4&	arg_all_nodes_addr,
	const uint32_t&	arg_all_nodes_port,
	Olsr401BindAddressCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_bind_address(
        arg_ifname,
        arg_vifname,
        arg_local_addr,
        arg_local_port,
        arg_all_nodes_addr,
        arg_all_nodes_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_bind_address(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/bind_address");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401BindAddressRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_bind_address, pxa_outputs);
	async_olsr4_0_1_bind_address(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "local_addr").ipv4(),
	    xa_inputs.get(3, "local_port").uint32(),
	    xa_inputs.get(4, "all_nodes_addr").ipv4(),
	    xa_inputs.get(5, "all_nodes_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_bind_address(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "local_addr").ipv4(),
	    xa_inputs.get(3, "local_port").uint32(),
	    xa_inputs.get(4, "all_nodes_addr").ipv4(),
	    xa_inputs.get(5, "all_nodes_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/bind_address", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_unbind_address
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/unbind_address", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_unbind_address(
	const string&	arg_ifname,
	const string&	arg_vifname,
	Olsr401UnbindAddressCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_unbind_address(
        arg_ifname,
        arg_vifname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_unbind_address(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/unbind_address");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401UnbindAddressRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_unbind_address, pxa_outputs);
	async_olsr4_0_1_unbind_address(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_unbind_address(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/unbind_address", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_binding_enabled
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_binding_enabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_binding_enabled(
	const string&	arg_ifname,
	const string&	arg_vifname,
	const bool&	arg_enabled,
	Olsr401SetBindingEnabledCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_binding_enabled(
        arg_ifname,
        arg_vifname,
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_binding_enabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_binding_enabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetBindingEnabledRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_binding_enabled, pxa_outputs);
	async_olsr4_0_1_set_binding_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_binding_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_binding_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_binding_enabled
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_binding_enabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_binding_enabled(
	const string&	arg_ifname,
	const string&	arg_vifname,
	Olsr401GetBindingEnabledCB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = olsr4_0_1_get_binding_enabled(
        arg_ifname,
        arg_vifname,
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_binding_enabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_binding_enabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetBindingEnabledRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_binding_enabled, pxa_outputs);
	async_olsr4_0_1_get_binding_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = olsr4_0_1_get_binding_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_binding_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_change_local_addr_port
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/change_local_addr_port", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_change_local_addr_port(
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	Olsr401ChangeLocalAddrPortCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_change_local_addr_port(
        arg_ifname,
        arg_vifname,
        arg_local_addr,
        arg_local_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_change_local_addr_port(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/change_local_addr_port");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401ChangeLocalAddrPortRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_change_local_addr_port, pxa_outputs);
	async_olsr4_0_1_change_local_addr_port(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "local_addr").ipv4(),
	    xa_inputs.get(3, "local_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_change_local_addr_port(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "local_addr").ipv4(),
	    xa_inputs.get(3, "local_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/change_local_addr_port", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_change_all_nodes_addr_port
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/change_all_nodes_addr_port", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_change_all_nodes_addr_port(
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv4&	arg_all_nodes_addr,
	const uint32_t&	arg_all_nodes_port,
	Olsr401ChangeAllNodesAddrPortCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_change_all_nodes_addr_port(
        arg_ifname,
        arg_vifname,
        arg_all_nodes_addr,
        arg_all_nodes_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_change_all_nodes_addr_port(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/change_all_nodes_addr_port");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401ChangeAllNodesAddrPortRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_change_all_nodes_addr_port, pxa_outputs);
	async_olsr4_0_1_change_all_nodes_addr_port(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "all_nodes_addr").ipv4(),
	    xa_inputs.get(3, "all_nodes_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_change_all_nodes_addr_port(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "all_nodes_addr").ipv4(),
	    xa_inputs.get(3, "all_nodes_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/change_all_nodes_addr_port", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_interface_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_interfaces,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_interface_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("interfaces", *rarg_interfaces);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_interface_list(
	Olsr401GetInterfaceListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_interfaces;
    XrlCmdError e = olsr4_0_1_get_interface_list(
        rarg_interfaces);
    return c_b->dispatch(e,
        &rarg_interfaces);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_interface_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_interface_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetInterfaceListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_interface_list, pxa_outputs);
	async_olsr4_0_1_get_interface_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_interfaces;
    try {
	XrlCmdError e = olsr4_0_1_get_interface_list(
	    r_interfaces);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_interface_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("interfaces", r_interfaces);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_interface_info
    (const XrlCmdError &e,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const IPv4* rarg_local_addr,
     const uint32_t* rarg_local_port,
     const IPv4* rarg_all_nodes_addr,
     const uint32_t* rarg_all_nodes_port,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_interface_info", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("local_addr", *rarg_local_addr);
	    out.add("local_port", *rarg_local_port);
	    out.add("all_nodes_addr", *rarg_all_nodes_addr);
	    out.add("all_nodes_port", *rarg_all_nodes_port);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_interface_info(
	const uint32_t&	arg_faceid,
	Olsr401GetInterfaceInfoCB c_b)
{

    /* Return value declarations */
    string rarg_ifname;
    string rarg_vifname;
    IPv4 rarg_local_addr;
    uint32_t rarg_local_port;
    IPv4 rarg_all_nodes_addr;
    uint32_t rarg_all_nodes_port;
    XrlCmdError e = olsr4_0_1_get_interface_info(
        arg_faceid,
        rarg_ifname,
        rarg_vifname,
        rarg_local_addr,
        rarg_local_port,
        rarg_all_nodes_addr,
        rarg_all_nodes_port);
    return c_b->dispatch(e,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_local_addr,
        &rarg_local_port,
        &rarg_all_nodes_addr,
        &rarg_all_nodes_port);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_interface_info(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_interface_info");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetInterfaceInfoRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_interface_info, pxa_outputs);
	async_olsr4_0_1_get_interface_info(
	    xa_inputs.get(0, "faceid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_ifname;
    string r_vifname;
    IPv4 r_local_addr;
    uint32_t r_local_port;
    IPv4 r_all_nodes_addr;
    uint32_t r_all_nodes_port;
    try {
	XrlCmdError e = olsr4_0_1_get_interface_info(
	    xa_inputs.get(0, "faceid").uint32(),
	    r_ifname,
	    r_vifname,
	    r_local_addr,
	    r_local_port,
	    r_all_nodes_addr,
	    r_all_nodes_port);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_interface_info", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("local_addr", r_local_addr);
	pxa_outputs->add("local_port", r_local_port);
	pxa_outputs->add("all_nodes_addr", r_all_nodes_addr);
	pxa_outputs->add("all_nodes_port", r_all_nodes_port);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_set_interface_cost
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/set_interface_cost", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_set_interface_cost(
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_cost,
	Olsr401SetInterfaceCostCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = olsr4_0_1_set_interface_cost(
        arg_ifname,
        arg_vifname,
        arg_cost);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_set_interface_cost(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/set_interface_cost");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401SetInterfaceCostRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_set_interface_cost, pxa_outputs);
	async_olsr4_0_1_set_interface_cost(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "cost").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = olsr4_0_1_set_interface_cost(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    xa_inputs.get(2, "cost").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/set_interface_cost", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_interface_stats
    (const XrlCmdError &e,
     const uint32_t* rarg_bad_packets,
     const uint32_t* rarg_bad_messages,
     const uint32_t* rarg_messages_from_self,
     const uint32_t* rarg_unknown_messages,
     const uint32_t* rarg_duplicates,
     const uint32_t* rarg_forwarded,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_interface_stats", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("bad_packets", *rarg_bad_packets);
	    out.add("bad_messages", *rarg_bad_messages);
	    out.add("messages_from_self", *rarg_messages_from_self);
	    out.add("unknown_messages", *rarg_unknown_messages);
	    out.add("duplicates", *rarg_duplicates);
	    out.add("forwarded", *rarg_forwarded);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_interface_stats(
	const string&	arg_ifname,
	const string&	arg_vifname,
	Olsr401GetInterfaceStatsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_bad_packets;
    uint32_t rarg_bad_messages;
    uint32_t rarg_messages_from_self;
    uint32_t rarg_unknown_messages;
    uint32_t rarg_duplicates;
    uint32_t rarg_forwarded;
    XrlCmdError e = olsr4_0_1_get_interface_stats(
        arg_ifname,
        arg_vifname,
        rarg_bad_packets,
        rarg_bad_messages,
        rarg_messages_from_self,
        rarg_unknown_messages,
        rarg_duplicates,
        rarg_forwarded);
    return c_b->dispatch(e,
        &rarg_bad_packets,
        &rarg_bad_messages,
        &rarg_messages_from_self,
        &rarg_unknown_messages,
        &rarg_duplicates,
        &rarg_forwarded);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_interface_stats(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_interface_stats");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetInterfaceStatsRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_interface_stats, pxa_outputs);
	async_olsr4_0_1_get_interface_stats(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_bad_packets;
    uint32_t r_bad_messages;
    uint32_t r_messages_from_self;
    uint32_t r_unknown_messages;
    uint32_t r_duplicates;
    uint32_t r_forwarded;
    try {
	XrlCmdError e = olsr4_0_1_get_interface_stats(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vifname").text(),
	    r_bad_packets,
	    r_bad_messages,
	    r_messages_from_self,
	    r_unknown_messages,
	    r_duplicates,
	    r_forwarded);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_interface_stats", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("bad_packets", r_bad_packets);
	pxa_outputs->add("bad_messages", r_bad_messages);
	pxa_outputs->add("messages_from_self", r_messages_from_self);
	pxa_outputs->add("unknown_messages", r_unknown_messages);
	pxa_outputs->add("duplicates", r_duplicates);
	pxa_outputs->add("forwarded", r_forwarded);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_link_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_links,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_link_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("links", *rarg_links);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_link_list(
	Olsr401GetLinkListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_links;
    XrlCmdError e = olsr4_0_1_get_link_list(
        rarg_links);
    return c_b->dispatch(e,
        &rarg_links);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_link_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_link_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetLinkListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_link_list, pxa_outputs);
	async_olsr4_0_1_get_link_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_links;
    try {
	XrlCmdError e = olsr4_0_1_get_link_list(
	    r_links);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_link_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("links", r_links);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_link_info
    (const XrlCmdError &e,
     const IPv4* rarg_local_addr,
     const IPv4* rarg_remote_addr,
     const IPv4* rarg_main_addr,
     const uint32_t* rarg_link_type,
     const uint32_t* rarg_sym_time,
     const uint32_t* rarg_asym_time,
     const uint32_t* rarg_hold_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_link_info", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("local_addr", *rarg_local_addr);
	    out.add("remote_addr", *rarg_remote_addr);
	    out.add("main_addr", *rarg_main_addr);
	    out.add("link_type", *rarg_link_type);
	    out.add("sym_time", *rarg_sym_time);
	    out.add("asym_time", *rarg_asym_time);
	    out.add("hold_time", *rarg_hold_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_link_info(
	const uint32_t&	arg_linkid,
	Olsr401GetLinkInfoCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_local_addr;
    IPv4 rarg_remote_addr;
    IPv4 rarg_main_addr;
    uint32_t rarg_link_type;
    uint32_t rarg_sym_time;
    uint32_t rarg_asym_time;
    uint32_t rarg_hold_time;
    XrlCmdError e = olsr4_0_1_get_link_info(
        arg_linkid,
        rarg_local_addr,
        rarg_remote_addr,
        rarg_main_addr,
        rarg_link_type,
        rarg_sym_time,
        rarg_asym_time,
        rarg_hold_time);
    return c_b->dispatch(e,
        &rarg_local_addr,
        &rarg_remote_addr,
        &rarg_main_addr,
        &rarg_link_type,
        &rarg_sym_time,
        &rarg_asym_time,
        &rarg_hold_time);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_link_info(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_link_info");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetLinkInfoRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_link_info, pxa_outputs);
	async_olsr4_0_1_get_link_info(
	    xa_inputs.get(0, "linkid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_local_addr;
    IPv4 r_remote_addr;
    IPv4 r_main_addr;
    uint32_t r_link_type;
    uint32_t r_sym_time;
    uint32_t r_asym_time;
    uint32_t r_hold_time;
    try {
	XrlCmdError e = olsr4_0_1_get_link_info(
	    xa_inputs.get(0, "linkid").uint32(),
	    r_local_addr,
	    r_remote_addr,
	    r_main_addr,
	    r_link_type,
	    r_sym_time,
	    r_asym_time,
	    r_hold_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_link_info", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("local_addr", r_local_addr);
	pxa_outputs->add("remote_addr", r_remote_addr);
	pxa_outputs->add("main_addr", r_main_addr);
	pxa_outputs->add("link_type", r_link_type);
	pxa_outputs->add("sym_time", r_sym_time);
	pxa_outputs->add("asym_time", r_asym_time);
	pxa_outputs->add("hold_time", r_hold_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_neighbor_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_neighbors,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_neighbor_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("neighbors", *rarg_neighbors);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_neighbor_list(
	Olsr401GetNeighborListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_neighbors;
    XrlCmdError e = olsr4_0_1_get_neighbor_list(
        rarg_neighbors);
    return c_b->dispatch(e,
        &rarg_neighbors);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_neighbor_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_neighbor_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetNeighborListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_neighbor_list, pxa_outputs);
	async_olsr4_0_1_get_neighbor_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_neighbors;
    try {
	XrlCmdError e = olsr4_0_1_get_neighbor_list(
	    r_neighbors);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_neighbor_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("neighbors", r_neighbors);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_neighbor_info
    (const XrlCmdError &e,
     const IPv4* rarg_main_addr,
     const uint32_t* rarg_willingness,
     const uint32_t* rarg_degree,
     const uint32_t* rarg_link_count,
     const uint32_t* rarg_twohop_link_count,
     const bool* rarg_is_advertised,
     const bool* rarg_is_sym,
     const bool* rarg_is_mpr,
     const bool* rarg_is_mpr_selector,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_neighbor_info", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("main_addr", *rarg_main_addr);
	    out.add("willingness", *rarg_willingness);
	    out.add("degree", *rarg_degree);
	    out.add("link_count", *rarg_link_count);
	    out.add("twohop_link_count", *rarg_twohop_link_count);
	    out.add("is_advertised", *rarg_is_advertised);
	    out.add("is_sym", *rarg_is_sym);
	    out.add("is_mpr", *rarg_is_mpr);
	    out.add("is_mpr_selector", *rarg_is_mpr_selector);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_neighbor_info(
	const uint32_t&	arg_nid,
	Olsr401GetNeighborInfoCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_main_addr;
    uint32_t rarg_willingness;
    uint32_t rarg_degree;
    uint32_t rarg_link_count;
    uint32_t rarg_twohop_link_count;
    bool rarg_is_advertised;
    bool rarg_is_sym;
    bool rarg_is_mpr;
    bool rarg_is_mpr_selector;
    XrlCmdError e = olsr4_0_1_get_neighbor_info(
        arg_nid,
        rarg_main_addr,
        rarg_willingness,
        rarg_degree,
        rarg_link_count,
        rarg_twohop_link_count,
        rarg_is_advertised,
        rarg_is_sym,
        rarg_is_mpr,
        rarg_is_mpr_selector);
    return c_b->dispatch(e,
        &rarg_main_addr,
        &rarg_willingness,
        &rarg_degree,
        &rarg_link_count,
        &rarg_twohop_link_count,
        &rarg_is_advertised,
        &rarg_is_sym,
        &rarg_is_mpr,
        &rarg_is_mpr_selector);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_neighbor_info(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_neighbor_info");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetNeighborInfoRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_neighbor_info, pxa_outputs);
	async_olsr4_0_1_get_neighbor_info(
	    xa_inputs.get(0, "nid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_main_addr;
    uint32_t r_willingness;
    uint32_t r_degree;
    uint32_t r_link_count;
    uint32_t r_twohop_link_count;
    bool r_is_advertised;
    bool r_is_sym;
    bool r_is_mpr;
    bool r_is_mpr_selector;
    try {
	XrlCmdError e = olsr4_0_1_get_neighbor_info(
	    xa_inputs.get(0, "nid").uint32(),
	    r_main_addr,
	    r_willingness,
	    r_degree,
	    r_link_count,
	    r_twohop_link_count,
	    r_is_advertised,
	    r_is_sym,
	    r_is_mpr,
	    r_is_mpr_selector);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_neighbor_info", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("main_addr", r_main_addr);
	pxa_outputs->add("willingness", r_willingness);
	pxa_outputs->add("degree", r_degree);
	pxa_outputs->add("link_count", r_link_count);
	pxa_outputs->add("twohop_link_count", r_twohop_link_count);
	pxa_outputs->add("is_advertised", r_is_advertised);
	pxa_outputs->add("is_sym", r_is_sym);
	pxa_outputs->add("is_mpr", r_is_mpr);
	pxa_outputs->add("is_mpr_selector", r_is_mpr_selector);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_link_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_twohop_links,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_twohop_link_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("twohop_links", *rarg_twohop_links);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_twohop_link_list(
	Olsr401GetTwohopLinkListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_twohop_links;
    XrlCmdError e = olsr4_0_1_get_twohop_link_list(
        rarg_twohop_links);
    return c_b->dispatch(e,
        &rarg_twohop_links);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_link_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_twohop_link_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTwohopLinkListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_link_list, pxa_outputs);
	async_olsr4_0_1_get_twohop_link_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_twohop_links;
    try {
	XrlCmdError e = olsr4_0_1_get_twohop_link_list(
	    r_twohop_links);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_twohop_link_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("twohop_links", r_twohop_links);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_link_info
    (const XrlCmdError &e,
     const uint32_t* rarg_last_face_id,
     const IPv4* rarg_nexthop_addr,
     const IPv4* rarg_dest_addr,
     const uint32_t* rarg_hold_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_twohop_link_info", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("last_face_id", *rarg_last_face_id);
	    out.add("nexthop_addr", *rarg_nexthop_addr);
	    out.add("dest_addr", *rarg_dest_addr);
	    out.add("hold_time", *rarg_hold_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_twohop_link_info(
	const uint32_t&	arg_tlid,
	Olsr401GetTwohopLinkInfoCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_last_face_id;
    IPv4 rarg_nexthop_addr;
    IPv4 rarg_dest_addr;
    uint32_t rarg_hold_time;
    XrlCmdError e = olsr4_0_1_get_twohop_link_info(
        arg_tlid,
        rarg_last_face_id,
        rarg_nexthop_addr,
        rarg_dest_addr,
        rarg_hold_time);
    return c_b->dispatch(e,
        &rarg_last_face_id,
        &rarg_nexthop_addr,
        &rarg_dest_addr,
        &rarg_hold_time);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_link_info(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_twohop_link_info");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTwohopLinkInfoRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_link_info, pxa_outputs);
	async_olsr4_0_1_get_twohop_link_info(
	    xa_inputs.get(0, "tlid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_last_face_id;
    IPv4 r_nexthop_addr;
    IPv4 r_dest_addr;
    uint32_t r_hold_time;
    try {
	XrlCmdError e = olsr4_0_1_get_twohop_link_info(
	    xa_inputs.get(0, "tlid").uint32(),
	    r_last_face_id,
	    r_nexthop_addr,
	    r_dest_addr,
	    r_hold_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_twohop_link_info", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("last_face_id", r_last_face_id);
	pxa_outputs->add("nexthop_addr", r_nexthop_addr);
	pxa_outputs->add("dest_addr", r_dest_addr);
	pxa_outputs->add("hold_time", r_hold_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_neighbor_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_twohop_neighbors,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_twohop_neighbor_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("twohop_neighbors", *rarg_twohop_neighbors);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_twohop_neighbor_list(
	Olsr401GetTwohopNeighborListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_twohop_neighbors;
    XrlCmdError e = olsr4_0_1_get_twohop_neighbor_list(
        rarg_twohop_neighbors);
    return c_b->dispatch(e,
        &rarg_twohop_neighbors);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_neighbor_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_twohop_neighbor_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTwohopNeighborListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_neighbor_list, pxa_outputs);
	async_olsr4_0_1_get_twohop_neighbor_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_twohop_neighbors;
    try {
	XrlCmdError e = olsr4_0_1_get_twohop_neighbor_list(
	    r_twohop_neighbors);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_twohop_neighbor_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("twohop_neighbors", r_twohop_neighbors);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_neighbor_info
    (const XrlCmdError &e,
     const IPv4* rarg_main_addr,
     const bool* rarg_is_strict,
     const uint32_t* rarg_link_count,
     const uint32_t* rarg_reachability,
     const uint32_t* rarg_coverage,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_twohop_neighbor_info", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("main_addr", *rarg_main_addr);
	    out.add("is_strict", *rarg_is_strict);
	    out.add("link_count", *rarg_link_count);
	    out.add("reachability", *rarg_reachability);
	    out.add("coverage", *rarg_coverage);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_twohop_neighbor_info(
	const uint32_t&	arg_tnid,
	Olsr401GetTwohopNeighborInfoCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_main_addr;
    bool rarg_is_strict;
    uint32_t rarg_link_count;
    uint32_t rarg_reachability;
    uint32_t rarg_coverage;
    XrlCmdError e = olsr4_0_1_get_twohop_neighbor_info(
        arg_tnid,
        rarg_main_addr,
        rarg_is_strict,
        rarg_link_count,
        rarg_reachability,
        rarg_coverage);
    return c_b->dispatch(e,
        &rarg_main_addr,
        &rarg_is_strict,
        &rarg_link_count,
        &rarg_reachability,
        &rarg_coverage);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_twohop_neighbor_info(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_twohop_neighbor_info");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTwohopNeighborInfoRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_twohop_neighbor_info, pxa_outputs);
	async_olsr4_0_1_get_twohop_neighbor_info(
	    xa_inputs.get(0, "tnid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_main_addr;
    bool r_is_strict;
    uint32_t r_link_count;
    uint32_t r_reachability;
    uint32_t r_coverage;
    try {
	XrlCmdError e = olsr4_0_1_get_twohop_neighbor_info(
	    xa_inputs.get(0, "tnid").uint32(),
	    r_main_addr,
	    r_is_strict,
	    r_link_count,
	    r_reachability,
	    r_coverage);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_twohop_neighbor_info", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("main_addr", r_main_addr);
	pxa_outputs->add("is_strict", r_is_strict);
	pxa_outputs->add("link_count", r_link_count);
	pxa_outputs->add("reachability", r_reachability);
	pxa_outputs->add("coverage", r_coverage);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_mid_entry_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_mid_entries,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_mid_entry_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("mid_entries", *rarg_mid_entries);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_mid_entry_list(
	Olsr401GetMidEntryListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_mid_entries;
    XrlCmdError e = olsr4_0_1_get_mid_entry_list(
        rarg_mid_entries);
    return c_b->dispatch(e,
        &rarg_mid_entries);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_mid_entry_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_mid_entry_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetMidEntryListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_mid_entry_list, pxa_outputs);
	async_olsr4_0_1_get_mid_entry_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_mid_entries;
    try {
	XrlCmdError e = olsr4_0_1_get_mid_entry_list(
	    r_mid_entries);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_mid_entry_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("mid_entries", r_mid_entries);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_mid_entry
    (const XrlCmdError &e,
     const IPv4* rarg_main_addr,
     const IPv4* rarg_iface_addr,
     const uint32_t* rarg_distance,
     const uint32_t* rarg_hold_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_mid_entry", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("main_addr", *rarg_main_addr);
	    out.add("iface_addr", *rarg_iface_addr);
	    out.add("distance", *rarg_distance);
	    out.add("hold_time", *rarg_hold_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_mid_entry(
	const uint32_t&	arg_midid,
	Olsr401GetMidEntryCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_main_addr;
    IPv4 rarg_iface_addr;
    uint32_t rarg_distance;
    uint32_t rarg_hold_time;
    XrlCmdError e = olsr4_0_1_get_mid_entry(
        arg_midid,
        rarg_main_addr,
        rarg_iface_addr,
        rarg_distance,
        rarg_hold_time);
    return c_b->dispatch(e,
        &rarg_main_addr,
        &rarg_iface_addr,
        &rarg_distance,
        &rarg_hold_time);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_mid_entry(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_mid_entry");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetMidEntryRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_mid_entry, pxa_outputs);
	async_olsr4_0_1_get_mid_entry(
	    xa_inputs.get(0, "midid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_main_addr;
    IPv4 r_iface_addr;
    uint32_t r_distance;
    uint32_t r_hold_time;
    try {
	XrlCmdError e = olsr4_0_1_get_mid_entry(
	    xa_inputs.get(0, "midid").uint32(),
	    r_main_addr,
	    r_iface_addr,
	    r_distance,
	    r_hold_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_mid_entry", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("main_addr", r_main_addr);
	pxa_outputs->add("iface_addr", r_iface_addr);
	pxa_outputs->add("distance", r_distance);
	pxa_outputs->add("hold_time", r_hold_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_entry_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_tc_entries,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_tc_entry_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tc_entries", *rarg_tc_entries);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_tc_entry_list(
	Olsr401GetTcEntryListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_tc_entries;
    XrlCmdError e = olsr4_0_1_get_tc_entry_list(
        rarg_tc_entries);
    return c_b->dispatch(e,
        &rarg_tc_entries);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_entry_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_tc_entry_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTcEntryListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_entry_list, pxa_outputs);
	async_olsr4_0_1_get_tc_entry_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_tc_entries;
    try {
	XrlCmdError e = olsr4_0_1_get_tc_entry_list(
	    r_tc_entries);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_tc_entry_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tc_entries", r_tc_entries);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_entry
    (const XrlCmdError &e,
     const IPv4* rarg_destination,
     const IPv4* rarg_lasthop,
     const uint32_t* rarg_distance,
     const uint32_t* rarg_seqno,
     const uint32_t* rarg_hold_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_tc_entry", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("destination", *rarg_destination);
	    out.add("lasthop", *rarg_lasthop);
	    out.add("distance", *rarg_distance);
	    out.add("seqno", *rarg_seqno);
	    out.add("hold_time", *rarg_hold_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_tc_entry(
	const uint32_t&	arg_tcid,
	Olsr401GetTcEntryCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_destination;
    IPv4 rarg_lasthop;
    uint32_t rarg_distance;
    uint32_t rarg_seqno;
    uint32_t rarg_hold_time;
    XrlCmdError e = olsr4_0_1_get_tc_entry(
        arg_tcid,
        rarg_destination,
        rarg_lasthop,
        rarg_distance,
        rarg_seqno,
        rarg_hold_time);
    return c_b->dispatch(e,
        &rarg_destination,
        &rarg_lasthop,
        &rarg_distance,
        &rarg_seqno,
        &rarg_hold_time);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_tc_entry(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_tc_entry");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetTcEntryRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_tc_entry, pxa_outputs);
	async_olsr4_0_1_get_tc_entry(
	    xa_inputs.get(0, "tcid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_destination;
    IPv4 r_lasthop;
    uint32_t r_distance;
    uint32_t r_seqno;
    uint32_t r_hold_time;
    try {
	XrlCmdError e = olsr4_0_1_get_tc_entry(
	    xa_inputs.get(0, "tcid").uint32(),
	    r_destination,
	    r_lasthop,
	    r_distance,
	    r_seqno,
	    r_hold_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_tc_entry", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("destination", r_destination);
	pxa_outputs->add("lasthop", r_lasthop);
	pxa_outputs->add("distance", r_distance);
	pxa_outputs->add("seqno", r_seqno);
	pxa_outputs->add("hold_time", r_hold_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_entry_list
    (const XrlCmdError &e,
     const XrlAtomList* rarg_hna_entries,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_hna_entry_list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("hna_entries", *rarg_hna_entries);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_hna_entry_list(
	Olsr401GetHnaEntryListCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_hna_entries;
    XrlCmdError e = olsr4_0_1_get_hna_entry_list(
        rarg_hna_entries);
    return c_b->dispatch(e,
        &rarg_hna_entries);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_entry_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_hna_entry_list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetHnaEntryListRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_entry_list, pxa_outputs);
	async_olsr4_0_1_get_hna_entry_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_hna_entries;
    try {
	XrlCmdError e = olsr4_0_1_get_hna_entry_list(
	    r_hna_entries);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_hna_entry_list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("hna_entries", r_hna_entries);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_entry
    (const XrlCmdError &e,
     const IPv4Net* rarg_destination,
     const IPv4* rarg_lasthop,
     const uint32_t* rarg_distance,
     const uint32_t* rarg_hold_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "olsr4/0.1/get_hna_entry", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("destination", *rarg_destination);
	    out.add("lasthop", *rarg_lasthop);
	    out.add("distance", *rarg_distance);
	    out.add("hold_time", *rarg_hold_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlOlsr4TargetBase::async_olsr4_0_1_get_hna_entry(
	const uint32_t&	arg_hnaid,
	Olsr401GetHnaEntryCB c_b)
{

    /* Return value declarations */
    IPv4Net rarg_destination;
    IPv4 rarg_lasthop;
    uint32_t rarg_distance;
    uint32_t rarg_hold_time;
    XrlCmdError e = olsr4_0_1_get_hna_entry(
        arg_hnaid,
        rarg_destination,
        rarg_lasthop,
        rarg_distance,
        rarg_hold_time);
    return c_b->dispatch(e,
        &rarg_destination,
        &rarg_lasthop,
        &rarg_distance,
        &rarg_hold_time);
}
#endif

XrlCmdRT
XrlOlsr4TargetBase::handle_olsr4_0_1_get_hna_entry(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "olsr4/0.1/get_hna_entry");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Olsr401GetHnaEntryRF mycb =
	    callback(this, &XrlOlsr4TargetBase::callback_olsr4_0_1_get_hna_entry, pxa_outputs);
	async_olsr4_0_1_get_hna_entry(
	    xa_inputs.get(0, "hnaid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4Net r_destination;
    IPv4 r_lasthop;
    uint32_t r_distance;
    uint32_t r_hold_time;
    try {
	XrlCmdError e = olsr4_0_1_get_hna_entry(
	    xa_inputs.get(0, "hnaid").uint32(),
	    r_destination,
	    r_lasthop,
	    r_distance,
	    r_hold_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "olsr4/0.1/get_hna_entry", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("destination", r_destination);
	pxa_outputs->add("lasthop", r_lasthop);
	pxa_outputs->add("distance", r_distance);
	pxa_outputs->add("hold_time", r_hold_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}

void
XrlOlsr4TargetBase::add_handlers()
{
    for (size_t i = 0; i < num_handlers; ++i) {
        if (!_cmds->add_handler(handlers[i].name,
                                callback(this, handlers[i].method))) {
            XLOG_ERROR("Failed to register xrl handler finder://%s/%s", "olsr4", handlers[i].name);
        }
    }
    _cmds->finalize();
}

void
XrlOlsr4TargetBase::remove_handlers()
{
     for (size_t i = 0; i < num_handlers; ++i) {
         _cmds->remove_handler(handlers[i].name);
     }
}
