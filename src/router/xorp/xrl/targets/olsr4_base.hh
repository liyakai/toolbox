/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/olsr4_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_OLSR4_BASE_HH__
#define __XRL_TARGETS_OLSR4_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlOlsr4Target"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlOlsr4TargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlOlsr4TargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlOlsr4TargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "olsr4/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when a packet arrives
     *  from an IPv4 source.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param if_name the interface name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param vif_name the vif name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param src_host the originating host.
     *
     *  @param src_port the originating IP port.
     *
     *  @param data the data received.
     */
    virtual XrlCmdError socket4_user_0_1_recv_event(
	// Input values,
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01RecvEventRF;

    class Socket4User01RecvEventCB {
        Socket4User01RecvEventRF cb;

    public:
        operator const Socket4User01RecvEventRF& () const { return cb; }
        const Socket4User01RecvEventRF& operator ->() const { return cb; }
        Socket4User01RecvEventCB(const Socket4User01RecvEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01RecvEventRsp :
      public Socket4User01RecvEventCB {
        Socket4User01RecvEventRsp(const Socket4User01RecvEventRF& cb)
          : Socket4User01RecvEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_recv_event
       (
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data,
	Socket4User01RecvEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when a connection
     *  request is received from an IPv4 source. It applies only to TCP
     *  sockets.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param src_host the connecting host.
     *
     *  @param src_port the connecting IP port.
     *
     *  @param new_sockid the identifier associated with the new socket that
     *  has been created to handle the new connection.
     *
     *  @param accept if true, the connection request has been accepted,
     *  otherwise it has been rejected.
     */
    virtual XrlCmdError socket4_user_0_1_inbound_connect_event(
	// Input values,
	const string&	sockid,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Socket4User01InboundConnectEventRF;

    class Socket4User01InboundConnectEventCB {
        Socket4User01InboundConnectEventRF cb;

    public:
        operator const Socket4User01InboundConnectEventRF& () const { return cb; }
        const Socket4User01InboundConnectEventRF& operator ->() const { return cb; }
        Socket4User01InboundConnectEventCB(const Socket4User01InboundConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Socket4User01InboundConnectEventRsp :
      public Socket4User01InboundConnectEventCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Socket4User01InboundConnectEventRsp(const Socket4User01InboundConnectEventRF& cb)
          : Socket4User01InboundConnectEventCB(cb) { }

        void respond() const {
            Socket4User01InboundConnectEventCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_user_0_1_inbound_connect_event
       (
	const string&	sockid,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	Socket4User01InboundConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when an outgoing
     *  connection request originated by the local host is completed. It
     *  applies only to TCP sockets. Note that if the connection failed, the
     *  error_event will be dispatched instead.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket4_user_0_1_outgoing_connect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01OutgoingConnectEventRF;

    class Socket4User01OutgoingConnectEventCB {
        Socket4User01OutgoingConnectEventRF cb;

    public:
        operator const Socket4User01OutgoingConnectEventRF& () const { return cb; }
        const Socket4User01OutgoingConnectEventRF& operator ->() const { return cb; }
        Socket4User01OutgoingConnectEventCB(const Socket4User01OutgoingConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01OutgoingConnectEventRsp :
      public Socket4User01OutgoingConnectEventCB {
        Socket4User01OutgoingConnectEventRsp(const Socket4User01OutgoingConnectEventRF& cb)
          : Socket4User01OutgoingConnectEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_outgoing_connect_event
       (
	const string&	sockid,
	Socket4User01OutgoingConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when an error occurs.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param error a textual description of the error.
     *
     *  @param fatal indication of whether socket is shutdown because of error.
     */
    virtual XrlCmdError socket4_user_0_1_error_event(
	// Input values,
	const string&	sockid,
	const string&	error,
	const bool&	fatal) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01ErrorEventRF;

    class Socket4User01ErrorEventCB {
        Socket4User01ErrorEventRF cb;

    public:
        operator const Socket4User01ErrorEventRF& () const { return cb; }
        const Socket4User01ErrorEventRF& operator ->() const { return cb; }
        Socket4User01ErrorEventCB(const Socket4User01ErrorEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01ErrorEventRsp :
      public Socket4User01ErrorEventCB {
        Socket4User01ErrorEventRsp(const Socket4User01ErrorEventRF& cb)
          : Socket4User01ErrorEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_error_event
       (
	const string&	sockid,
	const string&	error,
	const bool&	fatal,
	Socket4User01ErrorEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when the peer has
     *  closed the connection. It applies only to TCP sockets. Note that the
     *  socket itself is left open and must be explicitly closed.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket4_user_0_1_disconnect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01DisconnectEventRF;

    class Socket4User01DisconnectEventCB {
        Socket4User01DisconnectEventRF cb;

    public:
        operator const Socket4User01DisconnectEventRF& () const { return cb; }
        const Socket4User01DisconnectEventRF& operator ->() const { return cb; }
        Socket4User01DisconnectEventCB(const Socket4User01DisconnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01DisconnectEventRsp :
      public Socket4User01DisconnectEventCB {
        Socket4User01DisconnectEventRsp(const Socket4User01DisconnectEventRF& cb)
          : Socket4User01DisconnectEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_disconnect_event
       (
	const string&	sockid,
	Socket4User01DisconnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv4 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist4_0_1_add_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401AddRoute4RF;

    class PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4RF cb;

    public:
        operator const PolicyRedist401AddRoute4RF& () const { return cb; }
        const PolicyRedist401AddRoute4RF& operator ->() const { return cb; }
        PolicyRedist401AddRoute4CB(const PolicyRedist401AddRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401AddRoute4Rsp :
      public PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4Rsp(const PolicyRedist401AddRoute4RF& cb)
          : PolicyRedist401AddRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_add_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist401AddRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv4 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist4_0_1_delete_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401DeleteRoute4RF;

    class PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4RF cb;

    public:
        operator const PolicyRedist401DeleteRoute4RF& () const { return cb; }
        const PolicyRedist401DeleteRoute4RF& operator ->() const { return cb; }
        PolicyRedist401DeleteRoute4CB(const PolicyRedist401DeleteRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401DeleteRoute4Rsp :
      public PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4Rsp(const PolicyRedist401DeleteRoute4RF& cb)
          : PolicyRedist401DeleteRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_delete_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist401DeleteRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_enable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01EnableRF;

    class Profile01EnableCB {
        Profile01EnableRF cb;

    public:
        operator const Profile01EnableRF& () const { return cb; }
        const Profile01EnableRF& operator ->() const { return cb; }
        Profile01EnableCB(const Profile01EnableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01EnableRsp :
      public Profile01EnableCB {
        Profile01EnableRsp(const Profile01EnableRF& cb)
          : Profile01EnableCB(cb) { }

    };

    virtual void async_profile_0_1_enable
       (
	const string&	pname,
	Profile01EnableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_disable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01DisableRF;

    class Profile01DisableCB {
        Profile01DisableRF cb;

    public:
        operator const Profile01DisableRF& () const { return cb; }
        const Profile01DisableRF& operator ->() const { return cb; }
        Profile01DisableCB(const Profile01DisableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01DisableRsp :
      public Profile01DisableCB {
        Profile01DisableRsp(const Profile01DisableRF& cb)
          : Profile01DisableCB(cb) { }

    };

    virtual void async_profile_0_1_disable
       (
	const string&	pname,
	Profile01DisableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get log entries.
     *
     *  @param pname profile variable
     *
     *  @param instance_name to send the profiling info to.
     */
    virtual XrlCmdError profile_0_1_get_entries(
	// Input values,
	const string&	pname,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01GetEntriesRF;

    class Profile01GetEntriesCB {
        Profile01GetEntriesRF cb;

    public:
        operator const Profile01GetEntriesRF& () const { return cb; }
        const Profile01GetEntriesRF& operator ->() const { return cb; }
        Profile01GetEntriesCB(const Profile01GetEntriesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01GetEntriesRsp :
      public Profile01GetEntriesCB {
        Profile01GetEntriesRsp(const Profile01GetEntriesRF& cb)
          : Profile01GetEntriesCB(cb) { }

    };

    virtual void async_profile_0_1_get_entries
       (
	const string&	pname,
	const string&	instance_name,
	Profile01GetEntriesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the profiling entries
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_clear(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01ClearRF;

    class Profile01ClearCB {
        Profile01ClearRF cb;

    public:
        operator const Profile01ClearRF& () const { return cb; }
        const Profile01ClearRF& operator ->() const { return cb; }
        Profile01ClearCB(const Profile01ClearRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01ClearRsp :
      public Profile01ClearCB {
        Profile01ClearRsp(const Profile01ClearRF& cb)
          : Profile01ClearCB(cb) { }

    };

    virtual void async_profile_0_1_clear
       (
	const string&	pname,
	Profile01ClearCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  List all the profiling variables registered with this target.
     */
    virtual XrlCmdError profile_0_1_list(
	// Output values,
	string&	info) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Profile01ListRF;

    class Profile01ListCB {
        Profile01ListRF cb;

    public:
        operator const Profile01ListRF& () const { return cb; }
        const Profile01ListRF& operator ->() const { return cb; }
        Profile01ListCB(const Profile01ListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_info) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_info);
        }
    };

    struct Profile01ListRsp :
      public Profile01ListCB {
        struct args_str {
            string info;
        };

    private:
        args_str args;

    public:
        Profile01ListRsp(const Profile01ListRF& cb)
          : Profile01ListCB(cb) { }

        void respond() const {
            Profile01ListCB::
            respond(args.info);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_profile_0_1_list
       (
	Profile01ListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/Disable tracing.
     *
     *  @param tvar trace variable.
     *
     *  @param enable set to true to enable, false to disable.
     */
    virtual XrlCmdError olsr4_0_1_trace(
	// Input values,
	const string&	tvar,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401TraceRF;

    class Olsr401TraceCB {
        Olsr401TraceRF cb;

    public:
        operator const Olsr401TraceRF& () const { return cb; }
        const Olsr401TraceRF& operator ->() const { return cb; }
        Olsr401TraceCB(const Olsr401TraceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401TraceRsp :
      public Olsr401TraceCB {
        Olsr401TraceRsp(const Olsr401TraceRF& cb)
          : Olsr401TraceCB(cb) { }

    };

    virtual void async_olsr4_0_1_trace
       (
	const string&	tvar,
	const bool&	enable,
	Olsr401TraceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear all OLSR protocol databases.
     */
    virtual XrlCmdError olsr4_0_1_clear_database() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401ClearDatabaseRF;

    class Olsr401ClearDatabaseCB {
        Olsr401ClearDatabaseRF cb;

    public:
        operator const Olsr401ClearDatabaseRF& () const { return cb; }
        const Olsr401ClearDatabaseRF& operator ->() const { return cb; }
        Olsr401ClearDatabaseCB(const Olsr401ClearDatabaseRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401ClearDatabaseRsp :
      public Olsr401ClearDatabaseCB {
        Olsr401ClearDatabaseRsp(const Olsr401ClearDatabaseRF& cb)
          : Olsr401ClearDatabaseCB(cb) { }

    };

    virtual void async_olsr4_0_1_clear_database
       (
	Olsr401ClearDatabaseCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the willingness-to-forward.
     *
     *  @param willingness the new willingness-to-forward.
     */
    virtual XrlCmdError olsr4_0_1_set_willingness(
	// Input values,
	const uint32_t&	willingness) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetWillingnessRF;

    class Olsr401SetWillingnessCB {
        Olsr401SetWillingnessRF cb;

    public:
        operator const Olsr401SetWillingnessRF& () const { return cb; }
        const Olsr401SetWillingnessRF& operator ->() const { return cb; }
        Olsr401SetWillingnessCB(const Olsr401SetWillingnessRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetWillingnessRsp :
      public Olsr401SetWillingnessCB {
        Olsr401SetWillingnessRsp(const Olsr401SetWillingnessRF& cb)
          : Olsr401SetWillingnessCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_willingness
       (
	const uint32_t&	willingness,
	Olsr401SetWillingnessCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the willingness-to-forward.
     */
    virtual XrlCmdError olsr4_0_1_get_willingness(
	// Output values,
	uint32_t&	willingness) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetWillingnessRF;

    class Olsr401GetWillingnessCB {
        Olsr401GetWillingnessRF cb;

    public:
        operator const Olsr401GetWillingnessRF& () const { return cb; }
        const Olsr401GetWillingnessRF& operator ->() const { return cb; }
        Olsr401GetWillingnessCB(const Olsr401GetWillingnessRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_willingness) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_willingness);
        }
    };

    struct Olsr401GetWillingnessRsp :
      public Olsr401GetWillingnessCB {
        struct args_str {
            uint32_t willingness;
        };

    private:
        args_str args;

    public:
        Olsr401GetWillingnessRsp(const Olsr401GetWillingnessRF& cb)
          : Olsr401GetWillingnessCB(cb) { }

        void respond() const {
            Olsr401GetWillingnessCB::
            respond(args.willingness);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_willingness
       (
	Olsr401GetWillingnessCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the MPR_COVERAGE.
     *
     *  @param coverage the new MPR_COVERAGE value.
     */
    virtual XrlCmdError olsr4_0_1_set_mpr_coverage(
	// Input values,
	const uint32_t&	coverage) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetMprCoverageRF;

    class Olsr401SetMprCoverageCB {
        Olsr401SetMprCoverageRF cb;

    public:
        operator const Olsr401SetMprCoverageRF& () const { return cb; }
        const Olsr401SetMprCoverageRF& operator ->() const { return cb; }
        Olsr401SetMprCoverageCB(const Olsr401SetMprCoverageRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetMprCoverageRsp :
      public Olsr401SetMprCoverageCB {
        Olsr401SetMprCoverageRsp(const Olsr401SetMprCoverageRF& cb)
          : Olsr401SetMprCoverageCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_mpr_coverage
       (
	const uint32_t&	coverage,
	Olsr401SetMprCoverageCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the MPR_COVERAGE.
     */
    virtual XrlCmdError olsr4_0_1_get_mpr_coverage(
	// Output values,
	uint32_t&	coverage) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetMprCoverageRF;

    class Olsr401GetMprCoverageCB {
        Olsr401GetMprCoverageRF cb;

    public:
        operator const Olsr401GetMprCoverageRF& () const { return cb; }
        const Olsr401GetMprCoverageRF& operator ->() const { return cb; }
        Olsr401GetMprCoverageCB(const Olsr401GetMprCoverageRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_coverage) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_coverage);
        }
    };

    struct Olsr401GetMprCoverageRsp :
      public Olsr401GetMprCoverageCB {
        struct args_str {
            uint32_t coverage;
        };

    private:
        args_str args;

    public:
        Olsr401GetMprCoverageRsp(const Olsr401GetMprCoverageRF& cb)
          : Olsr401GetMprCoverageCB(cb) { }

        void respond() const {
            Olsr401GetMprCoverageCB::
            respond(args.coverage);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_mpr_coverage
       (
	Olsr401GetMprCoverageCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the TC_REDUNDANCY.
     */
    virtual XrlCmdError olsr4_0_1_set_tc_redundancy(
	// Input values,
	const string&	redundancy) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetTcRedundancyRF;

    class Olsr401SetTcRedundancyCB {
        Olsr401SetTcRedundancyRF cb;

    public:
        operator const Olsr401SetTcRedundancyRF& () const { return cb; }
        const Olsr401SetTcRedundancyRF& operator ->() const { return cb; }
        Olsr401SetTcRedundancyCB(const Olsr401SetTcRedundancyRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetTcRedundancyRsp :
      public Olsr401SetTcRedundancyCB {
        Olsr401SetTcRedundancyRsp(const Olsr401SetTcRedundancyRF& cb)
          : Olsr401SetTcRedundancyCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_tc_redundancy
       (
	const string&	redundancy,
	Olsr401SetTcRedundancyCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the TC_REDUNDANCY.
     */
    virtual XrlCmdError olsr4_0_1_get_tc_redundancy(
	// Output values,
	string&	redundancy) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Olsr401GetTcRedundancyRF;

    class Olsr401GetTcRedundancyCB {
        Olsr401GetTcRedundancyRF cb;

    public:
        operator const Olsr401GetTcRedundancyRF& () const { return cb; }
        const Olsr401GetTcRedundancyRF& operator ->() const { return cb; }
        Olsr401GetTcRedundancyCB(const Olsr401GetTcRedundancyRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_redundancy) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_redundancy);
        }
    };

    struct Olsr401GetTcRedundancyRsp :
      public Olsr401GetTcRedundancyCB {
        struct args_str {
            string redundancy;
        };

    private:
        args_str args;

    public:
        Olsr401GetTcRedundancyRsp(const Olsr401GetTcRedundancyRF& cb)
          : Olsr401GetTcRedundancyCB(cb) { }

        void respond() const {
            Olsr401GetTcRedundancyCB::
            respond(args.redundancy);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_tc_redundancy
       (
	Olsr401GetTcRedundancyCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/disable TC fisheye mode.
     *
     *  @param enabled true to enable fisheye, false to disable it.
     */
    virtual XrlCmdError olsr4_0_1_set_tc_fisheye(
	// Input values,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetTcFisheyeRF;

    class Olsr401SetTcFisheyeCB {
        Olsr401SetTcFisheyeRF cb;

    public:
        operator const Olsr401SetTcFisheyeRF& () const { return cb; }
        const Olsr401SetTcFisheyeRF& operator ->() const { return cb; }
        Olsr401SetTcFisheyeCB(const Olsr401SetTcFisheyeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetTcFisheyeRsp :
      public Olsr401SetTcFisheyeCB {
        Olsr401SetTcFisheyeRsp(const Olsr401SetTcFisheyeRF& cb)
          : Olsr401SetTcFisheyeCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_tc_fisheye
       (
	const bool&	enabled,
	Olsr401SetTcFisheyeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the current TC fisheye mode.
     */
    virtual XrlCmdError olsr4_0_1_get_tc_fisheye(
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Olsr401GetTcFisheyeRF;

    class Olsr401GetTcFisheyeCB {
        Olsr401GetTcFisheyeRF cb;

    public:
        operator const Olsr401GetTcFisheyeRF& () const { return cb; }
        const Olsr401GetTcFisheyeRF& operator ->() const { return cb; }
        Olsr401GetTcFisheyeCB(const Olsr401GetTcFisheyeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Olsr401GetTcFisheyeRsp :
      public Olsr401GetTcFisheyeCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Olsr401GetTcFisheyeRsp(const Olsr401GetTcFisheyeRF& cb)
          : Olsr401GetTcFisheyeCB(cb) { }

        void respond() const {
            Olsr401GetTcFisheyeCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_tc_fisheye
       (
	Olsr401GetTcFisheyeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the current HNA base cost metric.
     */
    virtual XrlCmdError olsr4_0_1_set_hna_base_cost(
	// Input values,
	const uint32_t&	metric) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetHnaBaseCostRF;

    class Olsr401SetHnaBaseCostCB {
        Olsr401SetHnaBaseCostRF cb;

    public:
        operator const Olsr401SetHnaBaseCostRF& () const { return cb; }
        const Olsr401SetHnaBaseCostRF& operator ->() const { return cb; }
        Olsr401SetHnaBaseCostCB(const Olsr401SetHnaBaseCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetHnaBaseCostRsp :
      public Olsr401SetHnaBaseCostCB {
        Olsr401SetHnaBaseCostRsp(const Olsr401SetHnaBaseCostRF& cb)
          : Olsr401SetHnaBaseCostCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_hna_base_cost
       (
	const uint32_t&	metric,
	Olsr401SetHnaBaseCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the current HNA base cost metric.
     */
    virtual XrlCmdError olsr4_0_1_get_hna_base_cost(
	// Output values,
	uint32_t&	metric) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetHnaBaseCostRF;

    class Olsr401GetHnaBaseCostCB {
        Olsr401GetHnaBaseCostRF cb;

    public:
        operator const Olsr401GetHnaBaseCostRF& () const { return cb; }
        const Olsr401GetHnaBaseCostRF& operator ->() const { return cb; }
        Olsr401GetHnaBaseCostCB(const Olsr401GetHnaBaseCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_metric) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_metric);
        }
    };

    struct Olsr401GetHnaBaseCostRsp :
      public Olsr401GetHnaBaseCostCB {
        struct args_str {
            uint32_t metric;
        };

    private:
        args_str args;

    public:
        Olsr401GetHnaBaseCostRsp(const Olsr401GetHnaBaseCostRF& cb)
          : Olsr401GetHnaBaseCostCB(cb) { }

        void respond() const {
            Olsr401GetHnaBaseCostCB::
            respond(args.metric);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_hna_base_cost
       (
	Olsr401GetHnaBaseCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the HELLO_INTERVAL.
     *
     *  @param interval the new HELLO_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_set_hello_interval(
	// Input values,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetHelloIntervalRF;

    class Olsr401SetHelloIntervalCB {
        Olsr401SetHelloIntervalRF cb;

    public:
        operator const Olsr401SetHelloIntervalRF& () const { return cb; }
        const Olsr401SetHelloIntervalRF& operator ->() const { return cb; }
        Olsr401SetHelloIntervalCB(const Olsr401SetHelloIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetHelloIntervalRsp :
      public Olsr401SetHelloIntervalCB {
        Olsr401SetHelloIntervalRsp(const Olsr401SetHelloIntervalRF& cb)
          : Olsr401SetHelloIntervalCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_hello_interval
       (
	const uint32_t&	interval,
	Olsr401SetHelloIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the HELLO_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_get_hello_interval(
	// Output values,
	uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetHelloIntervalRF;

    class Olsr401GetHelloIntervalCB {
        Olsr401GetHelloIntervalRF cb;

    public:
        operator const Olsr401GetHelloIntervalRF& () const { return cb; }
        const Olsr401GetHelloIntervalRF& operator ->() const { return cb; }
        Olsr401GetHelloIntervalCB(const Olsr401GetHelloIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interval);
        }
    };

    struct Olsr401GetHelloIntervalRsp :
      public Olsr401GetHelloIntervalCB {
        struct args_str {
            uint32_t interval;
        };

    private:
        args_str args;

    public:
        Olsr401GetHelloIntervalRsp(const Olsr401GetHelloIntervalRF& cb)
          : Olsr401GetHelloIntervalCB(cb) { }

        void respond() const {
            Olsr401GetHelloIntervalCB::
            respond(args.interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_hello_interval
       (
	Olsr401GetHelloIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the REFRESH_INTERVAL.
     *
     *  @param interval the new REFRESH_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_set_refresh_interval(
	// Input values,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetRefreshIntervalRF;

    class Olsr401SetRefreshIntervalCB {
        Olsr401SetRefreshIntervalRF cb;

    public:
        operator const Olsr401SetRefreshIntervalRF& () const { return cb; }
        const Olsr401SetRefreshIntervalRF& operator ->() const { return cb; }
        Olsr401SetRefreshIntervalCB(const Olsr401SetRefreshIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetRefreshIntervalRsp :
      public Olsr401SetRefreshIntervalCB {
        Olsr401SetRefreshIntervalRsp(const Olsr401SetRefreshIntervalRF& cb)
          : Olsr401SetRefreshIntervalCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_refresh_interval
       (
	const uint32_t&	interval,
	Olsr401SetRefreshIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the REFRESH_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_get_refresh_interval(
	// Output values,
	uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetRefreshIntervalRF;

    class Olsr401GetRefreshIntervalCB {
        Olsr401GetRefreshIntervalRF cb;

    public:
        operator const Olsr401GetRefreshIntervalRF& () const { return cb; }
        const Olsr401GetRefreshIntervalRF& operator ->() const { return cb; }
        Olsr401GetRefreshIntervalCB(const Olsr401GetRefreshIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interval);
        }
    };

    struct Olsr401GetRefreshIntervalRsp :
      public Olsr401GetRefreshIntervalCB {
        struct args_str {
            uint32_t interval;
        };

    private:
        args_str args;

    public:
        Olsr401GetRefreshIntervalRsp(const Olsr401GetRefreshIntervalRF& cb)
          : Olsr401GetRefreshIntervalCB(cb) { }

        void respond() const {
            Olsr401GetRefreshIntervalCB::
            respond(args.interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_refresh_interval
       (
	Olsr401GetRefreshIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the TC_INTERVAL.
     *
     *  @param interval the new TC_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_set_tc_interval(
	// Input values,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetTcIntervalRF;

    class Olsr401SetTcIntervalCB {
        Olsr401SetTcIntervalRF cb;

    public:
        operator const Olsr401SetTcIntervalRF& () const { return cb; }
        const Olsr401SetTcIntervalRF& operator ->() const { return cb; }
        Olsr401SetTcIntervalCB(const Olsr401SetTcIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetTcIntervalRsp :
      public Olsr401SetTcIntervalCB {
        Olsr401SetTcIntervalRsp(const Olsr401SetTcIntervalRF& cb)
          : Olsr401SetTcIntervalCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_tc_interval
       (
	const uint32_t&	interval,
	Olsr401SetTcIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the TC_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_get_tc_interval(
	// Output values,
	uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetTcIntervalRF;

    class Olsr401GetTcIntervalCB {
        Olsr401GetTcIntervalRF cb;

    public:
        operator const Olsr401GetTcIntervalRF& () const { return cb; }
        const Olsr401GetTcIntervalRF& operator ->() const { return cb; }
        Olsr401GetTcIntervalCB(const Olsr401GetTcIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interval);
        }
    };

    struct Olsr401GetTcIntervalRsp :
      public Olsr401GetTcIntervalCB {
        struct args_str {
            uint32_t interval;
        };

    private:
        args_str args;

    public:
        Olsr401GetTcIntervalRsp(const Olsr401GetTcIntervalRF& cb)
          : Olsr401GetTcIntervalCB(cb) { }

        void respond() const {
            Olsr401GetTcIntervalCB::
            respond(args.interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_tc_interval
       (
	Olsr401GetTcIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the MID_INTERVAL.
     *
     *  @param interval the new MID_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_set_mid_interval(
	// Input values,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetMidIntervalRF;

    class Olsr401SetMidIntervalCB {
        Olsr401SetMidIntervalRF cb;

    public:
        operator const Olsr401SetMidIntervalRF& () const { return cb; }
        const Olsr401SetMidIntervalRF& operator ->() const { return cb; }
        Olsr401SetMidIntervalCB(const Olsr401SetMidIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetMidIntervalRsp :
      public Olsr401SetMidIntervalCB {
        Olsr401SetMidIntervalRsp(const Olsr401SetMidIntervalRF& cb)
          : Olsr401SetMidIntervalCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_mid_interval
       (
	const uint32_t&	interval,
	Olsr401SetMidIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the MID_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_get_mid_interval(
	// Output values,
	uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetMidIntervalRF;

    class Olsr401GetMidIntervalCB {
        Olsr401GetMidIntervalRF cb;

    public:
        operator const Olsr401GetMidIntervalRF& () const { return cb; }
        const Olsr401GetMidIntervalRF& operator ->() const { return cb; }
        Olsr401GetMidIntervalCB(const Olsr401GetMidIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interval);
        }
    };

    struct Olsr401GetMidIntervalRsp :
      public Olsr401GetMidIntervalCB {
        struct args_str {
            uint32_t interval;
        };

    private:
        args_str args;

    public:
        Olsr401GetMidIntervalRsp(const Olsr401GetMidIntervalRF& cb)
          : Olsr401GetMidIntervalCB(cb) { }

        void respond() const {
            Olsr401GetMidIntervalCB::
            respond(args.interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_mid_interval
       (
	Olsr401GetMidIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the HNA_INTERVAL.
     *
     *  @param interval the new HNA_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_set_hna_interval(
	// Input values,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetHnaIntervalRF;

    class Olsr401SetHnaIntervalCB {
        Olsr401SetHnaIntervalRF cb;

    public:
        operator const Olsr401SetHnaIntervalRF& () const { return cb; }
        const Olsr401SetHnaIntervalRF& operator ->() const { return cb; }
        Olsr401SetHnaIntervalCB(const Olsr401SetHnaIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetHnaIntervalRsp :
      public Olsr401SetHnaIntervalCB {
        Olsr401SetHnaIntervalRsp(const Olsr401SetHnaIntervalRF& cb)
          : Olsr401SetHnaIntervalCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_hna_interval
       (
	const uint32_t&	interval,
	Olsr401SetHnaIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the HNA_INTERVAL.
     */
    virtual XrlCmdError olsr4_0_1_get_hna_interval(
	// Output values,
	uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetHnaIntervalRF;

    class Olsr401GetHnaIntervalCB {
        Olsr401GetHnaIntervalRF cb;

    public:
        operator const Olsr401GetHnaIntervalRF& () const { return cb; }
        const Olsr401GetHnaIntervalRF& operator ->() const { return cb; }
        Olsr401GetHnaIntervalCB(const Olsr401GetHnaIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interval);
        }
    };

    struct Olsr401GetHnaIntervalRsp :
      public Olsr401GetHnaIntervalCB {
        struct args_str {
            uint32_t interval;
        };

    private:
        args_str args;

    public:
        Olsr401GetHnaIntervalRsp(const Olsr401GetHnaIntervalRF& cb)
          : Olsr401GetHnaIntervalCB(cb) { }

        void respond() const {
            Olsr401GetHnaIntervalCB::
            respond(args.interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_hna_interval
       (
	Olsr401GetHnaIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the DUP_HOLD_TIME.
     *
     *  @param dup_hold_time the new DUP_HOLD_TIME.
     */
    virtual XrlCmdError olsr4_0_1_set_dup_hold_time(
	// Input values,
	const uint32_t&	dup_hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetDupHoldTimeRF;

    class Olsr401SetDupHoldTimeCB {
        Olsr401SetDupHoldTimeRF cb;

    public:
        operator const Olsr401SetDupHoldTimeRF& () const { return cb; }
        const Olsr401SetDupHoldTimeRF& operator ->() const { return cb; }
        Olsr401SetDupHoldTimeCB(const Olsr401SetDupHoldTimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetDupHoldTimeRsp :
      public Olsr401SetDupHoldTimeCB {
        Olsr401SetDupHoldTimeRsp(const Olsr401SetDupHoldTimeRF& cb)
          : Olsr401SetDupHoldTimeCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_dup_hold_time
       (
	const uint32_t&	dup_hold_time,
	Olsr401SetDupHoldTimeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the DUP_HOLD_TIME.
     */
    virtual XrlCmdError olsr4_0_1_get_dup_hold_time(
	// Output values,
	uint32_t&	dup_hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Olsr401GetDupHoldTimeRF;

    class Olsr401GetDupHoldTimeCB {
        Olsr401GetDupHoldTimeRF cb;

    public:
        operator const Olsr401GetDupHoldTimeRF& () const { return cb; }
        const Olsr401GetDupHoldTimeRF& operator ->() const { return cb; }
        Olsr401GetDupHoldTimeCB(const Olsr401GetDupHoldTimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_dup_hold_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_dup_hold_time);
        }
    };

    struct Olsr401GetDupHoldTimeRsp :
      public Olsr401GetDupHoldTimeCB {
        struct args_str {
            uint32_t dup_hold_time;
        };

    private:
        args_str args;

    public:
        Olsr401GetDupHoldTimeRsp(const Olsr401GetDupHoldTimeRF& cb)
          : Olsr401GetDupHoldTimeCB(cb) { }

        void respond() const {
            Olsr401GetDupHoldTimeCB::
            respond(args.dup_hold_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_dup_hold_time
       (
	Olsr401GetDupHoldTimeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the main address.
     *
     *  @param addr Our main IPv4 address which OLSR uses as a router ID.
     */
    virtual XrlCmdError olsr4_0_1_set_main_address(
	// Input values,
	const IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetMainAddressRF;

    class Olsr401SetMainAddressCB {
        Olsr401SetMainAddressRF cb;

    public:
        operator const Olsr401SetMainAddressRF& () const { return cb; }
        const Olsr401SetMainAddressRF& operator ->() const { return cb; }
        Olsr401SetMainAddressCB(const Olsr401SetMainAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetMainAddressRsp :
      public Olsr401SetMainAddressCB {
        Olsr401SetMainAddressRsp(const Olsr401SetMainAddressRF& cb)
          : Olsr401SetMainAddressCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_main_address
       (
	const IPv4&	addr,
	Olsr401SetMainAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the main address.
     */
    virtual XrlCmdError olsr4_0_1_get_main_address(
	// Output values,
	IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Olsr401GetMainAddressRF;

    class Olsr401GetMainAddressCB {
        Olsr401GetMainAddressRF cb;

    public:
        operator const Olsr401GetMainAddressRF& () const { return cb; }
        const Olsr401GetMainAddressRF& operator ->() const { return cb; }
        Olsr401GetMainAddressCB(const Olsr401GetMainAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_addr) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_addr);
        }
    };

    struct Olsr401GetMainAddressRsp :
      public Olsr401GetMainAddressCB {
        struct args_str {
            IPv4 addr;
        };

    private:
        args_str args;

    public:
        Olsr401GetMainAddressRsp(const Olsr401GetMainAddressRF& cb)
          : Olsr401GetMainAddressCB(cb) { }

        void respond() const {
            Olsr401GetMainAddressCB::
            respond(args.addr);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_main_address
       (
	Olsr401GetMainAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create an IPv4 address binding for OLSR. OLSR must be bound to a given
     *  protocol address on each interface, which means interface bindings in
     *  OLSRv1 must be keyed by interface name as well as protocol address.
     *  Only a single IPv4 address may be thus bound, and the address must be
     *  supplied when the binding is created. This is to workaround the lack of
     *  RFC 3927 link-scoped IPv4 capability in most IPv4 implementations. The
     *  addition of address is not instantaneous. OLSR has to instantiate state
     *  in the FEA to send and receive packets. Once instantiated, the address
     *  must be explicitly enabled with the set_binding_enabled XRL.
     *
     *  @param ifname the interface that owns vif that has addr
     *
     *  @param vifname virtual interface owning addr
     *
     *  @param local_addr the address to be added.
     *
     *  @param local_port the port to listen for control traffic on.
     *
     *  @param all_nodes_addr the address to use for transmission.
     *
     *  @param all_nodes_port the port to use for transmission.
     */
    virtual XrlCmdError olsr4_0_1_bind_address(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	all_nodes_addr,
	const uint32_t&	all_nodes_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401BindAddressRF;

    class Olsr401BindAddressCB {
        Olsr401BindAddressRF cb;

    public:
        operator const Olsr401BindAddressRF& () const { return cb; }
        const Olsr401BindAddressRF& operator ->() const { return cb; }
        Olsr401BindAddressCB(const Olsr401BindAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401BindAddressRsp :
      public Olsr401BindAddressCB {
        Olsr401BindAddressRsp(const Olsr401BindAddressRF& cb)
          : Olsr401BindAddressCB(cb) { }

    };

    virtual void async_olsr4_0_1_bind_address
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	all_nodes_addr,
	const uint32_t&	all_nodes_port,
	Olsr401BindAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Destroy an IPv4 address binding for OLSR.
     *
     *  @param ifname the interface to unbind.
     *
     *  @param vifname the vif to unbind.
     */
    virtual XrlCmdError olsr4_0_1_unbind_address(
	// Input values,
	const string&	ifname,
	const string&	vifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401UnbindAddressRF;

    class Olsr401UnbindAddressCB {
        Olsr401UnbindAddressRF cb;

    public:
        operator const Olsr401UnbindAddressRF& () const { return cb; }
        const Olsr401UnbindAddressRF& operator ->() const { return cb; }
        Olsr401UnbindAddressCB(const Olsr401UnbindAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401UnbindAddressRsp :
      public Olsr401UnbindAddressCB {
        Olsr401UnbindAddressRsp(const Olsr401UnbindAddressRF& cb)
          : Olsr401UnbindAddressCB(cb) { }

    };

    virtual void async_olsr4_0_1_unbind_address
       (
	const string&	ifname,
	const string&	vifname,
	Olsr401UnbindAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the enabled state of an IPv4 address binding for OLSR.
     *
     *  @param ifname the interface to set enabled state for.
     *
     *  @param vifname the vif to set enabled state for.
     *
     *  @param enabled true if OLSR is to be configured administratively up on
     *  the interface, false if it is to be configured down.
     */
    virtual XrlCmdError olsr4_0_1_set_binding_enabled(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetBindingEnabledRF;

    class Olsr401SetBindingEnabledCB {
        Olsr401SetBindingEnabledRF cb;

    public:
        operator const Olsr401SetBindingEnabledRF& () const { return cb; }
        const Olsr401SetBindingEnabledRF& operator ->() const { return cb; }
        Olsr401SetBindingEnabledCB(const Olsr401SetBindingEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetBindingEnabledRsp :
      public Olsr401SetBindingEnabledCB {
        Olsr401SetBindingEnabledRsp(const Olsr401SetBindingEnabledRF& cb)
          : Olsr401SetBindingEnabledCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_binding_enabled
       (
	const string&	ifname,
	const string&	vifname,
	const bool&	enabled,
	Olsr401SetBindingEnabledCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the state of an IPv4 address binding for OLSR.
     *
     *  @param ifname the interface to query.
     *
     *  @param vifname the vif to qurery
     *
     *  @param enabled true if OLSR is configured administratively up on the
     *  given interface.
     */
    virtual XrlCmdError olsr4_0_1_get_binding_enabled(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Olsr401GetBindingEnabledRF;

    class Olsr401GetBindingEnabledCB {
        Olsr401GetBindingEnabledRF cb;

    public:
        operator const Olsr401GetBindingEnabledRF& () const { return cb; }
        const Olsr401GetBindingEnabledRF& operator ->() const { return cb; }
        Olsr401GetBindingEnabledCB(const Olsr401GetBindingEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Olsr401GetBindingEnabledRsp :
      public Olsr401GetBindingEnabledCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Olsr401GetBindingEnabledRsp(const Olsr401GetBindingEnabledRF& cb)
          : Olsr401GetBindingEnabledCB(cb) { }

        void respond() const {
            Olsr401GetBindingEnabledCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_binding_enabled
       (
	const string&	ifname,
	const string&	vifname,
	Olsr401GetBindingEnabledCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change the UDP address and port where OLSR listens for control traffic
     *  on this interface. In order to do this the process must tell the FEA to
     *  tear down and re-bind the control traffic socket.
     *
     *  @param ifname the name of the interface.
     *
     *  @param vifname the name of the vif.
     *
     *  @param local_addr the new local IPv4 address.
     *
     *  @param local_port the new local port number.
     */
    virtual XrlCmdError olsr4_0_1_change_local_addr_port(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	local_addr,
	const uint32_t&	local_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401ChangeLocalAddrPortRF;

    class Olsr401ChangeLocalAddrPortCB {
        Olsr401ChangeLocalAddrPortRF cb;

    public:
        operator const Olsr401ChangeLocalAddrPortRF& () const { return cb; }
        const Olsr401ChangeLocalAddrPortRF& operator ->() const { return cb; }
        Olsr401ChangeLocalAddrPortCB(const Olsr401ChangeLocalAddrPortRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401ChangeLocalAddrPortRsp :
      public Olsr401ChangeLocalAddrPortCB {
        Olsr401ChangeLocalAddrPortRsp(const Olsr401ChangeLocalAddrPortRF& cb)
          : Olsr401ChangeLocalAddrPortCB(cb) { }

    };

    virtual void async_olsr4_0_1_change_local_addr_port
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	Olsr401ChangeLocalAddrPortCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change the address where OLSR sends control traffic on the given
     *  interface. By default OLSR will attempt to use the all-ones broadcast
     *  address. Currently multicast addresses are NOT supported.
     *
     *  @param ifname the name of the interface.
     *
     *  @param vifname the name of the vif.
     *
     *  @param all_nodes_addr the address to use.
     *
     *  @param all_nodes_port the port to use.
     */
    virtual XrlCmdError olsr4_0_1_change_all_nodes_addr_port(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	all_nodes_addr,
	const uint32_t&	all_nodes_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401ChangeAllNodesAddrPortRF;

    class Olsr401ChangeAllNodesAddrPortCB {
        Olsr401ChangeAllNodesAddrPortRF cb;

    public:
        operator const Olsr401ChangeAllNodesAddrPortRF& () const { return cb; }
        const Olsr401ChangeAllNodesAddrPortRF& operator ->() const { return cb; }
        Olsr401ChangeAllNodesAddrPortCB(const Olsr401ChangeAllNodesAddrPortRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401ChangeAllNodesAddrPortRsp :
      public Olsr401ChangeAllNodesAddrPortCB {
        Olsr401ChangeAllNodesAddrPortRsp(const Olsr401ChangeAllNodesAddrPortRF& cb)
          : Olsr401ChangeAllNodesAddrPortCB(cb) { }

    };

    virtual void async_olsr4_0_1_change_all_nodes_addr_port
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	all_nodes_addr,
	const uint32_t&	all_nodes_port,
	Olsr401ChangeAllNodesAddrPortCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of interfaces currently configured for OLSR. Return a list
     *  of u32 type values. Each value is an internal ID that can be used with
     *  the get_interface_info XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_interface_list(
	// Output values,
	XrlAtomList&	interfaces) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetInterfaceListRF;

    class Olsr401GetInterfaceListCB {
        Olsr401GetInterfaceListRF cb;

    public:
        operator const Olsr401GetInterfaceListRF& () const { return cb; }
        const Olsr401GetInterfaceListRF& operator ->() const { return cb; }
        Olsr401GetInterfaceListCB(const Olsr401GetInterfaceListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_interfaces) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interfaces);
        }
    };

    struct Olsr401GetInterfaceListRsp :
      public Olsr401GetInterfaceListCB {
        struct args_str {
            XrlAtomList interfaces;
        };

    private:
        args_str args;

    public:
        Olsr401GetInterfaceListRsp(const Olsr401GetInterfaceListRF& cb)
          : Olsr401GetInterfaceListCB(cb) { }

        void respond() const {
            Olsr401GetInterfaceListCB::
            respond(args.interfaces);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_interface_list
       (
	Olsr401GetInterfaceListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the per-interface information for the given interface.
     *
     *  @param faceid interface ID returned by get_interface_list.
     *
     *  @param ifname the name of the interface.
     *
     *  @param vifname the name of the vif.
     *
     *  @param local_addr the IPv4 address where OLSR is listening.
     *
     *  @param local_port the UDP port where OLSR is listening.
     *
     *  @param all_nodes_addr the IPv4 address where OLSR sends packets.
     *
     *  @param all_nodes_port the UDP port where OLSR sends packets.
     */
    virtual XrlCmdError olsr4_0_1_get_interface_info(
	// Input values,
	const uint32_t&	faceid,
	// Output values,
	string&	ifname,
	string&	vifname,
	IPv4&	local_addr,
	uint32_t&	local_port,
	IPv4&	all_nodes_addr,
	uint32_t&	all_nodes_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const string*,
	const string*,
	const IPv4*,
	const uint32_t*,
	const IPv4*,
	const uint32_t*>::RefPtr
    Olsr401GetInterfaceInfoRF;

    class Olsr401GetInterfaceInfoCB {
        Olsr401GetInterfaceInfoRF cb;

    public:
        operator const Olsr401GetInterfaceInfoRF& () const { return cb; }
        const Olsr401GetInterfaceInfoRF& operator ->() const { return cb; }
        Olsr401GetInterfaceInfoCB(const Olsr401GetInterfaceInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const string& arg_ifname,
                     const string& arg_vifname,
                     const IPv4& arg_local_addr,
                     const uint32_t& arg_local_port,
                     const IPv4& arg_all_nodes_addr,
                     const uint32_t& arg_all_nodes_port) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ifname,
                         &arg_vifname,
                         &arg_local_addr,
                         &arg_local_port,
                         &arg_all_nodes_addr,
                         &arg_all_nodes_port);
        }
    };

    struct Olsr401GetInterfaceInfoRsp :
      public Olsr401GetInterfaceInfoCB {
        struct args_str {
            string ifname;
            string vifname;
            IPv4 local_addr;
            uint32_t local_port;
            IPv4 all_nodes_addr;
            uint32_t all_nodes_port;
        };

    private:
        args_str args;

    public:
        Olsr401GetInterfaceInfoRsp(const Olsr401GetInterfaceInfoRF& cb)
          : Olsr401GetInterfaceInfoCB(cb) { }

        void respond() const {
            Olsr401GetInterfaceInfoCB::
            respond(args.ifname,
                        args.vifname,
                        args.local_addr,
                        args.local_port,
                        args.all_nodes_addr,
                        args.all_nodes_port);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_interface_info
       (
	const uint32_t&	faceid,
	Olsr401GetInterfaceInfoCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the edge cost of an interface/vif.
     *
     *  @param ifname the name of the interface.
     *
     *  @param vifname the name of the vif.
     *
     *  @param cost the new edge cost of the interface.
     */
    virtual XrlCmdError olsr4_0_1_set_interface_cost(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Olsr401SetInterfaceCostRF;

    class Olsr401SetInterfaceCostCB {
        Olsr401SetInterfaceCostRF cb;

    public:
        operator const Olsr401SetInterfaceCostRF& () const { return cb; }
        const Olsr401SetInterfaceCostRF& operator ->() const { return cb; }
        Olsr401SetInterfaceCostCB(const Olsr401SetInterfaceCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Olsr401SetInterfaceCostRsp :
      public Olsr401SetInterfaceCostCB {
        Olsr401SetInterfaceCostRsp(const Olsr401SetInterfaceCostRF& cb)
          : Olsr401SetInterfaceCostCB(cb) { }

    };

    virtual void async_olsr4_0_1_set_interface_cost
       (
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	cost,
	Olsr401SetInterfaceCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the per-interface statistics for the given interface.
     *
     *  @param ifname the interface to query.
     *
     *  @param vifname the vif to qurery
     *
     *  @param bad_packets the number of bad packets received.
     *
     *  @param bad_messages the number of bad messages received.
     *
     *  @param messages_from_self the number of messages which appeared to be
     *  from our own main address.
     *
     *  @param unknown_messages the number of messages which could not be
     *  decoded.
     *
     *  @param duplicates the number of messages which appeared to be
     *  duplicates, according to histogram based duplicate detection.
     *
     *  @param forwarded the number of messages which have been forwarded to
     *  the rest of the OLSR topology on this interface.
     */
    virtual XrlCmdError olsr4_0_1_get_interface_stats(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	// Output values,
	uint32_t&	bad_packets,
	uint32_t&	bad_messages,
	uint32_t&	messages_from_self,
	uint32_t&	unknown_messages,
	uint32_t&	duplicates,
	uint32_t&	forwarded) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Olsr401GetInterfaceStatsRF;

    class Olsr401GetInterfaceStatsCB {
        Olsr401GetInterfaceStatsRF cb;

    public:
        operator const Olsr401GetInterfaceStatsRF& () const { return cb; }
        const Olsr401GetInterfaceStatsRF& operator ->() const { return cb; }
        Olsr401GetInterfaceStatsCB(const Olsr401GetInterfaceStatsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_bad_packets,
                     const uint32_t& arg_bad_messages,
                     const uint32_t& arg_messages_from_self,
                     const uint32_t& arg_unknown_messages,
                     const uint32_t& arg_duplicates,
                     const uint32_t& arg_forwarded) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_bad_packets,
                         &arg_bad_messages,
                         &arg_messages_from_self,
                         &arg_unknown_messages,
                         &arg_duplicates,
                         &arg_forwarded);
        }
    };

    struct Olsr401GetInterfaceStatsRsp :
      public Olsr401GetInterfaceStatsCB {
        struct args_str {
            uint32_t bad_packets;
            uint32_t bad_messages;
            uint32_t messages_from_self;
            uint32_t unknown_messages;
            uint32_t duplicates;
            uint32_t forwarded;
        };

    private:
        args_str args;

    public:
        Olsr401GetInterfaceStatsRsp(const Olsr401GetInterfaceStatsRF& cb)
          : Olsr401GetInterfaceStatsCB(cb) { }

        void respond() const {
            Olsr401GetInterfaceStatsCB::
            respond(args.bad_packets,
                        args.bad_messages,
                        args.messages_from_self,
                        args.unknown_messages,
                        args.duplicates,
                        args.forwarded);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_interface_stats
       (
	const string&	ifname,
	const string&	vifname,
	Olsr401GetInterfaceStatsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of one-hop links. Return a list of u32 type values. Each
     *  value is an internal ID that can be used with the get_link_info XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_link_list(
	// Output values,
	XrlAtomList&	links) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetLinkListRF;

    class Olsr401GetLinkListCB {
        Olsr401GetLinkListRF cb;

    public:
        operator const Olsr401GetLinkListRF& () const { return cb; }
        const Olsr401GetLinkListRF& operator ->() const { return cb; }
        Olsr401GetLinkListCB(const Olsr401GetLinkListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_links) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_links);
        }
    };

    struct Olsr401GetLinkListRsp :
      public Olsr401GetLinkListCB {
        struct args_str {
            XrlAtomList links;
        };

    private:
        args_str args;

    public:
        Olsr401GetLinkListRsp(const Olsr401GetLinkListRF& cb)
          : Olsr401GetLinkListCB(cb) { }

        void respond() const {
            Olsr401GetLinkListCB::
            respond(args.links);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_link_list
       (
	Olsr401GetLinkListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information for a one-hop link. TODO: Add ETX support.
     *
     *  @param linkid Link entry ID returned by get_link_list.
     *
     *  @param local_addr the interface address of the local end of this link.
     *
     *  @param remote_addr the interface address of the remote end of this
     *  link.
     *
     *  @param main_addr the main address of the neighbor at the remote end of
     *  this link.
     *
     *  @param link_type the type of this link.
     *
     *  @param sym_time the time in seconds for which this link will be
     *  considered symmetric.
     *
     *  @param asym_time the time in seconds for which this link will be
     *  considered asymmetric.
     *
     *  @param hold_time the time in seconds until this link expires.
     */
    virtual XrlCmdError olsr4_0_1_get_link_info(
	// Input values,
	const uint32_t&	linkid,
	// Output values,
	IPv4&	local_addr,
	IPv4&	remote_addr,
	IPv4&	main_addr,
	uint32_t&	link_type,
	uint32_t&	sym_time,
	uint32_t&	asym_time,
	uint32_t&	hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback8<void, const XrlCmdError &,
	const IPv4*,
	const IPv4*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Olsr401GetLinkInfoRF;

    class Olsr401GetLinkInfoCB {
        Olsr401GetLinkInfoRF cb;

    public:
        operator const Olsr401GetLinkInfoRF& () const { return cb; }
        const Olsr401GetLinkInfoRF& operator ->() const { return cb; }
        Olsr401GetLinkInfoCB(const Olsr401GetLinkInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_local_addr,
                     const IPv4& arg_remote_addr,
                     const IPv4& arg_main_addr,
                     const uint32_t& arg_link_type,
                     const uint32_t& arg_sym_time,
                     const uint32_t& arg_asym_time,
                     const uint32_t& arg_hold_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_local_addr,
                         &arg_remote_addr,
                         &arg_main_addr,
                         &arg_link_type,
                         &arg_sym_time,
                         &arg_asym_time,
                         &arg_hold_time);
        }
    };

    struct Olsr401GetLinkInfoRsp :
      public Olsr401GetLinkInfoCB {
        struct args_str {
            IPv4 local_addr;
            IPv4 remote_addr;
            IPv4 main_addr;
            uint32_t link_type;
            uint32_t sym_time;
            uint32_t asym_time;
            uint32_t hold_time;
        };

    private:
        args_str args;

    public:
        Olsr401GetLinkInfoRsp(const Olsr401GetLinkInfoRF& cb)
          : Olsr401GetLinkInfoCB(cb) { }

        void respond() const {
            Olsr401GetLinkInfoCB::
            respond(args.local_addr,
                        args.remote_addr,
                        args.main_addr,
                        args.link_type,
                        args.sym_time,
                        args.asym_time,
                        args.hold_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_link_info
       (
	const uint32_t&	linkid,
	Olsr401GetLinkInfoCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of one-hop neighbors. Return a list of u32 type values.
     *  Each value is an internal ID that can be used with the
     *  get_neighbor_info XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_neighbor_list(
	// Output values,
	XrlAtomList&	neighbors) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetNeighborListRF;

    class Olsr401GetNeighborListCB {
        Olsr401GetNeighborListRF cb;

    public:
        operator const Olsr401GetNeighborListRF& () const { return cb; }
        const Olsr401GetNeighborListRF& operator ->() const { return cb; }
        Olsr401GetNeighborListCB(const Olsr401GetNeighborListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_neighbors) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_neighbors);
        }
    };

    struct Olsr401GetNeighborListRsp :
      public Olsr401GetNeighborListCB {
        struct args_str {
            XrlAtomList neighbors;
        };

    private:
        args_str args;

    public:
        Olsr401GetNeighborListRsp(const Olsr401GetNeighborListRF& cb)
          : Olsr401GetNeighborListCB(cb) { }

        void respond() const {
            Olsr401GetNeighborListCB::
            respond(args.neighbors);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_neighbor_list
       (
	Olsr401GetNeighborListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information for a one-hop neighbor.
     *
     *  @param nid Neighbor entry ID returned by get_neighbor_list.
     *
     *  @param main_addr the main address of this neighbor.
     *
     *  @param willingness the willingness of this neighbor to forward.
     *
     *  @param degree the number of symmetric strict neighbors of this
     *  neighbor, excluding one-hop neighbors and this node.
     *
     *  @param link_count the number of links to this neighbor.
     *
     *  @param twohop_link_count the number of two-hop links which transit this
     *  neighbor as next-hop.
     *
     *  @param is_advertised true if this neighbor is in the Advertised
     *  Neighbor Set of this node.
     *
     *  @param is_sym true if this neighbor is symmetric.
     *
     *  @param is_mpr true if this neighbor is selected as an MPR by this node.
     *
     *  @param is_mpr_selector true if this neighbor chooses this node as an
     *  MPR.
     */
    virtual XrlCmdError olsr4_0_1_get_neighbor_info(
	// Input values,
	const uint32_t&	nid,
	// Output values,
	IPv4&	main_addr,
	uint32_t&	willingness,
	uint32_t&	degree,
	uint32_t&	link_count,
	uint32_t&	twohop_link_count,
	bool&	is_advertised,
	bool&	is_sym,
	bool&	is_mpr,
	bool&	is_mpr_selector) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback10<void, const XrlCmdError &,
	const IPv4*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const bool*,
	const bool*,
	const bool*,
	const bool*>::RefPtr
    Olsr401GetNeighborInfoRF;

    class Olsr401GetNeighborInfoCB {
        Olsr401GetNeighborInfoRF cb;

    public:
        operator const Olsr401GetNeighborInfoRF& () const { return cb; }
        const Olsr401GetNeighborInfoRF& operator ->() const { return cb; }
        Olsr401GetNeighborInfoCB(const Olsr401GetNeighborInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_main_addr,
                     const uint32_t& arg_willingness,
                     const uint32_t& arg_degree,
                     const uint32_t& arg_link_count,
                     const uint32_t& arg_twohop_link_count,
                     const bool& arg_is_advertised,
                     const bool& arg_is_sym,
                     const bool& arg_is_mpr,
                     const bool& arg_is_mpr_selector) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_main_addr,
                         &arg_willingness,
                         &arg_degree,
                         &arg_link_count,
                         &arg_twohop_link_count,
                         &arg_is_advertised,
                         &arg_is_sym,
                         &arg_is_mpr,
                         &arg_is_mpr_selector);
        }
    };

    struct Olsr401GetNeighborInfoRsp :
      public Olsr401GetNeighborInfoCB {
        struct args_str {
            IPv4 main_addr;
            uint32_t willingness;
            uint32_t degree;
            uint32_t link_count;
            uint32_t twohop_link_count;
            bool is_advertised;
            bool is_sym;
            bool is_mpr;
            bool is_mpr_selector;
        };

    private:
        args_str args;

    public:
        Olsr401GetNeighborInfoRsp(const Olsr401GetNeighborInfoRF& cb)
          : Olsr401GetNeighborInfoCB(cb) { }

        void respond() const {
            Olsr401GetNeighborInfoCB::
            respond(args.main_addr,
                        args.willingness,
                        args.degree,
                        args.link_count,
                        args.twohop_link_count,
                        args.is_advertised,
                        args.is_sym,
                        args.is_mpr,
                        args.is_mpr_selector);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_neighbor_info
       (
	const uint32_t&	nid,
	Olsr401GetNeighborInfoCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of two-hop links. Return a list of u32 type values. Each
     *  value is an internal ID that can be used with the get_twohop_link_info
     *  XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_twohop_link_list(
	// Output values,
	XrlAtomList&	twohop_links) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetTwohopLinkListRF;

    class Olsr401GetTwohopLinkListCB {
        Olsr401GetTwohopLinkListRF cb;

    public:
        operator const Olsr401GetTwohopLinkListRF& () const { return cb; }
        const Olsr401GetTwohopLinkListRF& operator ->() const { return cb; }
        Olsr401GetTwohopLinkListCB(const Olsr401GetTwohopLinkListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_twohop_links) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_twohop_links);
        }
    };

    struct Olsr401GetTwohopLinkListRsp :
      public Olsr401GetTwohopLinkListCB {
        struct args_str {
            XrlAtomList twohop_links;
        };

    private:
        args_str args;

    public:
        Olsr401GetTwohopLinkListRsp(const Olsr401GetTwohopLinkListRF& cb)
          : Olsr401GetTwohopLinkListCB(cb) { }

        void respond() const {
            Olsr401GetTwohopLinkListCB::
            respond(args.twohop_links);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_twohop_link_list
       (
	Olsr401GetTwohopLinkListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information for a two-hop link. TODO: Add ETX support.
     *
     *  @param tlid two-hop link ID returned by get_twohop_link_list.
     *
     *  @param last_face_id the internal interface ID where advertisement of
     *  this two-hop link was last seen.
     *
     *  @param nexthop_addr the main address of the one-hop neighbor where this
     *  two-hop link exists.
     *
     *  @param dest_addr the main address of the two-hop neighbor at the remote
     *  end of this link.
     *
     *  @param hold_time the time in seconds until this two-hop link expires.
     */
    virtual XrlCmdError olsr4_0_1_get_twohop_link_info(
	// Input values,
	const uint32_t&	tlid,
	// Output values,
	uint32_t&	last_face_id,
	IPv4&	nexthop_addr,
	IPv4&	dest_addr,
	uint32_t&	hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const uint32_t*,
	const IPv4*,
	const IPv4*,
	const uint32_t*>::RefPtr
    Olsr401GetTwohopLinkInfoRF;

    class Olsr401GetTwohopLinkInfoCB {
        Olsr401GetTwohopLinkInfoRF cb;

    public:
        operator const Olsr401GetTwohopLinkInfoRF& () const { return cb; }
        const Olsr401GetTwohopLinkInfoRF& operator ->() const { return cb; }
        Olsr401GetTwohopLinkInfoCB(const Olsr401GetTwohopLinkInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_last_face_id,
                     const IPv4& arg_nexthop_addr,
                     const IPv4& arg_dest_addr,
                     const uint32_t& arg_hold_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_last_face_id,
                         &arg_nexthop_addr,
                         &arg_dest_addr,
                         &arg_hold_time);
        }
    };

    struct Olsr401GetTwohopLinkInfoRsp :
      public Olsr401GetTwohopLinkInfoCB {
        struct args_str {
            uint32_t last_face_id;
            IPv4 nexthop_addr;
            IPv4 dest_addr;
            uint32_t hold_time;
        };

    private:
        args_str args;

    public:
        Olsr401GetTwohopLinkInfoRsp(const Olsr401GetTwohopLinkInfoRF& cb)
          : Olsr401GetTwohopLinkInfoCB(cb) { }

        void respond() const {
            Olsr401GetTwohopLinkInfoCB::
            respond(args.last_face_id,
                        args.nexthop_addr,
                        args.dest_addr,
                        args.hold_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_twohop_link_info
       (
	const uint32_t&	tlid,
	Olsr401GetTwohopLinkInfoCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of two-hop neighbors. Return a list of u32 type values.
     *  Each value is an internal ID that can be used with the
     *  get_twohop_neighbor_info XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_twohop_neighbor_list(
	// Output values,
	XrlAtomList&	twohop_neighbors) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetTwohopNeighborListRF;

    class Olsr401GetTwohopNeighborListCB {
        Olsr401GetTwohopNeighborListRF cb;

    public:
        operator const Olsr401GetTwohopNeighborListRF& () const { return cb; }
        const Olsr401GetTwohopNeighborListRF& operator ->() const { return cb; }
        Olsr401GetTwohopNeighborListCB(const Olsr401GetTwohopNeighborListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_twohop_neighbors) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_twohop_neighbors);
        }
    };

    struct Olsr401GetTwohopNeighborListRsp :
      public Olsr401GetTwohopNeighborListCB {
        struct args_str {
            XrlAtomList twohop_neighbors;
        };

    private:
        args_str args;

    public:
        Olsr401GetTwohopNeighborListRsp(const Olsr401GetTwohopNeighborListRF& cb)
          : Olsr401GetTwohopNeighborListCB(cb) { }

        void respond() const {
            Olsr401GetTwohopNeighborListCB::
            respond(args.twohop_neighbors);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_twohop_neighbor_list
       (
	Olsr401GetTwohopNeighborListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information for a two-hop neighbor.
     *
     *  @param tnid two-hop neighbor ID returned by get_twohop_neighbor_list.
     *
     *  @param main_addr the main address of this two-hop neighbor.
     *
     *  @param is_strict true if this two-hop neighbor is not also a two-hop
     *  neighbor.
     *
     *  @param link_count the number of two-hop links that exist to this
     *  two-hop neighbor.
     *
     *  @param reachability the number of MPR candidates which cover this
     *  two-hop neighbor.
     *
     *  @param coverage the number of selected MPRs which cover this two-hop
     *  neighbor.
     */
    virtual XrlCmdError olsr4_0_1_get_twohop_neighbor_info(
	// Input values,
	const uint32_t&	tnid,
	// Output values,
	IPv4&	main_addr,
	bool&	is_strict,
	uint32_t&	link_count,
	uint32_t&	reachability,
	uint32_t&	coverage) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const IPv4*,
	const bool*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Olsr401GetTwohopNeighborInfoRF;

    class Olsr401GetTwohopNeighborInfoCB {
        Olsr401GetTwohopNeighborInfoRF cb;

    public:
        operator const Olsr401GetTwohopNeighborInfoRF& () const { return cb; }
        const Olsr401GetTwohopNeighborInfoRF& operator ->() const { return cb; }
        Olsr401GetTwohopNeighborInfoCB(const Olsr401GetTwohopNeighborInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_main_addr,
                     const bool& arg_is_strict,
                     const uint32_t& arg_link_count,
                     const uint32_t& arg_reachability,
                     const uint32_t& arg_coverage) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_main_addr,
                         &arg_is_strict,
                         &arg_link_count,
                         &arg_reachability,
                         &arg_coverage);
        }
    };

    struct Olsr401GetTwohopNeighborInfoRsp :
      public Olsr401GetTwohopNeighborInfoCB {
        struct args_str {
            IPv4 main_addr;
            bool is_strict;
            uint32_t link_count;
            uint32_t reachability;
            uint32_t coverage;
        };

    private:
        args_str args;

    public:
        Olsr401GetTwohopNeighborInfoRsp(const Olsr401GetTwohopNeighborInfoRF& cb)
          : Olsr401GetTwohopNeighborInfoCB(cb) { }

        void respond() const {
            Olsr401GetTwohopNeighborInfoCB::
            respond(args.main_addr,
                        args.is_strict,
                        args.link_count,
                        args.reachability,
                        args.coverage);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_twohop_neighbor_info
       (
	const uint32_t&	tnid,
	Olsr401GetTwohopNeighborInfoCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of learned Multiple Interface Declaration (MID) entries.
     *  Return a list of u32 type values. Each value is an internal ID that can
     *  be used with the get_mid_entry XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_mid_entry_list(
	// Output values,
	XrlAtomList&	mid_entries) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetMidEntryListRF;

    class Olsr401GetMidEntryListCB {
        Olsr401GetMidEntryListRF cb;

    public:
        operator const Olsr401GetMidEntryListRF& () const { return cb; }
        const Olsr401GetMidEntryListRF& operator ->() const { return cb; }
        Olsr401GetMidEntryListCB(const Olsr401GetMidEntryListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_mid_entries) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_mid_entries);
        }
    };

    struct Olsr401GetMidEntryListRsp :
      public Olsr401GetMidEntryListCB {
        struct args_str {
            XrlAtomList mid_entries;
        };

    private:
        args_str args;

    public:
        Olsr401GetMidEntryListRsp(const Olsr401GetMidEntryListRF& cb)
          : Olsr401GetMidEntryListCB(cb) { }

        void respond() const {
            Olsr401GetMidEntryListCB::
            respond(args.mid_entries);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_mid_entry_list
       (
	Olsr401GetMidEntryListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information contained in a MID entry.
     *
     *  @param midid MID entry ID returned by get_mid_entry_list.
     *
     *  @param main_addr the main address of the OLSR node
     *
     *  @param iface_addr the interface address being advertised.
     *
     *  @param distance the distance measured between this node and the origin
     *  of the MID packet containing this entry.
     *
     *  @param hold_time the time in seconds until this entry expires.
     */
    virtual XrlCmdError olsr4_0_1_get_mid_entry(
	// Input values,
	const uint32_t&	midid,
	// Output values,
	IPv4&	main_addr,
	IPv4&	iface_addr,
	uint32_t&	distance,
	uint32_t&	hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const IPv4*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Olsr401GetMidEntryRF;

    class Olsr401GetMidEntryCB {
        Olsr401GetMidEntryRF cb;

    public:
        operator const Olsr401GetMidEntryRF& () const { return cb; }
        const Olsr401GetMidEntryRF& operator ->() const { return cb; }
        Olsr401GetMidEntryCB(const Olsr401GetMidEntryRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_main_addr,
                     const IPv4& arg_iface_addr,
                     const uint32_t& arg_distance,
                     const uint32_t& arg_hold_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_main_addr,
                         &arg_iface_addr,
                         &arg_distance,
                         &arg_hold_time);
        }
    };

    struct Olsr401GetMidEntryRsp :
      public Olsr401GetMidEntryCB {
        struct args_str {
            IPv4 main_addr;
            IPv4 iface_addr;
            uint32_t distance;
            uint32_t hold_time;
        };

    private:
        args_str args;

    public:
        Olsr401GetMidEntryRsp(const Olsr401GetMidEntryRF& cb)
          : Olsr401GetMidEntryCB(cb) { }

        void respond() const {
            Olsr401GetMidEntryCB::
            respond(args.main_addr,
                        args.iface_addr,
                        args.distance,
                        args.hold_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_mid_entry
       (
	const uint32_t&	midid,
	Olsr401GetMidEntryCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of learned Topology Control (TC) entries. Return a list of
     *  u32 type values. Each value is an internal ID that can be used with the
     *  get_tc_entry XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_tc_entry_list(
	// Output values,
	XrlAtomList&	tc_entries) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetTcEntryListRF;

    class Olsr401GetTcEntryListCB {
        Olsr401GetTcEntryListRF cb;

    public:
        operator const Olsr401GetTcEntryListRF& () const { return cb; }
        const Olsr401GetTcEntryListRF& operator ->() const { return cb; }
        Olsr401GetTcEntryListCB(const Olsr401GetTcEntryListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_tc_entries) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tc_entries);
        }
    };

    struct Olsr401GetTcEntryListRsp :
      public Olsr401GetTcEntryListCB {
        struct args_str {
            XrlAtomList tc_entries;
        };

    private:
        args_str args;

    public:
        Olsr401GetTcEntryListRsp(const Olsr401GetTcEntryListRF& cb)
          : Olsr401GetTcEntryListCB(cb) { }

        void respond() const {
            Olsr401GetTcEntryListCB::
            respond(args.tc_entries);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_tc_entry_list
       (
	Olsr401GetTcEntryListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information contained in a TC entry.
     *
     *  @param tcid TC entry ID returned by get_tc_entry_list.
     *
     *  @param destination the main address of the advertised destination.
     *
     *  @param lasthop the main address of the node advertising this entry.
     *
     *  @param distance the distance measured between this node and the origin
     *  of the TC packet containing this entry.
     *
     *  @param seqno the advertised sequence number of this entry.
     *
     *  @param hold_time the time in seconds until this entry expires.
     */
    virtual XrlCmdError olsr4_0_1_get_tc_entry(
	// Input values,
	const uint32_t&	tcid,
	// Output values,
	IPv4&	destination,
	IPv4&	lasthop,
	uint32_t&	distance,
	uint32_t&	seqno,
	uint32_t&	hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const IPv4*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Olsr401GetTcEntryRF;

    class Olsr401GetTcEntryCB {
        Olsr401GetTcEntryRF cb;

    public:
        operator const Olsr401GetTcEntryRF& () const { return cb; }
        const Olsr401GetTcEntryRF& operator ->() const { return cb; }
        Olsr401GetTcEntryCB(const Olsr401GetTcEntryRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_destination,
                     const IPv4& arg_lasthop,
                     const uint32_t& arg_distance,
                     const uint32_t& arg_seqno,
                     const uint32_t& arg_hold_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_destination,
                         &arg_lasthop,
                         &arg_distance,
                         &arg_seqno,
                         &arg_hold_time);
        }
    };

    struct Olsr401GetTcEntryRsp :
      public Olsr401GetTcEntryCB {
        struct args_str {
            IPv4 destination;
            IPv4 lasthop;
            uint32_t distance;
            uint32_t seqno;
            uint32_t hold_time;
        };

    private:
        args_str args;

    public:
        Olsr401GetTcEntryRsp(const Olsr401GetTcEntryRF& cb)
          : Olsr401GetTcEntryCB(cb) { }

        void respond() const {
            Olsr401GetTcEntryCB::
            respond(args.destination,
                        args.lasthop,
                        args.distance,
                        args.seqno,
                        args.hold_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_tc_entry
       (
	const uint32_t&	tcid,
	Olsr401GetTcEntryCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of learned external route (HNA) entries. Return a list of
     *  u32 type values. Each value is an internal ID that can be used with the
     *  get_hna_entry XRL.
     */
    virtual XrlCmdError olsr4_0_1_get_hna_entry_list(
	// Output values,
	XrlAtomList&	hna_entries) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Olsr401GetHnaEntryListRF;

    class Olsr401GetHnaEntryListCB {
        Olsr401GetHnaEntryListRF cb;

    public:
        operator const Olsr401GetHnaEntryListRF& () const { return cb; }
        const Olsr401GetHnaEntryListRF& operator ->() const { return cb; }
        Olsr401GetHnaEntryListCB(const Olsr401GetHnaEntryListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_hna_entries) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_hna_entries);
        }
    };

    struct Olsr401GetHnaEntryListRsp :
      public Olsr401GetHnaEntryListCB {
        struct args_str {
            XrlAtomList hna_entries;
        };

    private:
        args_str args;

    public:
        Olsr401GetHnaEntryListRsp(const Olsr401GetHnaEntryListRF& cb)
          : Olsr401GetHnaEntryListCB(cb) { }

        void respond() const {
            Olsr401GetHnaEntryListCB::
            respond(args.hna_entries);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_hna_entry_list
       (
	Olsr401GetHnaEntryListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the information contained in a HNA entry.
     *
     *  @param hnaid HNA entry ID returned by get_hna_entry_list.
     *
     *  @param destination the main address of the advertised destination.
     *
     *  @param lasthop the main address of the node advertising this entry.
     *
     *  @param distance the distance measured between this node and the origin
     *  of the TC packet containing this entry.
     *
     *  @param hold_time the time in seconds until this entry expires.
     */
    virtual XrlCmdError olsr4_0_1_get_hna_entry(
	// Input values,
	const uint32_t&	hnaid,
	// Output values,
	IPv4Net&	destination,
	IPv4&	lasthop,
	uint32_t&	distance,
	uint32_t&	hold_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const IPv4Net*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Olsr401GetHnaEntryRF;

    class Olsr401GetHnaEntryCB {
        Olsr401GetHnaEntryRF cb;

    public:
        operator const Olsr401GetHnaEntryRF& () const { return cb; }
        const Olsr401GetHnaEntryRF& operator ->() const { return cb; }
        Olsr401GetHnaEntryCB(const Olsr401GetHnaEntryRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const IPv4Net& arg_destination,
                     const IPv4& arg_lasthop,
                     const uint32_t& arg_distance,
                     const uint32_t& arg_hold_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_destination,
                         &arg_lasthop,
                         &arg_distance,
                         &arg_hold_time);
        }
    };

    struct Olsr401GetHnaEntryRsp :
      public Olsr401GetHnaEntryCB {
        struct args_str {
            IPv4Net destination;
            IPv4 lasthop;
            uint32_t distance;
            uint32_t hold_time;
        };

    private:
        args_str args;

    public:
        Olsr401GetHnaEntryRsp(const Olsr401GetHnaEntryRF& cb)
          : Olsr401GetHnaEntryCB(cb) { }

        void respond() const {
            Olsr401GetHnaEntryCB::
            respond(args.destination,
                        args.lasthop,
                        args.distance,
                        args.hold_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_olsr4_0_1_get_hna_entry
       (
	const uint32_t&	hnaid,
	Olsr401GetHnaEntryCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_recv_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_recv_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_inbound_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_inbound_connect_event
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_outgoing_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_outgoing_connect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_error_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_error_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_disconnect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_disconnect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_add_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_add_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_delete_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_delete_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_enable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_enable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_disable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_disable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_get_entries(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_get_entries
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_clear(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_clear
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_list
       (const XrlCmdError &e,
	const string* arg_info,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_trace(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_trace
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_clear_database(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_clear_database
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_willingness(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_willingness
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_willingness(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_willingness
       (const XrlCmdError &e,
	const uint32_t* arg_willingness,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_mpr_coverage(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_mpr_coverage
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_mpr_coverage(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_mpr_coverage
       (const XrlCmdError &e,
	const uint32_t* arg_coverage,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_tc_redundancy(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_tc_redundancy
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_tc_redundancy(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_tc_redundancy
       (const XrlCmdError &e,
	const string* arg_redundancy,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_tc_fisheye(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_tc_fisheye
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_tc_fisheye(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_tc_fisheye
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_hna_base_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_hna_base_cost
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_hna_base_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_hna_base_cost
       (const XrlCmdError &e,
	const uint32_t* arg_metric,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_hello_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_hello_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_hello_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_hello_interval
       (const XrlCmdError &e,
	const uint32_t* arg_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_refresh_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_refresh_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_refresh_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_refresh_interval
       (const XrlCmdError &e,
	const uint32_t* arg_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_tc_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_tc_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_tc_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_tc_interval
       (const XrlCmdError &e,
	const uint32_t* arg_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_mid_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_mid_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_mid_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_mid_interval
       (const XrlCmdError &e,
	const uint32_t* arg_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_hna_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_hna_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_hna_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_hna_interval
       (const XrlCmdError &e,
	const uint32_t* arg_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_dup_hold_time(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_dup_hold_time
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_dup_hold_time(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_dup_hold_time
       (const XrlCmdError &e,
	const uint32_t* arg_dup_hold_time,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_main_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_main_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_main_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_main_address
       (const XrlCmdError &e,
	const IPv4* arg_addr,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_bind_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_bind_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_unbind_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_unbind_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_binding_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_binding_enabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_binding_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_binding_enabled
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_change_local_addr_port(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_change_local_addr_port
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_change_all_nodes_addr_port(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_change_all_nodes_addr_port
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_interface_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_interface_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_interfaces,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_interface_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_interface_info
       (const XrlCmdError &e,
	const string* arg_ifname,
	const string* arg_vifname,
	const IPv4* arg_local_addr,
	const uint32_t* arg_local_port,
	const IPv4* arg_all_nodes_addr,
	const uint32_t* arg_all_nodes_port,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_set_interface_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_set_interface_cost
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_interface_stats(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_interface_stats
       (const XrlCmdError &e,
	const uint32_t* arg_bad_packets,
	const uint32_t* arg_bad_messages,
	const uint32_t* arg_messages_from_self,
	const uint32_t* arg_unknown_messages,
	const uint32_t* arg_duplicates,
	const uint32_t* arg_forwarded,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_link_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_link_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_links,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_link_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_link_info
       (const XrlCmdError &e,
	const IPv4* arg_local_addr,
	const IPv4* arg_remote_addr,
	const IPv4* arg_main_addr,
	const uint32_t* arg_link_type,
	const uint32_t* arg_sym_time,
	const uint32_t* arg_asym_time,
	const uint32_t* arg_hold_time,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_neighbor_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_neighbor_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_neighbors,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_neighbor_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_neighbor_info
       (const XrlCmdError &e,
	const IPv4* arg_main_addr,
	const uint32_t* arg_willingness,
	const uint32_t* arg_degree,
	const uint32_t* arg_link_count,
	const uint32_t* arg_twohop_link_count,
	const bool* arg_is_advertised,
	const bool* arg_is_sym,
	const bool* arg_is_mpr,
	const bool* arg_is_mpr_selector,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_twohop_link_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_twohop_link_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_twohop_links,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_twohop_link_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_twohop_link_info
       (const XrlCmdError &e,
	const uint32_t* arg_last_face_id,
	const IPv4* arg_nexthop_addr,
	const IPv4* arg_dest_addr,
	const uint32_t* arg_hold_time,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_twohop_neighbor_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_twohop_neighbor_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_twohop_neighbors,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_twohop_neighbor_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_twohop_neighbor_info
       (const XrlCmdError &e,
	const IPv4* arg_main_addr,
	const bool* arg_is_strict,
	const uint32_t* arg_link_count,
	const uint32_t* arg_reachability,
	const uint32_t* arg_coverage,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_mid_entry_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_mid_entry_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_mid_entries,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_mid_entry(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_mid_entry
       (const XrlCmdError &e,
	const IPv4* arg_main_addr,
	const IPv4* arg_iface_addr,
	const uint32_t* arg_distance,
	const uint32_t* arg_hold_time,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_tc_entry_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_tc_entry_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_tc_entries,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_tc_entry(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_tc_entry
       (const XrlCmdError &e,
	const IPv4* arg_destination,
	const IPv4* arg_lasthop,
	const uint32_t* arg_distance,
	const uint32_t* arg_seqno,
	const uint32_t* arg_hold_time,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_hna_entry_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_hna_entry_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_hna_entries,
        XrlRespCallback);
#endif

    XrlCmdRT handle_olsr4_0_1_get_hna_entry(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_olsr4_0_1_get_hna_entry
       (const XrlCmdError &e,
	const IPv4Net* arg_destination,
	const IPv4* arg_lasthop,
	const uint32_t* arg_distance,
	const uint32_t* arg_hold_time,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlOlsr4TargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_OLSR4_BASE_HH__
