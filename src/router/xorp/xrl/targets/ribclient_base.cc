/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/ribclient_base.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#include "ribclient_base.hh"


const struct XrlRibclientTargetBase::handler_table XrlRibclientTargetBase::handlers[] = {
    { "rib_client/0.1/route_info_changed4",
      &XrlRibclientTargetBase::handle_rib_client_0_1_route_info_changed4 },
    { "rib_client/0.1/route_info_invalid4",
      &XrlRibclientTargetBase::handle_rib_client_0_1_route_info_invalid4 },
    { "rib_client/0.1/route_info_changed6",
      &XrlRibclientTargetBase::handle_rib_client_0_1_route_info_changed6 },
    { "rib_client/0.1/route_info_invalid6",
      &XrlRibclientTargetBase::handle_rib_client_0_1_route_info_invalid6 },
};

const size_t XrlRibclientTargetBase::num_handlers = (sizeof(XrlRibclientTargetBase::handlers) / sizeof(XrlRibclientTargetBase::handlers[0]));


XrlRibclientTargetBase::XrlRibclientTargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlRibclientTargetBase::~XrlRibclientTargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlRibclientTargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlRibclientTargetBase::callback_rib_client_0_1_route_info_changed4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_changed4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlRibclientTargetBase::async_rib_client_0_1_route_info_changed4(
	const IPv4&	arg_addr,
	const uint32_t&	arg_prefix_len,
	const IPv4&	arg_nexthop,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_protocol_origin,
	RibClient01RouteInfoChanged4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_changed4(
        arg_addr,
        arg_prefix_len,
        arg_nexthop,
        arg_metric,
        arg_admin_distance,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlRibclientTargetBase::handle_rib_client_0_1_route_info_changed4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_changed4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoChanged4RF mycb =
	    callback(this, &XrlRibclientTargetBase::callback_rib_client_0_1_route_info_changed4, pxa_outputs);
	async_rib_client_0_1_route_info_changed4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_changed4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_changed4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlRibclientTargetBase::callback_rib_client_0_1_route_info_invalid4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_invalid4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlRibclientTargetBase::async_rib_client_0_1_route_info_invalid4(
	const IPv4&	arg_addr,
	const uint32_t&	arg_prefix_len,
	RibClient01RouteInfoInvalid4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_invalid4(
        arg_addr,
        arg_prefix_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlRibclientTargetBase::handle_rib_client_0_1_route_info_invalid4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_invalid4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoInvalid4RF mycb =
	    callback(this, &XrlRibclientTargetBase::callback_rib_client_0_1_route_info_invalid4, pxa_outputs);
	async_rib_client_0_1_route_info_invalid4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_invalid4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_invalid4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlRibclientTargetBase::callback_rib_client_0_1_route_info_changed6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_changed6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlRibclientTargetBase::async_rib_client_0_1_route_info_changed6(
	const IPv6&	arg_addr,
	const uint32_t&	arg_prefix_len,
	const IPv6&	arg_nexthop,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_protocol_origin,
	RibClient01RouteInfoChanged6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_changed6(
        arg_addr,
        arg_prefix_len,
        arg_nexthop,
        arg_metric,
        arg_admin_distance,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlRibclientTargetBase::handle_rib_client_0_1_route_info_changed6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_changed6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoChanged6RF mycb =
	    callback(this, &XrlRibclientTargetBase::callback_rib_client_0_1_route_info_changed6, pxa_outputs);
	async_rib_client_0_1_route_info_changed6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_changed6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_changed6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlRibclientTargetBase::callback_rib_client_0_1_route_info_invalid6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_invalid6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlRibclientTargetBase::async_rib_client_0_1_route_info_invalid6(
	const IPv6&	arg_addr,
	const uint32_t&	arg_prefix_len,
	RibClient01RouteInfoInvalid6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_invalid6(
        arg_addr,
        arg_prefix_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlRibclientTargetBase::handle_rib_client_0_1_route_info_invalid6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_invalid6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoInvalid6RF mycb =
	    callback(this, &XrlRibclientTargetBase::callback_rib_client_0_1_route_info_invalid6, pxa_outputs);
	async_rib_client_0_1_route_info_invalid6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_invalid6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_invalid6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}

void
XrlRibclientTargetBase::add_handlers()
{
    for (size_t i = 0; i < num_handlers; ++i) {
        if (!_cmds->add_handler(handlers[i].name,
                                callback(this, handlers[i].method))) {
            XLOG_ERROR("Failed to register xrl handler finder://%s/%s", "ribclient", handlers[i].name);
        }
    }
    _cmds->finalize();
}

void
XrlRibclientTargetBase::remove_handlers()
{
     for (size_t i = 0; i < num_handlers; ++i) {
         _cmds->remove_handler(handlers[i].name);
     }
}
