/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/pim_base.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#include "pim_base.hh"


const struct XrlPimTargetBase::handler_table XrlPimTargetBase::handlers[] = {
    { "common/0.1/get_target_name",
      &XrlPimTargetBase::handle_common_0_1_get_target_name },
    { "common/0.1/get_version",
      &XrlPimTargetBase::handle_common_0_1_get_version },
    { "common/0.1/get_status",
      &XrlPimTargetBase::handle_common_0_1_get_status },
    { "common/0.1/shutdown",
      &XrlPimTargetBase::handle_common_0_1_shutdown },
    { "common/0.1/startup",
      &XrlPimTargetBase::handle_common_0_1_startup },
    { "cli_processor/0.1/process_command",
      &XrlPimTargetBase::handle_cli_processor_0_1_process_command },
    { "finder_event_observer/0.1/xrl_target_birth",
      &XrlPimTargetBase::handle_finder_event_observer_0_1_xrl_target_birth },
    { "finder_event_observer/0.1/xrl_target_death",
      &XrlPimTargetBase::handle_finder_event_observer_0_1_xrl_target_death },
    { "raw_packet4_client/0.1/recv",
      &XrlPimTargetBase::handle_raw_packet4_client_0_1_recv },
    { "raw_packet6_client/0.1/recv",
      &XrlPimTargetBase::handle_raw_packet6_client_0_1_recv },
    { "redist_transaction6/0.1/start_transaction",
      &XrlPimTargetBase::handle_redist_transaction6_0_1_start_transaction },
    { "redist_transaction6/0.1/commit_transaction",
      &XrlPimTargetBase::handle_redist_transaction6_0_1_commit_transaction },
    { "redist_transaction6/0.1/abort_transaction",
      &XrlPimTargetBase::handle_redist_transaction6_0_1_abort_transaction },
    { "redist_transaction6/0.1/add_route",
      &XrlPimTargetBase::handle_redist_transaction6_0_1_add_route },
    { "redist_transaction6/0.1/delete_route",
      &XrlPimTargetBase::handle_redist_transaction6_0_1_delete_route },
    { "redist_transaction6/0.1/delete_all_routes",
      &XrlPimTargetBase::handle_redist_transaction6_0_1_delete_all_routes },
    { "mfea_client/0.1/recv_kernel_signal_message4",
      &XrlPimTargetBase::handle_mfea_client_0_1_recv_kernel_signal_message4 },
    { "mfea_client/0.1/recv_dataflow_signal4",
      &XrlPimTargetBase::handle_mfea_client_0_1_recv_dataflow_signal4 },
    { "mfea_client/0.1/recv_kernel_signal_message6",
      &XrlPimTargetBase::handle_mfea_client_0_1_recv_kernel_signal_message6 },
    { "mfea_client/0.1/recv_dataflow_signal6",
      &XrlPimTargetBase::handle_mfea_client_0_1_recv_dataflow_signal6 },
    { "redist_transaction4/0.1/start_transaction",
      &XrlPimTargetBase::handle_redist_transaction4_0_1_start_transaction },
    { "redist_transaction4/0.1/commit_transaction",
      &XrlPimTargetBase::handle_redist_transaction4_0_1_commit_transaction },
    { "redist_transaction4/0.1/abort_transaction",
      &XrlPimTargetBase::handle_redist_transaction4_0_1_abort_transaction },
    { "redist_transaction4/0.1/add_route",
      &XrlPimTargetBase::handle_redist_transaction4_0_1_add_route },
    { "redist_transaction4/0.1/delete_route",
      &XrlPimTargetBase::handle_redist_transaction4_0_1_delete_route },
    { "redist_transaction4/0.1/delete_all_routes",
      &XrlPimTargetBase::handle_redist_transaction4_0_1_delete_all_routes },
    { "mld6igmp_client/0.1/add_membership4",
      &XrlPimTargetBase::handle_mld6igmp_client_0_1_add_membership4 },
    { "mld6igmp_client/0.1/add_membership6",
      &XrlPimTargetBase::handle_mld6igmp_client_0_1_add_membership6 },
    { "mld6igmp_client/0.1/delete_membership4",
      &XrlPimTargetBase::handle_mld6igmp_client_0_1_delete_membership4 },
    { "mld6igmp_client/0.1/delete_membership6",
      &XrlPimTargetBase::handle_mld6igmp_client_0_1_delete_membership6 },
    { "pim/0.1/enable_vif",
      &XrlPimTargetBase::handle_pim_0_1_enable_vif },
    { "pim/0.1/start_vif",
      &XrlPimTargetBase::handle_pim_0_1_start_vif },
    { "pim/0.1/stop_vif",
      &XrlPimTargetBase::handle_pim_0_1_stop_vif },
    { "pim/0.1/enable_all_vifs",
      &XrlPimTargetBase::handle_pim_0_1_enable_all_vifs },
    { "pim/0.1/start_all_vifs",
      &XrlPimTargetBase::handle_pim_0_1_start_all_vifs },
    { "pim/0.1/stop_all_vifs",
      &XrlPimTargetBase::handle_pim_0_1_stop_all_vifs },
    { "pim/0.1/enable_pim",
      &XrlPimTargetBase::handle_pim_0_1_enable_pim },
    { "pim/0.1/start_pim",
      &XrlPimTargetBase::handle_pim_0_1_start_pim },
    { "pim/0.1/stop_pim",
      &XrlPimTargetBase::handle_pim_0_1_stop_pim },
    { "pim/0.1/enable_cli",
      &XrlPimTargetBase::handle_pim_0_1_enable_cli },
    { "pim/0.1/start_cli",
      &XrlPimTargetBase::handle_pim_0_1_start_cli },
    { "pim/0.1/stop_cli",
      &XrlPimTargetBase::handle_pim_0_1_stop_cli },
    { "pim/0.1/enable_bsr",
      &XrlPimTargetBase::handle_pim_0_1_enable_bsr },
    { "pim/0.1/start_bsr",
      &XrlPimTargetBase::handle_pim_0_1_start_bsr },
    { "pim/0.1/stop_bsr",
      &XrlPimTargetBase::handle_pim_0_1_stop_bsr },
    { "pim/0.1/apply_bsr_changes",
      &XrlPimTargetBase::handle_pim_0_1_apply_bsr_changes },
    { "pim/0.1/add_config_scope_zone_by_vif_name4",
      &XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_name4 },
    { "pim/0.1/add_config_scope_zone_by_vif_name6",
      &XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_name6 },
    { "pim/0.1/add_config_scope_zone_by_vif_addr6",
      &XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_addr6 },
    { "pim/0.1/delete_config_scope_zone_by_vif_name6",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_name6 },
    { "pim/0.1/delete_config_scope_zone_by_vif_addr6",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_addr6 },
    { "pim/0.1/add_config_scope_zone_by_vif_addr4",
      &XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_addr4 },
    { "pim/0.1/delete_config_scope_zone_by_vif_name4",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_name4 },
    { "pim/0.1/delete_config_scope_zone_by_vif_addr4",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_addr4 },
    { "pim/0.1/add_config_cand_bsr4",
      &XrlPimTargetBase::handle_pim_0_1_add_config_cand_bsr4 },
    { "pim/0.1/add_config_cand_bsr6",
      &XrlPimTargetBase::handle_pim_0_1_add_config_cand_bsr6 },
    { "pim/0.1/delete_config_cand_bsr6",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_cand_bsr6 },
    { "pim/0.1/delete_config_cand_bsr4",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_cand_bsr4 },
    { "pim/0.1/add_config_cand_rp4",
      &XrlPimTargetBase::handle_pim_0_1_add_config_cand_rp4 },
    { "pim/0.1/add_config_cand_rp6",
      &XrlPimTargetBase::handle_pim_0_1_add_config_cand_rp6 },
    { "pim/0.1/delete_config_cand_rp6",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_cand_rp6 },
    { "pim/0.1/delete_config_cand_rp4",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_cand_rp4 },
    { "pim/0.1/add_config_static_rp4",
      &XrlPimTargetBase::handle_pim_0_1_add_config_static_rp4 },
    { "pim/0.1/add_config_static_rp6",
      &XrlPimTargetBase::handle_pim_0_1_add_config_static_rp6 },
    { "pim/0.1/delete_config_static_rp6",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_static_rp6 },
    { "pim/0.1/delete_config_all_static_group_prefixes_rp6",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_all_static_group_prefixes_rp6 },
    { "pim/0.1/delete_config_static_rp4",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_static_rp4 },
    { "pim/0.1/delete_config_all_static_group_prefixes_rp4",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_all_static_group_prefixes_rp4 },
    { "pim/0.1/delete_config_all_static_rps",
      &XrlPimTargetBase::handle_pim_0_1_delete_config_all_static_rps },
    { "pim/0.1/config_static_rp_done",
      &XrlPimTargetBase::handle_pim_0_1_config_static_rp_done },
    { "pim/0.1/get_vif_proto_version",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_proto_version },
    { "pim/0.1/set_vif_proto_version",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_proto_version },
    { "pim/0.1/reset_vif_proto_version",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_proto_version },
    { "pim/0.1/get_vif_hello_triggered_delay",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_hello_triggered_delay },
    { "pim/0.1/set_vif_hello_triggered_delay",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_hello_triggered_delay },
    { "pim/0.1/reset_vif_hello_triggered_delay",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_hello_triggered_delay },
    { "pim/0.1/get_vif_hello_period",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_hello_period },
    { "pim/0.1/set_vif_hello_period",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_hello_period },
    { "pim/0.1/reset_vif_hello_period",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_hello_period },
    { "pim/0.1/get_vif_hello_holdtime",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_hello_holdtime },
    { "pim/0.1/set_vif_hello_holdtime",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_hello_holdtime },
    { "pim/0.1/reset_vif_hello_holdtime",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_hello_holdtime },
    { "pim/0.1/get_vif_dr_priority",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_dr_priority },
    { "pim/0.1/set_vif_dr_priority",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_dr_priority },
    { "pim/0.1/reset_vif_dr_priority",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_dr_priority },
    { "pim/0.1/get_vif_propagation_delay",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_propagation_delay },
    { "pim/0.1/set_vif_propagation_delay",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_propagation_delay },
    { "pim/0.1/reset_vif_propagation_delay",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_propagation_delay },
    { "pim/0.1/get_vif_override_interval",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_override_interval },
    { "pim/0.1/set_vif_override_interval",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_override_interval },
    { "pim/0.1/reset_vif_override_interval",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_override_interval },
    { "pim/0.1/get_vif_is_tracking_support_disabled",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_is_tracking_support_disabled },
    { "pim/0.1/set_vif_is_tracking_support_disabled",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_is_tracking_support_disabled },
    { "pim/0.1/reset_vif_is_tracking_support_disabled",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_is_tracking_support_disabled },
    { "pim/0.1/get_vif_accept_nohello_neighbors",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_accept_nohello_neighbors },
    { "pim/0.1/set_vif_accept_nohello_neighbors",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_accept_nohello_neighbors },
    { "pim/0.1/reset_vif_accept_nohello_neighbors",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_accept_nohello_neighbors },
    { "pim/0.1/get_vif_join_prune_period",
      &XrlPimTargetBase::handle_pim_0_1_get_vif_join_prune_period },
    { "pim/0.1/set_vif_join_prune_period",
      &XrlPimTargetBase::handle_pim_0_1_set_vif_join_prune_period },
    { "pim/0.1/reset_vif_join_prune_period",
      &XrlPimTargetBase::handle_pim_0_1_reset_vif_join_prune_period },
    { "pim/0.1/get_switch_to_spt_threshold",
      &XrlPimTargetBase::handle_pim_0_1_get_switch_to_spt_threshold },
    { "pim/0.1/set_switch_to_spt_threshold",
      &XrlPimTargetBase::handle_pim_0_1_set_switch_to_spt_threshold },
    { "pim/0.1/reset_switch_to_spt_threshold",
      &XrlPimTargetBase::handle_pim_0_1_reset_switch_to_spt_threshold },
    { "pim/0.1/add_alternative_subnet4",
      &XrlPimTargetBase::handle_pim_0_1_add_alternative_subnet4 },
    { "pim/0.1/add_alternative_subnet6",
      &XrlPimTargetBase::handle_pim_0_1_add_alternative_subnet6 },
    { "pim/0.1/delete_alternative_subnet6",
      &XrlPimTargetBase::handle_pim_0_1_delete_alternative_subnet6 },
    { "pim/0.1/delete_alternative_subnet4",
      &XrlPimTargetBase::handle_pim_0_1_delete_alternative_subnet4 },
    { "pim/0.1/remove_all_alternative_subnets",
      &XrlPimTargetBase::handle_pim_0_1_remove_all_alternative_subnets },
    { "pim/0.1/log_trace_all",
      &XrlPimTargetBase::handle_pim_0_1_log_trace_all },
    { "pim/0.1/add_test_jp_entry4",
      &XrlPimTargetBase::handle_pim_0_1_add_test_jp_entry4 },
    { "pim/0.1/add_test_jp_entry6",
      &XrlPimTargetBase::handle_pim_0_1_add_test_jp_entry6 },
    { "pim/0.1/send_test_jp_entry6",
      &XrlPimTargetBase::handle_pim_0_1_send_test_jp_entry6 },
    { "pim/0.1/send_test_jp_entry4",
      &XrlPimTargetBase::handle_pim_0_1_send_test_jp_entry4 },
    { "pim/0.1/send_test_assert4",
      &XrlPimTargetBase::handle_pim_0_1_send_test_assert4 },
    { "pim/0.1/send_test_assert6",
      &XrlPimTargetBase::handle_pim_0_1_send_test_assert6 },
    { "pim/0.1/add_test_bsr_zone4",
      &XrlPimTargetBase::handle_pim_0_1_add_test_bsr_zone4 },
    { "pim/0.1/add_test_bsr_zone6",
      &XrlPimTargetBase::handle_pim_0_1_add_test_bsr_zone6 },
    { "pim/0.1/add_test_bsr_group_prefix6",
      &XrlPimTargetBase::handle_pim_0_1_add_test_bsr_group_prefix6 },
    { "pim/0.1/add_test_bsr_rp6",
      &XrlPimTargetBase::handle_pim_0_1_add_test_bsr_rp6 },
    { "pim/0.1/send_test_bootstrap_by_dest6",
      &XrlPimTargetBase::handle_pim_0_1_send_test_bootstrap_by_dest6 },
    { "pim/0.1/add_test_bsr_group_prefix4",
      &XrlPimTargetBase::handle_pim_0_1_add_test_bsr_group_prefix4 },
    { "pim/0.1/add_test_bsr_rp4",
      &XrlPimTargetBase::handle_pim_0_1_add_test_bsr_rp4 },
    { "pim/0.1/send_test_bootstrap",
      &XrlPimTargetBase::handle_pim_0_1_send_test_bootstrap },
    { "pim/0.1/send_test_bootstrap_by_dest4",
      &XrlPimTargetBase::handle_pim_0_1_send_test_bootstrap_by_dest4 },
    { "pim/0.1/send_test_cand_rp_adv",
      &XrlPimTargetBase::handle_pim_0_1_send_test_cand_rp_adv },
    { "pim/0.1/pimstat_neighbors4",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_neighbors4 },
    { "pim/0.1/pimstat_neighbors6",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_neighbors6 },
    { "pim/0.1/pimstat_interface4",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_interface4 },
    { "pim/0.1/pimstat_interface6",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_interface6 },
    { "pim/0.1/pimstat_rps4",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rps4 },
    { "pim/0.1/pimstat_rps6",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rps6 },
    { "pim/0.1/clear_pim_statistics",
      &XrlPimTargetBase::handle_pim_0_1_clear_pim_statistics },
    { "pim/0.1/clear_pim_statistics_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_clear_pim_statistics_per_vif },
    { "pim/0.1/pimstat_hello_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_received },
    { "pim/0.1/pimstat_hello_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_sent },
    { "pim/0.1/pimstat_hello_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_rx_errors },
    { "pim/0.1/pimstat_register_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_received },
    { "pim/0.1/pimstat_register_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_sent },
    { "pim/0.1/pimstat_register_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_rx_errors },
    { "pim/0.1/pimstat_register_stop_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_received },
    { "pim/0.1/pimstat_register_stop_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_sent },
    { "pim/0.1/pimstat_register_stop_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_rx_errors },
    { "pim/0.1/pimstat_join_prune_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_received },
    { "pim/0.1/pimstat_join_prune_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_sent },
    { "pim/0.1/pimstat_join_prune_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_rx_errors },
    { "pim/0.1/pimstat_bootstrap_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_received },
    { "pim/0.1/pimstat_bootstrap_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_sent },
    { "pim/0.1/pimstat_bootstrap_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_rx_errors },
    { "pim/0.1/pimstat_assert_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_received },
    { "pim/0.1/pimstat_assert_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_sent },
    { "pim/0.1/pimstat_assert_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_rx_errors },
    { "pim/0.1/pimstat_graft_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_received },
    { "pim/0.1/pimstat_graft_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_sent },
    { "pim/0.1/pimstat_graft_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_rx_errors },
    { "pim/0.1/pimstat_graft_ack_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_received },
    { "pim/0.1/pimstat_graft_ack_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_sent },
    { "pim/0.1/pimstat_graft_ack_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_rx_errors },
    { "pim/0.1/pimstat_candidate_rp_messages_received",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_received },
    { "pim/0.1/pimstat_candidate_rp_messages_sent",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_sent },
    { "pim/0.1/pimstat_candidate_rp_messages_rx_errors",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_rx_errors },
    { "pim/0.1/pimstat_unknown_type_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_type_messages },
    { "pim/0.1/pimstat_unknown_version_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_version_messages },
    { "pim/0.1/pimstat_neighbor_unknown_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_neighbor_unknown_messages },
    { "pim/0.1/pimstat_bad_length_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bad_length_messages },
    { "pim/0.1/pimstat_bad_checksum_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bad_checksum_messages },
    { "pim/0.1/pimstat_bad_receive_interface_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bad_receive_interface_messages },
    { "pim/0.1/pimstat_rx_interface_disabled_messages",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_interface_disabled_messages },
    { "pim/0.1/pimstat_rx_register_not_rp",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_register_not_rp },
    { "pim/0.1/pimstat_rp_filtered_source",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rp_filtered_source },
    { "pim/0.1/pimstat_unknown_register_stop",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_register_stop },
    { "pim/0.1/pimstat_rx_join_prune_no_state",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_prune_no_state },
    { "pim/0.1/pimstat_rx_graft_graft_ack_no_state",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_graft_ack_no_state },
    { "pim/0.1/pimstat_rx_graft_on_upstream_interface",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_on_upstream_interface },
    { "pim/0.1/pimstat_rx_candidate_rp_not_bsr",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_candidate_rp_not_bsr },
    { "pim/0.1/pimstat_rx_bsr_when_bsr",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_when_bsr },
    { "pim/0.1/pimstat_rx_bsr_not_rpf_interface",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_not_rpf_interface },
    { "pim/0.1/pimstat_rx_unknown_hello_option",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_unknown_hello_option },
    { "pim/0.1/pimstat_rx_data_no_state",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_data_no_state },
    { "pim/0.1/pimstat_rx_rp_no_state",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_rp_no_state },
    { "pim/0.1/pimstat_rx_aggregate",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_aggregate },
    { "pim/0.1/pimstat_rx_malformed_packet",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_malformed_packet },
    { "pim/0.1/pimstat_no_rp",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_no_rp },
    { "pim/0.1/pimstat_no_route_upstream",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_no_route_upstream },
    { "pim/0.1/pimstat_rp_mismatch",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rp_mismatch },
    { "pim/0.1/pimstat_rpf_neighbor_unknown",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rpf_neighbor_unknown },
    { "pim/0.1/pimstat_rx_join_rp",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_rp },
    { "pim/0.1/pimstat_rx_prune_rp",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_rp },
    { "pim/0.1/pimstat_rx_join_wc",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_wc },
    { "pim/0.1/pimstat_rx_prune_wc",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_wc },
    { "pim/0.1/pimstat_rx_join_sg",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg },
    { "pim/0.1/pimstat_rx_prune_sg",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg },
    { "pim/0.1/pimstat_rx_join_sg_rpt",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg_rpt },
    { "pim/0.1/pimstat_rx_prune_sg_rpt",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg_rpt },
    { "pim/0.1/pimstat_hello_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_received_per_vif },
    { "pim/0.1/pimstat_hello_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_sent_per_vif },
    { "pim/0.1/pimstat_hello_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_register_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_received_per_vif },
    { "pim/0.1/pimstat_register_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_sent_per_vif },
    { "pim/0.1/pimstat_register_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_register_stop_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_received_per_vif },
    { "pim/0.1/pimstat_register_stop_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_sent_per_vif },
    { "pim/0.1/pimstat_register_stop_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_join_prune_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_received_per_vif },
    { "pim/0.1/pimstat_join_prune_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_sent_per_vif },
    { "pim/0.1/pimstat_join_prune_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_bootstrap_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_received_per_vif },
    { "pim/0.1/pimstat_bootstrap_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_sent_per_vif },
    { "pim/0.1/pimstat_bootstrap_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_assert_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_received_per_vif },
    { "pim/0.1/pimstat_assert_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_sent_per_vif },
    { "pim/0.1/pimstat_assert_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_graft_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_received_per_vif },
    { "pim/0.1/pimstat_graft_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_sent_per_vif },
    { "pim/0.1/pimstat_graft_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_graft_ack_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_received_per_vif },
    { "pim/0.1/pimstat_graft_ack_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_sent_per_vif },
    { "pim/0.1/pimstat_graft_ack_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_candidate_rp_messages_received_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_received_per_vif },
    { "pim/0.1/pimstat_candidate_rp_messages_sent_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif },
    { "pim/0.1/pimstat_candidate_rp_messages_rx_errors_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif },
    { "pim/0.1/pimstat_unknown_type_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_type_messages_per_vif },
    { "pim/0.1/pimstat_unknown_version_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_version_messages_per_vif },
    { "pim/0.1/pimstat_neighbor_unknown_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_neighbor_unknown_messages_per_vif },
    { "pim/0.1/pimstat_bad_length_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bad_length_messages_per_vif },
    { "pim/0.1/pimstat_bad_checksum_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bad_checksum_messages_per_vif },
    { "pim/0.1/pimstat_bad_receive_interface_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_bad_receive_interface_messages_per_vif },
    { "pim/0.1/pimstat_rx_interface_disabled_messages_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif },
    { "pim/0.1/pimstat_rx_register_not_rp_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_register_not_rp_per_vif },
    { "pim/0.1/pimstat_rp_filtered_source_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rp_filtered_source_per_vif },
    { "pim/0.1/pimstat_unknown_register_stop_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_register_stop_per_vif },
    { "pim/0.1/pimstat_rx_join_prune_no_state_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_prune_no_state_per_vif },
    { "pim/0.1/pimstat_rx_graft_graft_ack_no_state_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif },
    { "pim/0.1/pimstat_rx_graft_on_upstream_interface_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif },
    { "pim/0.1/pimstat_rx_candidate_rp_not_bsr_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif },
    { "pim/0.1/pimstat_rx_bsr_when_bsr_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif },
    { "pim/0.1/pimstat_rx_bsr_not_rpf_interface_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif },
    { "pim/0.1/pimstat_rx_unknown_hello_option_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_unknown_hello_option_per_vif },
    { "pim/0.1/pimstat_rx_data_no_state_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_data_no_state_per_vif },
    { "pim/0.1/pimstat_rx_rp_no_state_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_rp_no_state_per_vif },
    { "pim/0.1/pimstat_rx_aggregate_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_aggregate_per_vif },
    { "pim/0.1/pimstat_rx_malformed_packet_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_malformed_packet_per_vif },
    { "pim/0.1/pimstat_no_rp_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_no_rp_per_vif },
    { "pim/0.1/pimstat_no_route_upstream_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_no_route_upstream_per_vif },
    { "pim/0.1/pimstat_rp_mismatch_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rp_mismatch_per_vif },
    { "pim/0.1/pimstat_rpf_neighbor_unknown_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif },
    { "pim/0.1/pimstat_rx_join_rp_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_rp_per_vif },
    { "pim/0.1/pimstat_rx_prune_rp_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_rp_per_vif },
    { "pim/0.1/pimstat_rx_join_wc_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_wc_per_vif },
    { "pim/0.1/pimstat_rx_prune_wc_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_wc_per_vif },
    { "pim/0.1/pimstat_rx_join_sg_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg_per_vif },
    { "pim/0.1/pimstat_rx_prune_sg_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg_per_vif },
    { "pim/0.1/pimstat_rx_join_sg_rpt_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg_rpt_per_vif },
    { "pim/0.1/pimstat_rx_prune_sg_rpt_per_vif",
      &XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif },
};

const size_t XrlPimTargetBase::num_handlers = (sizeof(XrlPimTargetBase::handlers) / sizeof(XrlPimTargetBase::handlers[0]));


XrlPimTargetBase::XrlPimTargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlPimTargetBase::~XrlPimTargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlPimTargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_common_0_1_get_target_name
    (const XrlCmdError &e,
     const string* rarg_name,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_target_name", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("name", *rarg_name);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_common_0_1_get_target_name(
	Common01GetTargetNameCB c_b)
{

    /* Return value declarations */
    string rarg_name;
    XrlCmdError e = common_0_1_get_target_name(
        rarg_name);
    return c_b->dispatch(e,
        &rarg_name);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_common_0_1_get_target_name(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_target_name");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetTargetNameRF mycb =
	    callback(this, &XrlPimTargetBase::callback_common_0_1_get_target_name, pxa_outputs);
	async_common_0_1_get_target_name( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_name;
    try {
	XrlCmdError e = common_0_1_get_target_name(
	    r_name);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_target_name", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("name", r_name);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_common_0_1_get_version
    (const XrlCmdError &e,
     const string* rarg_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("version", *rarg_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_common_0_1_get_version(
	Common01GetVersionCB c_b)
{

    /* Return value declarations */
    string rarg_version;
    XrlCmdError e = common_0_1_get_version(
        rarg_version);
    return c_b->dispatch(e,
        &rarg_version);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_common_0_1_get_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetVersionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_common_0_1_get_version, pxa_outputs);
	async_common_0_1_get_version( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_version;
    try {
	XrlCmdError e = common_0_1_get_version(
	    r_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", r_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_common_0_1_get_status
    (const XrlCmdError &e,
     const uint32_t* rarg_status,
     const string* rarg_reason,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_status", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("status", *rarg_status);
	    out.add("reason", *rarg_reason);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_common_0_1_get_status(
	Common01GetStatusCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_status;
    string rarg_reason;
    XrlCmdError e = common_0_1_get_status(
        rarg_status,
        rarg_reason);
    return c_b->dispatch(e,
        &rarg_status,
        &rarg_reason);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_common_0_1_get_status(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_status");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetStatusRF mycb =
	    callback(this, &XrlPimTargetBase::callback_common_0_1_get_status, pxa_outputs);
	async_common_0_1_get_status( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_status;
    string r_reason;
    try {
	XrlCmdError e = common_0_1_get_status(
	    r_status,
	    r_reason);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_status", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("status", r_status);
	pxa_outputs->add("reason", r_reason);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_common_0_1_shutdown
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/shutdown", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_common_0_1_shutdown(
	Common01ShutdownCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_shutdown();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_common_0_1_shutdown(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/shutdown");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01ShutdownRF mycb =
	    callback(this, &XrlPimTargetBase::callback_common_0_1_shutdown, pxa_outputs);
	async_common_0_1_shutdown( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_shutdown();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_common_0_1_startup
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/startup", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_common_0_1_startup(
	Common01StartupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_startup();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_common_0_1_startup(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/startup");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01StartupRF mycb =
	    callback(this, &XrlPimTargetBase::callback_common_0_1_startup, pxa_outputs);
	async_common_0_1_startup( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_startup();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/startup", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_cli_processor_0_1_process_command
    (const XrlCmdError &e,
     const string* rarg_ret_processor_name,
     const string* rarg_ret_cli_term_name,
     const uint32_t* rarg_ret_cli_session_id,
     const string* rarg_ret_command_output,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "cli_processor/0.1/process_command", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("ret_processor_name", *rarg_ret_processor_name);
	    out.add("ret_cli_term_name", *rarg_ret_cli_term_name);
	    out.add("ret_cli_session_id", *rarg_ret_cli_session_id);
	    out.add("ret_command_output", *rarg_ret_command_output);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_cli_processor_0_1_process_command(
	const string&	arg_processor_name,
	const string&	arg_cli_term_name,
	const uint32_t&	arg_cli_session_id,
	const string&	arg_command_name,
	const string&	arg_command_args,
	CliProcessor01ProcessCommandCB c_b)
{

    /* Return value declarations */
    string rarg_ret_processor_name;
    string rarg_ret_cli_term_name;
    uint32_t rarg_ret_cli_session_id;
    string rarg_ret_command_output;
    XrlCmdError e = cli_processor_0_1_process_command(
        arg_processor_name,
        arg_cli_term_name,
        arg_cli_session_id,
        arg_command_name,
        arg_command_args,
        rarg_ret_processor_name,
        rarg_ret_cli_term_name,
        rarg_ret_cli_session_id,
        rarg_ret_command_output);
    return c_b->dispatch(e,
        &rarg_ret_processor_name,
        &rarg_ret_cli_term_name,
        &rarg_ret_cli_session_id,
        &rarg_ret_command_output);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_cli_processor_0_1_process_command(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "cli_processor/0.1/process_command");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	CliProcessor01ProcessCommandRF mycb =
	    callback(this, &XrlPimTargetBase::callback_cli_processor_0_1_process_command, pxa_outputs);
	async_cli_processor_0_1_process_command(
	    xa_inputs.get(0, "processor_name").text(),
	    xa_inputs.get(1, "cli_term_name").text(),
	    xa_inputs.get(2, "cli_session_id").uint32(),
	    xa_inputs.get(3, "command_name").text(),
	    xa_inputs.get(4, "command_args").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_ret_processor_name;
    string r_ret_cli_term_name;
    uint32_t r_ret_cli_session_id;
    string r_ret_command_output;
    try {
	XrlCmdError e = cli_processor_0_1_process_command(
	    xa_inputs.get(0, "processor_name").text(),
	    xa_inputs.get(1, "cli_term_name").text(),
	    xa_inputs.get(2, "cli_session_id").uint32(),
	    xa_inputs.get(3, "command_name").text(),
	    xa_inputs.get(4, "command_args").text(),
	    r_ret_processor_name,
	    r_ret_cli_term_name,
	    r_ret_cli_session_id,
	    r_ret_command_output);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "cli_processor/0.1/process_command", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("ret_processor_name", r_ret_processor_name);
	pxa_outputs->add("ret_cli_term_name", r_ret_cli_term_name);
	pxa_outputs->add("ret_cli_session_id", r_ret_cli_session_id);
	pxa_outputs->add("ret_command_output", r_ret_command_output);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_finder_event_observer_0_1_xrl_target_birth
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_finder_event_observer_0_1_xrl_target_birth(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetBirthCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_birth");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetBirthRF mycb =
	    callback(this, &XrlPimTargetBase::callback_finder_event_observer_0_1_xrl_target_birth, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_finder_event_observer_0_1_xrl_target_death
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_finder_event_observer_0_1_xrl_target_death(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetDeathCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_death");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetDeathRF mycb =
	    callback(this, &XrlPimTargetBase::callback_finder_event_observer_0_1_xrl_target_death, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_raw_packet4_client_0_1_recv
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet4_client/0.1/recv", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_raw_packet4_client_0_1_recv(
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const IPv4&	arg_src_address,
	const IPv4&	arg_dst_address,
	const uint32_t&	arg_ip_protocol,
	const int32_t&	arg_ip_ttl,
	const int32_t&	arg_ip_tos,
	const bool&	arg_ip_router_alert,
	const bool&	arg_ip_internet_control,
	const vector<uint8_t>&	arg_payload,
	RawPacket4Client01RecvCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet4_client_0_1_recv(
        arg_if_name,
        arg_vif_name,
        arg_src_address,
        arg_dst_address,
        arg_ip_protocol,
        arg_ip_ttl,
        arg_ip_tos,
        arg_ip_router_alert,
        arg_ip_internet_control,
        arg_payload);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_raw_packet4_client_0_1_recv(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 10) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(10), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4_client/0.1/recv");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket4Client01RecvRF mycb =
	    callback(this, &XrlPimTargetBase::callback_raw_packet4_client_0_1_recv, pxa_outputs);
	async_raw_packet4_client_0_1_recv(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv4(),
	    xa_inputs.get(3, "dst_address").ipv4(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "payload").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_client_0_1_recv(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv4(),
	    xa_inputs.get(3, "dst_address").ipv4(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4_client/0.1/recv", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_raw_packet6_client_0_1_recv
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet6_client/0.1/recv", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_raw_packet6_client_0_1_recv(
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const IPv6&	arg_src_address,
	const IPv6&	arg_dst_address,
	const uint32_t&	arg_ip_protocol,
	const int32_t&	arg_ip_ttl,
	const int32_t&	arg_ip_tos,
	const bool&	arg_ip_router_alert,
	const bool&	arg_ip_internet_control,
	const XrlAtomList&	arg_ext_headers_type,
	const XrlAtomList&	arg_ext_headers_payload,
	const vector<uint8_t>&	arg_payload,
	RawPacket6Client01RecvCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet6_client_0_1_recv(
        arg_if_name,
        arg_vif_name,
        arg_src_address,
        arg_dst_address,
        arg_ip_protocol,
        arg_ip_ttl,
        arg_ip_tos,
        arg_ip_router_alert,
        arg_ip_internet_control,
        arg_ext_headers_type,
        arg_ext_headers_payload,
        arg_payload);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_raw_packet6_client_0_1_recv(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6_client/0.1/recv");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket6Client01RecvRF mycb =
	    callback(this, &XrlPimTargetBase::callback_raw_packet6_client_0_1_recv, pxa_outputs);
	async_raw_packet6_client_0_1_recv(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv6(),
	    xa_inputs.get(3, "dst_address").ipv6(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "ext_headers_type").list(),
	    xa_inputs.get(10, "ext_headers_payload").list(),
	    xa_inputs.get(11, "payload").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_client_0_1_recv(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv6(),
	    xa_inputs.get(3, "dst_address").ipv6(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "ext_headers_type").list(),
	    xa_inputs.get(10, "ext_headers_payload").list(),
	    xa_inputs.get(11, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6_client/0.1/recv", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction6_0_1_start_transaction
    (const XrlCmdError &e,
     const uint32_t* rarg_tid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/start_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tid", *rarg_tid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction6_0_1_start_transaction(
	RedistTransaction601StartTransactionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_tid;
    XrlCmdError e = redist_transaction6_0_1_start_transaction(
        rarg_tid);
    return c_b->dispatch(e,
        &rarg_tid);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction6_0_1_start_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/start_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601StartTransactionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction6_0_1_start_transaction, pxa_outputs);
	async_redist_transaction6_0_1_start_transaction( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_tid;
    try {
	XrlCmdError e = redist_transaction6_0_1_start_transaction(
	    r_tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", r_tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction6_0_1_commit_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/commit_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction6_0_1_commit_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction601CommitTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_commit_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction6_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/commit_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601CommitTransactionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction6_0_1_commit_transaction, pxa_outputs);
	async_redist_transaction6_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction6_0_1_abort_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/abort_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction6_0_1_abort_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction601AbortTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_abort_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction6_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/abort_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601AbortTransactionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction6_0_1_abort_transaction, pxa_outputs);
	async_redist_transaction6_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction6_0_1_add_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/add_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction6_0_1_add_route(
	const uint32_t&	arg_tid,
	const IPv6Net&	arg_dst,
	const IPv6&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction601AddRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_add_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction6_0_1_add_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/add_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601AddRouteRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction6_0_1_add_route, pxa_outputs);
	async_redist_transaction6_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/add_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction6_0_1_delete_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/delete_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction6_0_1_delete_route(
	const uint32_t&	arg_tid,
	const IPv6Net&	arg_dst,
	const IPv6&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction601DeleteRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_delete_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction6_0_1_delete_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/delete_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601DeleteRouteRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction6_0_1_delete_route, pxa_outputs);
	async_redist_transaction6_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/delete_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction6_0_1_delete_all_routes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/delete_all_routes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction6_0_1_delete_all_routes(
	const uint32_t&	arg_tid,
	const string&	arg_cookie,
	RedistTransaction601DeleteAllRoutesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_delete_all_routes(
        arg_tid,
        arg_cookie);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction6_0_1_delete_all_routes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/delete_all_routes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601DeleteAllRoutesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction6_0_1_delete_all_routes, pxa_outputs);
	async_redist_transaction6_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/delete_all_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mfea_client_0_1_recv_kernel_signal_message4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mfea_client/0.1/recv_kernel_signal_message4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mfea_client_0_1_recv_kernel_signal_message4(
	const string&	arg_xrl_sender_name,
	const uint32_t&	arg_message_type,
	const string&	arg_vif_name,
	const uint32_t&	arg_vif_index,
	const IPv4&	arg_source_address,
	const IPv4&	arg_dest_address,
	const vector<uint8_t>&	arg_protocol_message,
	MfeaClient01RecvKernelSignalMessage4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mfea_client_0_1_recv_kernel_signal_message4(
        arg_xrl_sender_name,
        arg_message_type,
        arg_vif_name,
        arg_vif_index,
        arg_source_address,
        arg_dest_address,
        arg_protocol_message);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mfea_client_0_1_recv_kernel_signal_message4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(7), XORP_UINT_CAST(xa_inputs.size()), "mfea_client/0.1/recv_kernel_signal_message4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	MfeaClient01RecvKernelSignalMessage4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mfea_client_0_1_recv_kernel_signal_message4, pxa_outputs);
	async_mfea_client_0_1_recv_kernel_signal_message4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "message_type").uint32(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_index").uint32(),
	    xa_inputs.get(4, "source_address").ipv4(),
	    xa_inputs.get(5, "dest_address").ipv4(),
	    xa_inputs.get(6, "protocol_message").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mfea_client_0_1_recv_kernel_signal_message4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "message_type").uint32(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_index").uint32(),
	    xa_inputs.get(4, "source_address").ipv4(),
	    xa_inputs.get(5, "dest_address").ipv4(),
	    xa_inputs.get(6, "protocol_message").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mfea_client/0.1/recv_kernel_signal_message4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mfea_client_0_1_recv_dataflow_signal4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mfea_client/0.1/recv_dataflow_signal4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mfea_client_0_1_recv_dataflow_signal4(
	const string&	arg_xrl_sender_name,
	const IPv4&	arg_source_address,
	const IPv4&	arg_group_address,
	const uint32_t&	arg_threshold_interval_sec,
	const uint32_t&	arg_threshold_interval_usec,
	const uint32_t&	arg_measured_interval_sec,
	const uint32_t&	arg_measured_interval_usec,
	const uint32_t&	arg_threshold_packets,
	const uint32_t&	arg_threshold_bytes,
	const uint32_t&	arg_measured_packets,
	const uint32_t&	arg_measured_bytes,
	const bool&	arg_is_threshold_in_packets,
	const bool&	arg_is_threshold_in_bytes,
	const bool&	arg_is_geq_upcall,
	const bool&	arg_is_leq_upcall,
	MfeaClient01RecvDataflowSignal4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mfea_client_0_1_recv_dataflow_signal4(
        arg_xrl_sender_name,
        arg_source_address,
        arg_group_address,
        arg_threshold_interval_sec,
        arg_threshold_interval_usec,
        arg_measured_interval_sec,
        arg_measured_interval_usec,
        arg_threshold_packets,
        arg_threshold_bytes,
        arg_measured_packets,
        arg_measured_bytes,
        arg_is_threshold_in_packets,
        arg_is_threshold_in_bytes,
        arg_is_geq_upcall,
        arg_is_leq_upcall);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mfea_client_0_1_recv_dataflow_signal4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 15) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(15), XORP_UINT_CAST(xa_inputs.size()), "mfea_client/0.1/recv_dataflow_signal4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	MfeaClient01RecvDataflowSignal4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mfea_client_0_1_recv_dataflow_signal4, pxa_outputs);
	async_mfea_client_0_1_recv_dataflow_signal4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "source_address").ipv4(),
	    xa_inputs.get(2, "group_address").ipv4(),
	    xa_inputs.get(3, "threshold_interval_sec").uint32(),
	    xa_inputs.get(4, "threshold_interval_usec").uint32(),
	    xa_inputs.get(5, "measured_interval_sec").uint32(),
	    xa_inputs.get(6, "measured_interval_usec").uint32(),
	    xa_inputs.get(7, "threshold_packets").uint32(),
	    xa_inputs.get(8, "threshold_bytes").uint32(),
	    xa_inputs.get(9, "measured_packets").uint32(),
	    xa_inputs.get(10, "measured_bytes").uint32(),
	    xa_inputs.get(11, "is_threshold_in_packets").boolean(),
	    xa_inputs.get(12, "is_threshold_in_bytes").boolean(),
	    xa_inputs.get(13, "is_geq_upcall").boolean(),
	    xa_inputs.get(14, "is_leq_upcall").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mfea_client_0_1_recv_dataflow_signal4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "source_address").ipv4(),
	    xa_inputs.get(2, "group_address").ipv4(),
	    xa_inputs.get(3, "threshold_interval_sec").uint32(),
	    xa_inputs.get(4, "threshold_interval_usec").uint32(),
	    xa_inputs.get(5, "measured_interval_sec").uint32(),
	    xa_inputs.get(6, "measured_interval_usec").uint32(),
	    xa_inputs.get(7, "threshold_packets").uint32(),
	    xa_inputs.get(8, "threshold_bytes").uint32(),
	    xa_inputs.get(9, "measured_packets").uint32(),
	    xa_inputs.get(10, "measured_bytes").uint32(),
	    xa_inputs.get(11, "is_threshold_in_packets").boolean(),
	    xa_inputs.get(12, "is_threshold_in_bytes").boolean(),
	    xa_inputs.get(13, "is_geq_upcall").boolean(),
	    xa_inputs.get(14, "is_leq_upcall").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mfea_client/0.1/recv_dataflow_signal4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mfea_client_0_1_recv_kernel_signal_message6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mfea_client/0.1/recv_kernel_signal_message6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mfea_client_0_1_recv_kernel_signal_message6(
	const string&	arg_xrl_sender_name,
	const uint32_t&	arg_message_type,
	const string&	arg_vif_name,
	const uint32_t&	arg_vif_index,
	const IPv6&	arg_source_address,
	const IPv6&	arg_dest_address,
	const vector<uint8_t>&	arg_protocol_message,
	MfeaClient01RecvKernelSignalMessage6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mfea_client_0_1_recv_kernel_signal_message6(
        arg_xrl_sender_name,
        arg_message_type,
        arg_vif_name,
        arg_vif_index,
        arg_source_address,
        arg_dest_address,
        arg_protocol_message);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mfea_client_0_1_recv_kernel_signal_message6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(7), XORP_UINT_CAST(xa_inputs.size()), "mfea_client/0.1/recv_kernel_signal_message6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	MfeaClient01RecvKernelSignalMessage6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mfea_client_0_1_recv_kernel_signal_message6, pxa_outputs);
	async_mfea_client_0_1_recv_kernel_signal_message6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "message_type").uint32(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_index").uint32(),
	    xa_inputs.get(4, "source_address").ipv6(),
	    xa_inputs.get(5, "dest_address").ipv6(),
	    xa_inputs.get(6, "protocol_message").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mfea_client_0_1_recv_kernel_signal_message6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "message_type").uint32(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_index").uint32(),
	    xa_inputs.get(4, "source_address").ipv6(),
	    xa_inputs.get(5, "dest_address").ipv6(),
	    xa_inputs.get(6, "protocol_message").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mfea_client/0.1/recv_kernel_signal_message6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mfea_client_0_1_recv_dataflow_signal6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mfea_client/0.1/recv_dataflow_signal6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mfea_client_0_1_recv_dataflow_signal6(
	const string&	arg_xrl_sender_name,
	const IPv6&	arg_source_address,
	const IPv6&	arg_group_address,
	const uint32_t&	arg_threshold_interval_sec,
	const uint32_t&	arg_threshold_interval_usec,
	const uint32_t&	arg_measured_interval_sec,
	const uint32_t&	arg_measured_interval_usec,
	const uint32_t&	arg_threshold_packets,
	const uint32_t&	arg_threshold_bytes,
	const uint32_t&	arg_measured_packets,
	const uint32_t&	arg_measured_bytes,
	const bool&	arg_is_threshold_in_packets,
	const bool&	arg_is_threshold_in_bytes,
	const bool&	arg_is_geq_upcall,
	const bool&	arg_is_leq_upcall,
	MfeaClient01RecvDataflowSignal6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mfea_client_0_1_recv_dataflow_signal6(
        arg_xrl_sender_name,
        arg_source_address,
        arg_group_address,
        arg_threshold_interval_sec,
        arg_threshold_interval_usec,
        arg_measured_interval_sec,
        arg_measured_interval_usec,
        arg_threshold_packets,
        arg_threshold_bytes,
        arg_measured_packets,
        arg_measured_bytes,
        arg_is_threshold_in_packets,
        arg_is_threshold_in_bytes,
        arg_is_geq_upcall,
        arg_is_leq_upcall);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mfea_client_0_1_recv_dataflow_signal6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 15) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(15), XORP_UINT_CAST(xa_inputs.size()), "mfea_client/0.1/recv_dataflow_signal6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	MfeaClient01RecvDataflowSignal6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mfea_client_0_1_recv_dataflow_signal6, pxa_outputs);
	async_mfea_client_0_1_recv_dataflow_signal6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "source_address").ipv6(),
	    xa_inputs.get(2, "group_address").ipv6(),
	    xa_inputs.get(3, "threshold_interval_sec").uint32(),
	    xa_inputs.get(4, "threshold_interval_usec").uint32(),
	    xa_inputs.get(5, "measured_interval_sec").uint32(),
	    xa_inputs.get(6, "measured_interval_usec").uint32(),
	    xa_inputs.get(7, "threshold_packets").uint32(),
	    xa_inputs.get(8, "threshold_bytes").uint32(),
	    xa_inputs.get(9, "measured_packets").uint32(),
	    xa_inputs.get(10, "measured_bytes").uint32(),
	    xa_inputs.get(11, "is_threshold_in_packets").boolean(),
	    xa_inputs.get(12, "is_threshold_in_bytes").boolean(),
	    xa_inputs.get(13, "is_geq_upcall").boolean(),
	    xa_inputs.get(14, "is_leq_upcall").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mfea_client_0_1_recv_dataflow_signal6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "source_address").ipv6(),
	    xa_inputs.get(2, "group_address").ipv6(),
	    xa_inputs.get(3, "threshold_interval_sec").uint32(),
	    xa_inputs.get(4, "threshold_interval_usec").uint32(),
	    xa_inputs.get(5, "measured_interval_sec").uint32(),
	    xa_inputs.get(6, "measured_interval_usec").uint32(),
	    xa_inputs.get(7, "threshold_packets").uint32(),
	    xa_inputs.get(8, "threshold_bytes").uint32(),
	    xa_inputs.get(9, "measured_packets").uint32(),
	    xa_inputs.get(10, "measured_bytes").uint32(),
	    xa_inputs.get(11, "is_threshold_in_packets").boolean(),
	    xa_inputs.get(12, "is_threshold_in_bytes").boolean(),
	    xa_inputs.get(13, "is_geq_upcall").boolean(),
	    xa_inputs.get(14, "is_leq_upcall").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mfea_client/0.1/recv_dataflow_signal6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction4_0_1_start_transaction
    (const XrlCmdError &e,
     const uint32_t* rarg_tid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/start_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tid", *rarg_tid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction4_0_1_start_transaction(
	RedistTransaction401StartTransactionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_tid;
    XrlCmdError e = redist_transaction4_0_1_start_transaction(
        rarg_tid);
    return c_b->dispatch(e,
        &rarg_tid);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction4_0_1_start_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/start_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401StartTransactionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction4_0_1_start_transaction, pxa_outputs);
	async_redist_transaction4_0_1_start_transaction( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_tid;
    try {
	XrlCmdError e = redist_transaction4_0_1_start_transaction(
	    r_tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", r_tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction4_0_1_commit_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/commit_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction4_0_1_commit_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction401CommitTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_commit_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction4_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/commit_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401CommitTransactionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction4_0_1_commit_transaction, pxa_outputs);
	async_redist_transaction4_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction4_0_1_abort_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/abort_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction4_0_1_abort_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction401AbortTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_abort_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction4_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/abort_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401AbortTransactionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction4_0_1_abort_transaction, pxa_outputs);
	async_redist_transaction4_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction4_0_1_add_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/add_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction4_0_1_add_route(
	const uint32_t&	arg_tid,
	const IPv4Net&	arg_dst,
	const IPv4&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction401AddRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_add_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction4_0_1_add_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/add_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401AddRouteRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction4_0_1_add_route, pxa_outputs);
	async_redist_transaction4_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/add_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction4_0_1_delete_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/delete_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction4_0_1_delete_route(
	const uint32_t&	arg_tid,
	const IPv4Net&	arg_dst,
	const IPv4&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction401DeleteRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_delete_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction4_0_1_delete_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/delete_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401DeleteRouteRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction4_0_1_delete_route, pxa_outputs);
	async_redist_transaction4_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/delete_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_redist_transaction4_0_1_delete_all_routes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/delete_all_routes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_redist_transaction4_0_1_delete_all_routes(
	const uint32_t&	arg_tid,
	const string&	arg_cookie,
	RedistTransaction401DeleteAllRoutesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_delete_all_routes(
        arg_tid,
        arg_cookie);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_redist_transaction4_0_1_delete_all_routes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/delete_all_routes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401DeleteAllRoutesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_redist_transaction4_0_1_delete_all_routes, pxa_outputs);
	async_redist_transaction4_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/delete_all_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mld6igmp_client_0_1_add_membership4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mld6igmp_client/0.1/add_membership4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mld6igmp_client_0_1_add_membership4(
	const string&	arg_xrl_sender_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_vif_index,
	const IPv4&	arg_source,
	const IPv4&	arg_group,
	Mld6IgmpClient01AddMembership4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mld6igmp_client_0_1_add_membership4(
        arg_xrl_sender_name,
        arg_vif_name,
        arg_vif_index,
        arg_source,
        arg_group);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mld6igmp_client_0_1_add_membership4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "mld6igmp_client/0.1/add_membership4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Mld6IgmpClient01AddMembership4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mld6igmp_client_0_1_add_membership4, pxa_outputs);
	async_mld6igmp_client_0_1_add_membership4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv4(),
	    xa_inputs.get(4, "group").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mld6igmp_client_0_1_add_membership4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv4(),
	    xa_inputs.get(4, "group").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mld6igmp_client/0.1/add_membership4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mld6igmp_client_0_1_add_membership6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mld6igmp_client/0.1/add_membership6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mld6igmp_client_0_1_add_membership6(
	const string&	arg_xrl_sender_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_vif_index,
	const IPv6&	arg_source,
	const IPv6&	arg_group,
	Mld6IgmpClient01AddMembership6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mld6igmp_client_0_1_add_membership6(
        arg_xrl_sender_name,
        arg_vif_name,
        arg_vif_index,
        arg_source,
        arg_group);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mld6igmp_client_0_1_add_membership6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "mld6igmp_client/0.1/add_membership6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Mld6IgmpClient01AddMembership6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mld6igmp_client_0_1_add_membership6, pxa_outputs);
	async_mld6igmp_client_0_1_add_membership6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv6(),
	    xa_inputs.get(4, "group").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mld6igmp_client_0_1_add_membership6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv6(),
	    xa_inputs.get(4, "group").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mld6igmp_client/0.1/add_membership6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mld6igmp_client_0_1_delete_membership4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mld6igmp_client/0.1/delete_membership4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mld6igmp_client_0_1_delete_membership4(
	const string&	arg_xrl_sender_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_vif_index,
	const IPv4&	arg_source,
	const IPv4&	arg_group,
	Mld6IgmpClient01DeleteMembership4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mld6igmp_client_0_1_delete_membership4(
        arg_xrl_sender_name,
        arg_vif_name,
        arg_vif_index,
        arg_source,
        arg_group);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mld6igmp_client_0_1_delete_membership4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "mld6igmp_client/0.1/delete_membership4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Mld6IgmpClient01DeleteMembership4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mld6igmp_client_0_1_delete_membership4, pxa_outputs);
	async_mld6igmp_client_0_1_delete_membership4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv4(),
	    xa_inputs.get(4, "group").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mld6igmp_client_0_1_delete_membership4(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv4(),
	    xa_inputs.get(4, "group").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mld6igmp_client/0.1/delete_membership4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_mld6igmp_client_0_1_delete_membership6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "mld6igmp_client/0.1/delete_membership6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_mld6igmp_client_0_1_delete_membership6(
	const string&	arg_xrl_sender_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_vif_index,
	const IPv6&	arg_source,
	const IPv6&	arg_group,
	Mld6IgmpClient01DeleteMembership6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = mld6igmp_client_0_1_delete_membership6(
        arg_xrl_sender_name,
        arg_vif_name,
        arg_vif_index,
        arg_source,
        arg_group);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_mld6igmp_client_0_1_delete_membership6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "mld6igmp_client/0.1/delete_membership6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Mld6IgmpClient01DeleteMembership6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_mld6igmp_client_0_1_delete_membership6, pxa_outputs);
	async_mld6igmp_client_0_1_delete_membership6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv6(),
	    xa_inputs.get(4, "group").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = mld6igmp_client_0_1_delete_membership6(
	    xa_inputs.get(0, "xrl_sender_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "vif_index").uint32(),
	    xa_inputs.get(3, "source").ipv6(),
	    xa_inputs.get(4, "group").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "mld6igmp_client/0.1/delete_membership6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_enable_vif
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/enable_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_enable_vif(
	const string&	arg_vif_name,
	const bool&	arg_enable,
	Pim01EnableVifCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_enable_vif(
        arg_vif_name,
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_enable_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/enable_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01EnableVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_enable_vif, pxa_outputs);
	async_pim_0_1_enable_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_enable_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/enable_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_start_vif
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/start_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_start_vif(
	const string&	arg_vif_name,
	Pim01StartVifCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_start_vif(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_start_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/start_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StartVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_start_vif, pxa_outputs);
	async_pim_0_1_start_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_start_vif(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/start_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_stop_vif
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/stop_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_stop_vif(
	const string&	arg_vif_name,
	Pim01StopVifCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_stop_vif(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_stop_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/stop_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StopVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_stop_vif, pxa_outputs);
	async_pim_0_1_stop_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_stop_vif(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/stop_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_enable_all_vifs
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/enable_all_vifs", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_enable_all_vifs(
	const bool&	arg_enable,
	Pim01EnableAllVifsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_enable_all_vifs(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_enable_all_vifs(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/enable_all_vifs");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01EnableAllVifsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_enable_all_vifs, pxa_outputs);
	async_pim_0_1_enable_all_vifs(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_enable_all_vifs(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/enable_all_vifs", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_start_all_vifs
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/start_all_vifs", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_start_all_vifs(
	Pim01StartAllVifsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_start_all_vifs();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_start_all_vifs(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/start_all_vifs");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StartAllVifsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_start_all_vifs, pxa_outputs);
	async_pim_0_1_start_all_vifs( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_start_all_vifs();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/start_all_vifs", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_stop_all_vifs
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/stop_all_vifs", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_stop_all_vifs(
	Pim01StopAllVifsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_stop_all_vifs();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_stop_all_vifs(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/stop_all_vifs");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StopAllVifsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_stop_all_vifs, pxa_outputs);
	async_pim_0_1_stop_all_vifs( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_stop_all_vifs();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/stop_all_vifs", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_enable_pim
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/enable_pim", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_enable_pim(
	const bool&	arg_enable,
	Pim01EnablePimCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_enable_pim(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_enable_pim(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/enable_pim");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01EnablePimRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_enable_pim, pxa_outputs);
	async_pim_0_1_enable_pim(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_enable_pim(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/enable_pim", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_start_pim
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/start_pim", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_start_pim(
	Pim01StartPimCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_start_pim();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_start_pim(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/start_pim");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StartPimRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_start_pim, pxa_outputs);
	async_pim_0_1_start_pim( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_start_pim();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/start_pim", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_stop_pim
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/stop_pim", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_stop_pim(
	Pim01StopPimCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_stop_pim();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_stop_pim(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/stop_pim");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StopPimRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_stop_pim, pxa_outputs);
	async_pim_0_1_stop_pim( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_stop_pim();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/stop_pim", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_enable_cli
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/enable_cli", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_enable_cli(
	const bool&	arg_enable,
	Pim01EnableCliCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_enable_cli(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_enable_cli(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/enable_cli");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01EnableCliRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_enable_cli, pxa_outputs);
	async_pim_0_1_enable_cli(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_enable_cli(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/enable_cli", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_start_cli
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/start_cli", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_start_cli(
	Pim01StartCliCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_start_cli();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_start_cli(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/start_cli");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StartCliRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_start_cli, pxa_outputs);
	async_pim_0_1_start_cli( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_start_cli();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/start_cli", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_stop_cli
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/stop_cli", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_stop_cli(
	Pim01StopCliCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_stop_cli();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_stop_cli(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/stop_cli");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StopCliRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_stop_cli, pxa_outputs);
	async_pim_0_1_stop_cli( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_stop_cli();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/stop_cli", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_enable_bsr
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/enable_bsr", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_enable_bsr(
	const bool&	arg_enable,
	Pim01EnableBsrCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_enable_bsr(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_enable_bsr(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/enable_bsr");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01EnableBsrRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_enable_bsr, pxa_outputs);
	async_pim_0_1_enable_bsr(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_enable_bsr(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/enable_bsr", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_start_bsr
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/start_bsr", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_start_bsr(
	Pim01StartBsrCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_start_bsr();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_start_bsr(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/start_bsr");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StartBsrRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_start_bsr, pxa_outputs);
	async_pim_0_1_start_bsr( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_start_bsr();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/start_bsr", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_stop_bsr
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/stop_bsr", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_stop_bsr(
	Pim01StopBsrCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_stop_bsr();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_stop_bsr(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/stop_bsr");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01StopBsrRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_stop_bsr, pxa_outputs);
	async_pim_0_1_stop_bsr( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_stop_bsr();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/stop_bsr", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_apply_bsr_changes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/apply_bsr_changes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_apply_bsr_changes(
	Pim01ApplyBsrChangesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_apply_bsr_changes();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_apply_bsr_changes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/apply_bsr_changes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ApplyBsrChangesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_apply_bsr_changes, pxa_outputs);
	async_pim_0_1_apply_bsr_changes( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_apply_bsr_changes();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/apply_bsr_changes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_name4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_scope_zone_by_vif_name4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_scope_zone_by_vif_name4(
	const IPv4Net&	arg_scope_zone_id,
	const string&	arg_vif_name,
	Pim01AddConfigScopeZoneByVifName4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_name4(
        arg_scope_zone_id,
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_name4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_scope_zone_by_vif_name4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigScopeZoneByVifName4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_name4, pxa_outputs);
	async_pim_0_1_add_config_scope_zone_by_vif_name4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_name4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_scope_zone_by_vif_name4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_name6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_scope_zone_by_vif_name6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_scope_zone_by_vif_name6(
	const IPv6Net&	arg_scope_zone_id,
	const string&	arg_vif_name,
	Pim01AddConfigScopeZoneByVifName6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_name6(
        arg_scope_zone_id,
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_name6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_scope_zone_by_vif_name6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigScopeZoneByVifName6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_name6, pxa_outputs);
	async_pim_0_1_add_config_scope_zone_by_vif_name6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_name6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_scope_zone_by_vif_name6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_addr6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_scope_zone_by_vif_addr6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_scope_zone_by_vif_addr6(
	const IPv6Net&	arg_scope_zone_id,
	const IPv6&	arg_vif_addr,
	Pim01AddConfigScopeZoneByVifAddr6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_addr6(
        arg_scope_zone_id,
        arg_vif_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_addr6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_scope_zone_by_vif_addr6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigScopeZoneByVifAddr6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_addr6, pxa_outputs);
	async_pim_0_1_add_config_scope_zone_by_vif_addr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_addr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_scope_zone_by_vif_addr6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_name6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_scope_zone_by_vif_name6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_scope_zone_by_vif_name6(
	const IPv6Net&	arg_scope_zone_id,
	const string&	arg_vif_name,
	Pim01DeleteConfigScopeZoneByVifName6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_name6(
        arg_scope_zone_id,
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_name6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_scope_zone_by_vif_name6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigScopeZoneByVifName6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_name6, pxa_outputs);
	async_pim_0_1_delete_config_scope_zone_by_vif_name6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_name6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_scope_zone_by_vif_name6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_addr6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_scope_zone_by_vif_addr6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_scope_zone_by_vif_addr6(
	const IPv6Net&	arg_scope_zone_id,
	const IPv6&	arg_vif_addr,
	Pim01DeleteConfigScopeZoneByVifAddr6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_addr6(
        arg_scope_zone_id,
        arg_vif_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_addr6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_scope_zone_by_vif_addr6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigScopeZoneByVifAddr6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_addr6, pxa_outputs);
	async_pim_0_1_delete_config_scope_zone_by_vif_addr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_addr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "vif_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_scope_zone_by_vif_addr6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_addr4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_scope_zone_by_vif_addr4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_scope_zone_by_vif_addr4(
	const IPv4Net&	arg_scope_zone_id,
	const IPv4&	arg_vif_addr,
	Pim01AddConfigScopeZoneByVifAddr4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_addr4(
        arg_scope_zone_id,
        arg_vif_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_scope_zone_by_vif_addr4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_scope_zone_by_vif_addr4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigScopeZoneByVifAddr4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_scope_zone_by_vif_addr4, pxa_outputs);
	async_pim_0_1_add_config_scope_zone_by_vif_addr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_scope_zone_by_vif_addr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_scope_zone_by_vif_addr4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_name4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_scope_zone_by_vif_name4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_scope_zone_by_vif_name4(
	const IPv4Net&	arg_scope_zone_id,
	const string&	arg_vif_name,
	Pim01DeleteConfigScopeZoneByVifName4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_name4(
        arg_scope_zone_id,
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_name4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_scope_zone_by_vif_name4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigScopeZoneByVifName4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_name4, pxa_outputs);
	async_pim_0_1_delete_config_scope_zone_by_vif_name4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_name4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_scope_zone_by_vif_name4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_addr4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_scope_zone_by_vif_addr4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_scope_zone_by_vif_addr4(
	const IPv4Net&	arg_scope_zone_id,
	const IPv4&	arg_vif_addr,
	Pim01DeleteConfigScopeZoneByVifAddr4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_addr4(
        arg_scope_zone_id,
        arg_vif_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_scope_zone_by_vif_addr4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_scope_zone_by_vif_addr4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigScopeZoneByVifAddr4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_scope_zone_by_vif_addr4, pxa_outputs);
	async_pim_0_1_delete_config_scope_zone_by_vif_addr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_scope_zone_by_vif_addr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "vif_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_scope_zone_by_vif_addr4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_cand_bsr4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_cand_bsr4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_cand_bsr4(
	const IPv4Net&	arg_scope_zone_id,
	const bool&	arg_is_scope_zone,
	const string&	arg_vif_name,
	const IPv4&	arg_vif_addr,
	const uint32_t&	arg_bsr_priority,
	const uint32_t&	arg_hash_mask_len,
	Pim01AddConfigCandBsr4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_cand_bsr4(
        arg_scope_zone_id,
        arg_is_scope_zone,
        arg_vif_name,
        arg_vif_addr,
        arg_bsr_priority,
        arg_hash_mask_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_cand_bsr4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_cand_bsr4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigCandBsr4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_cand_bsr4, pxa_outputs);
	async_pim_0_1_add_config_cand_bsr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv4(),
	    xa_inputs.get(4, "bsr_priority").uint32(),
	    xa_inputs.get(5, "hash_mask_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_cand_bsr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv4(),
	    xa_inputs.get(4, "bsr_priority").uint32(),
	    xa_inputs.get(5, "hash_mask_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_cand_bsr4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_cand_bsr6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_cand_bsr6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_cand_bsr6(
	const IPv6Net&	arg_scope_zone_id,
	const bool&	arg_is_scope_zone,
	const string&	arg_vif_name,
	const IPv6&	arg_vif_addr,
	const uint32_t&	arg_bsr_priority,
	const uint32_t&	arg_hash_mask_len,
	Pim01AddConfigCandBsr6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_cand_bsr6(
        arg_scope_zone_id,
        arg_is_scope_zone,
        arg_vif_name,
        arg_vif_addr,
        arg_bsr_priority,
        arg_hash_mask_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_cand_bsr6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_cand_bsr6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigCandBsr6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_cand_bsr6, pxa_outputs);
	async_pim_0_1_add_config_cand_bsr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv6(),
	    xa_inputs.get(4, "bsr_priority").uint32(),
	    xa_inputs.get(5, "hash_mask_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_cand_bsr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv6(),
	    xa_inputs.get(4, "bsr_priority").uint32(),
	    xa_inputs.get(5, "hash_mask_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_cand_bsr6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_cand_bsr6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_cand_bsr6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_cand_bsr6(
	const IPv6Net&	arg_scope_zone_id,
	const bool&	arg_is_scope_zone,
	Pim01DeleteConfigCandBsr6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_cand_bsr6(
        arg_scope_zone_id,
        arg_is_scope_zone);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_cand_bsr6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_cand_bsr6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigCandBsr6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_cand_bsr6, pxa_outputs);
	async_pim_0_1_delete_config_cand_bsr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_cand_bsr6(
	    xa_inputs.get(0, "scope_zone_id").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_cand_bsr6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_cand_bsr4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_cand_bsr4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_cand_bsr4(
	const IPv4Net&	arg_scope_zone_id,
	const bool&	arg_is_scope_zone,
	Pim01DeleteConfigCandBsr4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_cand_bsr4(
        arg_scope_zone_id,
        arg_is_scope_zone);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_cand_bsr4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_cand_bsr4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigCandBsr4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_cand_bsr4, pxa_outputs);
	async_pim_0_1_delete_config_cand_bsr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_cand_bsr4(
	    xa_inputs.get(0, "scope_zone_id").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_cand_bsr4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_cand_rp4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_cand_rp4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_cand_rp4(
	const IPv4Net&	arg_group_prefix,
	const bool&	arg_is_scope_zone,
	const string&	arg_vif_name,
	const IPv4&	arg_vif_addr,
	const uint32_t&	arg_rp_priority,
	const uint32_t&	arg_rp_holdtime,
	Pim01AddConfigCandRp4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_cand_rp4(
        arg_group_prefix,
        arg_is_scope_zone,
        arg_vif_name,
        arg_vif_addr,
        arg_rp_priority,
        arg_rp_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_cand_rp4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_cand_rp4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigCandRp4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_cand_rp4, pxa_outputs);
	async_pim_0_1_add_config_cand_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv4(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_cand_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv4(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_cand_rp4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_cand_rp6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_cand_rp6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_cand_rp6(
	const IPv6Net&	arg_group_prefix,
	const bool&	arg_is_scope_zone,
	const string&	arg_vif_name,
	const IPv6&	arg_vif_addr,
	const uint32_t&	arg_rp_priority,
	const uint32_t&	arg_rp_holdtime,
	Pim01AddConfigCandRp6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_cand_rp6(
        arg_group_prefix,
        arg_is_scope_zone,
        arg_vif_name,
        arg_vif_addr,
        arg_rp_priority,
        arg_rp_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_cand_rp6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_cand_rp6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigCandRp6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_cand_rp6, pxa_outputs);
	async_pim_0_1_add_config_cand_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv6(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_cand_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv6(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_cand_rp6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_cand_rp6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_cand_rp6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_cand_rp6(
	const IPv6Net&	arg_group_prefix,
	const bool&	arg_is_scope_zone,
	const string&	arg_vif_name,
	const IPv6&	arg_vif_addr,
	Pim01DeleteConfigCandRp6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_cand_rp6(
        arg_group_prefix,
        arg_is_scope_zone,
        arg_vif_name,
        arg_vif_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_cand_rp6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_cand_rp6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigCandRp6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_cand_rp6, pxa_outputs);
	async_pim_0_1_delete_config_cand_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_cand_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_cand_rp6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_cand_rp4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_cand_rp4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_cand_rp4(
	const IPv4Net&	arg_group_prefix,
	const bool&	arg_is_scope_zone,
	const string&	arg_vif_name,
	const IPv4&	arg_vif_addr,
	Pim01DeleteConfigCandRp4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_cand_rp4(
        arg_group_prefix,
        arg_is_scope_zone,
        arg_vif_name,
        arg_vif_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_cand_rp4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_cand_rp4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigCandRp4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_cand_rp4, pxa_outputs);
	async_pim_0_1_delete_config_cand_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_cand_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "is_scope_zone").boolean(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "vif_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_cand_rp4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_static_rp4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_static_rp4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_static_rp4(
	const IPv4Net&	arg_group_prefix,
	const IPv4&	arg_rp_addr,
	const uint32_t&	arg_rp_priority,
	const uint32_t&	arg_hash_mask_len,
	Pim01AddConfigStaticRp4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_static_rp4(
        arg_group_prefix,
        arg_rp_addr,
        arg_rp_priority,
        arg_hash_mask_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_static_rp4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_static_rp4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigStaticRp4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_static_rp4, pxa_outputs);
	async_pim_0_1_add_config_static_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "rp_addr").ipv4(),
	    xa_inputs.get(2, "rp_priority").uint32(),
	    xa_inputs.get(3, "hash_mask_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_static_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "rp_addr").ipv4(),
	    xa_inputs.get(2, "rp_priority").uint32(),
	    xa_inputs.get(3, "hash_mask_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_static_rp4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_config_static_rp6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_config_static_rp6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_config_static_rp6(
	const IPv6Net&	arg_group_prefix,
	const IPv6&	arg_rp_addr,
	const uint32_t&	arg_rp_priority,
	const uint32_t&	arg_hash_mask_len,
	Pim01AddConfigStaticRp6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_config_static_rp6(
        arg_group_prefix,
        arg_rp_addr,
        arg_rp_priority,
        arg_hash_mask_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_config_static_rp6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_config_static_rp6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddConfigStaticRp6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_config_static_rp6, pxa_outputs);
	async_pim_0_1_add_config_static_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "rp_addr").ipv6(),
	    xa_inputs.get(2, "rp_priority").uint32(),
	    xa_inputs.get(3, "hash_mask_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_config_static_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "rp_addr").ipv6(),
	    xa_inputs.get(2, "rp_priority").uint32(),
	    xa_inputs.get(3, "hash_mask_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_config_static_rp6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_static_rp6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_static_rp6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_static_rp6(
	const IPv6Net&	arg_group_prefix,
	const IPv6&	arg_rp_addr,
	Pim01DeleteConfigStaticRp6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_static_rp6(
        arg_group_prefix,
        arg_rp_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_static_rp6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_static_rp6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigStaticRp6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_static_rp6, pxa_outputs);
	async_pim_0_1_delete_config_static_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "rp_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_static_rp6(
	    xa_inputs.get(0, "group_prefix").ipv6net(),
	    xa_inputs.get(1, "rp_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_static_rp6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_all_static_group_prefixes_rp6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_all_static_group_prefixes_rp6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_all_static_group_prefixes_rp6(
	const IPv6&	arg_rp_addr,
	Pim01DeleteConfigAllStaticGroupPrefixesRp6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_all_static_group_prefixes_rp6(
        arg_rp_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_all_static_group_prefixes_rp6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_all_static_group_prefixes_rp6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigAllStaticGroupPrefixesRp6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_all_static_group_prefixes_rp6, pxa_outputs);
	async_pim_0_1_delete_config_all_static_group_prefixes_rp6(
	    xa_inputs.get(0, "rp_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_all_static_group_prefixes_rp6(
	    xa_inputs.get(0, "rp_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_all_static_group_prefixes_rp6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_static_rp4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_static_rp4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_static_rp4(
	const IPv4Net&	arg_group_prefix,
	const IPv4&	arg_rp_addr,
	Pim01DeleteConfigStaticRp4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_static_rp4(
        arg_group_prefix,
        arg_rp_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_static_rp4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_static_rp4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigStaticRp4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_static_rp4, pxa_outputs);
	async_pim_0_1_delete_config_static_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "rp_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_static_rp4(
	    xa_inputs.get(0, "group_prefix").ipv4net(),
	    xa_inputs.get(1, "rp_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_static_rp4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_all_static_group_prefixes_rp4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_all_static_group_prefixes_rp4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_all_static_group_prefixes_rp4(
	const IPv4&	arg_rp_addr,
	Pim01DeleteConfigAllStaticGroupPrefixesRp4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_all_static_group_prefixes_rp4(
        arg_rp_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_all_static_group_prefixes_rp4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_all_static_group_prefixes_rp4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigAllStaticGroupPrefixesRp4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_all_static_group_prefixes_rp4, pxa_outputs);
	async_pim_0_1_delete_config_all_static_group_prefixes_rp4(
	    xa_inputs.get(0, "rp_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_all_static_group_prefixes_rp4(
	    xa_inputs.get(0, "rp_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_all_static_group_prefixes_rp4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_config_all_static_rps
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_config_all_static_rps", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_config_all_static_rps(
	Pim01DeleteConfigAllStaticRpsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_config_all_static_rps();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_config_all_static_rps(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_config_all_static_rps");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteConfigAllStaticRpsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_config_all_static_rps, pxa_outputs);
	async_pim_0_1_delete_config_all_static_rps( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_config_all_static_rps();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_config_all_static_rps", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_config_static_rp_done
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/config_static_rp_done", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_config_static_rp_done(
	Pim01ConfigStaticRpDoneCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_config_static_rp_done();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_config_static_rp_done(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/config_static_rp_done");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ConfigStaticRpDoneRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_config_static_rp_done, pxa_outputs);
	async_pim_0_1_config_static_rp_done( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_config_static_rp_done();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/config_static_rp_done", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_proto_version
    (const XrlCmdError &e,
     const uint32_t* rarg_proto_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_proto_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("proto_version", *rarg_proto_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_proto_version(
	const string&	arg_vif_name,
	Pim01GetVifProtoVersionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_proto_version;
    XrlCmdError e = pim_0_1_get_vif_proto_version(
        arg_vif_name,
        rarg_proto_version);
    return c_b->dispatch(e,
        &rarg_proto_version);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_proto_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_proto_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifProtoVersionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_proto_version, pxa_outputs);
	async_pim_0_1_get_vif_proto_version(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_proto_version;
    try {
	XrlCmdError e = pim_0_1_get_vif_proto_version(
	    xa_inputs.get(0, "vif_name").text(),
	    r_proto_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_proto_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("proto_version", r_proto_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_proto_version
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_proto_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_proto_version(
	const string&	arg_vif_name,
	const uint32_t&	arg_proto_version,
	Pim01SetVifProtoVersionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_proto_version(
        arg_vif_name,
        arg_proto_version);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_proto_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_proto_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifProtoVersionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_proto_version, pxa_outputs);
	async_pim_0_1_set_vif_proto_version(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "proto_version").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_proto_version(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "proto_version").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_proto_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_proto_version
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_proto_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_proto_version(
	const string&	arg_vif_name,
	Pim01ResetVifProtoVersionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_proto_version(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_proto_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_proto_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifProtoVersionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_proto_version, pxa_outputs);
	async_pim_0_1_reset_vif_proto_version(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_proto_version(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_proto_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_hello_triggered_delay
    (const XrlCmdError &e,
     const uint32_t* rarg_hello_triggered_delay,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_hello_triggered_delay", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("hello_triggered_delay", *rarg_hello_triggered_delay);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_hello_triggered_delay(
	const string&	arg_vif_name,
	Pim01GetVifHelloTriggeredDelayCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_hello_triggered_delay;
    XrlCmdError e = pim_0_1_get_vif_hello_triggered_delay(
        arg_vif_name,
        rarg_hello_triggered_delay);
    return c_b->dispatch(e,
        &rarg_hello_triggered_delay);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_hello_triggered_delay(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_hello_triggered_delay");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifHelloTriggeredDelayRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_hello_triggered_delay, pxa_outputs);
	async_pim_0_1_get_vif_hello_triggered_delay(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_hello_triggered_delay;
    try {
	XrlCmdError e = pim_0_1_get_vif_hello_triggered_delay(
	    xa_inputs.get(0, "vif_name").text(),
	    r_hello_triggered_delay);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_hello_triggered_delay", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("hello_triggered_delay", r_hello_triggered_delay);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_hello_triggered_delay
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_hello_triggered_delay", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_hello_triggered_delay(
	const string&	arg_vif_name,
	const uint32_t&	arg_hello_triggered_delay,
	Pim01SetVifHelloTriggeredDelayCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_hello_triggered_delay(
        arg_vif_name,
        arg_hello_triggered_delay);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_hello_triggered_delay(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_hello_triggered_delay");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifHelloTriggeredDelayRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_hello_triggered_delay, pxa_outputs);
	async_pim_0_1_set_vif_hello_triggered_delay(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "hello_triggered_delay").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_hello_triggered_delay(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "hello_triggered_delay").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_hello_triggered_delay", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_hello_triggered_delay
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_hello_triggered_delay", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_hello_triggered_delay(
	const string&	arg_vif_name,
	Pim01ResetVifHelloTriggeredDelayCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_hello_triggered_delay(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_hello_triggered_delay(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_hello_triggered_delay");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifHelloTriggeredDelayRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_hello_triggered_delay, pxa_outputs);
	async_pim_0_1_reset_vif_hello_triggered_delay(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_hello_triggered_delay(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_hello_triggered_delay", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_hello_period
    (const XrlCmdError &e,
     const uint32_t* rarg_hello_period,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_hello_period", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("hello_period", *rarg_hello_period);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_hello_period(
	const string&	arg_vif_name,
	Pim01GetVifHelloPeriodCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_hello_period;
    XrlCmdError e = pim_0_1_get_vif_hello_period(
        arg_vif_name,
        rarg_hello_period);
    return c_b->dispatch(e,
        &rarg_hello_period);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_hello_period(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_hello_period");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifHelloPeriodRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_hello_period, pxa_outputs);
	async_pim_0_1_get_vif_hello_period(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_hello_period;
    try {
	XrlCmdError e = pim_0_1_get_vif_hello_period(
	    xa_inputs.get(0, "vif_name").text(),
	    r_hello_period);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_hello_period", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("hello_period", r_hello_period);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_hello_period
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_hello_period", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_hello_period(
	const string&	arg_vif_name,
	const uint32_t&	arg_hello_period,
	Pim01SetVifHelloPeriodCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_hello_period(
        arg_vif_name,
        arg_hello_period);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_hello_period(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_hello_period");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifHelloPeriodRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_hello_period, pxa_outputs);
	async_pim_0_1_set_vif_hello_period(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "hello_period").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_hello_period(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "hello_period").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_hello_period", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_hello_period
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_hello_period", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_hello_period(
	const string&	arg_vif_name,
	Pim01ResetVifHelloPeriodCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_hello_period(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_hello_period(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_hello_period");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifHelloPeriodRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_hello_period, pxa_outputs);
	async_pim_0_1_reset_vif_hello_period(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_hello_period(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_hello_period", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_hello_holdtime
    (const XrlCmdError &e,
     const uint32_t* rarg_hello_holdtime,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_hello_holdtime", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("hello_holdtime", *rarg_hello_holdtime);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_hello_holdtime(
	const string&	arg_vif_name,
	Pim01GetVifHelloHoldtimeCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_hello_holdtime;
    XrlCmdError e = pim_0_1_get_vif_hello_holdtime(
        arg_vif_name,
        rarg_hello_holdtime);
    return c_b->dispatch(e,
        &rarg_hello_holdtime);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_hello_holdtime(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_hello_holdtime");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifHelloHoldtimeRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_hello_holdtime, pxa_outputs);
	async_pim_0_1_get_vif_hello_holdtime(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_hello_holdtime;
    try {
	XrlCmdError e = pim_0_1_get_vif_hello_holdtime(
	    xa_inputs.get(0, "vif_name").text(),
	    r_hello_holdtime);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_hello_holdtime", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("hello_holdtime", r_hello_holdtime);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_hello_holdtime
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_hello_holdtime", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_hello_holdtime(
	const string&	arg_vif_name,
	const uint32_t&	arg_hello_holdtime,
	Pim01SetVifHelloHoldtimeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_hello_holdtime(
        arg_vif_name,
        arg_hello_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_hello_holdtime(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_hello_holdtime");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifHelloHoldtimeRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_hello_holdtime, pxa_outputs);
	async_pim_0_1_set_vif_hello_holdtime(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "hello_holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_hello_holdtime(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "hello_holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_hello_holdtime", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_hello_holdtime
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_hello_holdtime", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_hello_holdtime(
	const string&	arg_vif_name,
	Pim01ResetVifHelloHoldtimeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_hello_holdtime(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_hello_holdtime(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_hello_holdtime");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifHelloHoldtimeRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_hello_holdtime, pxa_outputs);
	async_pim_0_1_reset_vif_hello_holdtime(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_hello_holdtime(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_hello_holdtime", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_dr_priority
    (const XrlCmdError &e,
     const uint32_t* rarg_dr_priority,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_dr_priority", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("dr_priority", *rarg_dr_priority);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_dr_priority(
	const string&	arg_vif_name,
	Pim01GetVifDrPriorityCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_dr_priority;
    XrlCmdError e = pim_0_1_get_vif_dr_priority(
        arg_vif_name,
        rarg_dr_priority);
    return c_b->dispatch(e,
        &rarg_dr_priority);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_dr_priority(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_dr_priority");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifDrPriorityRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_dr_priority, pxa_outputs);
	async_pim_0_1_get_vif_dr_priority(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_dr_priority;
    try {
	XrlCmdError e = pim_0_1_get_vif_dr_priority(
	    xa_inputs.get(0, "vif_name").text(),
	    r_dr_priority);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_dr_priority", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("dr_priority", r_dr_priority);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_dr_priority
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_dr_priority", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_dr_priority(
	const string&	arg_vif_name,
	const uint32_t&	arg_dr_priority,
	Pim01SetVifDrPriorityCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_dr_priority(
        arg_vif_name,
        arg_dr_priority);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_dr_priority(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_dr_priority");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifDrPriorityRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_dr_priority, pxa_outputs);
	async_pim_0_1_set_vif_dr_priority(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "dr_priority").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_dr_priority(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "dr_priority").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_dr_priority", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_dr_priority
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_dr_priority", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_dr_priority(
	const string&	arg_vif_name,
	Pim01ResetVifDrPriorityCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_dr_priority(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_dr_priority(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_dr_priority");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifDrPriorityRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_dr_priority, pxa_outputs);
	async_pim_0_1_reset_vif_dr_priority(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_dr_priority(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_dr_priority", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_propagation_delay
    (const XrlCmdError &e,
     const uint32_t* rarg_propagation_delay,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_propagation_delay", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("propagation_delay", *rarg_propagation_delay);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_propagation_delay(
	const string&	arg_vif_name,
	Pim01GetVifPropagationDelayCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_propagation_delay;
    XrlCmdError e = pim_0_1_get_vif_propagation_delay(
        arg_vif_name,
        rarg_propagation_delay);
    return c_b->dispatch(e,
        &rarg_propagation_delay);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_propagation_delay(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_propagation_delay");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifPropagationDelayRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_propagation_delay, pxa_outputs);
	async_pim_0_1_get_vif_propagation_delay(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_propagation_delay;
    try {
	XrlCmdError e = pim_0_1_get_vif_propagation_delay(
	    xa_inputs.get(0, "vif_name").text(),
	    r_propagation_delay);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_propagation_delay", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("propagation_delay", r_propagation_delay);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_propagation_delay
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_propagation_delay", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_propagation_delay(
	const string&	arg_vif_name,
	const uint32_t&	arg_propagation_delay,
	Pim01SetVifPropagationDelayCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_propagation_delay(
        arg_vif_name,
        arg_propagation_delay);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_propagation_delay(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_propagation_delay");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifPropagationDelayRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_propagation_delay, pxa_outputs);
	async_pim_0_1_set_vif_propagation_delay(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "propagation_delay").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_propagation_delay(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "propagation_delay").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_propagation_delay", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_propagation_delay
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_propagation_delay", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_propagation_delay(
	const string&	arg_vif_name,
	Pim01ResetVifPropagationDelayCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_propagation_delay(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_propagation_delay(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_propagation_delay");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifPropagationDelayRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_propagation_delay, pxa_outputs);
	async_pim_0_1_reset_vif_propagation_delay(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_propagation_delay(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_propagation_delay", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_override_interval
    (const XrlCmdError &e,
     const uint32_t* rarg_override_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_override_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("override_interval", *rarg_override_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_override_interval(
	const string&	arg_vif_name,
	Pim01GetVifOverrideIntervalCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_override_interval;
    XrlCmdError e = pim_0_1_get_vif_override_interval(
        arg_vif_name,
        rarg_override_interval);
    return c_b->dispatch(e,
        &rarg_override_interval);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_override_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_override_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifOverrideIntervalRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_override_interval, pxa_outputs);
	async_pim_0_1_get_vif_override_interval(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_override_interval;
    try {
	XrlCmdError e = pim_0_1_get_vif_override_interval(
	    xa_inputs.get(0, "vif_name").text(),
	    r_override_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_override_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("override_interval", r_override_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_override_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_override_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_override_interval(
	const string&	arg_vif_name,
	const uint32_t&	arg_override_interval,
	Pim01SetVifOverrideIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_override_interval(
        arg_vif_name,
        arg_override_interval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_override_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_override_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifOverrideIntervalRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_override_interval, pxa_outputs);
	async_pim_0_1_set_vif_override_interval(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "override_interval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_override_interval(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "override_interval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_override_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_override_interval
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_override_interval", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_override_interval(
	const string&	arg_vif_name,
	Pim01ResetVifOverrideIntervalCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_override_interval(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_override_interval(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_override_interval");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifOverrideIntervalRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_override_interval, pxa_outputs);
	async_pim_0_1_reset_vif_override_interval(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_override_interval(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_override_interval", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_is_tracking_support_disabled
    (const XrlCmdError &e,
     const bool* rarg_is_tracking_support_disabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_is_tracking_support_disabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("is_tracking_support_disabled", *rarg_is_tracking_support_disabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_is_tracking_support_disabled(
	const string&	arg_vif_name,
	Pim01GetVifIsTrackingSupportDisabledCB c_b)
{

    /* Return value declarations */
    bool rarg_is_tracking_support_disabled;
    XrlCmdError e = pim_0_1_get_vif_is_tracking_support_disabled(
        arg_vif_name,
        rarg_is_tracking_support_disabled);
    return c_b->dispatch(e,
        &rarg_is_tracking_support_disabled);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_is_tracking_support_disabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_is_tracking_support_disabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifIsTrackingSupportDisabledRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_is_tracking_support_disabled, pxa_outputs);
	async_pim_0_1_get_vif_is_tracking_support_disabled(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_is_tracking_support_disabled;
    try {
	XrlCmdError e = pim_0_1_get_vif_is_tracking_support_disabled(
	    xa_inputs.get(0, "vif_name").text(),
	    r_is_tracking_support_disabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_is_tracking_support_disabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("is_tracking_support_disabled", r_is_tracking_support_disabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_is_tracking_support_disabled
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_is_tracking_support_disabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_is_tracking_support_disabled(
	const string&	arg_vif_name,
	const bool&	arg_is_tracking_support_disabled,
	Pim01SetVifIsTrackingSupportDisabledCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_is_tracking_support_disabled(
        arg_vif_name,
        arg_is_tracking_support_disabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_is_tracking_support_disabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_is_tracking_support_disabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifIsTrackingSupportDisabledRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_is_tracking_support_disabled, pxa_outputs);
	async_pim_0_1_set_vif_is_tracking_support_disabled(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "is_tracking_support_disabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_is_tracking_support_disabled(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "is_tracking_support_disabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_is_tracking_support_disabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_is_tracking_support_disabled
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_is_tracking_support_disabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_is_tracking_support_disabled(
	const string&	arg_vif_name,
	Pim01ResetVifIsTrackingSupportDisabledCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_is_tracking_support_disabled(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_is_tracking_support_disabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_is_tracking_support_disabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifIsTrackingSupportDisabledRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_is_tracking_support_disabled, pxa_outputs);
	async_pim_0_1_reset_vif_is_tracking_support_disabled(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_is_tracking_support_disabled(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_is_tracking_support_disabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_accept_nohello_neighbors
    (const XrlCmdError &e,
     const bool* rarg_accept_nohello_neighbors,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_accept_nohello_neighbors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("accept_nohello_neighbors", *rarg_accept_nohello_neighbors);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_accept_nohello_neighbors(
	const string&	arg_vif_name,
	Pim01GetVifAcceptNohelloNeighborsCB c_b)
{

    /* Return value declarations */
    bool rarg_accept_nohello_neighbors;
    XrlCmdError e = pim_0_1_get_vif_accept_nohello_neighbors(
        arg_vif_name,
        rarg_accept_nohello_neighbors);
    return c_b->dispatch(e,
        &rarg_accept_nohello_neighbors);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_accept_nohello_neighbors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_accept_nohello_neighbors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifAcceptNohelloNeighborsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_accept_nohello_neighbors, pxa_outputs);
	async_pim_0_1_get_vif_accept_nohello_neighbors(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_accept_nohello_neighbors;
    try {
	XrlCmdError e = pim_0_1_get_vif_accept_nohello_neighbors(
	    xa_inputs.get(0, "vif_name").text(),
	    r_accept_nohello_neighbors);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_accept_nohello_neighbors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("accept_nohello_neighbors", r_accept_nohello_neighbors);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_accept_nohello_neighbors
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_accept_nohello_neighbors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_accept_nohello_neighbors(
	const string&	arg_vif_name,
	const bool&	arg_accept_nohello_neighbors,
	Pim01SetVifAcceptNohelloNeighborsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_accept_nohello_neighbors(
        arg_vif_name,
        arg_accept_nohello_neighbors);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_accept_nohello_neighbors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_accept_nohello_neighbors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifAcceptNohelloNeighborsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_accept_nohello_neighbors, pxa_outputs);
	async_pim_0_1_set_vif_accept_nohello_neighbors(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "accept_nohello_neighbors").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_accept_nohello_neighbors(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "accept_nohello_neighbors").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_accept_nohello_neighbors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_accept_nohello_neighbors
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_accept_nohello_neighbors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_accept_nohello_neighbors(
	const string&	arg_vif_name,
	Pim01ResetVifAcceptNohelloNeighborsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_accept_nohello_neighbors(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_accept_nohello_neighbors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_accept_nohello_neighbors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifAcceptNohelloNeighborsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_accept_nohello_neighbors, pxa_outputs);
	async_pim_0_1_reset_vif_accept_nohello_neighbors(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_accept_nohello_neighbors(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_accept_nohello_neighbors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_vif_join_prune_period
    (const XrlCmdError &e,
     const uint32_t* rarg_join_prune_period,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_vif_join_prune_period", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("join_prune_period", *rarg_join_prune_period);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_vif_join_prune_period(
	const string&	arg_vif_name,
	Pim01GetVifJoinPrunePeriodCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_join_prune_period;
    XrlCmdError e = pim_0_1_get_vif_join_prune_period(
        arg_vif_name,
        rarg_join_prune_period);
    return c_b->dispatch(e,
        &rarg_join_prune_period);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_vif_join_prune_period(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_vif_join_prune_period");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetVifJoinPrunePeriodRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_vif_join_prune_period, pxa_outputs);
	async_pim_0_1_get_vif_join_prune_period(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_join_prune_period;
    try {
	XrlCmdError e = pim_0_1_get_vif_join_prune_period(
	    xa_inputs.get(0, "vif_name").text(),
	    r_join_prune_period);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_vif_join_prune_period", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("join_prune_period", r_join_prune_period);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_vif_join_prune_period
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_vif_join_prune_period", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_vif_join_prune_period(
	const string&	arg_vif_name,
	const uint32_t&	arg_join_prune_period,
	Pim01SetVifJoinPrunePeriodCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_vif_join_prune_period(
        arg_vif_name,
        arg_join_prune_period);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_vif_join_prune_period(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_vif_join_prune_period");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetVifJoinPrunePeriodRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_vif_join_prune_period, pxa_outputs);
	async_pim_0_1_set_vif_join_prune_period(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "join_prune_period").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_vif_join_prune_period(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "join_prune_period").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_vif_join_prune_period", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_vif_join_prune_period
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_vif_join_prune_period", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_vif_join_prune_period(
	const string&	arg_vif_name,
	Pim01ResetVifJoinPrunePeriodCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_vif_join_prune_period(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_vif_join_prune_period(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_vif_join_prune_period");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetVifJoinPrunePeriodRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_vif_join_prune_period, pxa_outputs);
	async_pim_0_1_reset_vif_join_prune_period(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_vif_join_prune_period(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_vif_join_prune_period", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_get_switch_to_spt_threshold
    (const XrlCmdError &e,
     const bool* rarg_is_enabled,
     const uint32_t* rarg_interval_sec,
     const uint32_t* rarg_bytes,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/get_switch_to_spt_threshold", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("is_enabled", *rarg_is_enabled);
	    out.add("interval_sec", *rarg_interval_sec);
	    out.add("bytes", *rarg_bytes);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_get_switch_to_spt_threshold(
	Pim01GetSwitchToSptThresholdCB c_b)
{

    /* Return value declarations */
    bool rarg_is_enabled;
    uint32_t rarg_interval_sec;
    uint32_t rarg_bytes;
    XrlCmdError e = pim_0_1_get_switch_to_spt_threshold(
        rarg_is_enabled,
        rarg_interval_sec,
        rarg_bytes);
    return c_b->dispatch(e,
        &rarg_is_enabled,
        &rarg_interval_sec,
        &rarg_bytes);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_get_switch_to_spt_threshold(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/get_switch_to_spt_threshold");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01GetSwitchToSptThresholdRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_get_switch_to_spt_threshold, pxa_outputs);
	async_pim_0_1_get_switch_to_spt_threshold( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_is_enabled;
    uint32_t r_interval_sec;
    uint32_t r_bytes;
    try {
	XrlCmdError e = pim_0_1_get_switch_to_spt_threshold(
	    r_is_enabled,
	    r_interval_sec,
	    r_bytes);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/get_switch_to_spt_threshold", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("is_enabled", r_is_enabled);
	pxa_outputs->add("interval_sec", r_interval_sec);
	pxa_outputs->add("bytes", r_bytes);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_set_switch_to_spt_threshold
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/set_switch_to_spt_threshold", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_set_switch_to_spt_threshold(
	const bool&	arg_is_enabled,
	const uint32_t&	arg_interval_sec,
	const uint32_t&	arg_bytes,
	Pim01SetSwitchToSptThresholdCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_set_switch_to_spt_threshold(
        arg_is_enabled,
        arg_interval_sec,
        arg_bytes);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_set_switch_to_spt_threshold(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/set_switch_to_spt_threshold");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SetSwitchToSptThresholdRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_set_switch_to_spt_threshold, pxa_outputs);
	async_pim_0_1_set_switch_to_spt_threshold(
	    xa_inputs.get(0, "is_enabled").boolean(),
	    xa_inputs.get(1, "interval_sec").uint32(),
	    xa_inputs.get(2, "bytes").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_set_switch_to_spt_threshold(
	    xa_inputs.get(0, "is_enabled").boolean(),
	    xa_inputs.get(1, "interval_sec").uint32(),
	    xa_inputs.get(2, "bytes").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/set_switch_to_spt_threshold", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_reset_switch_to_spt_threshold
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/reset_switch_to_spt_threshold", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_reset_switch_to_spt_threshold(
	Pim01ResetSwitchToSptThresholdCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_reset_switch_to_spt_threshold();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_reset_switch_to_spt_threshold(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/reset_switch_to_spt_threshold");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ResetSwitchToSptThresholdRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_reset_switch_to_spt_threshold, pxa_outputs);
	async_pim_0_1_reset_switch_to_spt_threshold( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_reset_switch_to_spt_threshold();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/reset_switch_to_spt_threshold", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_alternative_subnet4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_alternative_subnet4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_alternative_subnet4(
	const string&	arg_vif_name,
	const IPv4Net&	arg_subnet,
	Pim01AddAlternativeSubnet4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_alternative_subnet4(
        arg_vif_name,
        arg_subnet);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_alternative_subnet4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_alternative_subnet4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddAlternativeSubnet4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_alternative_subnet4, pxa_outputs);
	async_pim_0_1_add_alternative_subnet4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv4net(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_alternative_subnet4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv4net());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_alternative_subnet4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_alternative_subnet6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_alternative_subnet6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_alternative_subnet6(
	const string&	arg_vif_name,
	const IPv6Net&	arg_subnet,
	Pim01AddAlternativeSubnet6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_alternative_subnet6(
        arg_vif_name,
        arg_subnet);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_alternative_subnet6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_alternative_subnet6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddAlternativeSubnet6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_alternative_subnet6, pxa_outputs);
	async_pim_0_1_add_alternative_subnet6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv6net(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_alternative_subnet6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv6net());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_alternative_subnet6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_alternative_subnet6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_alternative_subnet6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_alternative_subnet6(
	const string&	arg_vif_name,
	const IPv6Net&	arg_subnet,
	Pim01DeleteAlternativeSubnet6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_alternative_subnet6(
        arg_vif_name,
        arg_subnet);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_alternative_subnet6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_alternative_subnet6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteAlternativeSubnet6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_alternative_subnet6, pxa_outputs);
	async_pim_0_1_delete_alternative_subnet6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv6net(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_alternative_subnet6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv6net());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_alternative_subnet6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_delete_alternative_subnet4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/delete_alternative_subnet4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_delete_alternative_subnet4(
	const string&	arg_vif_name,
	const IPv4Net&	arg_subnet,
	Pim01DeleteAlternativeSubnet4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_delete_alternative_subnet4(
        arg_vif_name,
        arg_subnet);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_delete_alternative_subnet4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/delete_alternative_subnet4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01DeleteAlternativeSubnet4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_delete_alternative_subnet4, pxa_outputs);
	async_pim_0_1_delete_alternative_subnet4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv4net(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_delete_alternative_subnet4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "subnet").ipv4net());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/delete_alternative_subnet4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_remove_all_alternative_subnets
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/remove_all_alternative_subnets", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_remove_all_alternative_subnets(
	const string&	arg_vif_name,
	Pim01RemoveAllAlternativeSubnetsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_remove_all_alternative_subnets(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_remove_all_alternative_subnets(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/remove_all_alternative_subnets");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01RemoveAllAlternativeSubnetsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_remove_all_alternative_subnets, pxa_outputs);
	async_pim_0_1_remove_all_alternative_subnets(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_remove_all_alternative_subnets(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/remove_all_alternative_subnets", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_log_trace_all
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/log_trace_all", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_log_trace_all(
	const bool&	arg_enable,
	Pim01LogTraceAllCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_log_trace_all(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_log_trace_all(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/log_trace_all");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01LogTraceAllRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_log_trace_all, pxa_outputs);
	async_pim_0_1_log_trace_all(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_log_trace_all(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/log_trace_all", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_jp_entry4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_jp_entry4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_jp_entry4(
	const IPv4&	arg_source_addr,
	const IPv4&	arg_group_addr,
	const uint32_t&	arg_group_mask_len,
	const string&	arg_mrt_entry_type,
	const string&	arg_action_jp,
	const uint32_t&	arg_holdtime,
	const bool&	arg_is_new_group,
	Pim01AddTestJpEntry4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_jp_entry4(
        arg_source_addr,
        arg_group_addr,
        arg_group_mask_len,
        arg_mrt_entry_type,
        arg_action_jp,
        arg_holdtime,
        arg_is_new_group);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_jp_entry4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(7), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_jp_entry4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestJpEntry4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_jp_entry4, pxa_outputs);
	async_pim_0_1_add_test_jp_entry4(
	    xa_inputs.get(0, "source_addr").ipv4(),
	    xa_inputs.get(1, "group_addr").ipv4(),
	    xa_inputs.get(2, "group_mask_len").uint32(),
	    xa_inputs.get(3, "mrt_entry_type").text(),
	    xa_inputs.get(4, "action_jp").text(),
	    xa_inputs.get(5, "holdtime").uint32(),
	    xa_inputs.get(6, "is_new_group").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_jp_entry4(
	    xa_inputs.get(0, "source_addr").ipv4(),
	    xa_inputs.get(1, "group_addr").ipv4(),
	    xa_inputs.get(2, "group_mask_len").uint32(),
	    xa_inputs.get(3, "mrt_entry_type").text(),
	    xa_inputs.get(4, "action_jp").text(),
	    xa_inputs.get(5, "holdtime").uint32(),
	    xa_inputs.get(6, "is_new_group").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_jp_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_jp_entry6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_jp_entry6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_jp_entry6(
	const IPv6&	arg_source_addr,
	const IPv6&	arg_group_addr,
	const uint32_t&	arg_group_mask_len,
	const string&	arg_mrt_entry_type,
	const string&	arg_action_jp,
	const uint32_t&	arg_holdtime,
	const bool&	arg_is_new_group,
	Pim01AddTestJpEntry6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_jp_entry6(
        arg_source_addr,
        arg_group_addr,
        arg_group_mask_len,
        arg_mrt_entry_type,
        arg_action_jp,
        arg_holdtime,
        arg_is_new_group);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_jp_entry6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 7) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(7), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_jp_entry6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestJpEntry6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_jp_entry6, pxa_outputs);
	async_pim_0_1_add_test_jp_entry6(
	    xa_inputs.get(0, "source_addr").ipv6(),
	    xa_inputs.get(1, "group_addr").ipv6(),
	    xa_inputs.get(2, "group_mask_len").uint32(),
	    xa_inputs.get(3, "mrt_entry_type").text(),
	    xa_inputs.get(4, "action_jp").text(),
	    xa_inputs.get(5, "holdtime").uint32(),
	    xa_inputs.get(6, "is_new_group").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_jp_entry6(
	    xa_inputs.get(0, "source_addr").ipv6(),
	    xa_inputs.get(1, "group_addr").ipv6(),
	    xa_inputs.get(2, "group_mask_len").uint32(),
	    xa_inputs.get(3, "mrt_entry_type").text(),
	    xa_inputs.get(4, "action_jp").text(),
	    xa_inputs.get(5, "holdtime").uint32(),
	    xa_inputs.get(6, "is_new_group").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_jp_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_jp_entry6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_jp_entry6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_jp_entry6(
	const string&	arg_vif_name,
	const IPv6&	arg_nbr_addr,
	Pim01SendTestJpEntry6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_jp_entry6(
        arg_vif_name,
        arg_nbr_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_jp_entry6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_jp_entry6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestJpEntry6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_jp_entry6, pxa_outputs);
	async_pim_0_1_send_test_jp_entry6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "nbr_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_jp_entry6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "nbr_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_jp_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_jp_entry4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_jp_entry4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_jp_entry4(
	const string&	arg_vif_name,
	const IPv4&	arg_nbr_addr,
	Pim01SendTestJpEntry4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_jp_entry4(
        arg_vif_name,
        arg_nbr_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_jp_entry4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_jp_entry4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestJpEntry4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_jp_entry4, pxa_outputs);
	async_pim_0_1_send_test_jp_entry4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "nbr_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_jp_entry4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "nbr_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_jp_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_assert4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_assert4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_assert4(
	const string&	arg_vif_name,
	const IPv4&	arg_source_addr,
	const IPv4&	arg_group_addr,
	const bool&	arg_rpt_bit,
	const uint32_t&	arg_metric_preference,
	const uint32_t&	arg_metric,
	Pim01SendTestAssert4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_assert4(
        arg_vif_name,
        arg_source_addr,
        arg_group_addr,
        arg_rpt_bit,
        arg_metric_preference,
        arg_metric);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_assert4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_assert4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestAssert4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_assert4, pxa_outputs);
	async_pim_0_1_send_test_assert4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "source_addr").ipv4(),
	    xa_inputs.get(2, "group_addr").ipv4(),
	    xa_inputs.get(3, "rpt_bit").boolean(),
	    xa_inputs.get(4, "metric_preference").uint32(),
	    xa_inputs.get(5, "metric").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_assert4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "source_addr").ipv4(),
	    xa_inputs.get(2, "group_addr").ipv4(),
	    xa_inputs.get(3, "rpt_bit").boolean(),
	    xa_inputs.get(4, "metric_preference").uint32(),
	    xa_inputs.get(5, "metric").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_assert4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_assert6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_assert6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_assert6(
	const string&	arg_vif_name,
	const IPv6&	arg_source_addr,
	const IPv6&	arg_group_addr,
	const bool&	arg_rpt_bit,
	const uint32_t&	arg_metric_preference,
	const uint32_t&	arg_metric,
	Pim01SendTestAssert6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_assert6(
        arg_vif_name,
        arg_source_addr,
        arg_group_addr,
        arg_rpt_bit,
        arg_metric_preference,
        arg_metric);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_assert6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_assert6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestAssert6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_assert6, pxa_outputs);
	async_pim_0_1_send_test_assert6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "source_addr").ipv6(),
	    xa_inputs.get(2, "group_addr").ipv6(),
	    xa_inputs.get(3, "rpt_bit").boolean(),
	    xa_inputs.get(4, "metric_preference").uint32(),
	    xa_inputs.get(5, "metric").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_assert6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "source_addr").ipv6(),
	    xa_inputs.get(2, "group_addr").ipv6(),
	    xa_inputs.get(3, "rpt_bit").boolean(),
	    xa_inputs.get(4, "metric_preference").uint32(),
	    xa_inputs.get(5, "metric").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_assert6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_bsr_zone4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_bsr_zone4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_bsr_zone4(
	const IPv4Net&	arg_zone_id_scope_zone_prefix,
	const bool&	arg_zone_id_is_scope_zone,
	const IPv4&	arg_bsr_addr,
	const uint32_t&	arg_bsr_priority,
	const uint32_t&	arg_hash_mask_len,
	const uint32_t&	arg_fragment_tag,
	Pim01AddTestBsrZone4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_bsr_zone4(
        arg_zone_id_scope_zone_prefix,
        arg_zone_id_is_scope_zone,
        arg_bsr_addr,
        arg_bsr_priority,
        arg_hash_mask_len,
        arg_fragment_tag);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_bsr_zone4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_bsr_zone4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestBsrZone4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_bsr_zone4, pxa_outputs);
	async_pim_0_1_add_test_bsr_zone4(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv4net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "bsr_addr").ipv4(),
	    xa_inputs.get(3, "bsr_priority").uint32(),
	    xa_inputs.get(4, "hash_mask_len").uint32(),
	    xa_inputs.get(5, "fragment_tag").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_bsr_zone4(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv4net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "bsr_addr").ipv4(),
	    xa_inputs.get(3, "bsr_priority").uint32(),
	    xa_inputs.get(4, "hash_mask_len").uint32(),
	    xa_inputs.get(5, "fragment_tag").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_bsr_zone4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_bsr_zone6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_bsr_zone6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_bsr_zone6(
	const IPv6Net&	arg_zone_id_scope_zone_prefix,
	const bool&	arg_zone_id_is_scope_zone,
	const IPv6&	arg_bsr_addr,
	const uint32_t&	arg_bsr_priority,
	const uint32_t&	arg_hash_mask_len,
	const uint32_t&	arg_fragment_tag,
	Pim01AddTestBsrZone6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_bsr_zone6(
        arg_zone_id_scope_zone_prefix,
        arg_zone_id_is_scope_zone,
        arg_bsr_addr,
        arg_bsr_priority,
        arg_hash_mask_len,
        arg_fragment_tag);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_bsr_zone6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_bsr_zone6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestBsrZone6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_bsr_zone6, pxa_outputs);
	async_pim_0_1_add_test_bsr_zone6(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv6net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "bsr_addr").ipv6(),
	    xa_inputs.get(3, "bsr_priority").uint32(),
	    xa_inputs.get(4, "hash_mask_len").uint32(),
	    xa_inputs.get(5, "fragment_tag").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_bsr_zone6(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv6net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "bsr_addr").ipv6(),
	    xa_inputs.get(3, "bsr_priority").uint32(),
	    xa_inputs.get(4, "hash_mask_len").uint32(),
	    xa_inputs.get(5, "fragment_tag").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_bsr_zone6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_bsr_group_prefix6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_bsr_group_prefix6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_bsr_group_prefix6(
	const IPv6Net&	arg_zone_id_scope_zone_prefix,
	const bool&	arg_zone_id_is_scope_zone,
	const IPv6Net&	arg_group_prefix,
	const bool&	arg_is_scope_zone,
	const uint32_t&	arg_expected_rp_count,
	Pim01AddTestBsrGroupPrefix6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_bsr_group_prefix6(
        arg_zone_id_scope_zone_prefix,
        arg_zone_id_is_scope_zone,
        arg_group_prefix,
        arg_is_scope_zone,
        arg_expected_rp_count);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_bsr_group_prefix6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_bsr_group_prefix6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestBsrGroupPrefix6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_bsr_group_prefix6, pxa_outputs);
	async_pim_0_1_add_test_bsr_group_prefix6(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv6net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv6net(),
	    xa_inputs.get(3, "is_scope_zone").boolean(),
	    xa_inputs.get(4, "expected_rp_count").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_bsr_group_prefix6(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv6net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv6net(),
	    xa_inputs.get(3, "is_scope_zone").boolean(),
	    xa_inputs.get(4, "expected_rp_count").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_bsr_group_prefix6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_bsr_rp6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_bsr_rp6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_bsr_rp6(
	const IPv6Net&	arg_zone_id_scope_zone_prefix,
	const bool&	arg_zone_id_is_scope_zone,
	const IPv6Net&	arg_group_prefix,
	const IPv6&	arg_rp_addr,
	const uint32_t&	arg_rp_priority,
	const uint32_t&	arg_rp_holdtime,
	Pim01AddTestBsrRp6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_bsr_rp6(
        arg_zone_id_scope_zone_prefix,
        arg_zone_id_is_scope_zone,
        arg_group_prefix,
        arg_rp_addr,
        arg_rp_priority,
        arg_rp_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_bsr_rp6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_bsr_rp6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestBsrRp6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_bsr_rp6, pxa_outputs);
	async_pim_0_1_add_test_bsr_rp6(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv6net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv6net(),
	    xa_inputs.get(3, "rp_addr").ipv6(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_bsr_rp6(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv6net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv6net(),
	    xa_inputs.get(3, "rp_addr").ipv6(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_bsr_rp6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_bootstrap_by_dest6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_bootstrap_by_dest6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_bootstrap_by_dest6(
	const string&	arg_vif_name,
	const IPv6&	arg_dest_addr,
	Pim01SendTestBootstrapByDest6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_bootstrap_by_dest6(
        arg_vif_name,
        arg_dest_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_bootstrap_by_dest6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_bootstrap_by_dest6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestBootstrapByDest6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_bootstrap_by_dest6, pxa_outputs);
	async_pim_0_1_send_test_bootstrap_by_dest6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "dest_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_bootstrap_by_dest6(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "dest_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_bootstrap_by_dest6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_bsr_group_prefix4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_bsr_group_prefix4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_bsr_group_prefix4(
	const IPv4Net&	arg_zone_id_scope_zone_prefix,
	const bool&	arg_zone_id_is_scope_zone,
	const IPv4Net&	arg_group_prefix,
	const bool&	arg_is_scope_zone,
	const uint32_t&	arg_expected_rp_count,
	Pim01AddTestBsrGroupPrefix4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_bsr_group_prefix4(
        arg_zone_id_scope_zone_prefix,
        arg_zone_id_is_scope_zone,
        arg_group_prefix,
        arg_is_scope_zone,
        arg_expected_rp_count);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_bsr_group_prefix4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_bsr_group_prefix4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestBsrGroupPrefix4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_bsr_group_prefix4, pxa_outputs);
	async_pim_0_1_add_test_bsr_group_prefix4(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv4net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv4net(),
	    xa_inputs.get(3, "is_scope_zone").boolean(),
	    xa_inputs.get(4, "expected_rp_count").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_bsr_group_prefix4(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv4net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv4net(),
	    xa_inputs.get(3, "is_scope_zone").boolean(),
	    xa_inputs.get(4, "expected_rp_count").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_bsr_group_prefix4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_add_test_bsr_rp4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/add_test_bsr_rp4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_add_test_bsr_rp4(
	const IPv4Net&	arg_zone_id_scope_zone_prefix,
	const bool&	arg_zone_id_is_scope_zone,
	const IPv4Net&	arg_group_prefix,
	const IPv4&	arg_rp_addr,
	const uint32_t&	arg_rp_priority,
	const uint32_t&	arg_rp_holdtime,
	Pim01AddTestBsrRp4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_add_test_bsr_rp4(
        arg_zone_id_scope_zone_prefix,
        arg_zone_id_is_scope_zone,
        arg_group_prefix,
        arg_rp_addr,
        arg_rp_priority,
        arg_rp_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_add_test_bsr_rp4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/add_test_bsr_rp4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01AddTestBsrRp4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_add_test_bsr_rp4, pxa_outputs);
	async_pim_0_1_add_test_bsr_rp4(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv4net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv4net(),
	    xa_inputs.get(3, "rp_addr").ipv4(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_add_test_bsr_rp4(
	    xa_inputs.get(0, "zone_id_scope_zone_prefix").ipv4net(),
	    xa_inputs.get(1, "zone_id_is_scope_zone").boolean(),
	    xa_inputs.get(2, "group_prefix").ipv4net(),
	    xa_inputs.get(3, "rp_addr").ipv4(),
	    xa_inputs.get(4, "rp_priority").uint32(),
	    xa_inputs.get(5, "rp_holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/add_test_bsr_rp4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_bootstrap
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_bootstrap", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_bootstrap(
	const string&	arg_vif_name,
	Pim01SendTestBootstrapCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_bootstrap(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_bootstrap(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_bootstrap");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestBootstrapRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_bootstrap, pxa_outputs);
	async_pim_0_1_send_test_bootstrap(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_bootstrap(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_bootstrap", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_bootstrap_by_dest4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_bootstrap_by_dest4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_bootstrap_by_dest4(
	const string&	arg_vif_name,
	const IPv4&	arg_dest_addr,
	Pim01SendTestBootstrapByDest4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_bootstrap_by_dest4(
        arg_vif_name,
        arg_dest_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_bootstrap_by_dest4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_bootstrap_by_dest4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestBootstrapByDest4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_bootstrap_by_dest4, pxa_outputs);
	async_pim_0_1_send_test_bootstrap_by_dest4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "dest_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_bootstrap_by_dest4(
	    xa_inputs.get(0, "vif_name").text(),
	    xa_inputs.get(1, "dest_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_bootstrap_by_dest4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_send_test_cand_rp_adv
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/send_test_cand_rp_adv", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_send_test_cand_rp_adv(
	Pim01SendTestCandRpAdvCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_send_test_cand_rp_adv();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_send_test_cand_rp_adv(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/send_test_cand_rp_adv");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01SendTestCandRpAdvRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_send_test_cand_rp_adv, pxa_outputs);
	async_pim_0_1_send_test_cand_rp_adv( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_send_test_cand_rp_adv();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/send_test_cand_rp_adv", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_neighbors4
    (const XrlCmdError &e,
     const uint32_t* rarg_nbrs_number,
     const XrlAtomList* rarg_vifs,
     const XrlAtomList* rarg_addresses,
     const XrlAtomList* rarg_pim_versions,
     const XrlAtomList* rarg_dr_priorities,
     const XrlAtomList* rarg_holdtimes,
     const XrlAtomList* rarg_timeouts,
     const XrlAtomList* rarg_uptimes,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_neighbors4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("nbrs_number", *rarg_nbrs_number);
	    out.add("vifs", *rarg_vifs);
	    out.add("addresses", *rarg_addresses);
	    out.add("pim_versions", *rarg_pim_versions);
	    out.add("dr_priorities", *rarg_dr_priorities);
	    out.add("holdtimes", *rarg_holdtimes);
	    out.add("timeouts", *rarg_timeouts);
	    out.add("uptimes", *rarg_uptimes);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_neighbors4(
	Pim01PimstatNeighbors4CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_nbrs_number;
    XrlAtomList rarg_vifs;
    XrlAtomList rarg_addresses;
    XrlAtomList rarg_pim_versions;
    XrlAtomList rarg_dr_priorities;
    XrlAtomList rarg_holdtimes;
    XrlAtomList rarg_timeouts;
    XrlAtomList rarg_uptimes;
    XrlCmdError e = pim_0_1_pimstat_neighbors4(
        rarg_nbrs_number,
        rarg_vifs,
        rarg_addresses,
        rarg_pim_versions,
        rarg_dr_priorities,
        rarg_holdtimes,
        rarg_timeouts,
        rarg_uptimes);
    return c_b->dispatch(e,
        &rarg_nbrs_number,
        &rarg_vifs,
        &rarg_addresses,
        &rarg_pim_versions,
        &rarg_dr_priorities,
        &rarg_holdtimes,
        &rarg_timeouts,
        &rarg_uptimes);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_neighbors4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_neighbors4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNeighbors4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_neighbors4, pxa_outputs);
	async_pim_0_1_pimstat_neighbors4( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_nbrs_number;
    XrlAtomList r_vifs;
    XrlAtomList r_addresses;
    XrlAtomList r_pim_versions;
    XrlAtomList r_dr_priorities;
    XrlAtomList r_holdtimes;
    XrlAtomList r_timeouts;
    XrlAtomList r_uptimes;
    try {
	XrlCmdError e = pim_0_1_pimstat_neighbors4(
	    r_nbrs_number,
	    r_vifs,
	    r_addresses,
	    r_pim_versions,
	    r_dr_priorities,
	    r_holdtimes,
	    r_timeouts,
	    r_uptimes);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_neighbors4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nbrs_number", r_nbrs_number);
	pxa_outputs->add("vifs", r_vifs);
	pxa_outputs->add("addresses", r_addresses);
	pxa_outputs->add("pim_versions", r_pim_versions);
	pxa_outputs->add("dr_priorities", r_dr_priorities);
	pxa_outputs->add("holdtimes", r_holdtimes);
	pxa_outputs->add("timeouts", r_timeouts);
	pxa_outputs->add("uptimes", r_uptimes);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_neighbors6
    (const XrlCmdError &e,
     const uint32_t* rarg_nbrs_number,
     const XrlAtomList* rarg_vifs,
     const XrlAtomList* rarg_addresses,
     const XrlAtomList* rarg_pim_versions,
     const XrlAtomList* rarg_dr_priorities,
     const XrlAtomList* rarg_holdtimes,
     const XrlAtomList* rarg_timeouts,
     const XrlAtomList* rarg_uptimes,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_neighbors6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("nbrs_number", *rarg_nbrs_number);
	    out.add("vifs", *rarg_vifs);
	    out.add("addresses", *rarg_addresses);
	    out.add("pim_versions", *rarg_pim_versions);
	    out.add("dr_priorities", *rarg_dr_priorities);
	    out.add("holdtimes", *rarg_holdtimes);
	    out.add("timeouts", *rarg_timeouts);
	    out.add("uptimes", *rarg_uptimes);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_neighbors6(
	Pim01PimstatNeighbors6CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_nbrs_number;
    XrlAtomList rarg_vifs;
    XrlAtomList rarg_addresses;
    XrlAtomList rarg_pim_versions;
    XrlAtomList rarg_dr_priorities;
    XrlAtomList rarg_holdtimes;
    XrlAtomList rarg_timeouts;
    XrlAtomList rarg_uptimes;
    XrlCmdError e = pim_0_1_pimstat_neighbors6(
        rarg_nbrs_number,
        rarg_vifs,
        rarg_addresses,
        rarg_pim_versions,
        rarg_dr_priorities,
        rarg_holdtimes,
        rarg_timeouts,
        rarg_uptimes);
    return c_b->dispatch(e,
        &rarg_nbrs_number,
        &rarg_vifs,
        &rarg_addresses,
        &rarg_pim_versions,
        &rarg_dr_priorities,
        &rarg_holdtimes,
        &rarg_timeouts,
        &rarg_uptimes);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_neighbors6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_neighbors6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNeighbors6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_neighbors6, pxa_outputs);
	async_pim_0_1_pimstat_neighbors6( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_nbrs_number;
    XrlAtomList r_vifs;
    XrlAtomList r_addresses;
    XrlAtomList r_pim_versions;
    XrlAtomList r_dr_priorities;
    XrlAtomList r_holdtimes;
    XrlAtomList r_timeouts;
    XrlAtomList r_uptimes;
    try {
	XrlCmdError e = pim_0_1_pimstat_neighbors6(
	    r_nbrs_number,
	    r_vifs,
	    r_addresses,
	    r_pim_versions,
	    r_dr_priorities,
	    r_holdtimes,
	    r_timeouts,
	    r_uptimes);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_neighbors6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nbrs_number", r_nbrs_number);
	pxa_outputs->add("vifs", r_vifs);
	pxa_outputs->add("addresses", r_addresses);
	pxa_outputs->add("pim_versions", r_pim_versions);
	pxa_outputs->add("dr_priorities", r_dr_priorities);
	pxa_outputs->add("holdtimes", r_holdtimes);
	pxa_outputs->add("timeouts", r_timeouts);
	pxa_outputs->add("uptimes", r_uptimes);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_interface4
    (const XrlCmdError &e,
     const uint32_t* rarg_pim_version,
     const bool* rarg_is_dr,
     const uint32_t* rarg_dr_priority,
     const IPv4* rarg_dr_address,
     const uint32_t* rarg_pim_nbrs_number,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_interface4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("pim_version", *rarg_pim_version);
	    out.add("is_dr", *rarg_is_dr);
	    out.add("dr_priority", *rarg_dr_priority);
	    out.add("dr_address", *rarg_dr_address);
	    out.add("pim_nbrs_number", *rarg_pim_nbrs_number);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_interface4(
	const string&	arg_vif_name,
	Pim01PimstatInterface4CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_pim_version;
    bool rarg_is_dr;
    uint32_t rarg_dr_priority;
    IPv4 rarg_dr_address;
    uint32_t rarg_pim_nbrs_number;
    XrlCmdError e = pim_0_1_pimstat_interface4(
        arg_vif_name,
        rarg_pim_version,
        rarg_is_dr,
        rarg_dr_priority,
        rarg_dr_address,
        rarg_pim_nbrs_number);
    return c_b->dispatch(e,
        &rarg_pim_version,
        &rarg_is_dr,
        &rarg_dr_priority,
        &rarg_dr_address,
        &rarg_pim_nbrs_number);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_interface4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_interface4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatInterface4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_interface4, pxa_outputs);
	async_pim_0_1_pimstat_interface4(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_pim_version;
    bool r_is_dr;
    uint32_t r_dr_priority;
    IPv4 r_dr_address;
    uint32_t r_pim_nbrs_number;
    try {
	XrlCmdError e = pim_0_1_pimstat_interface4(
	    xa_inputs.get(0, "vif_name").text(),
	    r_pim_version,
	    r_is_dr,
	    r_dr_priority,
	    r_dr_address,
	    r_pim_nbrs_number);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_interface4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("pim_version", r_pim_version);
	pxa_outputs->add("is_dr", r_is_dr);
	pxa_outputs->add("dr_priority", r_dr_priority);
	pxa_outputs->add("dr_address", r_dr_address);
	pxa_outputs->add("pim_nbrs_number", r_pim_nbrs_number);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_interface6
    (const XrlCmdError &e,
     const uint32_t* rarg_pim_version,
     const bool* rarg_is_dr,
     const uint32_t* rarg_dr_priority,
     const IPv6* rarg_dr_address,
     const uint32_t* rarg_pim_nbrs_number,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_interface6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("pim_version", *rarg_pim_version);
	    out.add("is_dr", *rarg_is_dr);
	    out.add("dr_priority", *rarg_dr_priority);
	    out.add("dr_address", *rarg_dr_address);
	    out.add("pim_nbrs_number", *rarg_pim_nbrs_number);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_interface6(
	const string&	arg_vif_name,
	Pim01PimstatInterface6CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_pim_version;
    bool rarg_is_dr;
    uint32_t rarg_dr_priority;
    IPv6 rarg_dr_address;
    uint32_t rarg_pim_nbrs_number;
    XrlCmdError e = pim_0_1_pimstat_interface6(
        arg_vif_name,
        rarg_pim_version,
        rarg_is_dr,
        rarg_dr_priority,
        rarg_dr_address,
        rarg_pim_nbrs_number);
    return c_b->dispatch(e,
        &rarg_pim_version,
        &rarg_is_dr,
        &rarg_dr_priority,
        &rarg_dr_address,
        &rarg_pim_nbrs_number);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_interface6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_interface6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatInterface6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_interface6, pxa_outputs);
	async_pim_0_1_pimstat_interface6(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_pim_version;
    bool r_is_dr;
    uint32_t r_dr_priority;
    IPv6 r_dr_address;
    uint32_t r_pim_nbrs_number;
    try {
	XrlCmdError e = pim_0_1_pimstat_interface6(
	    xa_inputs.get(0, "vif_name").text(),
	    r_pim_version,
	    r_is_dr,
	    r_dr_priority,
	    r_dr_address,
	    r_pim_nbrs_number);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_interface6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("pim_version", r_pim_version);
	pxa_outputs->add("is_dr", r_is_dr);
	pxa_outputs->add("dr_priority", r_dr_priority);
	pxa_outputs->add("dr_address", r_dr_address);
	pxa_outputs->add("pim_nbrs_number", r_pim_nbrs_number);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rps4
    (const XrlCmdError &e,
     const uint32_t* rarg_rps_number,
     const XrlAtomList* rarg_addresses,
     const XrlAtomList* rarg_types,
     const XrlAtomList* rarg_priorities,
     const XrlAtomList* rarg_holdtimes,
     const XrlAtomList* rarg_timeouts,
     const XrlAtomList* rarg_group_prefixes,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rps4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("rps_number", *rarg_rps_number);
	    out.add("addresses", *rarg_addresses);
	    out.add("types", *rarg_types);
	    out.add("priorities", *rarg_priorities);
	    out.add("holdtimes", *rarg_holdtimes);
	    out.add("timeouts", *rarg_timeouts);
	    out.add("group_prefixes", *rarg_group_prefixes);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rps4(
	Pim01PimstatRps4CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_rps_number;
    XrlAtomList rarg_addresses;
    XrlAtomList rarg_types;
    XrlAtomList rarg_priorities;
    XrlAtomList rarg_holdtimes;
    XrlAtomList rarg_timeouts;
    XrlAtomList rarg_group_prefixes;
    XrlCmdError e = pim_0_1_pimstat_rps4(
        rarg_rps_number,
        rarg_addresses,
        rarg_types,
        rarg_priorities,
        rarg_holdtimes,
        rarg_timeouts,
        rarg_group_prefixes);
    return c_b->dispatch(e,
        &rarg_rps_number,
        &rarg_addresses,
        &rarg_types,
        &rarg_priorities,
        &rarg_holdtimes,
        &rarg_timeouts,
        &rarg_group_prefixes);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rps4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rps4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRps4RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rps4, pxa_outputs);
	async_pim_0_1_pimstat_rps4( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_rps_number;
    XrlAtomList r_addresses;
    XrlAtomList r_types;
    XrlAtomList r_priorities;
    XrlAtomList r_holdtimes;
    XrlAtomList r_timeouts;
    XrlAtomList r_group_prefixes;
    try {
	XrlCmdError e = pim_0_1_pimstat_rps4(
	    r_rps_number,
	    r_addresses,
	    r_types,
	    r_priorities,
	    r_holdtimes,
	    r_timeouts,
	    r_group_prefixes);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rps4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rps_number", r_rps_number);
	pxa_outputs->add("addresses", r_addresses);
	pxa_outputs->add("types", r_types);
	pxa_outputs->add("priorities", r_priorities);
	pxa_outputs->add("holdtimes", r_holdtimes);
	pxa_outputs->add("timeouts", r_timeouts);
	pxa_outputs->add("group_prefixes", r_group_prefixes);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rps6
    (const XrlCmdError &e,
     const uint32_t* rarg_rps_number,
     const XrlAtomList* rarg_addresses,
     const XrlAtomList* rarg_types,
     const XrlAtomList* rarg_priorities,
     const XrlAtomList* rarg_holdtimes,
     const XrlAtomList* rarg_timeouts,
     const XrlAtomList* rarg_group_prefixes,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rps6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("rps_number", *rarg_rps_number);
	    out.add("addresses", *rarg_addresses);
	    out.add("types", *rarg_types);
	    out.add("priorities", *rarg_priorities);
	    out.add("holdtimes", *rarg_holdtimes);
	    out.add("timeouts", *rarg_timeouts);
	    out.add("group_prefixes", *rarg_group_prefixes);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rps6(
	Pim01PimstatRps6CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_rps_number;
    XrlAtomList rarg_addresses;
    XrlAtomList rarg_types;
    XrlAtomList rarg_priorities;
    XrlAtomList rarg_holdtimes;
    XrlAtomList rarg_timeouts;
    XrlAtomList rarg_group_prefixes;
    XrlCmdError e = pim_0_1_pimstat_rps6(
        rarg_rps_number,
        rarg_addresses,
        rarg_types,
        rarg_priorities,
        rarg_holdtimes,
        rarg_timeouts,
        rarg_group_prefixes);
    return c_b->dispatch(e,
        &rarg_rps_number,
        &rarg_addresses,
        &rarg_types,
        &rarg_priorities,
        &rarg_holdtimes,
        &rarg_timeouts,
        &rarg_group_prefixes);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rps6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rps6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRps6RF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rps6, pxa_outputs);
	async_pim_0_1_pimstat_rps6( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_rps_number;
    XrlAtomList r_addresses;
    XrlAtomList r_types;
    XrlAtomList r_priorities;
    XrlAtomList r_holdtimes;
    XrlAtomList r_timeouts;
    XrlAtomList r_group_prefixes;
    try {
	XrlCmdError e = pim_0_1_pimstat_rps6(
	    r_rps_number,
	    r_addresses,
	    r_types,
	    r_priorities,
	    r_holdtimes,
	    r_timeouts,
	    r_group_prefixes);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rps6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rps_number", r_rps_number);
	pxa_outputs->add("addresses", r_addresses);
	pxa_outputs->add("types", r_types);
	pxa_outputs->add("priorities", r_priorities);
	pxa_outputs->add("holdtimes", r_holdtimes);
	pxa_outputs->add("timeouts", r_timeouts);
	pxa_outputs->add("group_prefixes", r_group_prefixes);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_clear_pim_statistics
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/clear_pim_statistics", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_clear_pim_statistics(
	Pim01ClearPimStatisticsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_clear_pim_statistics();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_clear_pim_statistics(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/clear_pim_statistics");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ClearPimStatisticsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_clear_pim_statistics, pxa_outputs);
	async_pim_0_1_clear_pim_statistics( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_clear_pim_statistics();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/clear_pim_statistics", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_clear_pim_statistics_per_vif
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/clear_pim_statistics_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_clear_pim_statistics_per_vif(
	const string&	arg_vif_name,
	Pim01ClearPimStatisticsPerVifCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = pim_0_1_clear_pim_statistics_per_vif(
        arg_vif_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_clear_pim_statistics_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/clear_pim_statistics_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01ClearPimStatisticsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_clear_pim_statistics_per_vif, pxa_outputs);
	async_pim_0_1_clear_pim_statistics_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = pim_0_1_clear_pim_statistics_per_vif(
	    xa_inputs.get(0, "vif_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/clear_pim_statistics_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_hello_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_hello_messages_received(
	Pim01PimstatHelloMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_hello_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_hello_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatHelloMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_hello_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_hello_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_hello_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_hello_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_hello_messages_sent(
	Pim01PimstatHelloMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_hello_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_hello_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatHelloMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_hello_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_hello_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_hello_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_hello_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_hello_messages_rx_errors(
	Pim01PimstatHelloMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_hello_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_hello_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatHelloMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_hello_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_hello_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_hello_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_messages_received(
	Pim01PimstatRegisterMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_register_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_messages_sent(
	Pim01PimstatRegisterMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_register_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_messages_rx_errors(
	Pim01PimstatRegisterMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_register_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_stop_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_stop_messages_received(
	Pim01PimstatRegisterStopMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_stop_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_stop_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterStopMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_register_stop_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_stop_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_stop_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_stop_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_stop_messages_sent(
	Pim01PimstatRegisterStopMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_stop_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_stop_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterStopMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_register_stop_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_stop_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_stop_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_stop_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_stop_messages_rx_errors(
	Pim01PimstatRegisterStopMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_stop_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_stop_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterStopMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_register_stop_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_stop_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_stop_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_join_prune_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_join_prune_messages_received(
	Pim01PimstatJoinPruneMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_join_prune_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_join_prune_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatJoinPruneMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_join_prune_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_join_prune_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_join_prune_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_join_prune_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_join_prune_messages_sent(
	Pim01PimstatJoinPruneMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_join_prune_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_join_prune_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatJoinPruneMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_join_prune_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_join_prune_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_join_prune_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_join_prune_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_join_prune_messages_rx_errors(
	Pim01PimstatJoinPruneMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_join_prune_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_join_prune_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatJoinPruneMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_join_prune_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_join_prune_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_join_prune_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bootstrap_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bootstrap_messages_received(
	Pim01PimstatBootstrapMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bootstrap_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBootstrapMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_bootstrap_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bootstrap_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bootstrap_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bootstrap_messages_sent(
	Pim01PimstatBootstrapMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bootstrap_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBootstrapMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_bootstrap_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bootstrap_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bootstrap_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bootstrap_messages_rx_errors(
	Pim01PimstatBootstrapMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bootstrap_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBootstrapMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_bootstrap_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bootstrap_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_assert_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_assert_messages_received(
	Pim01PimstatAssertMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_assert_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_assert_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatAssertMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_assert_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_assert_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_assert_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_assert_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_assert_messages_sent(
	Pim01PimstatAssertMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_assert_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_assert_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatAssertMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_assert_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_assert_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_assert_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_assert_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_assert_messages_rx_errors(
	Pim01PimstatAssertMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_assert_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_assert_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatAssertMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_assert_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_assert_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_assert_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_messages_received(
	Pim01PimstatGraftMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_graft_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_messages_sent(
	Pim01PimstatGraftMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_graft_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_messages_rx_errors(
	Pim01PimstatGraftMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_graft_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_ack_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_ack_messages_received(
	Pim01PimstatGraftAckMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_ack_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftAckMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_graft_ack_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_ack_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_ack_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_ack_messages_sent(
	Pim01PimstatGraftAckMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_ack_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftAckMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_graft_ack_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_ack_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_ack_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_ack_messages_rx_errors(
	Pim01PimstatGraftAckMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_ack_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftAckMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_graft_ack_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_ack_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_received
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_candidate_rp_messages_received", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_candidate_rp_messages_received(
	Pim01PimstatCandidateRpMessagesReceivedCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_received(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_received(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_candidate_rp_messages_received");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatCandidateRpMessagesReceivedRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_received, pxa_outputs);
	async_pim_0_1_pimstat_candidate_rp_messages_received( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_received(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_candidate_rp_messages_received", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_sent
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_candidate_rp_messages_sent", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_candidate_rp_messages_sent(
	Pim01PimstatCandidateRpMessagesSentCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_sent(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_sent(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_candidate_rp_messages_sent");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatCandidateRpMessagesSentRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_sent, pxa_outputs);
	async_pim_0_1_pimstat_candidate_rp_messages_sent( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_sent(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_candidate_rp_messages_sent", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_rx_errors
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_candidate_rp_messages_rx_errors", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_candidate_rp_messages_rx_errors(
	Pim01PimstatCandidateRpMessagesRxErrorsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_rx_errors(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_rx_errors(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_candidate_rp_messages_rx_errors");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatCandidateRpMessagesRxErrorsRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_rx_errors, pxa_outputs);
	async_pim_0_1_pimstat_candidate_rp_messages_rx_errors( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_rx_errors(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_candidate_rp_messages_rx_errors", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_type_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_unknown_type_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_unknown_type_messages(
	Pim01PimstatUnknownTypeMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_unknown_type_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_type_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_unknown_type_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatUnknownTypeMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_type_messages, pxa_outputs);
	async_pim_0_1_pimstat_unknown_type_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_unknown_type_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_unknown_type_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_version_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_unknown_version_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_unknown_version_messages(
	Pim01PimstatUnknownVersionMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_unknown_version_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_version_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_unknown_version_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatUnknownVersionMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_version_messages, pxa_outputs);
	async_pim_0_1_pimstat_unknown_version_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_unknown_version_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_unknown_version_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_neighbor_unknown_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_neighbor_unknown_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_neighbor_unknown_messages(
	Pim01PimstatNeighborUnknownMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_neighbor_unknown_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_neighbor_unknown_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_neighbor_unknown_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNeighborUnknownMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_neighbor_unknown_messages, pxa_outputs);
	async_pim_0_1_pimstat_neighbor_unknown_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_neighbor_unknown_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_neighbor_unknown_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bad_length_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bad_length_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bad_length_messages(
	Pim01PimstatBadLengthMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bad_length_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bad_length_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bad_length_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBadLengthMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bad_length_messages, pxa_outputs);
	async_pim_0_1_pimstat_bad_length_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bad_length_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bad_length_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bad_checksum_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bad_checksum_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bad_checksum_messages(
	Pim01PimstatBadChecksumMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bad_checksum_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bad_checksum_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bad_checksum_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBadChecksumMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bad_checksum_messages, pxa_outputs);
	async_pim_0_1_pimstat_bad_checksum_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bad_checksum_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bad_checksum_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bad_receive_interface_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bad_receive_interface_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bad_receive_interface_messages(
	Pim01PimstatBadReceiveInterfaceMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bad_receive_interface_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bad_receive_interface_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bad_receive_interface_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBadReceiveInterfaceMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bad_receive_interface_messages, pxa_outputs);
	async_pim_0_1_pimstat_bad_receive_interface_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bad_receive_interface_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bad_receive_interface_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_interface_disabled_messages
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_interface_disabled_messages", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_interface_disabled_messages(
	Pim01PimstatRxInterfaceDisabledMessagesCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_interface_disabled_messages(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_interface_disabled_messages(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_interface_disabled_messages");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxInterfaceDisabledMessagesRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_interface_disabled_messages, pxa_outputs);
	async_pim_0_1_pimstat_rx_interface_disabled_messages( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_interface_disabled_messages(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_interface_disabled_messages", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_register_not_rp
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_register_not_rp", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_register_not_rp(
	Pim01PimstatRxRegisterNotRpCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_register_not_rp(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_register_not_rp(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_register_not_rp");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxRegisterNotRpRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_register_not_rp, pxa_outputs);
	async_pim_0_1_pimstat_rx_register_not_rp( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_register_not_rp(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_register_not_rp", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rp_filtered_source
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rp_filtered_source", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rp_filtered_source(
	Pim01PimstatRpFilteredSourceCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rp_filtered_source(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rp_filtered_source(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rp_filtered_source");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRpFilteredSourceRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rp_filtered_source, pxa_outputs);
	async_pim_0_1_pimstat_rp_filtered_source( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rp_filtered_source(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rp_filtered_source", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_register_stop
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_unknown_register_stop", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_unknown_register_stop(
	Pim01PimstatUnknownRegisterStopCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_unknown_register_stop(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_register_stop(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_unknown_register_stop");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatUnknownRegisterStopRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_register_stop, pxa_outputs);
	async_pim_0_1_pimstat_unknown_register_stop( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_unknown_register_stop(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_unknown_register_stop", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_prune_no_state
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_prune_no_state", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_prune_no_state(
	Pim01PimstatRxJoinPruneNoStateCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_prune_no_state(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_prune_no_state(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_prune_no_state");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinPruneNoStateRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_prune_no_state, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_prune_no_state( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_prune_no_state(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_prune_no_state", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_graft_ack_no_state
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_graft_graft_ack_no_state", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_graft_graft_ack_no_state(
	Pim01PimstatRxGraftGraftAckNoStateCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_graft_graft_ack_no_state(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_graft_ack_no_state(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_graft_graft_ack_no_state");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxGraftGraftAckNoStateRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_graft_ack_no_state, pxa_outputs);
	async_pim_0_1_pimstat_rx_graft_graft_ack_no_state( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_graft_graft_ack_no_state(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_graft_graft_ack_no_state", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_on_upstream_interface
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_graft_on_upstream_interface", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_graft_on_upstream_interface(
	Pim01PimstatRxGraftOnUpstreamInterfaceCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_graft_on_upstream_interface(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_on_upstream_interface(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_graft_on_upstream_interface");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxGraftOnUpstreamInterfaceRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_on_upstream_interface, pxa_outputs);
	async_pim_0_1_pimstat_rx_graft_on_upstream_interface( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_graft_on_upstream_interface(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_graft_on_upstream_interface", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_candidate_rp_not_bsr
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_candidate_rp_not_bsr", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_candidate_rp_not_bsr(
	Pim01PimstatRxCandidateRpNotBsrCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_candidate_rp_not_bsr(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_candidate_rp_not_bsr(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_candidate_rp_not_bsr");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxCandidateRpNotBsrRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_candidate_rp_not_bsr, pxa_outputs);
	async_pim_0_1_pimstat_rx_candidate_rp_not_bsr( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_candidate_rp_not_bsr(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_candidate_rp_not_bsr", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_when_bsr
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_bsr_when_bsr", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_bsr_when_bsr(
	Pim01PimstatRxBsrWhenBsrCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_bsr_when_bsr(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_when_bsr(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_bsr_when_bsr");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxBsrWhenBsrRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_when_bsr, pxa_outputs);
	async_pim_0_1_pimstat_rx_bsr_when_bsr( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_bsr_when_bsr(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_bsr_when_bsr", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_not_rpf_interface
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_bsr_not_rpf_interface", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_bsr_not_rpf_interface(
	Pim01PimstatRxBsrNotRpfInterfaceCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_bsr_not_rpf_interface(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_not_rpf_interface(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_bsr_not_rpf_interface");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxBsrNotRpfInterfaceRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_not_rpf_interface, pxa_outputs);
	async_pim_0_1_pimstat_rx_bsr_not_rpf_interface( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_bsr_not_rpf_interface(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_bsr_not_rpf_interface", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_unknown_hello_option
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_unknown_hello_option", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_unknown_hello_option(
	Pim01PimstatRxUnknownHelloOptionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_unknown_hello_option(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_unknown_hello_option(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_unknown_hello_option");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxUnknownHelloOptionRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_unknown_hello_option, pxa_outputs);
	async_pim_0_1_pimstat_rx_unknown_hello_option( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_unknown_hello_option(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_unknown_hello_option", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_data_no_state
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_data_no_state", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_data_no_state(
	Pim01PimstatRxDataNoStateCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_data_no_state(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_data_no_state(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_data_no_state");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxDataNoStateRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_data_no_state, pxa_outputs);
	async_pim_0_1_pimstat_rx_data_no_state( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_data_no_state(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_data_no_state", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_rp_no_state
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_rp_no_state", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_rp_no_state(
	Pim01PimstatRxRpNoStateCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_rp_no_state(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_rp_no_state(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_rp_no_state");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxRpNoStateRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_rp_no_state, pxa_outputs);
	async_pim_0_1_pimstat_rx_rp_no_state( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_rp_no_state(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_rp_no_state", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_aggregate
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_aggregate", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_aggregate(
	Pim01PimstatRxAggregateCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_aggregate(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_aggregate(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_aggregate");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxAggregateRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_aggregate, pxa_outputs);
	async_pim_0_1_pimstat_rx_aggregate( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_aggregate(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_aggregate", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_malformed_packet
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_malformed_packet", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_malformed_packet(
	Pim01PimstatRxMalformedPacketCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_malformed_packet(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_malformed_packet(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_malformed_packet");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxMalformedPacketRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_malformed_packet, pxa_outputs);
	async_pim_0_1_pimstat_rx_malformed_packet( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_malformed_packet(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_malformed_packet", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_no_rp
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_no_rp", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_no_rp(
	Pim01PimstatNoRpCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_no_rp(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_no_rp(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_no_rp");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNoRpRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_no_rp, pxa_outputs);
	async_pim_0_1_pimstat_no_rp( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_no_rp(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_no_rp", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_no_route_upstream
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_no_route_upstream", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_no_route_upstream(
	Pim01PimstatNoRouteUpstreamCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_no_route_upstream(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_no_route_upstream(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_no_route_upstream");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNoRouteUpstreamRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_no_route_upstream, pxa_outputs);
	async_pim_0_1_pimstat_no_route_upstream( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_no_route_upstream(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_no_route_upstream", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rp_mismatch
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rp_mismatch", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rp_mismatch(
	Pim01PimstatRpMismatchCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rp_mismatch(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rp_mismatch(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rp_mismatch");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRpMismatchRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rp_mismatch, pxa_outputs);
	async_pim_0_1_pimstat_rp_mismatch( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rp_mismatch(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rp_mismatch", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rpf_neighbor_unknown
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rpf_neighbor_unknown", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rpf_neighbor_unknown(
	Pim01PimstatRpfNeighborUnknownCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rpf_neighbor_unknown(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rpf_neighbor_unknown(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rpf_neighbor_unknown");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRpfNeighborUnknownRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rpf_neighbor_unknown, pxa_outputs);
	async_pim_0_1_pimstat_rpf_neighbor_unknown( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rpf_neighbor_unknown(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rpf_neighbor_unknown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_rp
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_rp", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_rp(
	Pim01PimstatRxJoinRpCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_rp(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_rp(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_rp");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinRpRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_rp, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_rp( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_rp(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_rp", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_rp
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_rp", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_rp(
	Pim01PimstatRxPruneRpCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_rp(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_rp(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_rp");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneRpRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_rp, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_rp( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_rp(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_rp", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_wc
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_wc", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_wc(
	Pim01PimstatRxJoinWcCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_wc(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_wc(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_wc");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinWcRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_wc, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_wc( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_wc(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_wc", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_wc
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_wc", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_wc(
	Pim01PimstatRxPruneWcCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_wc(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_wc(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_wc");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneWcRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_wc, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_wc( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_wc(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_wc", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_sg", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_sg(
	Pim01PimstatRxJoinSgCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_sg(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_sg");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinSgRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_sg( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_sg(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_sg", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_sg", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_sg(
	Pim01PimstatRxPruneSgCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_sg(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_sg");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneSgRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_sg( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_sg(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_sg", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg_rpt
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_sg_rpt", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_sg_rpt(
	Pim01PimstatRxJoinSgRptCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_sg_rpt(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg_rpt(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_sg_rpt");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinSgRptRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg_rpt, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_sg_rpt( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_sg_rpt(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_sg_rpt", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg_rpt
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_sg_rpt", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_sg_rpt(
	Pim01PimstatRxPruneSgRptCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_sg_rpt(
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg_rpt(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_sg_rpt");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneSgRptRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg_rpt, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_sg_rpt( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_sg_rpt(
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_sg_rpt", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_hello_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_hello_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatHelloMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_hello_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_hello_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatHelloMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_hello_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_hello_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_hello_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_hello_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_hello_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatHelloMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_hello_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_hello_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatHelloMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_hello_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_hello_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_hello_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_hello_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_hello_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatHelloMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_hello_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_hello_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_hello_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatHelloMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_hello_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_hello_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_hello_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_hello_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRegisterMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_register_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRegisterMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_register_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRegisterMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_register_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_stop_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_stop_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRegisterStopMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_stop_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_stop_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterStopMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_register_stop_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_stop_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_stop_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_stop_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_stop_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRegisterStopMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_stop_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_stop_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterStopMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_register_stop_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_stop_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_stop_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_register_stop_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRegisterStopMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_register_stop_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRegisterStopMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_register_stop_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_register_stop_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_join_prune_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_join_prune_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatJoinPruneMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_join_prune_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_join_prune_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatJoinPruneMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_join_prune_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_join_prune_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_join_prune_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_join_prune_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_join_prune_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatJoinPruneMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_join_prune_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_join_prune_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatJoinPruneMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_join_prune_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_join_prune_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_join_prune_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_join_prune_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatJoinPruneMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_join_prune_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatJoinPruneMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_join_prune_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_join_prune_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bootstrap_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bootstrap_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatBootstrapMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bootstrap_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBootstrapMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_bootstrap_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bootstrap_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bootstrap_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bootstrap_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatBootstrapMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bootstrap_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBootstrapMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_bootstrap_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bootstrap_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bootstrap_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatBootstrapMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bootstrap_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBootstrapMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bootstrap_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bootstrap_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_assert_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_assert_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatAssertMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_assert_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_assert_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatAssertMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_assert_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_assert_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_assert_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_assert_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_assert_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatAssertMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_assert_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_assert_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatAssertMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_assert_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_assert_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_assert_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_assert_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_assert_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatAssertMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_assert_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_assert_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_assert_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatAssertMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_assert_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_assert_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_assert_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_assert_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatGraftMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_graft_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatGraftMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_graft_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatGraftMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_graft_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_ack_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_ack_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatGraftAckMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_ack_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftAckMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_graft_ack_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_ack_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_ack_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_ack_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatGraftAckMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_ack_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftAckMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_graft_ack_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_ack_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_graft_ack_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatGraftAckMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_graft_ack_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatGraftAckMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_graft_ack_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_graft_ack_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_received_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_candidate_rp_messages_received_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_candidate_rp_messages_received_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatCandidateRpMessagesReceivedPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_received_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_received_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_candidate_rp_messages_received_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatCandidateRpMessagesReceivedPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_received_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_candidate_rp_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_received_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_candidate_rp_messages_received_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_candidate_rp_messages_sent_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatCandidateRpMessagesSentPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_candidate_rp_messages_sent_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatCandidateRpMessagesSentPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_sent_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_candidate_rp_messages_sent_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_candidate_rp_messages_rx_errors_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatCandidateRpMessagesRxErrorsPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_candidate_rp_messages_rx_errors_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatCandidateRpMessagesRxErrorsPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_candidate_rp_messages_rx_errors_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_candidate_rp_messages_rx_errors_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_type_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_unknown_type_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_unknown_type_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatUnknownTypeMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_unknown_type_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_type_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_unknown_type_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatUnknownTypeMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_type_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_unknown_type_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_unknown_type_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_unknown_type_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_version_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_unknown_version_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_unknown_version_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatUnknownVersionMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_unknown_version_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_version_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_unknown_version_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatUnknownVersionMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_version_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_unknown_version_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_unknown_version_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_unknown_version_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_neighbor_unknown_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_neighbor_unknown_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_neighbor_unknown_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatNeighborUnknownMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_neighbor_unknown_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_neighbor_unknown_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_neighbor_unknown_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNeighborUnknownMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_neighbor_unknown_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_neighbor_unknown_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_neighbor_unknown_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_neighbor_unknown_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bad_length_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bad_length_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bad_length_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatBadLengthMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bad_length_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bad_length_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bad_length_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBadLengthMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bad_length_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_bad_length_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bad_length_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bad_length_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bad_checksum_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bad_checksum_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bad_checksum_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatBadChecksumMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bad_checksum_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bad_checksum_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bad_checksum_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBadChecksumMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bad_checksum_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_bad_checksum_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bad_checksum_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bad_checksum_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_bad_receive_interface_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_bad_receive_interface_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_bad_receive_interface_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatBadReceiveInterfaceMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_bad_receive_interface_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_bad_receive_interface_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_bad_receive_interface_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatBadReceiveInterfaceMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_bad_receive_interface_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_bad_receive_interface_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_bad_receive_interface_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_bad_receive_interface_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_interface_disabled_messages_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxInterfaceDisabledMessagesPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_interface_disabled_messages_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxInterfaceDisabledMessagesPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_interface_disabled_messages_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_interface_disabled_messages_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_register_not_rp_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_register_not_rp_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_register_not_rp_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxRegisterNotRpPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_register_not_rp_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_register_not_rp_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_register_not_rp_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxRegisterNotRpPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_register_not_rp_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_register_not_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_register_not_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_register_not_rp_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rp_filtered_source_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rp_filtered_source_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rp_filtered_source_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRpFilteredSourcePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rp_filtered_source_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rp_filtered_source_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rp_filtered_source_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRpFilteredSourcePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rp_filtered_source_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rp_filtered_source_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rp_filtered_source_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rp_filtered_source_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_register_stop_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_unknown_register_stop_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_unknown_register_stop_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatUnknownRegisterStopPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_unknown_register_stop_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_unknown_register_stop_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_unknown_register_stop_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatUnknownRegisterStopPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_unknown_register_stop_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_unknown_register_stop_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_unknown_register_stop_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_unknown_register_stop_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_prune_no_state_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_prune_no_state_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_prune_no_state_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxJoinPruneNoStatePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_prune_no_state_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_prune_no_state_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_prune_no_state_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinPruneNoStatePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_prune_no_state_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_prune_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_prune_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_prune_no_state_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_graft_graft_ack_no_state_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxGraftGraftAckNoStatePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_graft_graft_ack_no_state_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxGraftGraftAckNoStatePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_graft_graft_ack_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_graft_graft_ack_no_state_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_graft_on_upstream_interface_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxGraftOnUpstreamInterfacePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_graft_on_upstream_interface_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxGraftOnUpstreamInterfacePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_graft_on_upstream_interface_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_graft_on_upstream_interface_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_candidate_rp_not_bsr_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxCandidateRpNotBsrPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_candidate_rp_not_bsr_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxCandidateRpNotBsrPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_candidate_rp_not_bsr_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_candidate_rp_not_bsr_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_bsr_when_bsr_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxBsrWhenBsrPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_bsr_when_bsr_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxBsrWhenBsrPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_bsr_when_bsr_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_bsr_when_bsr_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_bsr_not_rpf_interface_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxBsrNotRpfInterfacePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_bsr_not_rpf_interface_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxBsrNotRpfInterfacePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_bsr_not_rpf_interface_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_bsr_not_rpf_interface_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_unknown_hello_option_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_unknown_hello_option_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_unknown_hello_option_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxUnknownHelloOptionPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_unknown_hello_option_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_unknown_hello_option_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_unknown_hello_option_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxUnknownHelloOptionPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_unknown_hello_option_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_unknown_hello_option_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_unknown_hello_option_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_unknown_hello_option_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_data_no_state_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_data_no_state_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_data_no_state_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxDataNoStatePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_data_no_state_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_data_no_state_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_data_no_state_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxDataNoStatePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_data_no_state_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_data_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_data_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_data_no_state_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_rp_no_state_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_rp_no_state_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_rp_no_state_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxRpNoStatePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_rp_no_state_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_rp_no_state_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_rp_no_state_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxRpNoStatePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_rp_no_state_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_rp_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_rp_no_state_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_rp_no_state_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_aggregate_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_aggregate_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_aggregate_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxAggregatePerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_aggregate_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_aggregate_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_aggregate_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxAggregatePerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_aggregate_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_aggregate_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_aggregate_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_aggregate_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_malformed_packet_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_malformed_packet_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_malformed_packet_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxMalformedPacketPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_malformed_packet_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_malformed_packet_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_malformed_packet_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxMalformedPacketPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_malformed_packet_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_malformed_packet_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_malformed_packet_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_malformed_packet_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_no_rp_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_no_rp_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_no_rp_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatNoRpPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_no_rp_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_no_rp_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_no_rp_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNoRpPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_no_rp_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_no_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_no_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_no_rp_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_no_route_upstream_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_no_route_upstream_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_no_route_upstream_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatNoRouteUpstreamPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_no_route_upstream_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_no_route_upstream_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_no_route_upstream_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatNoRouteUpstreamPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_no_route_upstream_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_no_route_upstream_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_no_route_upstream_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_no_route_upstream_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rp_mismatch_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rp_mismatch_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rp_mismatch_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRpMismatchPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rp_mismatch_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rp_mismatch_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rp_mismatch_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRpMismatchPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rp_mismatch_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rp_mismatch_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rp_mismatch_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rp_mismatch_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rpf_neighbor_unknown_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRpfNeighborUnknownPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rpf_neighbor_unknown_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRpfNeighborUnknownPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rpf_neighbor_unknown_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rpf_neighbor_unknown_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_rp_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_rp_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_rp_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxJoinRpPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_rp_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_rp_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_rp_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinRpPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_rp_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_rp_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_rp_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_rp_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_rp_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxPruneRpPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_rp_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_rp_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_rp_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneRpPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_rp_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_rp_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_rp_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_wc_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_wc_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_wc_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxJoinWcPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_wc_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_wc_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_wc_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinWcPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_wc_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_wc_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_wc_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_wc_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_wc_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_wc_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_wc_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxPruneWcPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_wc_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_wc_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_wc_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneWcPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_wc_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_wc_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_wc_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_wc_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_sg_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_sg_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxJoinSgPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_sg_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_sg_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinSgPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_sg_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_sg_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_sg_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_sg_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_sg_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxPruneSgPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_sg_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_sg_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneSgPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_sg_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_sg_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_sg_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg_rpt_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_join_sg_rpt_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_join_sg_rpt_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxJoinSgRptPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_join_sg_rpt_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_join_sg_rpt_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_join_sg_rpt_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxJoinSgRptPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_join_sg_rpt_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_join_sg_rpt_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_join_sg_rpt_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_join_sg_rpt_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif
    (const XrlCmdError &e,
     const uint32_t* rarg_value,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "pim/0.1/pimstat_rx_prune_sg_rpt_per_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("value", *rarg_value);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlPimTargetBase::async_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(
	const string&	arg_vif_name,
	Pim01PimstatRxPruneSgRptPerVifCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_value;
    XrlCmdError e = pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(
        arg_vif_name,
        rarg_value);
    return c_b->dispatch(e,
        &rarg_value);
}
#endif

XrlCmdRT
XrlPimTargetBase::handle_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "pim/0.1/pimstat_rx_prune_sg_rpt_per_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Pim01PimstatRxPruneSgRptPerVifRF mycb =
	    callback(this, &XrlPimTargetBase::callback_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif, pxa_outputs);
	async_pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(
	    xa_inputs.get(0, "vif_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_value;
    try {
	XrlCmdError e = pim_0_1_pimstat_rx_prune_sg_rpt_per_vif(
	    xa_inputs.get(0, "vif_name").text(),
	    r_value);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "pim/0.1/pimstat_rx_prune_sg_rpt_per_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("value", r_value);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}

void
XrlPimTargetBase::add_handlers()
{
    for (size_t i = 0; i < num_handlers; ++i) {
        if (!_cmds->add_handler(handlers[i].name,
                                callback(this, handlers[i].method))) {
            XLOG_ERROR("Failed to register xrl handler finder://%s/%s", "pim", handlers[i].name);
        }
    }
    _cmds->finalize();
}

void
XrlPimTargetBase::remove_handlers()
{
     for (size_t i = 0; i < num_handlers; ++i) {
         _cmds->remove_handler(handlers[i].name);
     }
}
