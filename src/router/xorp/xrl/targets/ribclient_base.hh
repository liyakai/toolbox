/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/ribclient_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_RIBCLIENT_BASE_HH__
#define __XRL_TARGETS_RIBCLIENT_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlRibclientTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlRibclientTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlRibclientTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlRibclientTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "ribclient/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Route Info Changed route_info_changed is called by the RIB on the RIB
     *  client (typically a routing protocol) that had registered an interest
     *  in the routing of an address. This can be because the metric and/or
     *  nexthop changed.
     *
     *  @param addr base address of the subnet that was registered
     *
     *  @param prefix_len prefix length of the subnet that was registered
     *
     *  @param metric the routing metric toward the address.
     *
     *  @param admin_distance the administratively defined distance toward the
     *  address.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError rib_client_0_1_route_info_changed4(
	// Input values,
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoChanged4RF;

    class RibClient01RouteInfoChanged4CB {
        RibClient01RouteInfoChanged4RF cb;

    public:
        operator const RibClient01RouteInfoChanged4RF& () const { return cb; }
        const RibClient01RouteInfoChanged4RF& operator ->() const { return cb; }
        RibClient01RouteInfoChanged4CB(const RibClient01RouteInfoChanged4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoChanged4Rsp :
      public RibClient01RouteInfoChanged4CB {
        RibClient01RouteInfoChanged4Rsp(const RibClient01RouteInfoChanged4RF& cb)
          : RibClient01RouteInfoChanged4CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_changed4
       (
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin,
	RibClient01RouteInfoChanged4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Route Info Invalid route_info_invalid is called by the RIB on the RIB
     *  client (typically a routing protocol) that had registere d an interest
     *  in the routing of an address. This can be because the information
     *  previously reported as applying no longer applies for any number of
     *  reasons. When the RIB sends this message, it has automatically
     *  de-registered interest in the route, and the client will normally need
     *  to send a register_interest request again.
     */
    virtual XrlCmdError rib_client_0_1_route_info_invalid4(
	// Input values,
	const IPv4&	addr,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoInvalid4RF;

    class RibClient01RouteInfoInvalid4CB {
        RibClient01RouteInfoInvalid4RF cb;

    public:
        operator const RibClient01RouteInfoInvalid4RF& () const { return cb; }
        const RibClient01RouteInfoInvalid4RF& operator ->() const { return cb; }
        RibClient01RouteInfoInvalid4CB(const RibClient01RouteInfoInvalid4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoInvalid4Rsp :
      public RibClient01RouteInfoInvalid4CB {
        RibClient01RouteInfoInvalid4Rsp(const RibClient01RouteInfoInvalid4RF& cb)
          : RibClient01RouteInfoInvalid4CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_invalid4
       (
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	RibClient01RouteInfoInvalid4CB);
#endif

    virtual XrlCmdError rib_client_0_1_route_info_changed6(
	// Input values,
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoChanged6RF;

    class RibClient01RouteInfoChanged6CB {
        RibClient01RouteInfoChanged6RF cb;

    public:
        operator const RibClient01RouteInfoChanged6RF& () const { return cb; }
        const RibClient01RouteInfoChanged6RF& operator ->() const { return cb; }
        RibClient01RouteInfoChanged6CB(const RibClient01RouteInfoChanged6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoChanged6Rsp :
      public RibClient01RouteInfoChanged6CB {
        RibClient01RouteInfoChanged6Rsp(const RibClient01RouteInfoChanged6RF& cb)
          : RibClient01RouteInfoChanged6CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_changed6
       (
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin,
	RibClient01RouteInfoChanged6CB);
#endif

    virtual XrlCmdError rib_client_0_1_route_info_invalid6(
	// Input values,
	const IPv6&	addr,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoInvalid6RF;

    class RibClient01RouteInfoInvalid6CB {
        RibClient01RouteInfoInvalid6RF cb;

    public:
        operator const RibClient01RouteInfoInvalid6RF& () const { return cb; }
        const RibClient01RouteInfoInvalid6RF& operator ->() const { return cb; }
        RibClient01RouteInfoInvalid6CB(const RibClient01RouteInfoInvalid6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoInvalid6Rsp :
      public RibClient01RouteInfoInvalid6CB {
        RibClient01RouteInfoInvalid6Rsp(const RibClient01RouteInfoInvalid6RF& cb)
          : RibClient01RouteInfoInvalid6CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_invalid6
       (
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	RibClient01RouteInfoInvalid6CB);
#endif

private:
    XrlCmdRT handle_rib_client_0_1_route_info_changed4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_changed4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_invalid4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_invalid4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_changed6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_changed6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_invalid6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_invalid6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlRibclientTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_RIBCLIENT_BASE_HH__
