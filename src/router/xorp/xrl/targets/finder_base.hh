/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/finder_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_FINDER_BASE_HH__
#define __XRL_TARGETS_FINDER_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlFinderTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlFinderTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlFinderTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlFinderTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "finder/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register client with Finder. Once client has been registered Xrl
     *  registrations may proceed. Once Xrl registrations have have been
     *  completed the client needs to be enabled for the Finder to respond to
     *  queries about the client. Fails if instance_name is already registered,
     *  or another instance of the same class is registered as a singleton. The
     *  client must support the finder_client interface in order to be able to
     *  process messages from the finder.
     */
    virtual XrlCmdError finder_0_2_register_finder_client(
	// Input values,
	const string&	instance_name,
	const string&	class_name,
	const bool&	singleton,
	const string&	in_cookie,
	// Output values,
	string&	out_cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Finder02RegisterFinderClientRF;

    class Finder02RegisterFinderClientCB {
        Finder02RegisterFinderClientRF cb;

    public:
        operator const Finder02RegisterFinderClientRF& () const { return cb; }
        const Finder02RegisterFinderClientRF& operator ->() const { return cb; }
        Finder02RegisterFinderClientCB(const Finder02RegisterFinderClientRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_out_cookie) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_out_cookie);
        }
    };

    struct Finder02RegisterFinderClientRsp :
      public Finder02RegisterFinderClientCB {
        struct args_str {
            string out_cookie;
        };

    private:
        args_str args;

    public:
        Finder02RegisterFinderClientRsp(const Finder02RegisterFinderClientRF& cb)
          : Finder02RegisterFinderClientCB(cb) { }

        void respond() const {
            Finder02RegisterFinderClientCB::
            respond(args.out_cookie);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_register_finder_client
       (
	const string&	instance_name,
	const string&	class_name,
	const bool&	singleton,
	const string&	in_cookie,
	Finder02RegisterFinderClientCB);
#endif

    virtual XrlCmdError finder_0_2_unregister_finder_client(
	// Input values,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Finder02UnregisterFinderClientRF;

    class Finder02UnregisterFinderClientCB {
        Finder02UnregisterFinderClientRF cb;

    public:
        operator const Finder02UnregisterFinderClientRF& () const { return cb; }
        const Finder02UnregisterFinderClientRF& operator ->() const { return cb; }
        Finder02UnregisterFinderClientCB(const Finder02UnregisterFinderClientRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Finder02UnregisterFinderClientRsp :
      public Finder02UnregisterFinderClientCB {
        Finder02UnregisterFinderClientRsp(const Finder02UnregisterFinderClientRF& cb)
          : Finder02UnregisterFinderClientCB(cb) { }

    };

    virtual void async_finder_0_2_unregister_finder_client
       (
	const string&	instance_name,
	Finder02UnregisterFinderClientCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable resolution of Xrls associated with target. Disabling Xrls at
     *  present does not cause clients to flush state associated with target so
     *  cached entries in clients are unaffected by this Xrl. Caller must be
     *  client that registered Xrl.
     */
    virtual XrlCmdError finder_0_2_set_finder_client_enabled(
	// Input values,
	const string&	instance_name,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Finder02SetFinderClientEnabledRF;

    class Finder02SetFinderClientEnabledCB {
        Finder02SetFinderClientEnabledRF cb;

    public:
        operator const Finder02SetFinderClientEnabledRF& () const { return cb; }
        const Finder02SetFinderClientEnabledRF& operator ->() const { return cb; }
        Finder02SetFinderClientEnabledCB(const Finder02SetFinderClientEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Finder02SetFinderClientEnabledRsp :
      public Finder02SetFinderClientEnabledCB {
        Finder02SetFinderClientEnabledRsp(const Finder02SetFinderClientEnabledRF& cb)
          : Finder02SetFinderClientEnabledCB(cb) { }

    };

    virtual void async_finder_0_2_set_finder_client_enabled
       (
	const string&	instance_name,
	const bool&	enabled,
	Finder02SetFinderClientEnabledCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get enabled state information associated with finder client.
     */
    virtual XrlCmdError finder_0_2_finder_client_enabled(
	// Input values,
	const string&	instance_name,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Finder02FinderClientEnabledRF;

    class Finder02FinderClientEnabledCB {
        Finder02FinderClientEnabledRF cb;

    public:
        operator const Finder02FinderClientEnabledRF& () const { return cb; }
        const Finder02FinderClientEnabledRF& operator ->() const { return cb; }
        Finder02FinderClientEnabledCB(const Finder02FinderClientEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Finder02FinderClientEnabledRsp :
      public Finder02FinderClientEnabledCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Finder02FinderClientEnabledRsp(const Finder02FinderClientEnabledRF& cb)
          : Finder02FinderClientEnabledCB(cb) { }

        void respond() const {
            Finder02FinderClientEnabledCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_finder_client_enabled
       (
	const string&	instance_name,
	Finder02FinderClientEnabledCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add resolved Xrl into system, fails if xrl is already registered.
     */
    virtual XrlCmdError finder_0_2_add_xrl(
	// Input values,
	const string&	xrl,
	const string&	protocol_name,
	const string&	protocol_args,
	// Output values,
	string&	resolved_xrl_method_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Finder02AddXrlRF;

    class Finder02AddXrlCB {
        Finder02AddXrlRF cb;

    public:
        operator const Finder02AddXrlRF& () const { return cb; }
        const Finder02AddXrlRF& operator ->() const { return cb; }
        Finder02AddXrlCB(const Finder02AddXrlRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_resolved_xrl_method_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_resolved_xrl_method_name);
        }
    };

    struct Finder02AddXrlRsp :
      public Finder02AddXrlCB {
        struct args_str {
            string resolved_xrl_method_name;
        };

    private:
        args_str args;

    public:
        Finder02AddXrlRsp(const Finder02AddXrlRF& cb)
          : Finder02AddXrlCB(cb) { }

        void respond() const {
            Finder02AddXrlCB::
            respond(args.resolved_xrl_method_name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_add_xrl
       (
	const string&	xrl,
	const string&	protocol_name,
	const string&	protocol_args,
	Finder02AddXrlCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Remove xrl
     */
    virtual XrlCmdError finder_0_2_remove_xrl(
	// Input values,
	const string&	xrl) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Finder02RemoveXrlRF;

    class Finder02RemoveXrlCB {
        Finder02RemoveXrlRF cb;

    public:
        operator const Finder02RemoveXrlRF& () const { return cb; }
        const Finder02RemoveXrlRF& operator ->() const { return cb; }
        Finder02RemoveXrlCB(const Finder02RemoveXrlRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Finder02RemoveXrlRsp :
      public Finder02RemoveXrlCB {
        Finder02RemoveXrlRsp(const Finder02RemoveXrlRF& cb)
          : Finder02RemoveXrlCB(cb) { }

    };

    virtual void async_finder_0_2_remove_xrl
       (
	const string&	xrl,
	Finder02RemoveXrlCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Resolve Xrl
     */
    virtual XrlCmdError finder_0_2_resolve_xrl(
	// Input values,
	const string&	xrl,
	// Output values,
	XrlAtomList&	resolutions) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02ResolveXrlRF;

    class Finder02ResolveXrlCB {
        Finder02ResolveXrlRF cb;

    public:
        operator const Finder02ResolveXrlRF& () const { return cb; }
        const Finder02ResolveXrlRF& operator ->() const { return cb; }
        Finder02ResolveXrlCB(const Finder02ResolveXrlRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_resolutions) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_resolutions);
        }
    };

    struct Finder02ResolveXrlRsp :
      public Finder02ResolveXrlCB {
        struct args_str {
            XrlAtomList resolutions;
        };

    private:
        args_str args;

    public:
        Finder02ResolveXrlRsp(const Finder02ResolveXrlRF& cb)
          : Finder02ResolveXrlCB(cb) { }

        void respond() const {
            Finder02ResolveXrlCB::
            respond(args.resolutions);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_resolve_xrl
       (
	const string&	xrl,
	Finder02ResolveXrlCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of registered Xrl targets
     */
    virtual XrlCmdError finder_0_2_get_xrl_targets(
	// Output values,
	XrlAtomList&	target_names) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02GetXrlTargetsRF;

    class Finder02GetXrlTargetsCB {
        Finder02GetXrlTargetsRF cb;

    public:
        operator const Finder02GetXrlTargetsRF& () const { return cb; }
        const Finder02GetXrlTargetsRF& operator ->() const { return cb; }
        Finder02GetXrlTargetsCB(const Finder02GetXrlTargetsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_target_names) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_target_names);
        }
    };

    struct Finder02GetXrlTargetsRsp :
      public Finder02GetXrlTargetsCB {
        struct args_str {
            XrlAtomList target_names;
        };

    private:
        args_str args;

    public:
        Finder02GetXrlTargetsRsp(const Finder02GetXrlTargetsRF& cb)
          : Finder02GetXrlTargetsCB(cb) { }

        void respond() const {
            Finder02GetXrlTargetsCB::
            respond(args.target_names);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_get_xrl_targets
       (
	Finder02GetXrlTargetsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of Xrls registered by target
     */
    virtual XrlCmdError finder_0_2_get_xrls_registered_by(
	// Input values,
	const string&	target_name,
	// Output values,
	XrlAtomList&	xrls) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02GetXrlsRegisteredByRF;

    class Finder02GetXrlsRegisteredByCB {
        Finder02GetXrlsRegisteredByRF cb;

    public:
        operator const Finder02GetXrlsRegisteredByRF& () const { return cb; }
        const Finder02GetXrlsRegisteredByRF& operator ->() const { return cb; }
        Finder02GetXrlsRegisteredByCB(const Finder02GetXrlsRegisteredByRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_xrls) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_xrls);
        }
    };

    struct Finder02GetXrlsRegisteredByRsp :
      public Finder02GetXrlsRegisteredByCB {
        struct args_str {
            XrlAtomList xrls;
        };

    private:
        args_str args;

    public:
        Finder02GetXrlsRegisteredByRsp(const Finder02GetXrlsRegisteredByRF& cb)
          : Finder02GetXrlsRegisteredByCB(cb) { }

        void respond() const {
            Finder02GetXrlsRegisteredByCB::
            respond(args.xrls);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_get_xrls_registered_by
       (
	const string&	target_name,
	Finder02GetXrlsRegisteredByCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of IPv4 hosts that clients should accept IPC requests from.
     */
    virtual XrlCmdError finder_0_2_get_ipv4_permitted_hosts(
	// Output values,
	XrlAtomList&	ipv4s) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02GetIpv4PermittedHostsRF;

    class Finder02GetIpv4PermittedHostsCB {
        Finder02GetIpv4PermittedHostsRF cb;

    public:
        operator const Finder02GetIpv4PermittedHostsRF& () const { return cb; }
        const Finder02GetIpv4PermittedHostsRF& operator ->() const { return cb; }
        Finder02GetIpv4PermittedHostsCB(const Finder02GetIpv4PermittedHostsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_ipv4s) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ipv4s);
        }
    };

    struct Finder02GetIpv4PermittedHostsRsp :
      public Finder02GetIpv4PermittedHostsCB {
        struct args_str {
            XrlAtomList ipv4s;
        };

    private:
        args_str args;

    public:
        Finder02GetIpv4PermittedHostsRsp(const Finder02GetIpv4PermittedHostsRF& cb)
          : Finder02GetIpv4PermittedHostsCB(cb) { }

        void respond() const {
            Finder02GetIpv4PermittedHostsCB::
            respond(args.ipv4s);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_get_ipv4_permitted_hosts
       (
	Finder02GetIpv4PermittedHostsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of IPv4 nets that clients should accept IPC requests from.
     */
    virtual XrlCmdError finder_0_2_get_ipv4_permitted_nets(
	// Output values,
	XrlAtomList&	ipv4nets) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02GetIpv4PermittedNetsRF;

    class Finder02GetIpv4PermittedNetsCB {
        Finder02GetIpv4PermittedNetsRF cb;

    public:
        operator const Finder02GetIpv4PermittedNetsRF& () const { return cb; }
        const Finder02GetIpv4PermittedNetsRF& operator ->() const { return cb; }
        Finder02GetIpv4PermittedNetsCB(const Finder02GetIpv4PermittedNetsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_ipv4nets) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ipv4nets);
        }
    };

    struct Finder02GetIpv4PermittedNetsRsp :
      public Finder02GetIpv4PermittedNetsCB {
        struct args_str {
            XrlAtomList ipv4nets;
        };

    private:
        args_str args;

    public:
        Finder02GetIpv4PermittedNetsRsp(const Finder02GetIpv4PermittedNetsRF& cb)
          : Finder02GetIpv4PermittedNetsCB(cb) { }

        void respond() const {
            Finder02GetIpv4PermittedNetsCB::
            respond(args.ipv4nets);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_get_ipv4_permitted_nets
       (
	Finder02GetIpv4PermittedNetsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of IPv6 hosts that clients should accept IPC requests from.
     */
    virtual XrlCmdError finder_0_2_get_ipv6_permitted_hosts(
	// Output values,
	XrlAtomList&	ipv6s) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02GetIpv6PermittedHostsRF;

    class Finder02GetIpv6PermittedHostsCB {
        Finder02GetIpv6PermittedHostsRF cb;

    public:
        operator const Finder02GetIpv6PermittedHostsRF& () const { return cb; }
        const Finder02GetIpv6PermittedHostsRF& operator ->() const { return cb; }
        Finder02GetIpv6PermittedHostsCB(const Finder02GetIpv6PermittedHostsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_ipv6s) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ipv6s);
        }
    };

    struct Finder02GetIpv6PermittedHostsRsp :
      public Finder02GetIpv6PermittedHostsCB {
        struct args_str {
            XrlAtomList ipv6s;
        };

    private:
        args_str args;

    public:
        Finder02GetIpv6PermittedHostsRsp(const Finder02GetIpv6PermittedHostsRF& cb)
          : Finder02GetIpv6PermittedHostsCB(cb) { }

        void respond() const {
            Finder02GetIpv6PermittedHostsCB::
            respond(args.ipv6s);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_get_ipv6_permitted_hosts
       (
	Finder02GetIpv6PermittedHostsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of IPv6 nets that clients should accept IPC requests from.
     */
    virtual XrlCmdError finder_0_2_get_ipv6_permitted_nets(
	// Output values,
	XrlAtomList&	ipv6nets) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Finder02GetIpv6PermittedNetsRF;

    class Finder02GetIpv6PermittedNetsCB {
        Finder02GetIpv6PermittedNetsRF cb;

    public:
        operator const Finder02GetIpv6PermittedNetsRF& () const { return cb; }
        const Finder02GetIpv6PermittedNetsRF& operator ->() const { return cb; }
        Finder02GetIpv6PermittedNetsCB(const Finder02GetIpv6PermittedNetsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_ipv6nets) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ipv6nets);
        }
    };

    struct Finder02GetIpv6PermittedNetsRsp :
      public Finder02GetIpv6PermittedNetsCB {
        struct args_str {
            XrlAtomList ipv6nets;
        };

    private:
        args_str args;

    public:
        Finder02GetIpv6PermittedNetsRsp(const Finder02GetIpv6PermittedNetsRF& cb)
          : Finder02GetIpv6PermittedNetsCB(cb) { }

        void respond() const {
            Finder02GetIpv6PermittedNetsCB::
            respond(args.ipv6nets);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_finder_0_2_get_ipv6_permitted_nets
       (
	Finder02GetIpv6PermittedNetsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register interest in events relating to a particular class. Following
     *  this call the requester will receive birth event notifications for
     *  existing instances within the named class and will receive birth and
     *  deatch event notifications as instances are created and destroyed
     *  subsequently.
     *
     *  @param requester_instance instance name of Xrl Target interested in
     *  receiving event notifications.
     *
     *  @param class_name class of Xrl Targets to generate event notifications
     *  for.
     */
    virtual XrlCmdError finder_event_notifier_0_1_register_class_event_interest(
	// Input values,
	const string&	requester_instance,
	const string&	class_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventNotifier01RegisterClassEventInterestRF;

    class FinderEventNotifier01RegisterClassEventInterestCB {
        FinderEventNotifier01RegisterClassEventInterestRF cb;

    public:
        operator const FinderEventNotifier01RegisterClassEventInterestRF& () const { return cb; }
        const FinderEventNotifier01RegisterClassEventInterestRF& operator ->() const { return cb; }
        FinderEventNotifier01RegisterClassEventInterestCB(const FinderEventNotifier01RegisterClassEventInterestRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventNotifier01RegisterClassEventInterestRsp :
      public FinderEventNotifier01RegisterClassEventInterestCB {
        FinderEventNotifier01RegisterClassEventInterestRsp(const FinderEventNotifier01RegisterClassEventInterestRF& cb)
          : FinderEventNotifier01RegisterClassEventInterestCB(cb) { }

    };

    virtual void async_finder_event_notifier_0_1_register_class_event_interest
       (
	const string&	requester_instance,
	const string&	class_name,
	FinderEventNotifier01RegisterClassEventInterestCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Deregister interest in events relating to a particular class.
     *
     *  @param requester_instance instance name of Xrl Target interested in
     *  receiving event notifications.
     *
     *  @param class_name class of Xrl Targets to stop event notifications for.
     */
    virtual XrlCmdError finder_event_notifier_0_1_deregister_class_event_interest(
	// Input values,
	const string&	requester_instance,
	const string&	class_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventNotifier01DeregisterClassEventInterestRF;

    class FinderEventNotifier01DeregisterClassEventInterestCB {
        FinderEventNotifier01DeregisterClassEventInterestRF cb;

    public:
        operator const FinderEventNotifier01DeregisterClassEventInterestRF& () const { return cb; }
        const FinderEventNotifier01DeregisterClassEventInterestRF& operator ->() const { return cb; }
        FinderEventNotifier01DeregisterClassEventInterestCB(const FinderEventNotifier01DeregisterClassEventInterestRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventNotifier01DeregisterClassEventInterestRsp :
      public FinderEventNotifier01DeregisterClassEventInterestCB {
        FinderEventNotifier01DeregisterClassEventInterestRsp(const FinderEventNotifier01DeregisterClassEventInterestRF& cb)
          : FinderEventNotifier01DeregisterClassEventInterestCB(cb) { }

    };

    virtual void async_finder_event_notifier_0_1_deregister_class_event_interest
       (
	const string&	requester_instance,
	const string&	class_name,
	FinderEventNotifier01DeregisterClassEventInterestCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register interest in events relating to a particular instance.
     *  Following this call the requester will receive a birth event
     *  notification for the named instance if it exists. When the named
     *  instance dies, the requester will receive a death event notification.
     *  This method will fail if the named instance does not exist.
     *
     *  @param requester_instance instance name of Xrl Target interested in
     *  receiving event notifications.
     *
     *  @param instance_name name of Xrl Target instance to receive event
     *  notifications for.
     */
    virtual XrlCmdError finder_event_notifier_0_1_register_instance_event_interest(
	// Input values,
	const string&	requester_instance,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventNotifier01RegisterInstanceEventInterestRF;

    class FinderEventNotifier01RegisterInstanceEventInterestCB {
        FinderEventNotifier01RegisterInstanceEventInterestRF cb;

    public:
        operator const FinderEventNotifier01RegisterInstanceEventInterestRF& () const { return cb; }
        const FinderEventNotifier01RegisterInstanceEventInterestRF& operator ->() const { return cb; }
        FinderEventNotifier01RegisterInstanceEventInterestCB(const FinderEventNotifier01RegisterInstanceEventInterestRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventNotifier01RegisterInstanceEventInterestRsp :
      public FinderEventNotifier01RegisterInstanceEventInterestCB {
        FinderEventNotifier01RegisterInstanceEventInterestRsp(const FinderEventNotifier01RegisterInstanceEventInterestRF& cb)
          : FinderEventNotifier01RegisterInstanceEventInterestCB(cb) { }

    };

    virtual void async_finder_event_notifier_0_1_register_instance_event_interest
       (
	const string&	requester_instance,
	const string&	instance_name,
	FinderEventNotifier01RegisterInstanceEventInterestCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register interest in events relating to a particular instance.
     *
     *  @param requester_instance instance name of Xrl Target interested in
     *  receiving event notifications.
     *
     *  @param instance_name name of Xrl Target instance to stop event
     *  notifications for.
     */
    virtual XrlCmdError finder_event_notifier_0_1_deregister_instance_event_interest(
	// Input values,
	const string&	requester_instance,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventNotifier01DeregisterInstanceEventInterestRF;

    class FinderEventNotifier01DeregisterInstanceEventInterestCB {
        FinderEventNotifier01DeregisterInstanceEventInterestRF cb;

    public:
        operator const FinderEventNotifier01DeregisterInstanceEventInterestRF& () const { return cb; }
        const FinderEventNotifier01DeregisterInstanceEventInterestRF& operator ->() const { return cb; }
        FinderEventNotifier01DeregisterInstanceEventInterestCB(const FinderEventNotifier01DeregisterInstanceEventInterestRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventNotifier01DeregisterInstanceEventInterestRsp :
      public FinderEventNotifier01DeregisterInstanceEventInterestCB {
        FinderEventNotifier01DeregisterInstanceEventInterestRsp(const FinderEventNotifier01DeregisterInstanceEventInterestRF& cb)
          : FinderEventNotifier01DeregisterInstanceEventInterestCB(cb) { }

    };

    virtual void async_finder_event_notifier_0_1_deregister_instance_event_interest
       (
	const string&	requester_instance,
	const string&	instance_name,
	FinderEventNotifier01DeregisterInstanceEventInterestCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_register_finder_client(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_register_finder_client
       (const XrlCmdError &e,
	const string* arg_out_cookie,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_unregister_finder_client(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_unregister_finder_client
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_set_finder_client_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_set_finder_client_enabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_finder_client_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_finder_client_enabled
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_add_xrl(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_add_xrl
       (const XrlCmdError &e,
	const string* arg_resolved_xrl_method_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_remove_xrl(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_remove_xrl
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_resolve_xrl(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_resolve_xrl
       (const XrlCmdError &e,
	const XrlAtomList* arg_resolutions,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_get_xrl_targets(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_get_xrl_targets
       (const XrlCmdError &e,
	const XrlAtomList* arg_target_names,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_get_xrls_registered_by(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_get_xrls_registered_by
       (const XrlCmdError &e,
	const XrlAtomList* arg_xrls,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_get_ipv4_permitted_hosts(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_get_ipv4_permitted_hosts
       (const XrlCmdError &e,
	const XrlAtomList* arg_ipv4s,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_get_ipv4_permitted_nets(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_get_ipv4_permitted_nets
       (const XrlCmdError &e,
	const XrlAtomList* arg_ipv4nets,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_get_ipv6_permitted_hosts(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_get_ipv6_permitted_hosts
       (const XrlCmdError &e,
	const XrlAtomList* arg_ipv6s,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_0_2_get_ipv6_permitted_nets(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_0_2_get_ipv6_permitted_nets
       (const XrlCmdError &e,
	const XrlAtomList* arg_ipv6nets,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_notifier_0_1_register_class_event_interest(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_notifier_0_1_register_class_event_interest
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_notifier_0_1_deregister_class_event_interest(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_notifier_0_1_deregister_class_event_interest
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_notifier_0_1_register_instance_event_interest(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_notifier_0_1_register_instance_event_interest
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_notifier_0_1_deregister_instance_event_interest(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_notifier_0_1_deregister_instance_event_interest
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlFinderTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_FINDER_BASE_HH__
