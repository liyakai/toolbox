/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/bgp_base.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#include "bgp_base.hh"


const struct XrlBgpTargetBase::handler_table XrlBgpTargetBase::handlers[] = {
    { "common/0.1/get_target_name",
      &XrlBgpTargetBase::handle_common_0_1_get_target_name },
    { "common/0.1/get_version",
      &XrlBgpTargetBase::handle_common_0_1_get_version },
    { "common/0.1/get_status",
      &XrlBgpTargetBase::handle_common_0_1_get_status },
    { "common/0.1/shutdown",
      &XrlBgpTargetBase::handle_common_0_1_shutdown },
    { "common/0.1/startup",
      &XrlBgpTargetBase::handle_common_0_1_startup },
    { "bgp/0.3/get_bgp_version",
      &XrlBgpTargetBase::handle_bgp_0_3_get_bgp_version },
    { "bgp/0.3/local_config",
      &XrlBgpTargetBase::handle_bgp_0_3_local_config },
    { "bgp/0.3/set_local_as",
      &XrlBgpTargetBase::handle_bgp_0_3_set_local_as },
    { "bgp/0.3/set_4byte_as_support",
      &XrlBgpTargetBase::handle_bgp_0_3_set_4byte_as_support },
    { "bgp/0.3/get_local_as",
      &XrlBgpTargetBase::handle_bgp_0_3_get_local_as },
    { "bgp/0.3/set_bgp_id",
      &XrlBgpTargetBase::handle_bgp_0_3_set_bgp_id },
    { "bgp/0.3/get_bgp_id",
      &XrlBgpTargetBase::handle_bgp_0_3_get_bgp_id },
    { "bgp/0.3/set_confederation_identifier",
      &XrlBgpTargetBase::handle_bgp_0_3_set_confederation_identifier },
    { "bgp/0.3/set_cluster_id",
      &XrlBgpTargetBase::handle_bgp_0_3_set_cluster_id },
    { "bgp/0.3/set_damping",
      &XrlBgpTargetBase::handle_bgp_0_3_set_damping },
    { "bgp/0.3/add_peer",
      &XrlBgpTargetBase::handle_bgp_0_3_add_peer },
    { "bgp/0.3/delete_peer",
      &XrlBgpTargetBase::handle_bgp_0_3_delete_peer },
    { "bgp/0.3/enable_peer",
      &XrlBgpTargetBase::handle_bgp_0_3_enable_peer },
    { "bgp/0.3/disable_peer",
      &XrlBgpTargetBase::handle_bgp_0_3_disable_peer },
    { "bgp/0.3/change_local_ip",
      &XrlBgpTargetBase::handle_bgp_0_3_change_local_ip },
    { "bgp/0.3/change_local_port",
      &XrlBgpTargetBase::handle_bgp_0_3_change_local_port },
    { "bgp/0.3/change_peer_port",
      &XrlBgpTargetBase::handle_bgp_0_3_change_peer_port },
    { "bgp/0.3/set_peer_as",
      &XrlBgpTargetBase::handle_bgp_0_3_set_peer_as },
    { "bgp/0.3/set_holdtime",
      &XrlBgpTargetBase::handle_bgp_0_3_set_holdtime },
    { "bgp/0.3/set_delay_open_time",
      &XrlBgpTargetBase::handle_bgp_0_3_set_delay_open_time },
    { "bgp/0.3/set_route_reflector_client",
      &XrlBgpTargetBase::handle_bgp_0_3_set_route_reflector_client },
    { "bgp/0.3/set_confederation_member",
      &XrlBgpTargetBase::handle_bgp_0_3_set_confederation_member },
    { "bgp/0.3/set_prefix_limit",
      &XrlBgpTargetBase::handle_bgp_0_3_set_prefix_limit },
    { "bgp/0.3/set_nexthop4",
      &XrlBgpTargetBase::handle_bgp_0_3_set_nexthop4 },
    { "bgp/0.3/set_peer_state",
      &XrlBgpTargetBase::handle_bgp_0_3_set_peer_state },
    { "bgp/0.3/set_peer_md5_password",
      &XrlBgpTargetBase::handle_bgp_0_3_set_peer_md5_password },
    { "bgp/0.3/activate",
      &XrlBgpTargetBase::handle_bgp_0_3_activate },
    { "bgp/0.3/set_parameter",
      &XrlBgpTargetBase::handle_bgp_0_3_set_parameter },
    { "bgp/0.3/next_hop_rewrite_filter",
      &XrlBgpTargetBase::handle_bgp_0_3_next_hop_rewrite_filter },
    { "bgp/0.3/originate_route4",
      &XrlBgpTargetBase::handle_bgp_0_3_originate_route4 },
    { "bgp/0.3/withdraw_route4",
      &XrlBgpTargetBase::handle_bgp_0_3_withdraw_route4 },
    { "bgp/0.3/trace",
      &XrlBgpTargetBase::handle_bgp_0_3_trace },
    { "bgp/0.3/get_peer_list_start",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_list_start },
    { "bgp/0.3/get_peer_list_next",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_list_next },
    { "bgp/0.3/get_peer_id",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_id },
    { "bgp/0.3/get_peer_status",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_status },
    { "bgp/0.3/get_peer_negotiated_version",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_negotiated_version },
    { "bgp/0.3/get_peer_as",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_as },
    { "bgp/0.3/get_peer_msg_stats",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_msg_stats },
    { "bgp/0.3/get_peer_established_stats",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_established_stats },
    { "bgp/0.3/get_peer_timer_config",
      &XrlBgpTargetBase::handle_bgp_0_3_get_peer_timer_config },
    { "bgp/0.3/register_rib",
      &XrlBgpTargetBase::handle_bgp_0_3_register_rib },
    { "bgp/0.3/get_v4_route_list_start",
      &XrlBgpTargetBase::handle_bgp_0_3_get_v4_route_list_start },
    { "bgp/0.3/get_v4_route_list_next",
      &XrlBgpTargetBase::handle_bgp_0_3_get_v4_route_list_next },
    { "bgp/0.3/set_nexthop6",
      &XrlBgpTargetBase::handle_bgp_0_3_set_nexthop6 },
    { "bgp/0.3/get_nexthop6",
      &XrlBgpTargetBase::handle_bgp_0_3_get_nexthop6 },
    { "bgp/0.3/withdraw_route6",
      &XrlBgpTargetBase::handle_bgp_0_3_withdraw_route6 },
    { "bgp/0.3/get_v6_route_list_start",
      &XrlBgpTargetBase::handle_bgp_0_3_get_v6_route_list_start },
    { "bgp/0.3/originate_route6",
      &XrlBgpTargetBase::handle_bgp_0_3_originate_route6 },
    { "bgp/0.3/get_v6_route_list_next",
      &XrlBgpTargetBase::handle_bgp_0_3_get_v6_route_list_next },
    { "finder_event_observer/0.1/xrl_target_birth",
      &XrlBgpTargetBase::handle_finder_event_observer_0_1_xrl_target_birth },
    { "finder_event_observer/0.1/xrl_target_death",
      &XrlBgpTargetBase::handle_finder_event_observer_0_1_xrl_target_death },
    { "policy_backend/0.1/configure",
      &XrlBgpTargetBase::handle_policy_backend_0_1_configure },
    { "policy_backend/0.1/reset",
      &XrlBgpTargetBase::handle_policy_backend_0_1_reset },
    { "policy_backend/0.1/push_routes",
      &XrlBgpTargetBase::handle_policy_backend_0_1_push_routes },
    { "policy_redist4/0.1/add_route4",
      &XrlBgpTargetBase::handle_policy_redist4_0_1_add_route4 },
    { "policy_redist4/0.1/delete_route4",
      &XrlBgpTargetBase::handle_policy_redist4_0_1_delete_route4 },
    { "rib_client/0.1/route_info_changed4",
      &XrlBgpTargetBase::handle_rib_client_0_1_route_info_changed4 },
    { "rib_client/0.1/route_info_invalid4",
      &XrlBgpTargetBase::handle_rib_client_0_1_route_info_invalid4 },
    { "rib_client/0.1/route_info_changed6",
      &XrlBgpTargetBase::handle_rib_client_0_1_route_info_changed6 },
    { "rib_client/0.1/route_info_invalid6",
      &XrlBgpTargetBase::handle_rib_client_0_1_route_info_invalid6 },
    { "policy_redist6/0.1/add_route6",
      &XrlBgpTargetBase::handle_policy_redist6_0_1_add_route6 },
    { "policy_redist6/0.1/delete_route6",
      &XrlBgpTargetBase::handle_policy_redist6_0_1_delete_route6 },
    { "profile/0.1/enable",
      &XrlBgpTargetBase::handle_profile_0_1_enable },
    { "profile/0.1/disable",
      &XrlBgpTargetBase::handle_profile_0_1_disable },
    { "profile/0.1/get_entries",
      &XrlBgpTargetBase::handle_profile_0_1_get_entries },
    { "profile/0.1/clear",
      &XrlBgpTargetBase::handle_profile_0_1_clear },
    { "profile/0.1/list",
      &XrlBgpTargetBase::handle_profile_0_1_list },
};

const size_t XrlBgpTargetBase::num_handlers = (sizeof(XrlBgpTargetBase::handlers) / sizeof(XrlBgpTargetBase::handlers[0]));


XrlBgpTargetBase::XrlBgpTargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlBgpTargetBase::~XrlBgpTargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlBgpTargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_common_0_1_get_target_name
    (const XrlCmdError &e,
     const string* rarg_name,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_target_name", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("name", *rarg_name);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_common_0_1_get_target_name(
	Common01GetTargetNameCB c_b)
{

    /* Return value declarations */
    string rarg_name;
    XrlCmdError e = common_0_1_get_target_name(
        rarg_name);
    return c_b->dispatch(e,
        &rarg_name);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_common_0_1_get_target_name(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_target_name");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetTargetNameRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_common_0_1_get_target_name, pxa_outputs);
	async_common_0_1_get_target_name( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_name;
    try {
	XrlCmdError e = common_0_1_get_target_name(
	    r_name);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_target_name", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("name", r_name);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_common_0_1_get_version
    (const XrlCmdError &e,
     const string* rarg_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("version", *rarg_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_common_0_1_get_version(
	Common01GetVersionCB c_b)
{

    /* Return value declarations */
    string rarg_version;
    XrlCmdError e = common_0_1_get_version(
        rarg_version);
    return c_b->dispatch(e,
        &rarg_version);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_common_0_1_get_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetVersionRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_common_0_1_get_version, pxa_outputs);
	async_common_0_1_get_version( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_version;
    try {
	XrlCmdError e = common_0_1_get_version(
	    r_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", r_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_common_0_1_get_status
    (const XrlCmdError &e,
     const uint32_t* rarg_status,
     const string* rarg_reason,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_status", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("status", *rarg_status);
	    out.add("reason", *rarg_reason);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_common_0_1_get_status(
	Common01GetStatusCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_status;
    string rarg_reason;
    XrlCmdError e = common_0_1_get_status(
        rarg_status,
        rarg_reason);
    return c_b->dispatch(e,
        &rarg_status,
        &rarg_reason);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_common_0_1_get_status(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_status");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetStatusRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_common_0_1_get_status, pxa_outputs);
	async_common_0_1_get_status( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_status;
    string r_reason;
    try {
	XrlCmdError e = common_0_1_get_status(
	    r_status,
	    r_reason);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_status", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("status", r_status);
	pxa_outputs->add("reason", r_reason);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_common_0_1_shutdown
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/shutdown", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_common_0_1_shutdown(
	Common01ShutdownCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_shutdown();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_common_0_1_shutdown(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/shutdown");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01ShutdownRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_common_0_1_shutdown, pxa_outputs);
	async_common_0_1_shutdown( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_shutdown();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_common_0_1_startup
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/startup", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_common_0_1_startup(
	Common01StartupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_startup();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_common_0_1_startup(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/startup");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01StartupRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_common_0_1_startup, pxa_outputs);
	async_common_0_1_startup( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_startup();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/startup", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_bgp_version
    (const XrlCmdError &e,
     const uint32_t* rarg_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_bgp_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("version", *rarg_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_bgp_version(
	Bgp03GetBgpVersionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_version;
    XrlCmdError e = bgp_0_3_get_bgp_version(
        rarg_version);
    return c_b->dispatch(e,
        &rarg_version);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_bgp_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_bgp_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetBgpVersionRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_bgp_version, pxa_outputs);
	async_bgp_0_3_get_bgp_version( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_version;
    try {
	XrlCmdError e = bgp_0_3_get_bgp_version(
	    r_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_bgp_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", r_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_local_config
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/local_config", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_local_config(
	const string&	arg_as,
	const IPv4&	arg_id,
	const bool&	arg_use_4byte_asnums,
	Bgp03LocalConfigCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_local_config(
        arg_as,
        arg_id,
        arg_use_4byte_asnums);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_local_config(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/local_config");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03LocalConfigRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_local_config, pxa_outputs);
	async_bgp_0_3_local_config(
	    xa_inputs.get(0, "as").text(),
	    xa_inputs.get(1, "id").ipv4(),
	    xa_inputs.get(2, "use_4byte_asnums").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_local_config(
	    xa_inputs.get(0, "as").text(),
	    xa_inputs.get(1, "id").ipv4(),
	    xa_inputs.get(2, "use_4byte_asnums").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/local_config", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_local_as
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_local_as", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_local_as(
	const string&	arg_as,
	Bgp03SetLocalAsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_local_as(
        arg_as);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_local_as(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_local_as");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetLocalAsRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_local_as, pxa_outputs);
	async_bgp_0_3_set_local_as(
	    xa_inputs.get(0, "as").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_local_as(
	    xa_inputs.get(0, "as").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_local_as", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_4byte_as_support
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_4byte_as_support", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_4byte_as_support(
	const bool&	arg_enable,
	Bgp03Set4ByteAsSupportCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_4byte_as_support(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_4byte_as_support(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_4byte_as_support");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03Set4ByteAsSupportRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_4byte_as_support, pxa_outputs);
	async_bgp_0_3_set_4byte_as_support(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_4byte_as_support(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_4byte_as_support", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_local_as
    (const XrlCmdError &e,
     const string* rarg_as,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_local_as", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("as", *rarg_as);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_local_as(
	Bgp03GetLocalAsCB c_b)
{

    /* Return value declarations */
    string rarg_as;
    XrlCmdError e = bgp_0_3_get_local_as(
        rarg_as);
    return c_b->dispatch(e,
        &rarg_as);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_local_as(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_local_as");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetLocalAsRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_local_as, pxa_outputs);
	async_bgp_0_3_get_local_as( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_as;
    try {
	XrlCmdError e = bgp_0_3_get_local_as(
	    r_as);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_local_as", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("as", r_as);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_bgp_id
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_bgp_id", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_bgp_id(
	const IPv4&	arg_id,
	Bgp03SetBgpIdCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_bgp_id(
        arg_id);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_bgp_id(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_bgp_id");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetBgpIdRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_bgp_id, pxa_outputs);
	async_bgp_0_3_set_bgp_id(
	    xa_inputs.get(0, "id").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_bgp_id(
	    xa_inputs.get(0, "id").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_bgp_id", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_bgp_id
    (const XrlCmdError &e,
     const IPv4* rarg_id,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_bgp_id", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("id", *rarg_id);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_bgp_id(
	Bgp03GetBgpIdCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_id;
    XrlCmdError e = bgp_0_3_get_bgp_id(
        rarg_id);
    return c_b->dispatch(e,
        &rarg_id);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_bgp_id(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_bgp_id");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetBgpIdRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_bgp_id, pxa_outputs);
	async_bgp_0_3_get_bgp_id( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_id;
    try {
	XrlCmdError e = bgp_0_3_get_bgp_id(
	    r_id);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_bgp_id", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("id", r_id);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_confederation_identifier
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_confederation_identifier", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_confederation_identifier(
	const string&	arg_as,
	const bool&	arg_disable,
	Bgp03SetConfederationIdentifierCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_confederation_identifier(
        arg_as,
        arg_disable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_confederation_identifier(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_confederation_identifier");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetConfederationIdentifierRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_confederation_identifier, pxa_outputs);
	async_bgp_0_3_set_confederation_identifier(
	    xa_inputs.get(0, "as").text(),
	    xa_inputs.get(1, "disable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_confederation_identifier(
	    xa_inputs.get(0, "as").text(),
	    xa_inputs.get(1, "disable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_confederation_identifier", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_cluster_id
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_cluster_id", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_cluster_id(
	const IPv4&	arg_cluster_id,
	const bool&	arg_disable,
	Bgp03SetClusterIdCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_cluster_id(
        arg_cluster_id,
        arg_disable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_cluster_id(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_cluster_id");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetClusterIdRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_cluster_id, pxa_outputs);
	async_bgp_0_3_set_cluster_id(
	    xa_inputs.get(0, "cluster_id").ipv4(),
	    xa_inputs.get(1, "disable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_cluster_id(
	    xa_inputs.get(0, "cluster_id").ipv4(),
	    xa_inputs.get(1, "disable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_cluster_id", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_damping
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_damping", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_damping(
	const uint32_t&	arg_half_life,
	const uint32_t&	arg_max_suppress,
	const uint32_t&	arg_reuse,
	const uint32_t&	arg_suppress,
	const bool&	arg_disable,
	Bgp03SetDampingCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_damping(
        arg_half_life,
        arg_max_suppress,
        arg_reuse,
        arg_suppress,
        arg_disable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_damping(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_damping");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetDampingRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_damping, pxa_outputs);
	async_bgp_0_3_set_damping(
	    xa_inputs.get(0, "half_life").uint32(),
	    xa_inputs.get(1, "max_suppress").uint32(),
	    xa_inputs.get(2, "reuse").uint32(),
	    xa_inputs.get(3, "suppress").uint32(),
	    xa_inputs.get(4, "disable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_damping(
	    xa_inputs.get(0, "half_life").uint32(),
	    xa_inputs.get(1, "max_suppress").uint32(),
	    xa_inputs.get(2, "reuse").uint32(),
	    xa_inputs.get(3, "suppress").uint32(),
	    xa_inputs.get(4, "disable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_damping", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_add_peer
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/add_peer", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_add_peer(
	const string&	arg_local_dev,
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const string&	arg_as,
	const IPv4&	arg_next_hop,
	const uint32_t&	arg_holdtime,
	Bgp03AddPeerCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_add_peer(
        arg_local_dev,
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_as,
        arg_next_hop,
        arg_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_add_peer(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 8) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(8), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/add_peer");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03AddPeerRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_add_peer, pxa_outputs);
	async_bgp_0_3_add_peer(
	    xa_inputs.get(0, "local_dev").text(),
	    xa_inputs.get(1, "local_ip").text(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "peer_ip").text(),
	    xa_inputs.get(4, "peer_port").uint32(),
	    xa_inputs.get(5, "as").text(),
	    xa_inputs.get(6, "next_hop").ipv4(),
	    xa_inputs.get(7, "holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_add_peer(
	    xa_inputs.get(0, "local_dev").text(),
	    xa_inputs.get(1, "local_ip").text(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "peer_ip").text(),
	    xa_inputs.get(4, "peer_port").uint32(),
	    xa_inputs.get(5, "as").text(),
	    xa_inputs.get(6, "next_hop").ipv4(),
	    xa_inputs.get(7, "holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/add_peer", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_delete_peer
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/delete_peer", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_delete_peer(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03DeletePeerCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_delete_peer(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_delete_peer(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/delete_peer");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03DeletePeerRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_delete_peer, pxa_outputs);
	async_bgp_0_3_delete_peer(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_delete_peer(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/delete_peer", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_enable_peer
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/enable_peer", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_enable_peer(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03EnablePeerCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_enable_peer(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_enable_peer(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/enable_peer");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03EnablePeerRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_enable_peer, pxa_outputs);
	async_bgp_0_3_enable_peer(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_enable_peer(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/enable_peer", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_disable_peer
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/disable_peer", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_disable_peer(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03DisablePeerCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_disable_peer(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_disable_peer(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/disable_peer");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03DisablePeerRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_disable_peer, pxa_outputs);
	async_bgp_0_3_disable_peer(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_disable_peer(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/disable_peer", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_change_local_ip
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/change_local_ip", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_change_local_ip(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const string&	arg_new_local_ip,
	const string&	arg_new_local_dev,
	Bgp03ChangeLocalIpCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_change_local_ip(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_new_local_ip,
        arg_new_local_dev);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_change_local_ip(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/change_local_ip");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03ChangeLocalIpRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_change_local_ip, pxa_outputs);
	async_bgp_0_3_change_local_ip(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "new_local_ip").text(),
	    xa_inputs.get(5, "new_local_dev").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_change_local_ip(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "new_local_ip").text(),
	    xa_inputs.get(5, "new_local_dev").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/change_local_ip", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_change_local_port
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/change_local_port", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_change_local_port(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const uint32_t&	arg_new_local_port,
	Bgp03ChangeLocalPortCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_change_local_port(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_new_local_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_change_local_port(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/change_local_port");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03ChangeLocalPortRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_change_local_port, pxa_outputs);
	async_bgp_0_3_change_local_port(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "new_local_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_change_local_port(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "new_local_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/change_local_port", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_change_peer_port
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/change_peer_port", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_change_peer_port(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const uint32_t&	arg_new_peer_port,
	Bgp03ChangePeerPortCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_change_peer_port(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_new_peer_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_change_peer_port(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/change_peer_port");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03ChangePeerPortRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_change_peer_port, pxa_outputs);
	async_bgp_0_3_change_peer_port(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "new_peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_change_peer_port(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "new_peer_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/change_peer_port", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_peer_as
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_peer_as", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_peer_as(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const string&	arg_peer_as,
	Bgp03SetPeerAsCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_peer_as(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_peer_as);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_peer_as(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_peer_as");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetPeerAsRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_peer_as, pxa_outputs);
	async_bgp_0_3_set_peer_as(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "peer_as").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_peer_as(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "peer_as").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_peer_as", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_holdtime
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_holdtime", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_holdtime(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const uint32_t&	arg_holdtime,
	Bgp03SetHoldtimeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_holdtime(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_holdtime);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_holdtime(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_holdtime");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetHoldtimeRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_holdtime, pxa_outputs);
	async_bgp_0_3_set_holdtime(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "holdtime").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_holdtime(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "holdtime").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_holdtime", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_delay_open_time
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_delay_open_time", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_delay_open_time(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const uint32_t&	arg_delay_open_time,
	Bgp03SetDelayOpenTimeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_delay_open_time(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_delay_open_time);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_delay_open_time(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_delay_open_time");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetDelayOpenTimeRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_delay_open_time, pxa_outputs);
	async_bgp_0_3_set_delay_open_time(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "delay_open_time").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_delay_open_time(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "delay_open_time").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_delay_open_time", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_route_reflector_client
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_route_reflector_client", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_route_reflector_client(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const bool&	arg_state,
	Bgp03SetRouteReflectorClientCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_route_reflector_client(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_state);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_route_reflector_client(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_route_reflector_client");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetRouteReflectorClientRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_route_reflector_client, pxa_outputs);
	async_bgp_0_3_set_route_reflector_client(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "state").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_route_reflector_client(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "state").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_route_reflector_client", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_confederation_member
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_confederation_member", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_confederation_member(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const bool&	arg_state,
	Bgp03SetConfederationMemberCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_confederation_member(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_state);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_confederation_member(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_confederation_member");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetConfederationMemberRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_confederation_member, pxa_outputs);
	async_bgp_0_3_set_confederation_member(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "state").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_confederation_member(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "state").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_confederation_member", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_prefix_limit
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_prefix_limit", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_prefix_limit(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const uint32_t&	arg_maximum,
	const bool&	arg_state,
	Bgp03SetPrefixLimitCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_prefix_limit(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_maximum,
        arg_state);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_prefix_limit(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_prefix_limit");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetPrefixLimitRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_prefix_limit, pxa_outputs);
	async_bgp_0_3_set_prefix_limit(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "maximum").uint32(),
	    xa_inputs.get(5, "state").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_prefix_limit(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "maximum").uint32(),
	    xa_inputs.get(5, "state").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_prefix_limit", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_nexthop4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_nexthop4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_nexthop4(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const IPv4&	arg_next_hop,
	Bgp03SetNexthop4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_nexthop4(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_next_hop);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_nexthop4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_nexthop4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetNexthop4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_nexthop4, pxa_outputs);
	async_bgp_0_3_set_nexthop4(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "next_hop").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_nexthop4(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "next_hop").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_nexthop4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_peer_state
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_peer_state", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_peer_state(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const bool&	arg_toggle,
	Bgp03SetPeerStateCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_peer_state(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_toggle);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_peer_state(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_peer_state");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetPeerStateRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_peer_state, pxa_outputs);
	async_bgp_0_3_set_peer_state(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "toggle").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_peer_state(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "toggle").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_peer_state", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_peer_md5_password
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_peer_md5_password", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_peer_md5_password(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const string&	arg_password,
	Bgp03SetPeerMd5PasswordCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_peer_md5_password(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_password);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_peer_md5_password(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_peer_md5_password");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetPeerMd5PasswordRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_peer_md5_password, pxa_outputs);
	async_bgp_0_3_set_peer_md5_password(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "password").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_peer_md5_password(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "password").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_peer_md5_password", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_activate
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/activate", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_activate(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03ActivateCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_activate(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_activate(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/activate");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03ActivateRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_activate, pxa_outputs);
	async_bgp_0_3_activate(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_activate(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/activate", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_parameter
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_parameter", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_parameter(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const string&	arg_parameter,
	const bool&	arg_toggle,
	Bgp03SetParameterCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_parameter(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_parameter,
        arg_toggle);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_parameter(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_parameter");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetParameterRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_parameter, pxa_outputs);
	async_bgp_0_3_set_parameter(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "parameter").text(),
	    xa_inputs.get(5, "toggle").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_parameter(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "parameter").text(),
	    xa_inputs.get(5, "toggle").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_parameter", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_next_hop_rewrite_filter
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/next_hop_rewrite_filter", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_next_hop_rewrite_filter(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const IPv4&	arg_next_hop,
	Bgp03NextHopRewriteFilterCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_next_hop_rewrite_filter(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_next_hop);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_next_hop_rewrite_filter(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/next_hop_rewrite_filter");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03NextHopRewriteFilterRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_next_hop_rewrite_filter, pxa_outputs);
	async_bgp_0_3_next_hop_rewrite_filter(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "next_hop").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_next_hop_rewrite_filter(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "next_hop").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/next_hop_rewrite_filter", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_originate_route4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/originate_route4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_originate_route4(
	const IPv4Net&	arg_nlri,
	const IPv4&	arg_next_hop,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	Bgp03OriginateRoute4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_originate_route4(
        arg_nlri,
        arg_next_hop,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_originate_route4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/originate_route4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03OriginateRoute4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_originate_route4, pxa_outputs);
	async_bgp_0_3_originate_route4(
	    xa_inputs.get(0, "nlri").ipv4net(),
	    xa_inputs.get(1, "next_hop").ipv4(),
	    xa_inputs.get(2, "unicast").boolean(),
	    xa_inputs.get(3, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_originate_route4(
	    xa_inputs.get(0, "nlri").ipv4net(),
	    xa_inputs.get(1, "next_hop").ipv4(),
	    xa_inputs.get(2, "unicast").boolean(),
	    xa_inputs.get(3, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/originate_route4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_withdraw_route4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/withdraw_route4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_withdraw_route4(
	const IPv4Net&	arg_nlri,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	Bgp03WithdrawRoute4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_withdraw_route4(
        arg_nlri,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_withdraw_route4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/withdraw_route4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03WithdrawRoute4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_withdraw_route4, pxa_outputs);
	async_bgp_0_3_withdraw_route4(
	    xa_inputs.get(0, "nlri").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_withdraw_route4(
	    xa_inputs.get(0, "nlri").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/withdraw_route4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_trace
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/trace", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_trace(
	const string&	arg_tvar,
	const bool&	arg_enable,
	Bgp03TraceCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_trace(
        arg_tvar,
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_trace(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/trace");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03TraceRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_trace, pxa_outputs);
	async_bgp_0_3_trace(
	    xa_inputs.get(0, "tvar").text(),
	    xa_inputs.get(1, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_trace(
	    xa_inputs.get(0, "tvar").text(),
	    xa_inputs.get(1, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/trace", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_list_start
    (const XrlCmdError &e,
     const uint32_t* rarg_token,
     const bool* rarg_more,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_list_start", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("token", *rarg_token);
	    out.add("more", *rarg_more);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_list_start(
	Bgp03GetPeerListStartCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_token;
    bool rarg_more;
    XrlCmdError e = bgp_0_3_get_peer_list_start(
        rarg_token,
        rarg_more);
    return c_b->dispatch(e,
        &rarg_token,
        &rarg_more);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_list_start(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_list_start");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerListStartRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_list_start, pxa_outputs);
	async_bgp_0_3_get_peer_list_start( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_token;
    bool r_more;
    try {
	XrlCmdError e = bgp_0_3_get_peer_list_start(
	    r_token,
	    r_more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_list_start", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", r_token);
	pxa_outputs->add("more", r_more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_list_next
    (const XrlCmdError &e,
     const string* rarg_local_ip,
     const uint32_t* rarg_local_port,
     const string* rarg_peer_ip,
     const uint32_t* rarg_peer_port,
     const bool* rarg_more,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_list_next", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("local_ip", *rarg_local_ip);
	    out.add("local_port", *rarg_local_port);
	    out.add("peer_ip", *rarg_peer_ip);
	    out.add("peer_port", *rarg_peer_port);
	    out.add("more", *rarg_more);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_list_next(
	const uint32_t&	arg_token,
	Bgp03GetPeerListNextCB c_b)
{

    /* Return value declarations */
    string rarg_local_ip;
    uint32_t rarg_local_port;
    string rarg_peer_ip;
    uint32_t rarg_peer_port;
    bool rarg_more;
    XrlCmdError e = bgp_0_3_get_peer_list_next(
        arg_token,
        rarg_local_ip,
        rarg_local_port,
        rarg_peer_ip,
        rarg_peer_port,
        rarg_more);
    return c_b->dispatch(e,
        &rarg_local_ip,
        &rarg_local_port,
        &rarg_peer_ip,
        &rarg_peer_port,
        &rarg_more);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_list_next(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_list_next");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerListNextRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_list_next, pxa_outputs);
	async_bgp_0_3_get_peer_list_next(
	    xa_inputs.get(0, "token").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_local_ip;
    uint32_t r_local_port;
    string r_peer_ip;
    uint32_t r_peer_port;
    bool r_more;
    try {
	XrlCmdError e = bgp_0_3_get_peer_list_next(
	    xa_inputs.get(0, "token").uint32(),
	    r_local_ip,
	    r_local_port,
	    r_peer_ip,
	    r_peer_port,
	    r_more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_list_next", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("local_ip", r_local_ip);
	pxa_outputs->add("local_port", r_local_port);
	pxa_outputs->add("peer_ip", r_peer_ip);
	pxa_outputs->add("peer_port", r_peer_port);
	pxa_outputs->add("more", r_more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_id
    (const XrlCmdError &e,
     const IPv4* rarg_peer_id,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_id", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("peer_id", *rarg_peer_id);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_id(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerIdCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_peer_id;
    XrlCmdError e = bgp_0_3_get_peer_id(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_peer_id);
    return c_b->dispatch(e,
        &rarg_peer_id);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_id(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_id");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerIdRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_id, pxa_outputs);
	async_bgp_0_3_get_peer_id(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_peer_id;
    try {
	XrlCmdError e = bgp_0_3_get_peer_id(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_peer_id);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_id", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("peer_id", r_peer_id);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_status
    (const XrlCmdError &e,
     const uint32_t* rarg_peer_state,
     const uint32_t* rarg_admin_status,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_status", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("peer_state", *rarg_peer_state);
	    out.add("admin_status", *rarg_admin_status);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_status(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerStatusCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_peer_state;
    uint32_t rarg_admin_status;
    XrlCmdError e = bgp_0_3_get_peer_status(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_peer_state,
        rarg_admin_status);
    return c_b->dispatch(e,
        &rarg_peer_state,
        &rarg_admin_status);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_status(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_status");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerStatusRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_status, pxa_outputs);
	async_bgp_0_3_get_peer_status(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_peer_state;
    uint32_t r_admin_status;
    try {
	XrlCmdError e = bgp_0_3_get_peer_status(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_peer_state,
	    r_admin_status);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_status", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("peer_state", r_peer_state);
	pxa_outputs->add("admin_status", r_admin_status);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_negotiated_version
    (const XrlCmdError &e,
     const int32_t* rarg_neg_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_negotiated_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("neg_version", *rarg_neg_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_negotiated_version(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerNegotiatedVersionCB c_b)
{

    /* Return value declarations */
    int32_t rarg_neg_version;
    XrlCmdError e = bgp_0_3_get_peer_negotiated_version(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_neg_version);
    return c_b->dispatch(e,
        &rarg_neg_version);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_negotiated_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_negotiated_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerNegotiatedVersionRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_negotiated_version, pxa_outputs);
	async_bgp_0_3_get_peer_negotiated_version(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    int32_t r_neg_version;
    try {
	XrlCmdError e = bgp_0_3_get_peer_negotiated_version(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_neg_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_negotiated_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("neg_version", r_neg_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_as
    (const XrlCmdError &e,
     const string* rarg_peer_as,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_as", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("peer_as", *rarg_peer_as);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_as(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerAsCB c_b)
{

    /* Return value declarations */
    string rarg_peer_as;
    XrlCmdError e = bgp_0_3_get_peer_as(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_peer_as);
    return c_b->dispatch(e,
        &rarg_peer_as);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_as(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_as");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerAsRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_as, pxa_outputs);
	async_bgp_0_3_get_peer_as(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_peer_as;
    try {
	XrlCmdError e = bgp_0_3_get_peer_as(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_peer_as);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_as", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("peer_as", r_peer_as);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_msg_stats
    (const XrlCmdError &e,
     const uint32_t* rarg_in_updates,
     const uint32_t* rarg_out_updates,
     const uint32_t* rarg_in_msgs,
     const uint32_t* rarg_out_msgs,
     const uint32_t* rarg_last_error,
     const uint32_t* rarg_in_update_elapsed,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_msg_stats", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("in_updates", *rarg_in_updates);
	    out.add("out_updates", *rarg_out_updates);
	    out.add("in_msgs", *rarg_in_msgs);
	    out.add("out_msgs", *rarg_out_msgs);
	    out.add("last_error", *rarg_last_error);
	    out.add("in_update_elapsed", *rarg_in_update_elapsed);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_msg_stats(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerMsgStatsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_in_updates;
    uint32_t rarg_out_updates;
    uint32_t rarg_in_msgs;
    uint32_t rarg_out_msgs;
    uint32_t rarg_last_error;
    uint32_t rarg_in_update_elapsed;
    XrlCmdError e = bgp_0_3_get_peer_msg_stats(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_in_updates,
        rarg_out_updates,
        rarg_in_msgs,
        rarg_out_msgs,
        rarg_last_error,
        rarg_in_update_elapsed);
    return c_b->dispatch(e,
        &rarg_in_updates,
        &rarg_out_updates,
        &rarg_in_msgs,
        &rarg_out_msgs,
        &rarg_last_error,
        &rarg_in_update_elapsed);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_msg_stats(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_msg_stats");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerMsgStatsRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_msg_stats, pxa_outputs);
	async_bgp_0_3_get_peer_msg_stats(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_in_updates;
    uint32_t r_out_updates;
    uint32_t r_in_msgs;
    uint32_t r_out_msgs;
    uint32_t r_last_error;
    uint32_t r_in_update_elapsed;
    try {
	XrlCmdError e = bgp_0_3_get_peer_msg_stats(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_in_updates,
	    r_out_updates,
	    r_in_msgs,
	    r_out_msgs,
	    r_last_error,
	    r_in_update_elapsed);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_msg_stats", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("in_updates", r_in_updates);
	pxa_outputs->add("out_updates", r_out_updates);
	pxa_outputs->add("in_msgs", r_in_msgs);
	pxa_outputs->add("out_msgs", r_out_msgs);
	pxa_outputs->add("last_error", r_last_error);
	pxa_outputs->add("in_update_elapsed", r_in_update_elapsed);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_established_stats
    (const XrlCmdError &e,
     const uint32_t* rarg_transitions,
     const uint32_t* rarg_established_time,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_established_stats", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("transitions", *rarg_transitions);
	    out.add("established_time", *rarg_established_time);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_established_stats(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerEstablishedStatsCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_transitions;
    uint32_t rarg_established_time;
    XrlCmdError e = bgp_0_3_get_peer_established_stats(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_transitions,
        rarg_established_time);
    return c_b->dispatch(e,
        &rarg_transitions,
        &rarg_established_time);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_established_stats(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_established_stats");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerEstablishedStatsRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_established_stats, pxa_outputs);
	async_bgp_0_3_get_peer_established_stats(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_transitions;
    uint32_t r_established_time;
    try {
	XrlCmdError e = bgp_0_3_get_peer_established_stats(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_transitions,
	    r_established_time);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_established_stats", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("transitions", r_transitions);
	pxa_outputs->add("established_time", r_established_time);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_peer_timer_config
    (const XrlCmdError &e,
     const uint32_t* rarg_retry_interval,
     const uint32_t* rarg_hold_time,
     const uint32_t* rarg_keep_alive,
     const uint32_t* rarg_hold_time_conf,
     const uint32_t* rarg_keep_alive_conf,
     const uint32_t* rarg_min_as_orgination_interval,
     const uint32_t* rarg_min_route_adv_interval,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_peer_timer_config", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("retry_interval", *rarg_retry_interval);
	    out.add("hold_time", *rarg_hold_time);
	    out.add("keep_alive", *rarg_keep_alive);
	    out.add("hold_time_conf", *rarg_hold_time_conf);
	    out.add("keep_alive_conf", *rarg_keep_alive_conf);
	    out.add("min_as_orgination_interval", *rarg_min_as_orgination_interval);
	    out.add("min_route_adv_interval", *rarg_min_route_adv_interval);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_peer_timer_config(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetPeerTimerConfigCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_retry_interval;
    uint32_t rarg_hold_time;
    uint32_t rarg_keep_alive;
    uint32_t rarg_hold_time_conf;
    uint32_t rarg_keep_alive_conf;
    uint32_t rarg_min_as_orgination_interval;
    uint32_t rarg_min_route_adv_interval;
    XrlCmdError e = bgp_0_3_get_peer_timer_config(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_retry_interval,
        rarg_hold_time,
        rarg_keep_alive,
        rarg_hold_time_conf,
        rarg_keep_alive_conf,
        rarg_min_as_orgination_interval,
        rarg_min_route_adv_interval);
    return c_b->dispatch(e,
        &rarg_retry_interval,
        &rarg_hold_time,
        &rarg_keep_alive,
        &rarg_hold_time_conf,
        &rarg_keep_alive_conf,
        &rarg_min_as_orgination_interval,
        &rarg_min_route_adv_interval);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_peer_timer_config(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_peer_timer_config");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetPeerTimerConfigRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_peer_timer_config, pxa_outputs);
	async_bgp_0_3_get_peer_timer_config(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_retry_interval;
    uint32_t r_hold_time;
    uint32_t r_keep_alive;
    uint32_t r_hold_time_conf;
    uint32_t r_keep_alive_conf;
    uint32_t r_min_as_orgination_interval;
    uint32_t r_min_route_adv_interval;
    try {
	XrlCmdError e = bgp_0_3_get_peer_timer_config(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_retry_interval,
	    r_hold_time,
	    r_keep_alive,
	    r_hold_time_conf,
	    r_keep_alive_conf,
	    r_min_as_orgination_interval,
	    r_min_route_adv_interval);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_peer_timer_config", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("retry_interval", r_retry_interval);
	pxa_outputs->add("hold_time", r_hold_time);
	pxa_outputs->add("keep_alive", r_keep_alive);
	pxa_outputs->add("hold_time_conf", r_hold_time_conf);
	pxa_outputs->add("keep_alive_conf", r_keep_alive_conf);
	pxa_outputs->add("min_as_orgination_interval", r_min_as_orgination_interval);
	pxa_outputs->add("min_route_adv_interval", r_min_route_adv_interval);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_register_rib
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/register_rib", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_register_rib(
	const string&	arg_name,
	Bgp03RegisterRibCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_register_rib(
        arg_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_register_rib(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/register_rib");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03RegisterRibRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_register_rib, pxa_outputs);
	async_bgp_0_3_register_rib(
	    xa_inputs.get(0, "name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_register_rib(
	    xa_inputs.get(0, "name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/register_rib", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_v4_route_list_start
    (const XrlCmdError &e,
     const uint32_t* rarg_token,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_v4_route_list_start", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("token", *rarg_token);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_v4_route_list_start(
	const IPv4Net&	arg_net,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	Bgp03GetV4RouteListStartCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_token;
    XrlCmdError e = bgp_0_3_get_v4_route_list_start(
        arg_net,
        arg_unicast,
        arg_multicast,
        rarg_token);
    return c_b->dispatch(e,
        &rarg_token);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_v4_route_list_start(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_v4_route_list_start");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetV4RouteListStartRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_v4_route_list_start, pxa_outputs);
	async_bgp_0_3_get_v4_route_list_start(
	    xa_inputs.get(0, "net").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_token;
    try {
	XrlCmdError e = bgp_0_3_get_v4_route_list_start(
	    xa_inputs.get(0, "net").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    r_token);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_v4_route_list_start", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", r_token);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_v4_route_list_next
    (const XrlCmdError &e,
     const IPv4* rarg_peer_id,
     const IPv4Net* rarg_net,
     const uint32_t* rarg_best_and_origin,
     const vector<uint8_t>* rarg_aspath,
     const IPv4* rarg_nexthop,
     const int32_t* rarg_med,
     const int32_t* rarg_localpref,
     const int32_t* rarg_atomic_agg,
     const vector<uint8_t>* rarg_aggregator,
     const int32_t* rarg_calc_localpref,
     const vector<uint8_t>* rarg_attr_unknown,
     const bool* rarg_valid,
     const bool* rarg_unicast,
     const bool* rarg_multicast,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_v4_route_list_next", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("peer_id", *rarg_peer_id);
	    out.add("net", *rarg_net);
	    out.add("best_and_origin", *rarg_best_and_origin);
	    out.add("aspath", *rarg_aspath);
	    out.add("nexthop", *rarg_nexthop);
	    out.add("med", *rarg_med);
	    out.add("localpref", *rarg_localpref);
	    out.add("atomic_agg", *rarg_atomic_agg);
	    out.add("aggregator", *rarg_aggregator);
	    out.add("calc_localpref", *rarg_calc_localpref);
	    out.add("attr_unknown", *rarg_attr_unknown);
	    out.add("valid", *rarg_valid);
	    out.add("unicast", *rarg_unicast);
	    out.add("multicast", *rarg_multicast);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_v4_route_list_next(
	const uint32_t&	arg_token,
	Bgp03GetV4RouteListNextCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_peer_id;
    IPv4Net rarg_net;
    uint32_t rarg_best_and_origin;
    vector<uint8_t> rarg_aspath;
    IPv4 rarg_nexthop;
    int32_t rarg_med;
    int32_t rarg_localpref;
    int32_t rarg_atomic_agg;
    vector<uint8_t> rarg_aggregator;
    int32_t rarg_calc_localpref;
    vector<uint8_t> rarg_attr_unknown;
    bool rarg_valid;
    bool rarg_unicast;
    bool rarg_multicast;
    XrlCmdError e = bgp_0_3_get_v4_route_list_next(
        arg_token,
        rarg_peer_id,
        rarg_net,
        rarg_best_and_origin,
        rarg_aspath,
        rarg_nexthop,
        rarg_med,
        rarg_localpref,
        rarg_atomic_agg,
        rarg_aggregator,
        rarg_calc_localpref,
        rarg_attr_unknown,
        rarg_valid,
        rarg_unicast,
        rarg_multicast);
    return c_b->dispatch(e,
        &rarg_peer_id,
        &rarg_net,
        &rarg_best_and_origin,
        &rarg_aspath,
        &rarg_nexthop,
        &rarg_med,
        &rarg_localpref,
        &rarg_atomic_agg,
        &rarg_aggregator,
        &rarg_calc_localpref,
        &rarg_attr_unknown,
        &rarg_valid,
        &rarg_unicast,
        &rarg_multicast);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_v4_route_list_next(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_v4_route_list_next");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetV4RouteListNextRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_v4_route_list_next, pxa_outputs);
	async_bgp_0_3_get_v4_route_list_next(
	    xa_inputs.get(0, "token").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_peer_id;
    IPv4Net r_net;
    uint32_t r_best_and_origin;
    vector<uint8_t> r_aspath;
    IPv4 r_nexthop;
    int32_t r_med;
    int32_t r_localpref;
    int32_t r_atomic_agg;
    vector<uint8_t> r_aggregator;
    int32_t r_calc_localpref;
    vector<uint8_t> r_attr_unknown;
    bool r_valid;
    bool r_unicast;
    bool r_multicast;
    try {
	XrlCmdError e = bgp_0_3_get_v4_route_list_next(
	    xa_inputs.get(0, "token").uint32(),
	    r_peer_id,
	    r_net,
	    r_best_and_origin,
	    r_aspath,
	    r_nexthop,
	    r_med,
	    r_localpref,
	    r_atomic_agg,
	    r_aggregator,
	    r_calc_localpref,
	    r_attr_unknown,
	    r_valid,
	    r_unicast,
	    r_multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_v4_route_list_next", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("peer_id", r_peer_id);
	pxa_outputs->add("net", r_net);
	pxa_outputs->add("best_and_origin", r_best_and_origin);
	pxa_outputs->add("aspath", r_aspath);
	pxa_outputs->add("nexthop", r_nexthop);
	pxa_outputs->add("med", r_med);
	pxa_outputs->add("localpref", r_localpref);
	pxa_outputs->add("atomic_agg", r_atomic_agg);
	pxa_outputs->add("aggregator", r_aggregator);
	pxa_outputs->add("calc_localpref", r_calc_localpref);
	pxa_outputs->add("attr_unknown", r_attr_unknown);
	pxa_outputs->add("valid", r_valid);
	pxa_outputs->add("unicast", r_unicast);
	pxa_outputs->add("multicast", r_multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_set_nexthop6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/set_nexthop6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_set_nexthop6(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	const IPv6&	arg_next_hop,
	Bgp03SetNexthop6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_set_nexthop6(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        arg_next_hop);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_set_nexthop6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/set_nexthop6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03SetNexthop6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_set_nexthop6, pxa_outputs);
	async_bgp_0_3_set_nexthop6(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "next_hop").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_set_nexthop6(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    xa_inputs.get(4, "next_hop").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/set_nexthop6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_nexthop6
    (const XrlCmdError &e,
     const IPv6* rarg_next_hop,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_nexthop6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("next_hop", *rarg_next_hop);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_nexthop6(
	const string&	arg_local_ip,
	const uint32_t&	arg_local_port,
	const string&	arg_peer_ip,
	const uint32_t&	arg_peer_port,
	Bgp03GetNexthop6CB c_b)
{

    /* Return value declarations */
    IPv6 rarg_next_hop;
    XrlCmdError e = bgp_0_3_get_nexthop6(
        arg_local_ip,
        arg_local_port,
        arg_peer_ip,
        arg_peer_port,
        rarg_next_hop);
    return c_b->dispatch(e,
        &rarg_next_hop);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_nexthop6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_nexthop6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetNexthop6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_nexthop6, pxa_outputs);
	async_bgp_0_3_get_nexthop6(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv6 r_next_hop;
    try {
	XrlCmdError e = bgp_0_3_get_nexthop6(
	    xa_inputs.get(0, "local_ip").text(),
	    xa_inputs.get(1, "local_port").uint32(),
	    xa_inputs.get(2, "peer_ip").text(),
	    xa_inputs.get(3, "peer_port").uint32(),
	    r_next_hop);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_nexthop6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("next_hop", r_next_hop);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_withdraw_route6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/withdraw_route6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_withdraw_route6(
	const IPv6Net&	arg_nlri,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	Bgp03WithdrawRoute6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_withdraw_route6(
        arg_nlri,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_withdraw_route6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/withdraw_route6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03WithdrawRoute6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_withdraw_route6, pxa_outputs);
	async_bgp_0_3_withdraw_route6(
	    xa_inputs.get(0, "nlri").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_withdraw_route6(
	    xa_inputs.get(0, "nlri").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/withdraw_route6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_v6_route_list_start
    (const XrlCmdError &e,
     const uint32_t* rarg_token,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_v6_route_list_start", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("token", *rarg_token);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_v6_route_list_start(
	const IPv6Net&	arg_net,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	Bgp03GetV6RouteListStartCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_token;
    XrlCmdError e = bgp_0_3_get_v6_route_list_start(
        arg_net,
        arg_unicast,
        arg_multicast,
        rarg_token);
    return c_b->dispatch(e,
        &rarg_token);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_v6_route_list_start(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_v6_route_list_start");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetV6RouteListStartRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_v6_route_list_start, pxa_outputs);
	async_bgp_0_3_get_v6_route_list_start(
	    xa_inputs.get(0, "net").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_token;
    try {
	XrlCmdError e = bgp_0_3_get_v6_route_list_start(
	    xa_inputs.get(0, "net").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    r_token);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_v6_route_list_start", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", r_token);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_originate_route6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/originate_route6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_originate_route6(
	const IPv6Net&	arg_nlri,
	const IPv6&	arg_next_hop,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	Bgp03OriginateRoute6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = bgp_0_3_originate_route6(
        arg_nlri,
        arg_next_hop,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_originate_route6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/originate_route6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03OriginateRoute6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_originate_route6, pxa_outputs);
	async_bgp_0_3_originate_route6(
	    xa_inputs.get(0, "nlri").ipv6net(),
	    xa_inputs.get(1, "next_hop").ipv6(),
	    xa_inputs.get(2, "unicast").boolean(),
	    xa_inputs.get(3, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = bgp_0_3_originate_route6(
	    xa_inputs.get(0, "nlri").ipv6net(),
	    xa_inputs.get(1, "next_hop").ipv6(),
	    xa_inputs.get(2, "unicast").boolean(),
	    xa_inputs.get(3, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/originate_route6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_bgp_0_3_get_v6_route_list_next
    (const XrlCmdError &e,
     const IPv4* rarg_peer_id,
     const IPv6Net* rarg_net,
     const uint32_t* rarg_best_and_origin,
     const vector<uint8_t>* rarg_aspath,
     const IPv6* rarg_nexthop,
     const int32_t* rarg_med,
     const int32_t* rarg_localpref,
     const int32_t* rarg_atomic_agg,
     const vector<uint8_t>* rarg_aggregator,
     const int32_t* rarg_calc_localpref,
     const vector<uint8_t>* rarg_attr_unknown,
     const bool* rarg_valid,
     const bool* rarg_unicast,
     const bool* rarg_multicast,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "bgp/0.3/get_v6_route_list_next", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("peer_id", *rarg_peer_id);
	    out.add("net", *rarg_net);
	    out.add("best_and_origin", *rarg_best_and_origin);
	    out.add("aspath", *rarg_aspath);
	    out.add("nexthop", *rarg_nexthop);
	    out.add("med", *rarg_med);
	    out.add("localpref", *rarg_localpref);
	    out.add("atomic_agg", *rarg_atomic_agg);
	    out.add("aggregator", *rarg_aggregator);
	    out.add("calc_localpref", *rarg_calc_localpref);
	    out.add("attr_unknown", *rarg_attr_unknown);
	    out.add("valid", *rarg_valid);
	    out.add("unicast", *rarg_unicast);
	    out.add("multicast", *rarg_multicast);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_bgp_0_3_get_v6_route_list_next(
	const uint32_t&	arg_token,
	Bgp03GetV6RouteListNextCB c_b)
{

    /* Return value declarations */
    IPv4 rarg_peer_id;
    IPv6Net rarg_net;
    uint32_t rarg_best_and_origin;
    vector<uint8_t> rarg_aspath;
    IPv6 rarg_nexthop;
    int32_t rarg_med;
    int32_t rarg_localpref;
    int32_t rarg_atomic_agg;
    vector<uint8_t> rarg_aggregator;
    int32_t rarg_calc_localpref;
    vector<uint8_t> rarg_attr_unknown;
    bool rarg_valid;
    bool rarg_unicast;
    bool rarg_multicast;
    XrlCmdError e = bgp_0_3_get_v6_route_list_next(
        arg_token,
        rarg_peer_id,
        rarg_net,
        rarg_best_and_origin,
        rarg_aspath,
        rarg_nexthop,
        rarg_med,
        rarg_localpref,
        rarg_atomic_agg,
        rarg_aggregator,
        rarg_calc_localpref,
        rarg_attr_unknown,
        rarg_valid,
        rarg_unicast,
        rarg_multicast);
    return c_b->dispatch(e,
        &rarg_peer_id,
        &rarg_net,
        &rarg_best_and_origin,
        &rarg_aspath,
        &rarg_nexthop,
        &rarg_med,
        &rarg_localpref,
        &rarg_atomic_agg,
        &rarg_aggregator,
        &rarg_calc_localpref,
        &rarg_attr_unknown,
        &rarg_valid,
        &rarg_unicast,
        &rarg_multicast);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_bgp_0_3_get_v6_route_list_next(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "bgp/0.3/get_v6_route_list_next");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Bgp03GetV6RouteListNextRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_bgp_0_3_get_v6_route_list_next, pxa_outputs);
	async_bgp_0_3_get_v6_route_list_next(
	    xa_inputs.get(0, "token").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_peer_id;
    IPv6Net r_net;
    uint32_t r_best_and_origin;
    vector<uint8_t> r_aspath;
    IPv6 r_nexthop;
    int32_t r_med;
    int32_t r_localpref;
    int32_t r_atomic_agg;
    vector<uint8_t> r_aggregator;
    int32_t r_calc_localpref;
    vector<uint8_t> r_attr_unknown;
    bool r_valid;
    bool r_unicast;
    bool r_multicast;
    try {
	XrlCmdError e = bgp_0_3_get_v6_route_list_next(
	    xa_inputs.get(0, "token").uint32(),
	    r_peer_id,
	    r_net,
	    r_best_and_origin,
	    r_aspath,
	    r_nexthop,
	    r_med,
	    r_localpref,
	    r_atomic_agg,
	    r_aggregator,
	    r_calc_localpref,
	    r_attr_unknown,
	    r_valid,
	    r_unicast,
	    r_multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "bgp/0.3/get_v6_route_list_next", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("peer_id", r_peer_id);
	pxa_outputs->add("net", r_net);
	pxa_outputs->add("best_and_origin", r_best_and_origin);
	pxa_outputs->add("aspath", r_aspath);
	pxa_outputs->add("nexthop", r_nexthop);
	pxa_outputs->add("med", r_med);
	pxa_outputs->add("localpref", r_localpref);
	pxa_outputs->add("atomic_agg", r_atomic_agg);
	pxa_outputs->add("aggregator", r_aggregator);
	pxa_outputs->add("calc_localpref", r_calc_localpref);
	pxa_outputs->add("attr_unknown", r_attr_unknown);
	pxa_outputs->add("valid", r_valid);
	pxa_outputs->add("unicast", r_unicast);
	pxa_outputs->add("multicast", r_multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_finder_event_observer_0_1_xrl_target_birth
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_finder_event_observer_0_1_xrl_target_birth(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetBirthCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_birth");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetBirthRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_finder_event_observer_0_1_xrl_target_birth, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_finder_event_observer_0_1_xrl_target_death
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_finder_event_observer_0_1_xrl_target_death(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetDeathCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_death");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetDeathRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_finder_event_observer_0_1_xrl_target_death, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_backend_0_1_configure
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_backend/0.1/configure", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_backend_0_1_configure(
	const uint32_t&	arg_filter,
	const string&	arg_conf,
	PolicyBackend01ConfigureCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_backend_0_1_configure(
        arg_filter,
        arg_conf);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_backend_0_1_configure(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "policy_backend/0.1/configure");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyBackend01ConfigureRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_backend_0_1_configure, pxa_outputs);
	async_policy_backend_0_1_configure(
	    xa_inputs.get(0, "filter").uint32(),
	    xa_inputs.get(1, "conf").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_backend_0_1_configure(
	    xa_inputs.get(0, "filter").uint32(),
	    xa_inputs.get(1, "conf").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_backend/0.1/configure", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_backend_0_1_reset
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_backend/0.1/reset", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_backend_0_1_reset(
	const uint32_t&	arg_filter,
	PolicyBackend01ResetCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_backend_0_1_reset(
        arg_filter);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_backend_0_1_reset(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "policy_backend/0.1/reset");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyBackend01ResetRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_backend_0_1_reset, pxa_outputs);
	async_policy_backend_0_1_reset(
	    xa_inputs.get(0, "filter").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_backend_0_1_reset(
	    xa_inputs.get(0, "filter").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_backend/0.1/reset", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_backend_0_1_push_routes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_backend/0.1/push_routes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_backend_0_1_push_routes(
	PolicyBackend01PushRoutesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_backend_0_1_push_routes();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_backend_0_1_push_routes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "policy_backend/0.1/push_routes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyBackend01PushRoutesRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_backend_0_1_push_routes, pxa_outputs);
	async_policy_backend_0_1_push_routes( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_backend_0_1_push_routes();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_backend/0.1/push_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_redist4_0_1_add_route4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_redist4/0.1/add_route4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_redist4_0_1_add_route4(
	const IPv4Net&	arg_network,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	const IPv4&	arg_nexthop,
	const uint32_t&	arg_metric,
	const XrlAtomList&	arg_policytags,
	PolicyRedist401AddRoute4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_redist4_0_1_add_route4(
        arg_network,
        arg_unicast,
        arg_multicast,
        arg_nexthop,
        arg_metric,
        arg_policytags);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_redist4_0_1_add_route4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "policy_redist4/0.1/add_route4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyRedist401AddRoute4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_redist4_0_1_add_route4, pxa_outputs);
	async_policy_redist4_0_1_add_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    xa_inputs.get(3, "nexthop").ipv4(),
	    xa_inputs.get(4, "metric").uint32(),
	    xa_inputs.get(5, "policytags").list(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_redist4_0_1_add_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    xa_inputs.get(3, "nexthop").ipv4(),
	    xa_inputs.get(4, "metric").uint32(),
	    xa_inputs.get(5, "policytags").list());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_redist4/0.1/add_route4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_redist4_0_1_delete_route4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_redist4/0.1/delete_route4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_redist4_0_1_delete_route4(
	const IPv4Net&	arg_network,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	PolicyRedist401DeleteRoute4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_redist4_0_1_delete_route4(
        arg_network,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_redist4_0_1_delete_route4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "policy_redist4/0.1/delete_route4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyRedist401DeleteRoute4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_redist4_0_1_delete_route4, pxa_outputs);
	async_policy_redist4_0_1_delete_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_redist4_0_1_delete_route4(
	    xa_inputs.get(0, "network").ipv4net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_redist4/0.1/delete_route4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_rib_client_0_1_route_info_changed4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_changed4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_rib_client_0_1_route_info_changed4(
	const IPv4&	arg_addr,
	const uint32_t&	arg_prefix_len,
	const IPv4&	arg_nexthop,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_protocol_origin,
	RibClient01RouteInfoChanged4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_changed4(
        arg_addr,
        arg_prefix_len,
        arg_nexthop,
        arg_metric,
        arg_admin_distance,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_rib_client_0_1_route_info_changed4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_changed4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoChanged4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_rib_client_0_1_route_info_changed4, pxa_outputs);
	async_rib_client_0_1_route_info_changed4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_changed4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_changed4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_rib_client_0_1_route_info_invalid4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_invalid4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_rib_client_0_1_route_info_invalid4(
	const IPv4&	arg_addr,
	const uint32_t&	arg_prefix_len,
	RibClient01RouteInfoInvalid4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_invalid4(
        arg_addr,
        arg_prefix_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_rib_client_0_1_route_info_invalid4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_invalid4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoInvalid4RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_rib_client_0_1_route_info_invalid4, pxa_outputs);
	async_rib_client_0_1_route_info_invalid4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_invalid4(
	    xa_inputs.get(0, "addr").ipv4(),
	    xa_inputs.get(1, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_invalid4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_rib_client_0_1_route_info_changed6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_changed6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_rib_client_0_1_route_info_changed6(
	const IPv6&	arg_addr,
	const uint32_t&	arg_prefix_len,
	const IPv6&	arg_nexthop,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_protocol_origin,
	RibClient01RouteInfoChanged6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_changed6(
        arg_addr,
        arg_prefix_len,
        arg_nexthop,
        arg_metric,
        arg_admin_distance,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_rib_client_0_1_route_info_changed6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_changed6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoChanged6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_rib_client_0_1_route_info_changed6, pxa_outputs);
	async_rib_client_0_1_route_info_changed6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_changed6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "metric").uint32(),
	    xa_inputs.get(4, "admin_distance").uint32(),
	    xa_inputs.get(5, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_changed6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_rib_client_0_1_route_info_invalid6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "rib_client/0.1/route_info_invalid6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_rib_client_0_1_route_info_invalid6(
	const IPv6&	arg_addr,
	const uint32_t&	arg_prefix_len,
	RibClient01RouteInfoInvalid6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = rib_client_0_1_route_info_invalid6(
        arg_addr,
        arg_prefix_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_rib_client_0_1_route_info_invalid6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "rib_client/0.1/route_info_invalid6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RibClient01RouteInfoInvalid6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_rib_client_0_1_route_info_invalid6, pxa_outputs);
	async_rib_client_0_1_route_info_invalid6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = rib_client_0_1_route_info_invalid6(
	    xa_inputs.get(0, "addr").ipv6(),
	    xa_inputs.get(1, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "rib_client/0.1/route_info_invalid6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_redist6_0_1_add_route6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_redist6/0.1/add_route6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_redist6_0_1_add_route6(
	const IPv6Net&	arg_network,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	const IPv6&	arg_nexthop,
	const uint32_t&	arg_metric,
	const XrlAtomList&	arg_policytags,
	PolicyRedist601AddRoute6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_redist6_0_1_add_route6(
        arg_network,
        arg_unicast,
        arg_multicast,
        arg_nexthop,
        arg_metric,
        arg_policytags);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_redist6_0_1_add_route6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "policy_redist6/0.1/add_route6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyRedist601AddRoute6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_redist6_0_1_add_route6, pxa_outputs);
	async_policy_redist6_0_1_add_route6(
	    xa_inputs.get(0, "network").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    xa_inputs.get(3, "nexthop").ipv6(),
	    xa_inputs.get(4, "metric").uint32(),
	    xa_inputs.get(5, "policytags").list(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_redist6_0_1_add_route6(
	    xa_inputs.get(0, "network").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(),
	    xa_inputs.get(3, "nexthop").ipv6(),
	    xa_inputs.get(4, "metric").uint32(),
	    xa_inputs.get(5, "policytags").list());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_redist6/0.1/add_route6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_policy_redist6_0_1_delete_route6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "policy_redist6/0.1/delete_route6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_policy_redist6_0_1_delete_route6(
	const IPv6Net&	arg_network,
	const bool&	arg_unicast,
	const bool&	arg_multicast,
	PolicyRedist601DeleteRoute6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = policy_redist6_0_1_delete_route6(
        arg_network,
        arg_unicast,
        arg_multicast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_policy_redist6_0_1_delete_route6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "policy_redist6/0.1/delete_route6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	PolicyRedist601DeleteRoute6RF mycb =
	    callback(this, &XrlBgpTargetBase::callback_policy_redist6_0_1_delete_route6, pxa_outputs);
	async_policy_redist6_0_1_delete_route6(
	    xa_inputs.get(0, "network").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = policy_redist6_0_1_delete_route6(
	    xa_inputs.get(0, "network").ipv6net(),
	    xa_inputs.get(1, "unicast").boolean(),
	    xa_inputs.get(2, "multicast").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "policy_redist6/0.1/delete_route6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_profile_0_1_enable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/enable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_profile_0_1_enable(
	const string&	arg_pname,
	Profile01EnableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_enable(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_profile_0_1_enable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/enable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01EnableRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_profile_0_1_enable, pxa_outputs);
	async_profile_0_1_enable(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_enable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/enable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_profile_0_1_disable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/disable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_profile_0_1_disable(
	const string&	arg_pname,
	Profile01DisableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_disable(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_profile_0_1_disable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/disable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01DisableRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_profile_0_1_disable, pxa_outputs);
	async_profile_0_1_disable(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_disable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/disable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_profile_0_1_get_entries
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/get_entries", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_profile_0_1_get_entries(
	const string&	arg_pname,
	const string&	arg_instance_name,
	Profile01GetEntriesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_get_entries(
        arg_pname,
        arg_instance_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_profile_0_1_get_entries(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/get_entries");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01GetEntriesRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_profile_0_1_get_entries, pxa_outputs);
	async_profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/get_entries", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_profile_0_1_clear
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/clear", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_profile_0_1_clear(
	const string&	arg_pname,
	Profile01ClearCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_clear(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_profile_0_1_clear(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/clear");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01ClearRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_profile_0_1_clear, pxa_outputs);
	async_profile_0_1_clear(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_clear(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/clear", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlBgpTargetBase::callback_profile_0_1_list
    (const XrlCmdError &e,
     const string* rarg_info,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("info", *rarg_info);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlBgpTargetBase::async_profile_0_1_list(
	Profile01ListCB c_b)
{

    /* Return value declarations */
    string rarg_info;
    XrlCmdError e = profile_0_1_list(
        rarg_info);
    return c_b->dispatch(e,
        &rarg_info);
}
#endif

XrlCmdRT
XrlBgpTargetBase::handle_profile_0_1_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01ListRF mycb =
	    callback(this, &XrlBgpTargetBase::callback_profile_0_1_list, pxa_outputs);
	async_profile_0_1_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_info;
    try {
	XrlCmdError e = profile_0_1_list(
	    r_info);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("info", r_info);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}

void
XrlBgpTargetBase::add_handlers()
{
    for (size_t i = 0; i < num_handlers; ++i) {
        if (!_cmds->add_handler(handlers[i].name,
                                callback(this, handlers[i].method))) {
            XLOG_ERROR("Failed to register xrl handler finder://%s/%s", "bgp", handlers[i].name);
        }
    }
    _cmds->finalize();
}

void
XrlBgpTargetBase::remove_handlers()
{
     for (size_t i = 0; i < num_handlers; ++i) {
         _cmds->remove_handler(handlers[i].name);
     }
}
