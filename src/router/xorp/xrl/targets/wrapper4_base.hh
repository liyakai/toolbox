/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/wrapper4_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_WRAPPER4_BASE_HH__
#define __XRL_TARGETS_WRAPPER4_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlWrapper4Target"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlWrapper4TargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlWrapper4TargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlWrapper4TargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "wrapper4/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when a packet arrives
     *  from an IPv4 source.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param if_name the interface name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param vif_name the vif name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param src_host the originating host.
     *
     *  @param src_port the originating IP port.
     *
     *  @param data the data received.
     */
    virtual XrlCmdError socket4_user_0_1_recv_event(
	// Input values,
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01RecvEventRF;

    class Socket4User01RecvEventCB {
        Socket4User01RecvEventRF cb;

    public:
        operator const Socket4User01RecvEventRF& () const { return cb; }
        const Socket4User01RecvEventRF& operator ->() const { return cb; }
        Socket4User01RecvEventCB(const Socket4User01RecvEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01RecvEventRsp :
      public Socket4User01RecvEventCB {
        Socket4User01RecvEventRsp(const Socket4User01RecvEventRF& cb)
          : Socket4User01RecvEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_recv_event
       (
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data,
	Socket4User01RecvEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when a connection
     *  request is received from an IPv4 source. It applies only to TCP
     *  sockets.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param src_host the connecting host.
     *
     *  @param src_port the connecting IP port.
     *
     *  @param new_sockid the identifier associated with the new socket that
     *  has been created to handle the new connection.
     *
     *  @param accept if true, the connection request has been accepted,
     *  otherwise it has been rejected.
     */
    virtual XrlCmdError socket4_user_0_1_inbound_connect_event(
	// Input values,
	const string&	sockid,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Socket4User01InboundConnectEventRF;

    class Socket4User01InboundConnectEventCB {
        Socket4User01InboundConnectEventRF cb;

    public:
        operator const Socket4User01InboundConnectEventRF& () const { return cb; }
        const Socket4User01InboundConnectEventRF& operator ->() const { return cb; }
        Socket4User01InboundConnectEventCB(const Socket4User01InboundConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Socket4User01InboundConnectEventRsp :
      public Socket4User01InboundConnectEventCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Socket4User01InboundConnectEventRsp(const Socket4User01InboundConnectEventRF& cb)
          : Socket4User01InboundConnectEventCB(cb) { }

        void respond() const {
            Socket4User01InboundConnectEventCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_user_0_1_inbound_connect_event
       (
	const string&	sockid,
	const IPv4&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	Socket4User01InboundConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when an outgoing
     *  connection request originated by the local host is completed. It
     *  applies only to TCP sockets. Note that if the connection failed, the
     *  error_event will be dispatched instead.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket4_user_0_1_outgoing_connect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01OutgoingConnectEventRF;

    class Socket4User01OutgoingConnectEventCB {
        Socket4User01OutgoingConnectEventRF cb;

    public:
        operator const Socket4User01OutgoingConnectEventRF& () const { return cb; }
        const Socket4User01OutgoingConnectEventRF& operator ->() const { return cb; }
        Socket4User01OutgoingConnectEventCB(const Socket4User01OutgoingConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01OutgoingConnectEventRsp :
      public Socket4User01OutgoingConnectEventCB {
        Socket4User01OutgoingConnectEventRsp(const Socket4User01OutgoingConnectEventRF& cb)
          : Socket4User01OutgoingConnectEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_outgoing_connect_event
       (
	const string&	sockid,
	Socket4User01OutgoingConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when an error occurs.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param error a textual description of the error.
     *
     *  @param fatal indication of whether socket is shutdown because of error.
     */
    virtual XrlCmdError socket4_user_0_1_error_event(
	// Input values,
	const string&	sockid,
	const string&	error,
	const bool&	fatal) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01ErrorEventRF;

    class Socket4User01ErrorEventCB {
        Socket4User01ErrorEventRF cb;

    public:
        operator const Socket4User01ErrorEventRF& () const { return cb; }
        const Socket4User01ErrorEventRF& operator ->() const { return cb; }
        Socket4User01ErrorEventCB(const Socket4User01ErrorEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01ErrorEventRsp :
      public Socket4User01ErrorEventCB {
        Socket4User01ErrorEventRsp(const Socket4User01ErrorEventRF& cb)
          : Socket4User01ErrorEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_error_event
       (
	const string&	sockid,
	const string&	error,
	const bool&	fatal,
	Socket4User01ErrorEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket4/0.1 when the peer has
     *  closed the connection. It applies only to TCP sockets. Note that the
     *  socket itself is left open and must be explicitly closed.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket4_user_0_1_disconnect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket4User01DisconnectEventRF;

    class Socket4User01DisconnectEventCB {
        Socket4User01DisconnectEventRF cb;

    public:
        operator const Socket4User01DisconnectEventRF& () const { return cb; }
        const Socket4User01DisconnectEventRF& operator ->() const { return cb; }
        Socket4User01DisconnectEventCB(const Socket4User01DisconnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket4User01DisconnectEventRsp :
      public Socket4User01DisconnectEventCB {
        Socket4User01DisconnectEventRsp(const Socket4User01DisconnectEventRF& cb)
          : Socket4User01DisconnectEventCB(cb) { }

    };

    virtual void async_socket4_user_0_1_disconnect_event
       (
	const string&	sockid,
	Socket4User01DisconnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv4 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist4_0_1_add_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401AddRoute4RF;

    class PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4RF cb;

    public:
        operator const PolicyRedist401AddRoute4RF& () const { return cb; }
        const PolicyRedist401AddRoute4RF& operator ->() const { return cb; }
        PolicyRedist401AddRoute4CB(const PolicyRedist401AddRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401AddRoute4Rsp :
      public PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4Rsp(const PolicyRedist401AddRoute4RF& cb)
          : PolicyRedist401AddRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_add_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist401AddRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv4 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist4_0_1_delete_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401DeleteRoute4RF;

    class PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4RF cb;

    public:
        operator const PolicyRedist401DeleteRoute4RF& () const { return cb; }
        const PolicyRedist401DeleteRoute4RF& operator ->() const { return cb; }
        PolicyRedist401DeleteRoute4CB(const PolicyRedist401DeleteRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401DeleteRoute4Rsp :
      public PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4Rsp(const PolicyRedist401DeleteRoute4RF& cb)
          : PolicyRedist401DeleteRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_delete_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist401DeleteRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_enable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01EnableRF;

    class Profile01EnableCB {
        Profile01EnableRF cb;

    public:
        operator const Profile01EnableRF& () const { return cb; }
        const Profile01EnableRF& operator ->() const { return cb; }
        Profile01EnableCB(const Profile01EnableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01EnableRsp :
      public Profile01EnableCB {
        Profile01EnableRsp(const Profile01EnableRF& cb)
          : Profile01EnableCB(cb) { }

    };

    virtual void async_profile_0_1_enable
       (
	const string&	pname,
	Profile01EnableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_disable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01DisableRF;

    class Profile01DisableCB {
        Profile01DisableRF cb;

    public:
        operator const Profile01DisableRF& () const { return cb; }
        const Profile01DisableRF& operator ->() const { return cb; }
        Profile01DisableCB(const Profile01DisableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01DisableRsp :
      public Profile01DisableCB {
        Profile01DisableRsp(const Profile01DisableRF& cb)
          : Profile01DisableCB(cb) { }

    };

    virtual void async_profile_0_1_disable
       (
	const string&	pname,
	Profile01DisableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get log entries.
     *
     *  @param pname profile variable
     *
     *  @param instance_name to send the profiling info to.
     */
    virtual XrlCmdError profile_0_1_get_entries(
	// Input values,
	const string&	pname,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01GetEntriesRF;

    class Profile01GetEntriesCB {
        Profile01GetEntriesRF cb;

    public:
        operator const Profile01GetEntriesRF& () const { return cb; }
        const Profile01GetEntriesRF& operator ->() const { return cb; }
        Profile01GetEntriesCB(const Profile01GetEntriesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01GetEntriesRsp :
      public Profile01GetEntriesCB {
        Profile01GetEntriesRsp(const Profile01GetEntriesRF& cb)
          : Profile01GetEntriesCB(cb) { }

    };

    virtual void async_profile_0_1_get_entries
       (
	const string&	pname,
	const string&	instance_name,
	Profile01GetEntriesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the profiling entries
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_clear(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01ClearRF;

    class Profile01ClearCB {
        Profile01ClearRF cb;

    public:
        operator const Profile01ClearRF& () const { return cb; }
        const Profile01ClearRF& operator ->() const { return cb; }
        Profile01ClearCB(const Profile01ClearRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01ClearRsp :
      public Profile01ClearCB {
        Profile01ClearRsp(const Profile01ClearRF& cb)
          : Profile01ClearCB(cb) { }

    };

    virtual void async_profile_0_1_clear
       (
	const string&	pname,
	Profile01ClearCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  List all the profiling variables registered with this target.
     */
    virtual XrlCmdError profile_0_1_list(
	// Output values,
	string&	info) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Profile01ListRF;

    class Profile01ListCB {
        Profile01ListRF cb;

    public:
        operator const Profile01ListRF& () const { return cb; }
        const Profile01ListRF& operator ->() const { return cb; }
        Profile01ListCB(const Profile01ListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_info) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_info);
        }
    };

    struct Profile01ListRsp :
      public Profile01ListCB {
        struct args_str {
            string info;
        };

    private:
        args_str args;

    public:
        Profile01ListRsp(const Profile01ListRF& cb)
          : Profile01ListCB(cb) { }

        void respond() const {
            Profile01ListCB::
            respond(args.info);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_profile_0_1_list
       (
	Profile01ListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get admin distance.
     */
    virtual XrlCmdError wrapper4_0_1_get_admin_distance(
	// Output values,
	uint32_t&	admin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Wrapper401GetAdminDistanceRF;

    class Wrapper401GetAdminDistanceCB {
        Wrapper401GetAdminDistanceRF cb;

    public:
        operator const Wrapper401GetAdminDistanceRF& () const { return cb; }
        const Wrapper401GetAdminDistanceRF& operator ->() const { return cb; }
        Wrapper401GetAdminDistanceCB(const Wrapper401GetAdminDistanceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_admin) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_admin);
        }
    };

    struct Wrapper401GetAdminDistanceRsp :
      public Wrapper401GetAdminDistanceCB {
        struct args_str {
            uint32_t admin;
        };

    private:
        args_str args;

    public:
        Wrapper401GetAdminDistanceRsp(const Wrapper401GetAdminDistanceRF& cb)
          : Wrapper401GetAdminDistanceCB(cb) { }

        void respond() const {
            Wrapper401GetAdminDistanceCB::
            respond(args.admin);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_wrapper4_0_1_get_admin_distance
       (
	Wrapper401GetAdminDistanceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set admin distance.
     */
    virtual XrlCmdError wrapper4_0_1_set_admin_distance(
	// Input values,
	const uint32_t&	admin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Wrapper401SetAdminDistanceRF;

    class Wrapper401SetAdminDistanceCB {
        Wrapper401SetAdminDistanceRF cb;

    public:
        operator const Wrapper401SetAdminDistanceRF& () const { return cb; }
        const Wrapper401SetAdminDistanceRF& operator ->() const { return cb; }
        Wrapper401SetAdminDistanceCB(const Wrapper401SetAdminDistanceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Wrapper401SetAdminDistanceRsp :
      public Wrapper401SetAdminDistanceCB {
        Wrapper401SetAdminDistanceRsp(const Wrapper401SetAdminDistanceRF& cb)
          : Wrapper401SetAdminDistanceCB(cb) { }

    };

    virtual void async_wrapper4_0_1_set_admin_distance
       (
	const uint32_t&	admin,
	Wrapper401SetAdminDistanceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get Wrapper main address.
     */
    virtual XrlCmdError wrapper4_0_1_get_main_address(
	// Output values,
	IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Wrapper401GetMainAddressRF;

    class Wrapper401GetMainAddressCB {
        Wrapper401GetMainAddressRF cb;

    public:
        operator const Wrapper401GetMainAddressRF& () const { return cb; }
        const Wrapper401GetMainAddressRF& operator ->() const { return cb; }
        Wrapper401GetMainAddressCB(const Wrapper401GetMainAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_addr) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_addr);
        }
    };

    struct Wrapper401GetMainAddressRsp :
      public Wrapper401GetMainAddressCB {
        struct args_str {
            IPv4 addr;
        };

    private:
        args_str args;

    public:
        Wrapper401GetMainAddressRsp(const Wrapper401GetMainAddressRF& cb)
          : Wrapper401GetMainAddressCB(cb) { }

        void respond() const {
            Wrapper401GetMainAddressCB::
            respond(args.addr);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_wrapper4_0_1_get_main_address
       (
	Wrapper401GetMainAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set Wrapper main address.
     */
    virtual XrlCmdError wrapper4_0_1_set_main_address(
	// Input values,
	const IPv4&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Wrapper401SetMainAddressRF;

    class Wrapper401SetMainAddressCB {
        Wrapper401SetMainAddressRF cb;

    public:
        operator const Wrapper401SetMainAddressRF& () const { return cb; }
        const Wrapper401SetMainAddressRF& operator ->() const { return cb; }
        Wrapper401SetMainAddressCB(const Wrapper401SetMainAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Wrapper401SetMainAddressRsp :
      public Wrapper401SetMainAddressCB {
        Wrapper401SetMainAddressRsp(const Wrapper401SetMainAddressRF& cb)
          : Wrapper401SetMainAddressCB(cb) { }

    };

    virtual void async_wrapper4_0_1_set_main_address
       (
	const IPv4&	addr,
	Wrapper401SetMainAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset connection to xopr
     */
    virtual XrlCmdError wrapper4_0_1_restart() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Wrapper401RestartRF;

    class Wrapper401RestartCB {
        Wrapper401RestartRF cb;

    public:
        operator const Wrapper401RestartRF& () const { return cb; }
        const Wrapper401RestartRF& operator ->() const { return cb; }
        Wrapper401RestartCB(const Wrapper401RestartRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Wrapper401RestartRsp :
      public Wrapper401RestartCB {
        Wrapper401RestartRsp(const Wrapper401RestartRF& cb)
          : Wrapper401RestartCB(cb) { }

    };

    virtual void async_wrapper4_0_1_restart
       (
	Wrapper401RestartCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of interfaces currently configured for Wrapper. Return a
     *  list of u32 type values. Each value is an internal ID that can be used
     *  with the get_interface_info XRL.
     */
    virtual XrlCmdError wrapper4_0_1_get_interface_list(
	// Output values,
	XrlAtomList&	interfaces) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Wrapper401GetInterfaceListRF;

    class Wrapper401GetInterfaceListCB {
        Wrapper401GetInterfaceListRF cb;

    public:
        operator const Wrapper401GetInterfaceListRF& () const { return cb; }
        const Wrapper401GetInterfaceListRF& operator ->() const { return cb; }
        Wrapper401GetInterfaceListCB(const Wrapper401GetInterfaceListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_interfaces) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_interfaces);
        }
    };

    struct Wrapper401GetInterfaceListRsp :
      public Wrapper401GetInterfaceListCB {
        struct args_str {
            XrlAtomList interfaces;
        };

    private:
        args_str args;

    public:
        Wrapper401GetInterfaceListRsp(const Wrapper401GetInterfaceListRF& cb)
          : Wrapper401GetInterfaceListCB(cb) { }

        void respond() const {
            Wrapper401GetInterfaceListCB::
            respond(args.interfaces);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_wrapper4_0_1_get_interface_list
       (
	Wrapper401GetInterfaceListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the per-interface information for the given interface.
     *
     *  @param faceid interface ID returned by get_interface_list.
     *
     *  @param ifname the name of the interface.
     *
     *  @param vifname the name of the vif.
     *
     *  @param local_addr the IPv4 address where Wrapper is listening.
     *
     *  @param local_port the UDP port where Wrapper is listening.
     *
     *  @param all_nodes_addr the IPv4 address where Wrapper sends packets.
     *
     *  @param all_nodes_port the UDP port where Wrapper sends packets.
     */
    virtual XrlCmdError wrapper4_0_1_get_interface_info(
	// Input values,
	const uint32_t&	faceid,
	// Output values,
	string&	ifname,
	string&	vifname,
	IPv4&	local_addr,
	uint32_t&	local_port,
	IPv4&	all_nodes_addr,
	uint32_t&	all_nodes_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const string*,
	const string*,
	const IPv4*,
	const uint32_t*,
	const IPv4*,
	const uint32_t*>::RefPtr
    Wrapper401GetInterfaceInfoRF;

    class Wrapper401GetInterfaceInfoCB {
        Wrapper401GetInterfaceInfoRF cb;

    public:
        operator const Wrapper401GetInterfaceInfoRF& () const { return cb; }
        const Wrapper401GetInterfaceInfoRF& operator ->() const { return cb; }
        Wrapper401GetInterfaceInfoCB(const Wrapper401GetInterfaceInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const string& arg_ifname,
                     const string& arg_vifname,
                     const IPv4& arg_local_addr,
                     const uint32_t& arg_local_port,
                     const IPv4& arg_all_nodes_addr,
                     const uint32_t& arg_all_nodes_port) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ifname,
                         &arg_vifname,
                         &arg_local_addr,
                         &arg_local_port,
                         &arg_all_nodes_addr,
                         &arg_all_nodes_port);
        }
    };

    struct Wrapper401GetInterfaceInfoRsp :
      public Wrapper401GetInterfaceInfoCB {
        struct args_str {
            string ifname;
            string vifname;
            IPv4 local_addr;
            uint32_t local_port;
            IPv4 all_nodes_addr;
            uint32_t all_nodes_port;
        };

    private:
        args_str args;

    public:
        Wrapper401GetInterfaceInfoRsp(const Wrapper401GetInterfaceInfoRF& cb)
          : Wrapper401GetInterfaceInfoCB(cb) { }

        void respond() const {
            Wrapper401GetInterfaceInfoCB::
            respond(args.ifname,
                        args.vifname,
                        args.local_addr,
                        args.local_port,
                        args.all_nodes_addr,
                        args.all_nodes_port);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_wrapper4_0_1_get_interface_info
       (
	const uint32_t&	faceid,
	Wrapper401GetInterfaceInfoCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_recv_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_recv_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_inbound_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_inbound_connect_event
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_outgoing_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_outgoing_connect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_error_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_error_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_user_0_1_disconnect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_user_0_1_disconnect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_add_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_add_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_delete_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_delete_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_enable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_enable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_disable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_disable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_get_entries(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_get_entries
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_clear(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_clear
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_list
       (const XrlCmdError &e,
	const string* arg_info,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_get_admin_distance(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_get_admin_distance
       (const XrlCmdError &e,
	const uint32_t* arg_admin,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_set_admin_distance(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_set_admin_distance
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_get_main_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_get_main_address
       (const XrlCmdError &e,
	const IPv4* arg_addr,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_set_main_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_set_main_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_restart(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_restart
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_get_interface_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_get_interface_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_interfaces,
        XrlRespCallback);
#endif

    XrlCmdRT handle_wrapper4_0_1_get_interface_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_wrapper4_0_1_get_interface_info
       (const XrlCmdError &e,
	const string* arg_ifname,
	const string* arg_vifname,
	const IPv4* arg_local_addr,
	const uint32_t* arg_local_port,
	const IPv4* arg_all_nodes_addr,
	const uint32_t* arg_all_nodes_port,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlWrapper4TargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_WRAPPER4_BASE_HH__
