/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/fea_base.cc
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#include "fea_base.hh"


const struct XrlFeaTargetBase::handler_table XrlFeaTargetBase::handlers[] = {
    { "common/0.1/get_target_name",
      &XrlFeaTargetBase::handle_common_0_1_get_target_name },
    { "common/0.1/get_version",
      &XrlFeaTargetBase::handle_common_0_1_get_version },
    { "common/0.1/get_status",
      &XrlFeaTargetBase::handle_common_0_1_get_status },
    { "common/0.1/shutdown",
      &XrlFeaTargetBase::handle_common_0_1_shutdown },
    { "common/0.1/startup",
      &XrlFeaTargetBase::handle_common_0_1_startup },
    { "finder_event_observer/0.1/xrl_target_birth",
      &XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_birth },
    { "finder_event_observer/0.1/xrl_target_death",
      &XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_death },
    { "fea_fib/0.1/add_fib_client4",
      &XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client4 },
    { "fea_fib/0.1/delete_fib_client4",
      &XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client4 },
    { "fea_fib/0.1/add_fib_client6",
      &XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client6 },
    { "fea_fib/0.1/delete_fib_client6",
      &XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client6 },
    { "fea_firewall/0.1/start_transaction",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_start_transaction },
    { "fea_firewall/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_commit_transaction },
    { "fea_firewall/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_abort_transaction },
    { "fea_firewall/0.1/add_entry4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry4 },
    { "fea_firewall/0.1/replace_entry4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry4 },
    { "fea_firewall/0.1/delete_entry4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry4 },
    { "fea_firewall/0.1/delete_all_entries4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries4 },
    { "fea_firewall/0.1/get_entry_list_start4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start4 },
    { "fea_firewall/0.1/get_entry_list_next4",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next4 },
    { "fea_firewall/0.1/add_entry6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry6 },
    { "fea_firewall/0.1/replace_entry6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry6 },
    { "fea_firewall/0.1/delete_entry6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry6 },
    { "fea_firewall/0.1/delete_all_entries6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries6 },
    { "fea_firewall/0.1/get_entry_list_start6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start6 },
    { "fea_firewall/0.1/get_entry_list_next6",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next6 },
    { "fea_firewall/0.1/startup_firewall",
      &XrlFeaTargetBase::handle_fea_firewall_0_1_startup_firewall },
    { "ifmgr/0.1/set_restore_original_config_on_shutdown",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_restore_original_config_on_shutdown },
    { "ifmgr/0.1/get_configured_interface_names",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_names },
    { "ifmgr/0.1/get_configured_vif_names",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_names },
    { "ifmgr/0.1/get_configured_vif_flags",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_flags },
    { "ifmgr/0.1/get_configured_vif_pif_index",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_pif_index },
    { "ifmgr/0.1/get_configured_vif_addresses4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses4 },
    { "ifmgr/0.1/get_configured_address_flags4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags4 },
    { "ifmgr/0.1/get_configured_interface_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_enabled },
    { "ifmgr/0.1/get_configured_interface_discard",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_discard },
    { "ifmgr/0.1/get_configured_interface_unreachable",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_unreachable },
    { "ifmgr/0.1/get_configured_interface_management",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_management },
    { "ifmgr/0.1/get_configured_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mac },
    { "ifmgr/0.1/get_configured_mtu",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mtu },
    { "ifmgr/0.1/get_configured_no_carrier",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_no_carrier },
    { "ifmgr/0.1/get_configured_baudrate",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_baudrate },
    { "ifmgr/0.1/get_configured_vif_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_enabled },
    { "ifmgr/0.1/get_configured_prefix4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix4 },
    { "ifmgr/0.1/get_configured_broadcast4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_broadcast4 },
    { "ifmgr/0.1/get_configured_endpoint4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint4 },
    { "ifmgr/0.1/start_transaction",
      &XrlFeaTargetBase::handle_ifmgr_0_1_start_transaction },
    { "ifmgr/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_ifmgr_0_1_commit_transaction },
    { "ifmgr/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_ifmgr_0_1_abort_transaction },
    { "ifmgr/0.1/create_interface",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_interface },
    { "ifmgr/0.1/delete_interface",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_interface },
    { "ifmgr/0.1/configure_all_interfaces_from_system",
      &XrlFeaTargetBase::handle_ifmgr_0_1_configure_all_interfaces_from_system },
    { "ifmgr/0.1/configure_interface_from_system",
      &XrlFeaTargetBase::handle_ifmgr_0_1_configure_interface_from_system },
    { "ifmgr/0.1/set_interface_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_enabled },
    { "ifmgr/0.1/set_interface_discard",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_discard },
    { "ifmgr/0.1/set_interface_unreachable",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_unreachable },
    { "ifmgr/0.1/set_interface_management",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_management },
    { "ifmgr/0.1/set_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_mac },
    { "ifmgr/0.1/create_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_mac },
    { "ifmgr/0.1/delete_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_mac },
    { "ifmgr/0.1/restore_original_mac",
      &XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mac },
    { "ifmgr/0.1/set_mtu",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_mtu },
    { "ifmgr/0.1/restore_original_mtu",
      &XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mtu },
    { "ifmgr/0.1/create_vif",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_vif },
    { "ifmgr/0.1/delete_vif",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_vif },
    { "ifmgr/0.1/set_vif_enabled",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_vif_enabled },
    { "ifmgr/0.1/set_parent_ifname",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_parent_ifname },
    { "ifmgr/0.1/set_iface_type",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_iface_type },
    { "ifmgr/0.1/set_vid",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_vid },
    { "ifmgr/0.1/create_address4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_address4 },
    { "ifmgr/0.1/delete_address4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_address4 },
    { "ifmgr/0.1/create_address_atomic",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_address_atomic },
    { "ifmgr/0.1/delete_address_atomic",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_address_atomic },
    { "ifmgr/0.1/set_address_enabled4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled4 },
    { "ifmgr/0.1/get_configured_address_enabled4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled4 },
    { "ifmgr/0.1/set_prefix4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix4 },
    { "ifmgr/0.1/set_broadcast4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_broadcast4 },
    { "ifmgr/0.1/set_endpoint4",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint4 },
    { "ifmgr/0.1/startup_ifmgr",
      &XrlFeaTargetBase::handle_ifmgr_0_1_startup_ifmgr },
    { "ifmgr/0.1/get_configured_vif_addresses6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses6 },
    { "ifmgr/0.1/get_configured_address_flags6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags6 },
    { "ifmgr/0.1/get_configured_prefix6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix6 },
    { "ifmgr/0.1/get_configured_endpoint6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint6 },
    { "ifmgr/0.1/create_address6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_create_address6 },
    { "ifmgr/0.1/delete_address6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_delete_address6 },
    { "ifmgr/0.1/set_address_enabled6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled6 },
    { "ifmgr/0.1/get_configured_address_enabled6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled6 },
    { "ifmgr/0.1/set_prefix6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix6 },
    { "ifmgr/0.1/set_endpoint6",
      &XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint6 },
    { "ifmgr_replicator/0.1/register_ifmgr_mirror",
      &XrlFeaTargetBase::handle_ifmgr_replicator_0_1_register_ifmgr_mirror },
    { "ifmgr_replicator/0.1/unregister_ifmgr_mirror",
      &XrlFeaTargetBase::handle_ifmgr_replicator_0_1_unregister_ifmgr_mirror },
    { "fti/0.2/lookup_route_by_dest4",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest4 },
    { "fti/0.2/lookup_route_by_network4",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network4 },
    { "fti/0.2/have_ipv4",
      &XrlFeaTargetBase::handle_fti_0_2_have_ipv4 },
    { "fti/0.2/get_unicast_forwarding_enabled4",
      &XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled4 },
    { "fti/0.2/set_unicast_forwarding_enabled4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled4 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4 },
    { "fti/0.2/set_unicast_forwarding_table_id4",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id4 },
    { "fti/0.2/lookup_route_by_dest6",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest6 },
    { "fti/0.2/lookup_route_by_network6",
      &XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network6 },
    { "fti/0.2/have_ipv6",
      &XrlFeaTargetBase::handle_fti_0_2_have_ipv6 },
    { "fti/0.2/get_unicast_forwarding_enabled6",
      &XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled6 },
    { "fti/0.2/set_unicast_forwarding_enabled6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled6 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6 },
    { "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6 },
    { "fti/0.2/set_unicast_forwarding_table_id6",
      &XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id6 },
    { "redist_transaction4/0.1/start_transaction",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_start_transaction },
    { "redist_transaction4/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_commit_transaction },
    { "redist_transaction4/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_abort_transaction },
    { "redist_transaction4/0.1/add_route",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_add_route },
    { "redist_transaction4/0.1/delete_route",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_route },
    { "redist_transaction4/0.1/delete_all_routes",
      &XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_all_routes },
    { "raw_link/0.1/send",
      &XrlFeaTargetBase::handle_raw_link_0_1_send },
    { "raw_link/0.1/register_receiver",
      &XrlFeaTargetBase::handle_raw_link_0_1_register_receiver },
    { "raw_link/0.1/unregister_receiver",
      &XrlFeaTargetBase::handle_raw_link_0_1_unregister_receiver },
    { "raw_link/0.1/join_multicast_group",
      &XrlFeaTargetBase::handle_raw_link_0_1_join_multicast_group },
    { "raw_link/0.1/leave_multicast_group",
      &XrlFeaTargetBase::handle_raw_link_0_1_leave_multicast_group },
    { "raw_packet4/0.1/send",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_send },
    { "raw_packet4/0.1/register_receiver",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_register_receiver },
    { "raw_packet4/0.1/unregister_receiver",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_unregister_receiver },
    { "raw_packet4/0.1/join_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_join_multicast_group },
    { "raw_packet4/0.1/leave_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet4_0_1_leave_multicast_group },
    { "socket4/0.1/tcp_open",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_open },
    { "socket4/0.1/udp_open",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open },
    { "socket4/0.1/tcp_open_and_bind",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_open_and_bind },
    { "socket4/0.1/udp_open_and_bind",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_and_bind },
    { "socket4/0.1/udp_open_bind_join",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_join },
    { "socket4/0.1/tcp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_open_bind_connect },
    { "socket4/0.1/udp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_connect },
    { "socket4/0.1/udp_open_bind_broadcast",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_broadcast },
    { "socket4/0.1/bind",
      &XrlFeaTargetBase::handle_socket4_0_1_bind },
    { "socket4/0.1/udp_join_group",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_join_group },
    { "socket4/0.1/udp_leave_group",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_leave_group },
    { "socket4/0.1/close",
      &XrlFeaTargetBase::handle_socket4_0_1_close },
    { "socket4/0.1/tcp_listen",
      &XrlFeaTargetBase::handle_socket4_0_1_tcp_listen },
    { "socket4/0.1/udp_enable_recv",
      &XrlFeaTargetBase::handle_socket4_0_1_udp_enable_recv },
    { "socket4/0.1/send",
      &XrlFeaTargetBase::handle_socket4_0_1_send },
    { "socket4/0.1/send_to",
      &XrlFeaTargetBase::handle_socket4_0_1_send_to },
    { "socket4/0.1/send_from_multicast_if",
      &XrlFeaTargetBase::handle_socket4_0_1_send_from_multicast_if },
    { "socket4/0.1/set_socket_option",
      &XrlFeaTargetBase::handle_socket4_0_1_set_socket_option },
    { "socket4/0.1/set_socket_option_txt",
      &XrlFeaTargetBase::handle_socket4_0_1_set_socket_option_txt },
    { "redist_transaction6/0.1/start_transaction",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_start_transaction },
    { "redist_transaction6/0.1/commit_transaction",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_commit_transaction },
    { "redist_transaction6/0.1/abort_transaction",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_abort_transaction },
    { "redist_transaction6/0.1/add_route",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_add_route },
    { "redist_transaction6/0.1/delete_route",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_route },
    { "redist_transaction6/0.1/delete_all_routes",
      &XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_all_routes },
    { "socket6/0.1/tcp_open",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_open },
    { "socket6/0.1/udp_open",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open },
    { "socket6/0.1/tcp_open_and_bind",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_open_and_bind },
    { "socket6/0.1/udp_open_and_bind",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open_and_bind },
    { "socket6/0.1/udp_open_bind_join",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_join },
    { "socket6/0.1/tcp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_open_bind_connect },
    { "socket6/0.1/udp_open_bind_connect",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_connect },
    { "socket6/0.1/bind",
      &XrlFeaTargetBase::handle_socket6_0_1_bind },
    { "socket6/0.1/udp_join_group",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_join_group },
    { "socket6/0.1/udp_leave_group",
      &XrlFeaTargetBase::handle_socket6_0_1_udp_leave_group },
    { "socket6/0.1/close",
      &XrlFeaTargetBase::handle_socket6_0_1_close },
    { "socket6/0.1/tcp_listen",
      &XrlFeaTargetBase::handle_socket6_0_1_tcp_listen },
    { "socket6/0.1/send",
      &XrlFeaTargetBase::handle_socket6_0_1_send },
    { "socket6/0.1/send_to",
      &XrlFeaTargetBase::handle_socket6_0_1_send_to },
    { "socket6/0.1/send_from_multicast_if",
      &XrlFeaTargetBase::handle_socket6_0_1_send_from_multicast_if },
    { "socket6/0.1/set_socket_option",
      &XrlFeaTargetBase::handle_socket6_0_1_set_socket_option },
    { "raw_packet6/0.1/send",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_send },
    { "raw_packet6/0.1/register_receiver",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_register_receiver },
    { "raw_packet6/0.1/unregister_receiver",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_unregister_receiver },
    { "raw_packet6/0.1/join_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_join_multicast_group },
    { "raw_packet6/0.1/leave_multicast_group",
      &XrlFeaTargetBase::handle_raw_packet6_0_1_leave_multicast_group },
    { "profile/0.1/enable",
      &XrlFeaTargetBase::handle_profile_0_1_enable },
    { "profile/0.1/disable",
      &XrlFeaTargetBase::handle_profile_0_1_disable },
    { "profile/0.1/get_entries",
      &XrlFeaTargetBase::handle_profile_0_1_get_entries },
    { "profile/0.1/clear",
      &XrlFeaTargetBase::handle_profile_0_1_clear },
    { "profile/0.1/list",
      &XrlFeaTargetBase::handle_profile_0_1_list },
};

const size_t XrlFeaTargetBase::num_handlers = (sizeof(XrlFeaTargetBase::handlers) / sizeof(XrlFeaTargetBase::handlers[0]));


XrlFeaTargetBase::XrlFeaTargetBase(XrlCmdMap* cmds)
    : _cmds(cmds)
{
    if (_cmds)
	add_handlers();
}

XrlFeaTargetBase::~XrlFeaTargetBase()
{
    if (_cmds)
	remove_handlers();
}

bool
XrlFeaTargetBase::set_command_map(XrlCmdMap* cmds)
{
    if (_cmds == 0 && cmds) {
        _cmds = cmds;
        add_handlers();
        return true;
    }
    if (_cmds && cmds == 0) {
	remove_handlers();
        _cmds = cmds;
        return true;
    }
    return false;
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_common_0_1_get_target_name
    (const XrlCmdError &e,
     const string* rarg_name,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_target_name", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("name", *rarg_name);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_common_0_1_get_target_name(
	Common01GetTargetNameCB c_b)
{

    /* Return value declarations */
    string rarg_name;
    XrlCmdError e = common_0_1_get_target_name(
        rarg_name);
    return c_b->dispatch(e,
        &rarg_name);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_common_0_1_get_target_name(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_target_name");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetTargetNameRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_common_0_1_get_target_name, pxa_outputs);
	async_common_0_1_get_target_name( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_name;
    try {
	XrlCmdError e = common_0_1_get_target_name(
	    r_name);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_target_name", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("name", r_name);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_common_0_1_get_version
    (const XrlCmdError &e,
     const string* rarg_version,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_version", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("version", *rarg_version);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_common_0_1_get_version(
	Common01GetVersionCB c_b)
{

    /* Return value declarations */
    string rarg_version;
    XrlCmdError e = common_0_1_get_version(
        rarg_version);
    return c_b->dispatch(e,
        &rarg_version);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_common_0_1_get_version(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_version");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetVersionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_common_0_1_get_version, pxa_outputs);
	async_common_0_1_get_version( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_version;
    try {
	XrlCmdError e = common_0_1_get_version(
	    r_version);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_version", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("version", r_version);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_common_0_1_get_status
    (const XrlCmdError &e,
     const uint32_t* rarg_status,
     const string* rarg_reason,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/get_status", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("status", *rarg_status);
	    out.add("reason", *rarg_reason);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_common_0_1_get_status(
	Common01GetStatusCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_status;
    string rarg_reason;
    XrlCmdError e = common_0_1_get_status(
        rarg_status,
        rarg_reason);
    return c_b->dispatch(e,
        &rarg_status,
        &rarg_reason);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_common_0_1_get_status(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/get_status");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01GetStatusRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_common_0_1_get_status, pxa_outputs);
	async_common_0_1_get_status( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_status;
    string r_reason;
    try {
	XrlCmdError e = common_0_1_get_status(
	    r_status,
	    r_reason);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/get_status", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("status", r_status);
	pxa_outputs->add("reason", r_reason);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_common_0_1_shutdown
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/shutdown", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_common_0_1_shutdown(
	Common01ShutdownCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_shutdown();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_common_0_1_shutdown(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/shutdown");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01ShutdownRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_common_0_1_shutdown, pxa_outputs);
	async_common_0_1_shutdown( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_shutdown();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_common_0_1_startup
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "common/0.1/startup", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_common_0_1_startup(
	Common01StartupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = common_0_1_startup();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_common_0_1_startup(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "common/0.1/startup");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Common01StartupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_common_0_1_startup, pxa_outputs);
	async_common_0_1_startup( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = common_0_1_startup();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "common/0.1/startup", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_finder_event_observer_0_1_xrl_target_birth
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_finder_event_observer_0_1_xrl_target_birth(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetBirthCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_birth");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetBirthRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_finder_event_observer_0_1_xrl_target_birth, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_birth(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_birth", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_finder_event_observer_0_1_xrl_target_death
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_finder_event_observer_0_1_xrl_target_death(
	const string&	arg_target_class,
	const string&	arg_target_instance,
	FinderEventObserver01XrlTargetDeathCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
        arg_target_class,
        arg_target_instance);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "finder_event_observer/0.1/xrl_target_death");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FinderEventObserver01XrlTargetDeathRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_finder_event_observer_0_1_xrl_target_death, pxa_outputs);
	async_finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = finder_event_observer_0_1_xrl_target_death(
	    xa_inputs.get(0, "target_class").text(),
	    xa_inputs.get(1, "target_instance").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "finder_event_observer/0.1/xrl_target_death", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_fib_0_1_add_fib_client4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_fib/0.1/add_fib_client4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_fib_0_1_add_fib_client4(
	const string&	arg_client_target_name,
	const bool&	arg_send_updates,
	const bool&	arg_send_resolves,
	FeaFib01AddFibClient4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_fib_0_1_add_fib_client4(
        arg_client_target_name,
        arg_send_updates,
        arg_send_resolves);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/add_fib_client4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFib01AddFibClient4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_fib_0_1_add_fib_client4, pxa_outputs);
	async_fea_fib_0_1_add_fib_client4(
	    xa_inputs.get(0, "client_target_name").text(),
	    xa_inputs.get(1, "send_updates").boolean(),
	    xa_inputs.get(2, "send_resolves").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_add_fib_client4(
	    xa_inputs.get(0, "client_target_name").text(),
	    xa_inputs.get(1, "send_updates").boolean(),
	    xa_inputs.get(2, "send_resolves").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/add_fib_client4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_fib_0_1_delete_fib_client4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_fib/0.1/delete_fib_client4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_fib_0_1_delete_fib_client4(
	const string&	arg_client_target_name,
	FeaFib01DeleteFibClient4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_fib_0_1_delete_fib_client4(
        arg_client_target_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/delete_fib_client4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFib01DeleteFibClient4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_fib_0_1_delete_fib_client4, pxa_outputs);
	async_fea_fib_0_1_delete_fib_client4(
	    xa_inputs.get(0, "client_target_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_delete_fib_client4(
	    xa_inputs.get(0, "client_target_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/delete_fib_client4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_fib_0_1_add_fib_client6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_fib/0.1/add_fib_client6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_fib_0_1_add_fib_client6(
	const string&	arg_client_target_name,
	const bool&	arg_send_updates,
	const bool&	arg_send_resolves,
	FeaFib01AddFibClient6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_fib_0_1_add_fib_client6(
        arg_client_target_name,
        arg_send_updates,
        arg_send_resolves);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_fib_0_1_add_fib_client6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/add_fib_client6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFib01AddFibClient6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_fib_0_1_add_fib_client6, pxa_outputs);
	async_fea_fib_0_1_add_fib_client6(
	    xa_inputs.get(0, "client_target_name").text(),
	    xa_inputs.get(1, "send_updates").boolean(),
	    xa_inputs.get(2, "send_resolves").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_add_fib_client6(
	    xa_inputs.get(0, "client_target_name").text(),
	    xa_inputs.get(1, "send_updates").boolean(),
	    xa_inputs.get(2, "send_resolves").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/add_fib_client6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_fib_0_1_delete_fib_client6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_fib/0.1/delete_fib_client6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_fib_0_1_delete_fib_client6(
	const string&	arg_client_target_name,
	FeaFib01DeleteFibClient6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_fib_0_1_delete_fib_client6(
        arg_client_target_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_fib_0_1_delete_fib_client6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_fib/0.1/delete_fib_client6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFib01DeleteFibClient6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_fib_0_1_delete_fib_client6, pxa_outputs);
	async_fea_fib_0_1_delete_fib_client6(
	    xa_inputs.get(0, "client_target_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_fib_0_1_delete_fib_client6(
	    xa_inputs.get(0, "client_target_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_fib/0.1/delete_fib_client6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_start_transaction
    (const XrlCmdError &e,
     const uint32_t* rarg_tid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/start_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tid", *rarg_tid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_start_transaction(
	FeaFirewall01StartTransactionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_tid;
    XrlCmdError e = fea_firewall_0_1_start_transaction(
        rarg_tid);
    return c_b->dispatch(e,
        &rarg_tid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_start_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/start_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01StartTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_start_transaction, pxa_outputs);
	async_fea_firewall_0_1_start_transaction( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_tid;
    try {
	XrlCmdError e = fea_firewall_0_1_start_transaction(
	    r_tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", r_tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_commit_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/commit_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_commit_transaction(
	const uint32_t&	arg_tid,
	FeaFirewall01CommitTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_commit_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/commit_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01CommitTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_commit_transaction, pxa_outputs);
	async_fea_firewall_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_abort_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/abort_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_abort_transaction(
	const uint32_t&	arg_tid,
	FeaFirewall01AbortTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_abort_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/abort_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01AbortTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_abort_transaction, pxa_outputs);
	async_fea_firewall_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_add_entry4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/add_entry4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_add_entry4(
	const uint32_t&	arg_tid,
	const uint32_t&	arg_rule_number,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv4Net&	arg_src_network,
	const IPv4Net&	arg_dst_network,
	const uint32_t&	arg_ip_protocol,
	const uint32_t&	arg_src_port_begin,
	const uint32_t&	arg_src_port_end,
	const uint32_t&	arg_dst_port_begin,
	const uint32_t&	arg_dst_port_end,
	const string&	arg_action,
	FeaFirewall01AddEntry4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_add_entry4(
        arg_tid,
        arg_rule_number,
        arg_ifname,
        arg_vifname,
        arg_src_network,
        arg_dst_network,
        arg_ip_protocol,
        arg_src_port_begin,
        arg_src_port_end,
        arg_dst_port_begin,
        arg_dst_port_end,
        arg_action);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/add_entry4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01AddEntry4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_add_entry4, pxa_outputs);
	async_fea_firewall_0_1_add_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_add_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/add_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_replace_entry4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/replace_entry4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_replace_entry4(
	const uint32_t&	arg_tid,
	const uint32_t&	arg_rule_number,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv4Net&	arg_src_network,
	const IPv4Net&	arg_dst_network,
	const uint32_t&	arg_ip_protocol,
	const uint32_t&	arg_src_port_begin,
	const uint32_t&	arg_src_port_end,
	const uint32_t&	arg_dst_port_begin,
	const uint32_t&	arg_dst_port_end,
	const string&	arg_action,
	FeaFirewall01ReplaceEntry4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_replace_entry4(
        arg_tid,
        arg_rule_number,
        arg_ifname,
        arg_vifname,
        arg_src_network,
        arg_dst_network,
        arg_ip_protocol,
        arg_src_port_begin,
        arg_src_port_end,
        arg_dst_port_begin,
        arg_dst_port_end,
        arg_action);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/replace_entry4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01ReplaceEntry4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_replace_entry4, pxa_outputs);
	async_fea_firewall_0_1_replace_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_replace_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/replace_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_delete_entry4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/delete_entry4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_delete_entry4(
	const uint32_t&	arg_tid,
	const uint32_t&	arg_rule_number,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv4Net&	arg_src_network,
	const IPv4Net&	arg_dst_network,
	const uint32_t&	arg_ip_protocol,
	const uint32_t&	arg_src_port_begin,
	const uint32_t&	arg_src_port_end,
	const uint32_t&	arg_dst_port_begin,
	const uint32_t&	arg_dst_port_end,
	FeaFirewall01DeleteEntry4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_delete_entry4(
        arg_tid,
        arg_rule_number,
        arg_ifname,
        arg_vifname,
        arg_src_network,
        arg_dst_network,
        arg_ip_protocol,
        arg_src_port_begin,
        arg_src_port_end,
        arg_dst_port_begin,
        arg_dst_port_end);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 11) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(11), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_entry4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01DeleteEntry4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_delete_entry4, pxa_outputs);
	async_fea_firewall_0_1_delete_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_entry4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv4net(),
	    xa_inputs.get(5, "dst_network").ipv4net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_entry4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_delete_all_entries4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/delete_all_entries4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_delete_all_entries4(
	const uint32_t&	arg_tid,
	FeaFirewall01DeleteAllEntries4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_delete_all_entries4(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_all_entries4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01DeleteAllEntries4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_delete_all_entries4, pxa_outputs);
	async_fea_firewall_0_1_delete_all_entries4(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_all_entries4(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_all_entries4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_start4
    (const XrlCmdError &e,
     const uint32_t* rarg_token,
     const bool* rarg_more,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/get_entry_list_start4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("token", *rarg_token);
	    out.add("more", *rarg_more);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_get_entry_list_start4(
	FeaFirewall01GetEntryListStart4CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_token;
    bool rarg_more;
    XrlCmdError e = fea_firewall_0_1_get_entry_list_start4(
        rarg_token,
        rarg_more);
    return c_b->dispatch(e,
        &rarg_token,
        &rarg_more);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_start4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01GetEntryListStart4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_start4, pxa_outputs);
	async_fea_firewall_0_1_get_entry_list_start4( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_token;
    bool r_more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_start4(
	    r_token,
	    r_more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_start4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", r_token);
	pxa_outputs->add("more", r_more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_next4
    (const XrlCmdError &e,
     const uint32_t* rarg_rule_number,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const IPv4Net* rarg_src_network,
     const IPv4Net* rarg_dst_network,
     const uint32_t* rarg_ip_protocol,
     const uint32_t* rarg_src_port_begin,
     const uint32_t* rarg_src_port_end,
     const uint32_t* rarg_dst_port_begin,
     const uint32_t* rarg_dst_port_end,
     const string* rarg_action,
     const bool* rarg_more,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/get_entry_list_next4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("rule_number", *rarg_rule_number);
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("src_network", *rarg_src_network);
	    out.add("dst_network", *rarg_dst_network);
	    out.add("ip_protocol", *rarg_ip_protocol);
	    out.add("src_port_begin", *rarg_src_port_begin);
	    out.add("src_port_end", *rarg_src_port_end);
	    out.add("dst_port_begin", *rarg_dst_port_begin);
	    out.add("dst_port_end", *rarg_dst_port_end);
	    out.add("action", *rarg_action);
	    out.add("more", *rarg_more);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_get_entry_list_next4(
	const uint32_t&	arg_token,
	FeaFirewall01GetEntryListNext4CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_rule_number;
    string rarg_ifname;
    string rarg_vifname;
    IPv4Net rarg_src_network;
    IPv4Net rarg_dst_network;
    uint32_t rarg_ip_protocol;
    uint32_t rarg_src_port_begin;
    uint32_t rarg_src_port_end;
    uint32_t rarg_dst_port_begin;
    uint32_t rarg_dst_port_end;
    string rarg_action;
    bool rarg_more;
    XrlCmdError e = fea_firewall_0_1_get_entry_list_next4(
        arg_token,
        rarg_rule_number,
        rarg_ifname,
        rarg_vifname,
        rarg_src_network,
        rarg_dst_network,
        rarg_ip_protocol,
        rarg_src_port_begin,
        rarg_src_port_end,
        rarg_dst_port_begin,
        rarg_dst_port_end,
        rarg_action,
        rarg_more);
    return c_b->dispatch(e,
        &rarg_rule_number,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_src_network,
        &rarg_dst_network,
        &rarg_ip_protocol,
        &rarg_src_port_begin,
        &rarg_src_port_end,
        &rarg_dst_port_begin,
        &rarg_dst_port_end,
        &rarg_action,
        &rarg_more);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_next4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01GetEntryListNext4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_next4, pxa_outputs);
	async_fea_firewall_0_1_get_entry_list_next4(
	    xa_inputs.get(0, "token").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_rule_number;
    string r_ifname;
    string r_vifname;
    IPv4Net r_src_network;
    IPv4Net r_dst_network;
    uint32_t r_ip_protocol;
    uint32_t r_src_port_begin;
    uint32_t r_src_port_end;
    uint32_t r_dst_port_begin;
    uint32_t r_dst_port_end;
    string r_action;
    bool r_more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_next4(
	    xa_inputs.get(0, "token").uint32(),
	    r_rule_number,
	    r_ifname,
	    r_vifname,
	    r_src_network,
	    r_dst_network,
	    r_ip_protocol,
	    r_src_port_begin,
	    r_src_port_end,
	    r_dst_port_begin,
	    r_dst_port_end,
	    r_action,
	    r_more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_next4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rule_number", r_rule_number);
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("src_network", r_src_network);
	pxa_outputs->add("dst_network", r_dst_network);
	pxa_outputs->add("ip_protocol", r_ip_protocol);
	pxa_outputs->add("src_port_begin", r_src_port_begin);
	pxa_outputs->add("src_port_end", r_src_port_end);
	pxa_outputs->add("dst_port_begin", r_dst_port_begin);
	pxa_outputs->add("dst_port_end", r_dst_port_end);
	pxa_outputs->add("action", r_action);
	pxa_outputs->add("more", r_more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_add_entry6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/add_entry6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_add_entry6(
	const uint32_t&	arg_tid,
	const uint32_t&	arg_rule_number,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv6Net&	arg_src_network,
	const IPv6Net&	arg_dst_network,
	const uint32_t&	arg_ip_protocol,
	const uint32_t&	arg_src_port_begin,
	const uint32_t&	arg_src_port_end,
	const uint32_t&	arg_dst_port_begin,
	const uint32_t&	arg_dst_port_end,
	const string&	arg_action,
	FeaFirewall01AddEntry6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_add_entry6(
        arg_tid,
        arg_rule_number,
        arg_ifname,
        arg_vifname,
        arg_src_network,
        arg_dst_network,
        arg_ip_protocol,
        arg_src_port_begin,
        arg_src_port_end,
        arg_dst_port_begin,
        arg_dst_port_end,
        arg_action);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_add_entry6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/add_entry6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01AddEntry6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_add_entry6, pxa_outputs);
	async_fea_firewall_0_1_add_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_add_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/add_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_replace_entry6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/replace_entry6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_replace_entry6(
	const uint32_t&	arg_tid,
	const uint32_t&	arg_rule_number,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv6Net&	arg_src_network,
	const IPv6Net&	arg_dst_network,
	const uint32_t&	arg_ip_protocol,
	const uint32_t&	arg_src_port_begin,
	const uint32_t&	arg_src_port_end,
	const uint32_t&	arg_dst_port_begin,
	const uint32_t&	arg_dst_port_end,
	const string&	arg_action,
	FeaFirewall01ReplaceEntry6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_replace_entry6(
        arg_tid,
        arg_rule_number,
        arg_ifname,
        arg_vifname,
        arg_src_network,
        arg_dst_network,
        arg_ip_protocol,
        arg_src_port_begin,
        arg_src_port_end,
        arg_dst_port_begin,
        arg_dst_port_end,
        arg_action);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_replace_entry6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/replace_entry6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01ReplaceEntry6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_replace_entry6, pxa_outputs);
	async_fea_firewall_0_1_replace_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_replace_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(),
	    xa_inputs.get(11, "action").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/replace_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_delete_entry6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/delete_entry6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_delete_entry6(
	const uint32_t&	arg_tid,
	const uint32_t&	arg_rule_number,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const IPv6Net&	arg_src_network,
	const IPv6Net&	arg_dst_network,
	const uint32_t&	arg_ip_protocol,
	const uint32_t&	arg_src_port_begin,
	const uint32_t&	arg_src_port_end,
	const uint32_t&	arg_dst_port_begin,
	const uint32_t&	arg_dst_port_end,
	FeaFirewall01DeleteEntry6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_delete_entry6(
        arg_tid,
        arg_rule_number,
        arg_ifname,
        arg_vifname,
        arg_src_network,
        arg_dst_network,
        arg_ip_protocol,
        arg_src_port_begin,
        arg_src_port_end,
        arg_dst_port_begin,
        arg_dst_port_end);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_entry6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 11) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(11), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_entry6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01DeleteEntry6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_delete_entry6, pxa_outputs);
	async_fea_firewall_0_1_delete_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_entry6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "rule_number").uint32(),
	    xa_inputs.get(2, "ifname").text(),
	    xa_inputs.get(3, "vifname").text(),
	    xa_inputs.get(4, "src_network").ipv6net(),
	    xa_inputs.get(5, "dst_network").ipv6net(),
	    xa_inputs.get(6, "ip_protocol").uint32(),
	    xa_inputs.get(7, "src_port_begin").uint32(),
	    xa_inputs.get(8, "src_port_end").uint32(),
	    xa_inputs.get(9, "dst_port_begin").uint32(),
	    xa_inputs.get(10, "dst_port_end").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_entry6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_delete_all_entries6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/delete_all_entries6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_delete_all_entries6(
	const uint32_t&	arg_tid,
	FeaFirewall01DeleteAllEntries6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_delete_all_entries6(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_delete_all_entries6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/delete_all_entries6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01DeleteAllEntries6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_delete_all_entries6, pxa_outputs);
	async_fea_firewall_0_1_delete_all_entries6(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_delete_all_entries6(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/delete_all_entries6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_start6
    (const XrlCmdError &e,
     const uint32_t* rarg_token,
     const bool* rarg_more,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/get_entry_list_start6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("token", *rarg_token);
	    out.add("more", *rarg_more);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_get_entry_list_start6(
	FeaFirewall01GetEntryListStart6CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_token;
    bool rarg_more;
    XrlCmdError e = fea_firewall_0_1_get_entry_list_start6(
        rarg_token,
        rarg_more);
    return c_b->dispatch(e,
        &rarg_token,
        &rarg_more);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_start6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_start6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01GetEntryListStart6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_start6, pxa_outputs);
	async_fea_firewall_0_1_get_entry_list_start6( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_token;
    bool r_more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_start6(
	    r_token,
	    r_more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_start6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("token", r_token);
	pxa_outputs->add("more", r_more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_next6
    (const XrlCmdError &e,
     const uint32_t* rarg_rule_number,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const IPv6Net* rarg_src_network,
     const IPv6Net* rarg_dst_network,
     const uint32_t* rarg_ip_protocol,
     const uint32_t* rarg_src_port_begin,
     const uint32_t* rarg_src_port_end,
     const uint32_t* rarg_dst_port_begin,
     const uint32_t* rarg_dst_port_end,
     const string* rarg_action,
     const bool* rarg_more,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/get_entry_list_next6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("rule_number", *rarg_rule_number);
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("src_network", *rarg_src_network);
	    out.add("dst_network", *rarg_dst_network);
	    out.add("ip_protocol", *rarg_ip_protocol);
	    out.add("src_port_begin", *rarg_src_port_begin);
	    out.add("src_port_end", *rarg_src_port_end);
	    out.add("dst_port_begin", *rarg_dst_port_begin);
	    out.add("dst_port_end", *rarg_dst_port_end);
	    out.add("action", *rarg_action);
	    out.add("more", *rarg_more);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_get_entry_list_next6(
	const uint32_t&	arg_token,
	FeaFirewall01GetEntryListNext6CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_rule_number;
    string rarg_ifname;
    string rarg_vifname;
    IPv6Net rarg_src_network;
    IPv6Net rarg_dst_network;
    uint32_t rarg_ip_protocol;
    uint32_t rarg_src_port_begin;
    uint32_t rarg_src_port_end;
    uint32_t rarg_dst_port_begin;
    uint32_t rarg_dst_port_end;
    string rarg_action;
    bool rarg_more;
    XrlCmdError e = fea_firewall_0_1_get_entry_list_next6(
        arg_token,
        rarg_rule_number,
        rarg_ifname,
        rarg_vifname,
        rarg_src_network,
        rarg_dst_network,
        rarg_ip_protocol,
        rarg_src_port_begin,
        rarg_src_port_end,
        rarg_dst_port_begin,
        rarg_dst_port_end,
        rarg_action,
        rarg_more);
    return c_b->dispatch(e,
        &rarg_rule_number,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_src_network,
        &rarg_dst_network,
        &rarg_ip_protocol,
        &rarg_src_port_begin,
        &rarg_src_port_end,
        &rarg_dst_port_begin,
        &rarg_dst_port_end,
        &rarg_action,
        &rarg_more);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_get_entry_list_next6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/get_entry_list_next6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01GetEntryListNext6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_get_entry_list_next6, pxa_outputs);
	async_fea_firewall_0_1_get_entry_list_next6(
	    xa_inputs.get(0, "token").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_rule_number;
    string r_ifname;
    string r_vifname;
    IPv6Net r_src_network;
    IPv6Net r_dst_network;
    uint32_t r_ip_protocol;
    uint32_t r_src_port_begin;
    uint32_t r_src_port_end;
    uint32_t r_dst_port_begin;
    uint32_t r_dst_port_end;
    string r_action;
    bool r_more;
    try {
	XrlCmdError e = fea_firewall_0_1_get_entry_list_next6(
	    xa_inputs.get(0, "token").uint32(),
	    r_rule_number,
	    r_ifname,
	    r_vifname,
	    r_src_network,
	    r_dst_network,
	    r_ip_protocol,
	    r_src_port_begin,
	    r_src_port_end,
	    r_dst_port_begin,
	    r_dst_port_end,
	    r_action,
	    r_more);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/get_entry_list_next6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("rule_number", r_rule_number);
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("src_network", r_src_network);
	pxa_outputs->add("dst_network", r_dst_network);
	pxa_outputs->add("ip_protocol", r_ip_protocol);
	pxa_outputs->add("src_port_begin", r_src_port_begin);
	pxa_outputs->add("src_port_end", r_src_port_end);
	pxa_outputs->add("dst_port_begin", r_dst_port_begin);
	pxa_outputs->add("dst_port_end", r_dst_port_end);
	pxa_outputs->add("action", r_action);
	pxa_outputs->add("more", r_more);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fea_firewall_0_1_startup_firewall
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fea_firewall/0.1/startup_firewall", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fea_firewall_0_1_startup_firewall(
	FeaFirewall01StartupFirewallCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fea_firewall_0_1_startup_firewall();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fea_firewall_0_1_startup_firewall(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fea_firewall/0.1/startup_firewall");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	FeaFirewall01StartupFirewallRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fea_firewall_0_1_startup_firewall, pxa_outputs);
	async_fea_firewall_0_1_startup_firewall( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fea_firewall_0_1_startup_firewall();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fea_firewall/0.1/startup_firewall", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_restore_original_config_on_shutdown
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_restore_original_config_on_shutdown", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_restore_original_config_on_shutdown(
	const bool&	arg_enable,
	Ifmgr01SetRestoreOriginalConfigOnShutdownCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_restore_original_config_on_shutdown(
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_restore_original_config_on_shutdown(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_restore_original_config_on_shutdown");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetRestoreOriginalConfigOnShutdownRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_restore_original_config_on_shutdown, pxa_outputs);
	async_ifmgr_0_1_set_restore_original_config_on_shutdown(
	    xa_inputs.get(0, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_restore_original_config_on_shutdown(
	    xa_inputs.get(0, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_restore_original_config_on_shutdown", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_names
    (const XrlCmdError &e,
     const XrlAtomList* rarg_ifnames,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_interface_names", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("ifnames", *rarg_ifnames);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_interface_names(
	Ifmgr01GetConfiguredInterfaceNamesCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_ifnames;
    XrlCmdError e = ifmgr_0_1_get_configured_interface_names(
        rarg_ifnames);
    return c_b->dispatch(e,
        &rarg_ifnames);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_names(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_names");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredInterfaceNamesRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_names, pxa_outputs);
	async_ifmgr_0_1_get_configured_interface_names( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_ifnames;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_names(
	    r_ifnames);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_names", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("ifnames", r_ifnames);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_names
    (const XrlCmdError &e,
     const XrlAtomList* rarg_vifs,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_vif_names", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("vifs", *rarg_vifs);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_vif_names(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredVifNamesCB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_vifs;
    XrlCmdError e = ifmgr_0_1_get_configured_vif_names(
        arg_ifname,
        rarg_vifs);
    return c_b->dispatch(e,
        &rarg_vifs);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_names(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_names");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredVifNamesRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_names, pxa_outputs);
	async_ifmgr_0_1_get_configured_vif_names(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_vifs;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_names(
	    xa_inputs.get(0, "ifname").text(),
	    r_vifs);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_names", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("vifs", r_vifs);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_flags
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     const bool* rarg_broadcast,
     const bool* rarg_loopback,
     const bool* rarg_point_to_point,
     const bool* rarg_multicast,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_vif_flags", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
	    out.add("broadcast", *rarg_broadcast);
	    out.add("loopback", *rarg_loopback);
	    out.add("point_to_point", *rarg_point_to_point);
	    out.add("multicast", *rarg_multicast);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_vif_flags(
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01GetConfiguredVifFlagsCB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    bool rarg_broadcast;
    bool rarg_loopback;
    bool rarg_point_to_point;
    bool rarg_multicast;
    XrlCmdError e = ifmgr_0_1_get_configured_vif_flags(
        arg_ifname,
        arg_vif,
        rarg_enabled,
        rarg_broadcast,
        rarg_loopback,
        rarg_point_to_point,
        rarg_multicast);
    return c_b->dispatch(e,
        &rarg_enabled,
        &rarg_broadcast,
        &rarg_loopback,
        &rarg_point_to_point,
        &rarg_multicast);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_flags(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_flags");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredVifFlagsRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_flags, pxa_outputs);
	async_ifmgr_0_1_get_configured_vif_flags(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    bool r_broadcast;
    bool r_loopback;
    bool r_point_to_point;
    bool r_multicast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_flags(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    r_enabled,
	    r_broadcast,
	    r_loopback,
	    r_point_to_point,
	    r_multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_flags", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
	pxa_outputs->add("broadcast", r_broadcast);
	pxa_outputs->add("loopback", r_loopback);
	pxa_outputs->add("point_to_point", r_point_to_point);
	pxa_outputs->add("multicast", r_multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_pif_index
    (const XrlCmdError &e,
     const uint32_t* rarg_pif_index,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_vif_pif_index", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("pif_index", *rarg_pif_index);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_vif_pif_index(
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01GetConfiguredVifPifIndexCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_pif_index;
    XrlCmdError e = ifmgr_0_1_get_configured_vif_pif_index(
        arg_ifname,
        arg_vif,
        rarg_pif_index);
    return c_b->dispatch(e,
        &rarg_pif_index);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_pif_index(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_pif_index");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredVifPifIndexRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_pif_index, pxa_outputs);
	async_ifmgr_0_1_get_configured_vif_pif_index(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_pif_index;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_pif_index(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    r_pif_index);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_pif_index", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("pif_index", r_pif_index);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_addresses4
    (const XrlCmdError &e,
     const XrlAtomList* rarg_addresses,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_vif_addresses4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("addresses", *rarg_addresses);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_vif_addresses4(
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01GetConfiguredVifAddresses4CB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_addresses;
    XrlCmdError e = ifmgr_0_1_get_configured_vif_addresses4(
        arg_ifname,
        arg_vif,
        rarg_addresses);
    return c_b->dispatch(e,
        &rarg_addresses);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_addresses4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredVifAddresses4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_addresses4, pxa_outputs);
	async_ifmgr_0_1_get_configured_vif_addresses4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_addresses;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_addresses4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    r_addresses);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_addresses4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("addresses", r_addresses);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_flags4
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     const bool* rarg_broadcast,
     const bool* rarg_loopback,
     const bool* rarg_point_to_point,
     const bool* rarg_multicast,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_address_flags4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
	    out.add("broadcast", *rarg_broadcast);
	    out.add("loopback", *rarg_loopback);
	    out.add("point_to_point", *rarg_point_to_point);
	    out.add("multicast", *rarg_multicast);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_address_flags4(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01GetConfiguredAddressFlags4CB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    bool rarg_broadcast;
    bool rarg_loopback;
    bool rarg_point_to_point;
    bool rarg_multicast;
    XrlCmdError e = ifmgr_0_1_get_configured_address_flags4(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_enabled,
        rarg_broadcast,
        rarg_loopback,
        rarg_point_to_point,
        rarg_multicast);
    return c_b->dispatch(e,
        &rarg_enabled,
        &rarg_broadcast,
        &rarg_loopback,
        &rarg_point_to_point,
        &rarg_multicast);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_flags4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredAddressFlags4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_flags4, pxa_outputs);
	async_ifmgr_0_1_get_configured_address_flags4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    bool r_broadcast;
    bool r_loopback;
    bool r_point_to_point;
    bool r_multicast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_flags4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    r_enabled,
	    r_broadcast,
	    r_loopback,
	    r_point_to_point,
	    r_multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_flags4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
	pxa_outputs->add("broadcast", r_broadcast);
	pxa_outputs->add("loopback", r_loopback);
	pxa_outputs->add("point_to_point", r_point_to_point);
	pxa_outputs->add("multicast", r_multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_enabled
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_interface_enabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_interface_enabled(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredInterfaceEnabledCB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = ifmgr_0_1_get_configured_interface_enabled(
        arg_ifname,
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_enabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_enabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredInterfaceEnabledRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_enabled, pxa_outputs);
	async_ifmgr_0_1_get_configured_interface_enabled(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_discard
    (const XrlCmdError &e,
     const bool* rarg_discard,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_interface_discard", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("discard", *rarg_discard);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_interface_discard(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredInterfaceDiscardCB c_b)
{

    /* Return value declarations */
    bool rarg_discard;
    XrlCmdError e = ifmgr_0_1_get_configured_interface_discard(
        arg_ifname,
        rarg_discard);
    return c_b->dispatch(e,
        &rarg_discard);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_discard(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_discard");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredInterfaceDiscardRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_discard, pxa_outputs);
	async_ifmgr_0_1_get_configured_interface_discard(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_discard;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_discard(
	    xa_inputs.get(0, "ifname").text(),
	    r_discard);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_discard", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("discard", r_discard);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_unreachable
    (const XrlCmdError &e,
     const bool* rarg_unreachable,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_interface_unreachable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("unreachable", *rarg_unreachable);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_interface_unreachable(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredInterfaceUnreachableCB c_b)
{

    /* Return value declarations */
    bool rarg_unreachable;
    XrlCmdError e = ifmgr_0_1_get_configured_interface_unreachable(
        arg_ifname,
        rarg_unreachable);
    return c_b->dispatch(e,
        &rarg_unreachable);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_unreachable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_unreachable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredInterfaceUnreachableRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_unreachable, pxa_outputs);
	async_ifmgr_0_1_get_configured_interface_unreachable(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_unreachable;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_unreachable(
	    xa_inputs.get(0, "ifname").text(),
	    r_unreachable);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_unreachable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("unreachable", r_unreachable);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_management
    (const XrlCmdError &e,
     const bool* rarg_management,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_interface_management", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("management", *rarg_management);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_interface_management(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredInterfaceManagementCB c_b)
{

    /* Return value declarations */
    bool rarg_management;
    XrlCmdError e = ifmgr_0_1_get_configured_interface_management(
        arg_ifname,
        rarg_management);
    return c_b->dispatch(e,
        &rarg_management);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_interface_management(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_interface_management");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredInterfaceManagementRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_interface_management, pxa_outputs);
	async_ifmgr_0_1_get_configured_interface_management(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_management;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_interface_management(
	    xa_inputs.get(0, "ifname").text(),
	    r_management);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_interface_management", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("management", r_management);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_mac
    (const XrlCmdError &e,
     const Mac* rarg_mac,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_mac", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("mac", *rarg_mac);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_mac(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredMacCB c_b)
{

    /* Return value declarations */
    Mac rarg_mac;
    XrlCmdError e = ifmgr_0_1_get_configured_mac(
        arg_ifname,
        rarg_mac);
    return c_b->dispatch(e,
        &rarg_mac);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mac(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_mac");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredMacRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_mac, pxa_outputs);
	async_ifmgr_0_1_get_configured_mac(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    Mac r_mac;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_mac(
	    xa_inputs.get(0, "ifname").text(),
	    r_mac);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("mac", r_mac);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_mtu
    (const XrlCmdError &e,
     const uint32_t* rarg_mtu,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_mtu", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("mtu", *rarg_mtu);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_mtu(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredMtuCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_mtu;
    XrlCmdError e = ifmgr_0_1_get_configured_mtu(
        arg_ifname,
        rarg_mtu);
    return c_b->dispatch(e,
        &rarg_mtu);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_mtu(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_mtu");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredMtuRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_mtu, pxa_outputs);
	async_ifmgr_0_1_get_configured_mtu(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_mtu;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_mtu(
	    xa_inputs.get(0, "ifname").text(),
	    r_mtu);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_mtu", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("mtu", r_mtu);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_no_carrier
    (const XrlCmdError &e,
     const bool* rarg_no_carrier,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_no_carrier", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("no_carrier", *rarg_no_carrier);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_no_carrier(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredNoCarrierCB c_b)
{

    /* Return value declarations */
    bool rarg_no_carrier;
    XrlCmdError e = ifmgr_0_1_get_configured_no_carrier(
        arg_ifname,
        rarg_no_carrier);
    return c_b->dispatch(e,
        &rarg_no_carrier);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_no_carrier(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_no_carrier");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredNoCarrierRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_no_carrier, pxa_outputs);
	async_ifmgr_0_1_get_configured_no_carrier(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_no_carrier;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_no_carrier(
	    xa_inputs.get(0, "ifname").text(),
	    r_no_carrier);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_no_carrier", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("no_carrier", r_no_carrier);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_baudrate
    (const XrlCmdError &e,
     const uint64_t* rarg_baudrate,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_baudrate", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("baudrate", *rarg_baudrate);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_baudrate(
	const string&	arg_ifname,
	Ifmgr01GetConfiguredBaudrateCB c_b)
{

    /* Return value declarations */
    uint64_t rarg_baudrate;
    XrlCmdError e = ifmgr_0_1_get_configured_baudrate(
        arg_ifname,
        rarg_baudrate);
    return c_b->dispatch(e,
        &rarg_baudrate);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_baudrate(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_baudrate");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredBaudrateRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_baudrate, pxa_outputs);
	async_ifmgr_0_1_get_configured_baudrate(
	    xa_inputs.get(0, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint64_t r_baudrate;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_baudrate(
	    xa_inputs.get(0, "ifname").text(),
	    r_baudrate);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_baudrate", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("baudrate", r_baudrate);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_enabled
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_vif_enabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_vif_enabled(
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01GetConfiguredVifEnabledCB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = ifmgr_0_1_get_configured_vif_enabled(
        arg_ifname,
        arg_vif,
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_enabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_enabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredVifEnabledRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_enabled, pxa_outputs);
	async_ifmgr_0_1_get_configured_vif_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_enabled(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_prefix4
    (const XrlCmdError &e,
     const uint32_t* rarg_prefix_len,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_prefix4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("prefix_len", *rarg_prefix_len);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_prefix4(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01GetConfiguredPrefix4CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_prefix_len;
    XrlCmdError e = ifmgr_0_1_get_configured_prefix4(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_prefix_len);
    return c_b->dispatch(e,
        &rarg_prefix_len);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_prefix4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredPrefix4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_prefix4, pxa_outputs);
	async_ifmgr_0_1_get_configured_prefix4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_prefix_len;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_prefix4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    r_prefix_len);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_prefix4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("prefix_len", r_prefix_len);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_broadcast4
    (const XrlCmdError &e,
     const IPv4* rarg_broadcast,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_broadcast4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("broadcast", *rarg_broadcast);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_broadcast4(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01GetConfiguredBroadcast4CB c_b)
{

    /* Return value declarations */
    IPv4 rarg_broadcast;
    XrlCmdError e = ifmgr_0_1_get_configured_broadcast4(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_broadcast);
    return c_b->dispatch(e,
        &rarg_broadcast);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_broadcast4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_broadcast4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredBroadcast4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_broadcast4, pxa_outputs);
	async_ifmgr_0_1_get_configured_broadcast4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_broadcast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_broadcast4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    r_broadcast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_broadcast4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("broadcast", r_broadcast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_endpoint4
    (const XrlCmdError &e,
     const IPv4* rarg_endpoint,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_endpoint4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("endpoint", *rarg_endpoint);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_endpoint4(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01GetConfiguredEndpoint4CB c_b)
{

    /* Return value declarations */
    IPv4 rarg_endpoint;
    XrlCmdError e = ifmgr_0_1_get_configured_endpoint4(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_endpoint);
    return c_b->dispatch(e,
        &rarg_endpoint);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_endpoint4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredEndpoint4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_endpoint4, pxa_outputs);
	async_ifmgr_0_1_get_configured_endpoint4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_endpoint;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_endpoint4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    r_endpoint);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_endpoint4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("endpoint", r_endpoint);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_start_transaction
    (const XrlCmdError &e,
     const uint32_t* rarg_tid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/start_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tid", *rarg_tid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_start_transaction(
	Ifmgr01StartTransactionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_tid;
    XrlCmdError e = ifmgr_0_1_start_transaction(
        rarg_tid);
    return c_b->dispatch(e,
        &rarg_tid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_start_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/start_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01StartTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_start_transaction, pxa_outputs);
	async_ifmgr_0_1_start_transaction( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_tid;
    try {
	XrlCmdError e = ifmgr_0_1_start_transaction(
	    r_tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", r_tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_commit_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/commit_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_commit_transaction(
	const uint32_t&	arg_tid,
	Ifmgr01CommitTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_commit_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/commit_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CommitTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_commit_transaction, pxa_outputs);
	async_ifmgr_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_abort_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/abort_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_abort_transaction(
	const uint32_t&	arg_tid,
	Ifmgr01AbortTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_abort_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/abort_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01AbortTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_abort_transaction, pxa_outputs);
	async_ifmgr_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_create_interface
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/create_interface", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_create_interface(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	Ifmgr01CreateInterfaceCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_create_interface(
        arg_tid,
        arg_ifname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_create_interface(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_interface");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CreateInterfaceRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_create_interface, pxa_outputs);
	async_ifmgr_0_1_create_interface(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_interface(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_interface", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_delete_interface
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/delete_interface", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_delete_interface(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	Ifmgr01DeleteInterfaceCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_delete_interface(
        arg_tid,
        arg_ifname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_delete_interface(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_interface");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01DeleteInterfaceRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_delete_interface, pxa_outputs);
	async_ifmgr_0_1_delete_interface(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_interface(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_interface", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_configure_all_interfaces_from_system
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/configure_all_interfaces_from_system", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_configure_all_interfaces_from_system(
	const uint32_t&	arg_tid,
	const bool&	arg_enable,
	Ifmgr01ConfigureAllInterfacesFromSystemCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_configure_all_interfaces_from_system(
        arg_tid,
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_configure_all_interfaces_from_system(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/configure_all_interfaces_from_system");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01ConfigureAllInterfacesFromSystemRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_configure_all_interfaces_from_system, pxa_outputs);
	async_ifmgr_0_1_configure_all_interfaces_from_system(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_configure_all_interfaces_from_system(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/configure_all_interfaces_from_system", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_configure_interface_from_system
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/configure_interface_from_system", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_configure_interface_from_system(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const bool&	arg_enable,
	Ifmgr01ConfigureInterfaceFromSystemCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_configure_interface_from_system(
        arg_tid,
        arg_ifname,
        arg_enable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_configure_interface_from_system(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/configure_interface_from_system");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01ConfigureInterfaceFromSystemRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_configure_interface_from_system, pxa_outputs);
	async_ifmgr_0_1_configure_interface_from_system(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "enable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_configure_interface_from_system(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "enable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/configure_interface_from_system", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_enabled
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_interface_enabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_interface_enabled(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const bool&	arg_enabled,
	Ifmgr01SetInterfaceEnabledCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_interface_enabled(
        arg_tid,
        arg_ifname,
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_enabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_enabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetInterfaceEnabledRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_enabled, pxa_outputs);
	async_ifmgr_0_1_set_interface_enabled(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_enabled(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_discard
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_interface_discard", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_interface_discard(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const bool&	arg_discard,
	Ifmgr01SetInterfaceDiscardCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_interface_discard(
        arg_tid,
        arg_ifname,
        arg_discard);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_discard(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_discard");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetInterfaceDiscardRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_discard, pxa_outputs);
	async_ifmgr_0_1_set_interface_discard(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "discard").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_discard(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "discard").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_discard", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_unreachable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_interface_unreachable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_interface_unreachable(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const bool&	arg_unreachable,
	Ifmgr01SetInterfaceUnreachableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_interface_unreachable(
        arg_tid,
        arg_ifname,
        arg_unreachable);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_unreachable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_unreachable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetInterfaceUnreachableRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_unreachable, pxa_outputs);
	async_ifmgr_0_1_set_interface_unreachable(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "unreachable").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_unreachable(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "unreachable").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_unreachable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_management
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_interface_management", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_interface_management(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const bool&	arg_management,
	Ifmgr01SetInterfaceManagementCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_interface_management(
        arg_tid,
        arg_ifname,
        arg_management);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_interface_management(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_interface_management");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetInterfaceManagementRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_interface_management, pxa_outputs);
	async_ifmgr_0_1_set_interface_management(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "management").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_interface_management(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "management").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_interface_management", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_mac
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_mac", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_mac(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const Mac&	arg_mac,
	Ifmgr01SetMacCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_mac(
        arg_tid,
        arg_ifname,
        arg_mac);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_mac(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_mac");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetMacRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_mac, pxa_outputs);
	async_ifmgr_0_1_set_mac(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "mac").mac(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_mac(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "mac").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_create_mac
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/create_mac", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_create_mac(
	const string&	arg_ifname,
	const Mac&	arg_mac,
	Ifmgr01CreateMacCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_create_mac(
        arg_ifname,
        arg_mac);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_create_mac(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_mac");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CreateMacRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_create_mac, pxa_outputs);
	async_ifmgr_0_1_create_mac(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "mac").mac(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_mac(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "mac").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_delete_mac
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/delete_mac", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_delete_mac(
	const string&	arg_ifname,
	const Mac&	arg_mac,
	Ifmgr01DeleteMacCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_delete_mac(
        arg_ifname,
        arg_mac);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_delete_mac(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_mac");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01DeleteMacRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_delete_mac, pxa_outputs);
	async_ifmgr_0_1_delete_mac(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "mac").mac(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_mac(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "mac").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_restore_original_mac
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/restore_original_mac", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_restore_original_mac(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	Ifmgr01RestoreOriginalMacCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_restore_original_mac(
        arg_tid,
        arg_ifname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mac(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/restore_original_mac");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01RestoreOriginalMacRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_restore_original_mac, pxa_outputs);
	async_ifmgr_0_1_restore_original_mac(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_restore_original_mac(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/restore_original_mac", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_mtu
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_mtu", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_mtu(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const uint32_t&	arg_mtu,
	Ifmgr01SetMtuCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_mtu(
        arg_tid,
        arg_ifname,
        arg_mtu);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_mtu(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_mtu");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetMtuRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_mtu, pxa_outputs);
	async_ifmgr_0_1_set_mtu(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "mtu").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_mtu(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "mtu").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_mtu", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_restore_original_mtu
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/restore_original_mtu", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_restore_original_mtu(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	Ifmgr01RestoreOriginalMtuCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_restore_original_mtu(
        arg_tid,
        arg_ifname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_restore_original_mtu(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/restore_original_mtu");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01RestoreOriginalMtuRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_restore_original_mtu, pxa_outputs);
	async_ifmgr_0_1_restore_original_mtu(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_restore_original_mtu(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/restore_original_mtu", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_create_vif
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/create_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_create_vif(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01CreateVifCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_create_vif(
        arg_tid,
        arg_ifname,
        arg_vif);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_create_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CreateVifRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_create_vif, pxa_outputs);
	async_ifmgr_0_1_create_vif(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_vif(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_delete_vif
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/delete_vif", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_delete_vif(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01DeleteVifCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_delete_vif(
        arg_tid,
        arg_ifname,
        arg_vif);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_delete_vif(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_vif");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01DeleteVifRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_delete_vif, pxa_outputs);
	async_ifmgr_0_1_delete_vif(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_vif(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_vif", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_vif_enabled
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_vif_enabled", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_vif_enabled(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const bool&	arg_enabled,
	Ifmgr01SetVifEnabledCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_vif_enabled(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_vif_enabled(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_vif_enabled");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetVifEnabledRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_vif_enabled, pxa_outputs);
	async_ifmgr_0_1_set_vif_enabled(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_vif_enabled(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_vif_enabled", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_parent_ifname
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_parent_ifname", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_parent_ifname(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_parent_ifname,
	Ifmgr01SetParentIfnameCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_parent_ifname(
        arg_tid,
        arg_ifname,
        arg_parent_ifname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_parent_ifname(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_parent_ifname");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetParentIfnameRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_parent_ifname, pxa_outputs);
	async_ifmgr_0_1_set_parent_ifname(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "parent_ifname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_parent_ifname(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "parent_ifname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_parent_ifname", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_iface_type
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_iface_type", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_iface_type(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_iface_type,
	Ifmgr01SetIfaceTypeCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_iface_type(
        arg_tid,
        arg_ifname,
        arg_iface_type);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_iface_type(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_iface_type");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetIfaceTypeRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_iface_type, pxa_outputs);
	async_ifmgr_0_1_set_iface_type(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "iface_type").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_iface_type(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "iface_type").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_iface_type", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_vid
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_vid", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_vid(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vid,
	Ifmgr01SetVidCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_vid(
        arg_tid,
        arg_ifname,
        arg_vid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_vid(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_vid");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetVidRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_vid, pxa_outputs);
	async_ifmgr_0_1_set_vid(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_vid(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_vid", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_create_address4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/create_address4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_create_address4(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01CreateAddress4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_create_address4(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_create_address4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_address4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CreateAddress4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_create_address4, pxa_outputs);
	async_ifmgr_0_1_create_address4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_address4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_address4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_delete_address4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/delete_address4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_delete_address4(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01DeleteAddress4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_delete_address4(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_delete_address4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_address4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01DeleteAddress4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_delete_address4, pxa_outputs);
	async_ifmgr_0_1_delete_address4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_address4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_address4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_create_address_atomic
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/create_address_atomic", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_create_address_atomic(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	const uint32_t&	arg_prefix_length,
	Ifmgr01CreateAddressAtomicCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_create_address_atomic(
        arg_ifname,
        arg_vif,
        arg_address,
        arg_prefix_length);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_create_address_atomic(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_address_atomic");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CreateAddressAtomicRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_create_address_atomic, pxa_outputs);
	async_ifmgr_0_1_create_address_atomic(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    xa_inputs.get(3, "prefix_length").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_address_atomic(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    xa_inputs.get(3, "prefix_length").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_address_atomic", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_delete_address_atomic
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/delete_address_atomic", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_delete_address_atomic(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01DeleteAddressAtomicCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_delete_address_atomic(
        arg_ifname,
        arg_vif,
        arg_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_delete_address_atomic(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_address_atomic");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01DeleteAddressAtomicRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_delete_address_atomic, pxa_outputs);
	async_ifmgr_0_1_delete_address_atomic(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_address_atomic(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_address_atomic", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_address_enabled4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_address_enabled4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_address_enabled4(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	const bool&	arg_enabled,
	Ifmgr01SetAddressEnabled4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_address_enabled4(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_address_enabled4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetAddressEnabled4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_address_enabled4, pxa_outputs);
	async_ifmgr_0_1_set_address_enabled4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_address_enabled4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_address_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_enabled4
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_address_enabled4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_address_enabled4(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	Ifmgr01GetConfiguredAddressEnabled4CB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = ifmgr_0_1_get_configured_address_enabled4(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_enabled4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredAddressEnabled4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_enabled4, pxa_outputs);
	async_ifmgr_0_1_get_configured_address_enabled4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_enabled4(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv4(),
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_prefix4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_prefix4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_prefix4(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	const uint32_t&	arg_prefix_len,
	Ifmgr01SetPrefix4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_prefix4(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_prefix_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_prefix4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetPrefix4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_prefix4, pxa_outputs);
	async_ifmgr_0_1_set_prefix4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "prefix_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_prefix4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_prefix4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_broadcast4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_broadcast4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_broadcast4(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	const IPv4&	arg_broadcast,
	Ifmgr01SetBroadcast4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_broadcast4(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_broadcast);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_broadcast4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_broadcast4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetBroadcast4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_broadcast4, pxa_outputs);
	async_ifmgr_0_1_set_broadcast4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "broadcast").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_broadcast4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "broadcast").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_broadcast4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_endpoint4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_endpoint4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_endpoint4(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv4&	arg_address,
	const IPv4&	arg_endpoint,
	Ifmgr01SetEndpoint4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_endpoint4(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_endpoint);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_endpoint4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetEndpoint4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_endpoint4, pxa_outputs);
	async_ifmgr_0_1_set_endpoint4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "endpoint").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_endpoint4(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv4(),
	    xa_inputs.get(4, "endpoint").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_endpoint4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_startup_ifmgr
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/startup_ifmgr", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_startup_ifmgr(
	Ifmgr01StartupIfmgrCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_startup_ifmgr();
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_startup_ifmgr(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/startup_ifmgr");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01StartupIfmgrRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_startup_ifmgr, pxa_outputs);
	async_ifmgr_0_1_startup_ifmgr( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_startup_ifmgr();
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/startup_ifmgr", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_addresses6
    (const XrlCmdError &e,
     const XrlAtomList* rarg_addresses,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_vif_addresses6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("addresses", *rarg_addresses);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_vif_addresses6(
	const string&	arg_ifname,
	const string&	arg_vif,
	Ifmgr01GetConfiguredVifAddresses6CB c_b)
{

    /* Return value declarations */
    XrlAtomList rarg_addresses;
    XrlCmdError e = ifmgr_0_1_get_configured_vif_addresses6(
        arg_ifname,
        arg_vif,
        rarg_addresses);
    return c_b->dispatch(e,
        &rarg_addresses);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_vif_addresses6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_vif_addresses6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredVifAddresses6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_vif_addresses6, pxa_outputs);
	async_ifmgr_0_1_get_configured_vif_addresses6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    XrlAtomList r_addresses;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_vif_addresses6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    r_addresses);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_vif_addresses6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("addresses", r_addresses);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_flags6
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     const bool* rarg_loopback,
     const bool* rarg_point_to_point,
     const bool* rarg_multicast,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_address_flags6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
	    out.add("loopback", *rarg_loopback);
	    out.add("point_to_point", *rarg_point_to_point);
	    out.add("multicast", *rarg_multicast);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_address_flags6(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	Ifmgr01GetConfiguredAddressFlags6CB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    bool rarg_loopback;
    bool rarg_point_to_point;
    bool rarg_multicast;
    XrlCmdError e = ifmgr_0_1_get_configured_address_flags6(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_enabled,
        rarg_loopback,
        rarg_point_to_point,
        rarg_multicast);
    return c_b->dispatch(e,
        &rarg_enabled,
        &rarg_loopback,
        &rarg_point_to_point,
        &rarg_multicast);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_flags6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_flags6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredAddressFlags6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_flags6, pxa_outputs);
	async_ifmgr_0_1_get_configured_address_flags6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    bool r_loopback;
    bool r_point_to_point;
    bool r_multicast;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_flags6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    r_enabled,
	    r_loopback,
	    r_point_to_point,
	    r_multicast);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_flags6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
	pxa_outputs->add("loopback", r_loopback);
	pxa_outputs->add("point_to_point", r_point_to_point);
	pxa_outputs->add("multicast", r_multicast);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_prefix6
    (const XrlCmdError &e,
     const uint32_t* rarg_prefix_len,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_prefix6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("prefix_len", *rarg_prefix_len);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_prefix6(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	Ifmgr01GetConfiguredPrefix6CB c_b)
{

    /* Return value declarations */
    uint32_t rarg_prefix_len;
    XrlCmdError e = ifmgr_0_1_get_configured_prefix6(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_prefix_len);
    return c_b->dispatch(e,
        &rarg_prefix_len);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_prefix6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_prefix6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredPrefix6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_prefix6, pxa_outputs);
	async_ifmgr_0_1_get_configured_prefix6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_prefix_len;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_prefix6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    r_prefix_len);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_prefix6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("prefix_len", r_prefix_len);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_endpoint6
    (const XrlCmdError &e,
     const IPv6* rarg_endpoint,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_endpoint6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("endpoint", *rarg_endpoint);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_endpoint6(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	Ifmgr01GetConfiguredEndpoint6CB c_b)
{

    /* Return value declarations */
    IPv6 rarg_endpoint;
    XrlCmdError e = ifmgr_0_1_get_configured_endpoint6(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_endpoint);
    return c_b->dispatch(e,
        &rarg_endpoint);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_endpoint6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_endpoint6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredEndpoint6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_endpoint6, pxa_outputs);
	async_ifmgr_0_1_get_configured_endpoint6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv6 r_endpoint;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_endpoint6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    r_endpoint);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_endpoint6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("endpoint", r_endpoint);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_create_address6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/create_address6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_create_address6(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	Ifmgr01CreateAddress6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_create_address6(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_create_address6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/create_address6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01CreateAddress6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_create_address6, pxa_outputs);
	async_ifmgr_0_1_create_address6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_create_address6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/create_address6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_delete_address6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/delete_address6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_delete_address6(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	Ifmgr01DeleteAddress6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_delete_address6(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_delete_address6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/delete_address6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01DeleteAddress6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_delete_address6, pxa_outputs);
	async_ifmgr_0_1_delete_address6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_delete_address6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/delete_address6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_address_enabled6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_address_enabled6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_address_enabled6(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	const bool&	arg_enabled,
	Ifmgr01SetAddressEnabled6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_address_enabled6(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_address_enabled6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_address_enabled6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetAddressEnabled6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_address_enabled6, pxa_outputs);
	async_ifmgr_0_1_set_address_enabled6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_address_enabled6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_address_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_enabled6
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/get_configured_address_enabled6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_get_configured_address_enabled6(
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	Ifmgr01GetConfiguredAddressEnabled6CB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = ifmgr_0_1_get_configured_address_enabled6(
        arg_ifname,
        arg_vif,
        arg_address,
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_get_configured_address_enabled6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/get_configured_address_enabled6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01GetConfiguredAddressEnabled6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_get_configured_address_enabled6, pxa_outputs);
	async_ifmgr_0_1_get_configured_address_enabled6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = ifmgr_0_1_get_configured_address_enabled6(
	    xa_inputs.get(0, "ifname").text(),
	    xa_inputs.get(1, "vif").text(),
	    xa_inputs.get(2, "address").ipv6(),
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/get_configured_address_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_prefix6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_prefix6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_prefix6(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	const uint32_t&	arg_prefix_len,
	Ifmgr01SetPrefix6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_prefix6(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_prefix_len);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_prefix6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_prefix6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetPrefix6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_prefix6, pxa_outputs);
	async_ifmgr_0_1_set_prefix6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "prefix_len").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_prefix6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "prefix_len").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_prefix6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_0_1_set_endpoint6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr/0.1/set_endpoint6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_0_1_set_endpoint6(
	const uint32_t&	arg_tid,
	const string&	arg_ifname,
	const string&	arg_vif,
	const IPv6&	arg_address,
	const IPv6&	arg_endpoint,
	Ifmgr01SetEndpoint6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_0_1_set_endpoint6(
        arg_tid,
        arg_ifname,
        arg_vif,
        arg_address,
        arg_endpoint);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_0_1_set_endpoint6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "ifmgr/0.1/set_endpoint6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Ifmgr01SetEndpoint6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_0_1_set_endpoint6, pxa_outputs);
	async_ifmgr_0_1_set_endpoint6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "endpoint").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_0_1_set_endpoint6(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vif").text(),
	    xa_inputs.get(3, "address").ipv6(),
	    xa_inputs.get(4, "endpoint").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr/0.1/set_endpoint6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_replicator_0_1_register_ifmgr_mirror
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr_replicator/0.1/register_ifmgr_mirror", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_replicator_0_1_register_ifmgr_mirror(
	const string&	arg_clientname,
	IfmgrReplicator01RegisterIfmgrMirrorCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_replicator_0_1_register_ifmgr_mirror(
        arg_clientname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_replicator_0_1_register_ifmgr_mirror(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr_replicator/0.1/register_ifmgr_mirror");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	IfmgrReplicator01RegisterIfmgrMirrorRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_replicator_0_1_register_ifmgr_mirror, pxa_outputs);
	async_ifmgr_replicator_0_1_register_ifmgr_mirror(
	    xa_inputs.get(0, "clientname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_replicator_0_1_register_ifmgr_mirror(
	    xa_inputs.get(0, "clientname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr_replicator/0.1/register_ifmgr_mirror", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_ifmgr_replicator_0_1_unregister_ifmgr_mirror
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "ifmgr_replicator/0.1/unregister_ifmgr_mirror", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_ifmgr_replicator_0_1_unregister_ifmgr_mirror(
	const string&	arg_clientname,
	IfmgrReplicator01UnregisterIfmgrMirrorCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = ifmgr_replicator_0_1_unregister_ifmgr_mirror(
        arg_clientname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_ifmgr_replicator_0_1_unregister_ifmgr_mirror(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "ifmgr_replicator/0.1/unregister_ifmgr_mirror");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	IfmgrReplicator01UnregisterIfmgrMirrorRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_ifmgr_replicator_0_1_unregister_ifmgr_mirror, pxa_outputs);
	async_ifmgr_replicator_0_1_unregister_ifmgr_mirror(
	    xa_inputs.get(0, "clientname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = ifmgr_replicator_0_1_unregister_ifmgr_mirror(
	    xa_inputs.get(0, "clientname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "ifmgr_replicator/0.1/unregister_ifmgr_mirror", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_dest4
    (const XrlCmdError &e,
     const IPv4Net* rarg_netmask,
     const IPv4* rarg_nexthop,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const uint32_t* rarg_metric,
     const uint32_t* rarg_admin_distance,
     const string* rarg_protocol_origin,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/lookup_route_by_dest4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("netmask", *rarg_netmask);
	    out.add("nexthop", *rarg_nexthop);
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("metric", *rarg_metric);
	    out.add("admin_distance", *rarg_admin_distance);
	    out.add("protocol_origin", *rarg_protocol_origin);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_lookup_route_by_dest4(
	const IPv4&	arg_dst,
	Fti02LookupRouteByDest4CB c_b)
{

    /* Return value declarations */
    IPv4Net rarg_netmask;
    IPv4 rarg_nexthop;
    string rarg_ifname;
    string rarg_vifname;
    uint32_t rarg_metric;
    uint32_t rarg_admin_distance;
    string rarg_protocol_origin;
    XrlCmdError e = fti_0_2_lookup_route_by_dest4(
        arg_dst,
        rarg_netmask,
        rarg_nexthop,
        rarg_ifname,
        rarg_vifname,
        rarg_metric,
        rarg_admin_distance,
        rarg_protocol_origin);
    return c_b->dispatch(e,
        &rarg_netmask,
        &rarg_nexthop,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_metric,
        &rarg_admin_distance,
        &rarg_protocol_origin);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_dest4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02LookupRouteByDest4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_dest4, pxa_outputs);
	async_fti_0_2_lookup_route_by_dest4(
	    xa_inputs.get(0, "dst").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4Net r_netmask;
    IPv4 r_nexthop;
    string r_ifname;
    string r_vifname;
    uint32_t r_metric;
    uint32_t r_admin_distance;
    string r_protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_dest4(
	    xa_inputs.get(0, "dst").ipv4(),
	    r_netmask,
	    r_nexthop,
	    r_ifname,
	    r_vifname,
	    r_metric,
	    r_admin_distance,
	    r_protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_dest4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("netmask", r_netmask);
	pxa_outputs->add("nexthop", r_nexthop);
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("metric", r_metric);
	pxa_outputs->add("admin_distance", r_admin_distance);
	pxa_outputs->add("protocol_origin", r_protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_network4
    (const XrlCmdError &e,
     const IPv4* rarg_nexthop,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const uint32_t* rarg_metric,
     const uint32_t* rarg_admin_distance,
     const string* rarg_protocol_origin,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/lookup_route_by_network4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("nexthop", *rarg_nexthop);
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("metric", *rarg_metric);
	    out.add("admin_distance", *rarg_admin_distance);
	    out.add("protocol_origin", *rarg_protocol_origin);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_lookup_route_by_network4(
	const IPv4Net&	arg_dst,
	Fti02LookupRouteByNetwork4CB c_b)
{

    /* Return value declarations */
    IPv4 rarg_nexthop;
    string rarg_ifname;
    string rarg_vifname;
    uint32_t rarg_metric;
    uint32_t rarg_admin_distance;
    string rarg_protocol_origin;
    XrlCmdError e = fti_0_2_lookup_route_by_network4(
        arg_dst,
        rarg_nexthop,
        rarg_ifname,
        rarg_vifname,
        rarg_metric,
        rarg_admin_distance,
        rarg_protocol_origin);
    return c_b->dispatch(e,
        &rarg_nexthop,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_metric,
        &rarg_admin_distance,
        &rarg_protocol_origin);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_network4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02LookupRouteByNetwork4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_network4, pxa_outputs);
	async_fti_0_2_lookup_route_by_network4(
	    xa_inputs.get(0, "dst").ipv4net(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv4 r_nexthop;
    string r_ifname;
    string r_vifname;
    uint32_t r_metric;
    uint32_t r_admin_distance;
    string r_protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_network4(
	    xa_inputs.get(0, "dst").ipv4net(),
	    r_nexthop,
	    r_ifname,
	    r_vifname,
	    r_metric,
	    r_admin_distance,
	    r_protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_network4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nexthop", r_nexthop);
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("metric", r_metric);
	pxa_outputs->add("admin_distance", r_admin_distance);
	pxa_outputs->add("protocol_origin", r_protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_have_ipv4
    (const XrlCmdError &e,
     const bool* rarg_result,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/have_ipv4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("result", *rarg_result);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_have_ipv4(
	Fti02HaveIpv4CB c_b)
{

    /* Return value declarations */
    bool rarg_result;
    XrlCmdError e = fti_0_2_have_ipv4(
        rarg_result);
    return c_b->dispatch(e,
        &rarg_result);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_have_ipv4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/have_ipv4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02HaveIpv4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_have_ipv4, pxa_outputs);
	async_fti_0_2_have_ipv4( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_result;
    try {
	XrlCmdError e = fti_0_2_have_ipv4(
	    r_result);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/have_ipv4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("result", r_result);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_get_unicast_forwarding_enabled4
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/get_unicast_forwarding_enabled4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_get_unicast_forwarding_enabled4(
	Fti02GetUnicastForwardingEnabled4CB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = fti_0_2_get_unicast_forwarding_enabled4(
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/get_unicast_forwarding_enabled4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02GetUnicastForwardingEnabled4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_get_unicast_forwarding_enabled4, pxa_outputs);
	async_fti_0_2_get_unicast_forwarding_enabled4( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = fti_0_2_get_unicast_forwarding_enabled4(
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/get_unicast_forwarding_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_enabled4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_enabled4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_enabled4(
	const bool&	arg_enabled,
	Fti02SetUnicastForwardingEnabled4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_enabled4(
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_enabled4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingEnabled4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_enabled4, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_enabled4(
	    xa_inputs.get(0, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_enabled4(
	    xa_inputs.get(0, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_enabled4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
	const bool&	arg_retain,
	Fti02SetUnicastForwardingEntriesRetainOnStartup4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
        arg_retain);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingEntriesRetainOnStartup4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
	    xa_inputs.get(0, "retain").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_startup4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
	const bool&	arg_retain,
	Fti02SetUnicastForwardingEntriesRetainOnShutdown4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
        arg_retain);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
	    xa_inputs.get(0, "retain").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_table_id4
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_table_id4", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_table_id4(
	const bool&	arg_is_configured,
	const uint32_t&	arg_table_id,
	Fti02SetUnicastForwardingTableId4CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_table_id4(
        arg_is_configured,
        arg_table_id);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id4(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_table_id4");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingTableId4RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_table_id4, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_table_id4(
	    xa_inputs.get(0, "is_configured").boolean(),
	    xa_inputs.get(1, "table_id").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_table_id4(
	    xa_inputs.get(0, "is_configured").boolean(),
	    xa_inputs.get(1, "table_id").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_table_id4", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_dest6
    (const XrlCmdError &e,
     const IPv6Net* rarg_netmask,
     const IPv6* rarg_nexthop,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const uint32_t* rarg_metric,
     const uint32_t* rarg_admin_distance,
     const string* rarg_protocol_origin,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/lookup_route_by_dest6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("netmask", *rarg_netmask);
	    out.add("nexthop", *rarg_nexthop);
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("metric", *rarg_metric);
	    out.add("admin_distance", *rarg_admin_distance);
	    out.add("protocol_origin", *rarg_protocol_origin);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_lookup_route_by_dest6(
	const IPv6&	arg_dst,
	Fti02LookupRouteByDest6CB c_b)
{

    /* Return value declarations */
    IPv6Net rarg_netmask;
    IPv6 rarg_nexthop;
    string rarg_ifname;
    string rarg_vifname;
    uint32_t rarg_metric;
    uint32_t rarg_admin_distance;
    string rarg_protocol_origin;
    XrlCmdError e = fti_0_2_lookup_route_by_dest6(
        arg_dst,
        rarg_netmask,
        rarg_nexthop,
        rarg_ifname,
        rarg_vifname,
        rarg_metric,
        rarg_admin_distance,
        rarg_protocol_origin);
    return c_b->dispatch(e,
        &rarg_netmask,
        &rarg_nexthop,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_metric,
        &rarg_admin_distance,
        &rarg_protocol_origin);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_dest6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_dest6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02LookupRouteByDest6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_dest6, pxa_outputs);
	async_fti_0_2_lookup_route_by_dest6(
	    xa_inputs.get(0, "dst").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv6Net r_netmask;
    IPv6 r_nexthop;
    string r_ifname;
    string r_vifname;
    uint32_t r_metric;
    uint32_t r_admin_distance;
    string r_protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_dest6(
	    xa_inputs.get(0, "dst").ipv6(),
	    r_netmask,
	    r_nexthop,
	    r_ifname,
	    r_vifname,
	    r_metric,
	    r_admin_distance,
	    r_protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_dest6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("netmask", r_netmask);
	pxa_outputs->add("nexthop", r_nexthop);
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("metric", r_metric);
	pxa_outputs->add("admin_distance", r_admin_distance);
	pxa_outputs->add("protocol_origin", r_protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_network6
    (const XrlCmdError &e,
     const IPv6* rarg_nexthop,
     const string* rarg_ifname,
     const string* rarg_vifname,
     const uint32_t* rarg_metric,
     const uint32_t* rarg_admin_distance,
     const string* rarg_protocol_origin,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/lookup_route_by_network6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("nexthop", *rarg_nexthop);
	    out.add("ifname", *rarg_ifname);
	    out.add("vifname", *rarg_vifname);
	    out.add("metric", *rarg_metric);
	    out.add("admin_distance", *rarg_admin_distance);
	    out.add("protocol_origin", *rarg_protocol_origin);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_lookup_route_by_network6(
	const IPv6Net&	arg_dst,
	Fti02LookupRouteByNetwork6CB c_b)
{

    /* Return value declarations */
    IPv6 rarg_nexthop;
    string rarg_ifname;
    string rarg_vifname;
    uint32_t rarg_metric;
    uint32_t rarg_admin_distance;
    string rarg_protocol_origin;
    XrlCmdError e = fti_0_2_lookup_route_by_network6(
        arg_dst,
        rarg_nexthop,
        rarg_ifname,
        rarg_vifname,
        rarg_metric,
        rarg_admin_distance,
        rarg_protocol_origin);
    return c_b->dispatch(e,
        &rarg_nexthop,
        &rarg_ifname,
        &rarg_vifname,
        &rarg_metric,
        &rarg_admin_distance,
        &rarg_protocol_origin);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_lookup_route_by_network6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/lookup_route_by_network6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02LookupRouteByNetwork6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_lookup_route_by_network6, pxa_outputs);
	async_fti_0_2_lookup_route_by_network6(
	    xa_inputs.get(0, "dst").ipv6net(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    IPv6 r_nexthop;
    string r_ifname;
    string r_vifname;
    uint32_t r_metric;
    uint32_t r_admin_distance;
    string r_protocol_origin;
    try {
	XrlCmdError e = fti_0_2_lookup_route_by_network6(
	    xa_inputs.get(0, "dst").ipv6net(),
	    r_nexthop,
	    r_ifname,
	    r_vifname,
	    r_metric,
	    r_admin_distance,
	    r_protocol_origin);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/lookup_route_by_network6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("nexthop", r_nexthop);
	pxa_outputs->add("ifname", r_ifname);
	pxa_outputs->add("vifname", r_vifname);
	pxa_outputs->add("metric", r_metric);
	pxa_outputs->add("admin_distance", r_admin_distance);
	pxa_outputs->add("protocol_origin", r_protocol_origin);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_have_ipv6
    (const XrlCmdError &e,
     const bool* rarg_result,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/have_ipv6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("result", *rarg_result);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_have_ipv6(
	Fti02HaveIpv6CB c_b)
{

    /* Return value declarations */
    bool rarg_result;
    XrlCmdError e = fti_0_2_have_ipv6(
        rarg_result);
    return c_b->dispatch(e,
        &rarg_result);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_have_ipv6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/have_ipv6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02HaveIpv6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_have_ipv6, pxa_outputs);
	async_fti_0_2_have_ipv6( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_result;
    try {
	XrlCmdError e = fti_0_2_have_ipv6(
	    r_result);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/have_ipv6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("result", r_result);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_get_unicast_forwarding_enabled6
    (const XrlCmdError &e,
     const bool* rarg_enabled,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/get_unicast_forwarding_enabled6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("enabled", *rarg_enabled);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_get_unicast_forwarding_enabled6(
	Fti02GetUnicastForwardingEnabled6CB c_b)
{

    /* Return value declarations */
    bool rarg_enabled;
    XrlCmdError e = fti_0_2_get_unicast_forwarding_enabled6(
        rarg_enabled);
    return c_b->dispatch(e,
        &rarg_enabled);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_get_unicast_forwarding_enabled6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/get_unicast_forwarding_enabled6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02GetUnicastForwardingEnabled6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_get_unicast_forwarding_enabled6, pxa_outputs);
	async_fti_0_2_get_unicast_forwarding_enabled6( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    bool r_enabled;
    try {
	XrlCmdError e = fti_0_2_get_unicast_forwarding_enabled6(
	    r_enabled);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/get_unicast_forwarding_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("enabled", r_enabled);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_enabled6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_enabled6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_enabled6(
	const bool&	arg_enabled,
	Fti02SetUnicastForwardingEnabled6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_enabled6(
        arg_enabled);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_enabled6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_enabled6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingEnabled6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_enabled6, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_enabled6(
	    xa_inputs.get(0, "enabled").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_enabled6(
	    xa_inputs.get(0, "enabled").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_enabled6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
	const bool&	arg_retain,
	Fti02SetUnicastForwardingEntriesRetainOnStartup6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
        arg_retain);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingEntriesRetainOnStartup6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
	    xa_inputs.get(0, "retain").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_startup6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
	const bool&	arg_retain,
	Fti02SetUnicastForwardingEntriesRetainOnShutdown6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
        arg_retain);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
	    xa_inputs.get(0, "retain").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
	    xa_inputs.get(0, "retain").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_entries_retain_on_shutdown6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_table_id6
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "fti/0.2/set_unicast_forwarding_table_id6", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_fti_0_2_set_unicast_forwarding_table_id6(
	const bool&	arg_is_configured,
	const uint32_t&	arg_table_id,
	Fti02SetUnicastForwardingTableId6CB c_b)
{

    /* Return value declarations */
    XrlCmdError e = fti_0_2_set_unicast_forwarding_table_id6(
        arg_is_configured,
        arg_table_id);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_fti_0_2_set_unicast_forwarding_table_id6(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "fti/0.2/set_unicast_forwarding_table_id6");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Fti02SetUnicastForwardingTableId6RF mycb =
	    callback(this, &XrlFeaTargetBase::callback_fti_0_2_set_unicast_forwarding_table_id6, pxa_outputs);
	async_fti_0_2_set_unicast_forwarding_table_id6(
	    xa_inputs.get(0, "is_configured").boolean(),
	    xa_inputs.get(1, "table_id").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = fti_0_2_set_unicast_forwarding_table_id6(
	    xa_inputs.get(0, "is_configured").boolean(),
	    xa_inputs.get(1, "table_id").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "fti/0.2/set_unicast_forwarding_table_id6", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction4_0_1_start_transaction
    (const XrlCmdError &e,
     const uint32_t* rarg_tid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/start_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tid", *rarg_tid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction4_0_1_start_transaction(
	RedistTransaction401StartTransactionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_tid;
    XrlCmdError e = redist_transaction4_0_1_start_transaction(
        rarg_tid);
    return c_b->dispatch(e,
        &rarg_tid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction4_0_1_start_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/start_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401StartTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction4_0_1_start_transaction, pxa_outputs);
	async_redist_transaction4_0_1_start_transaction( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_tid;
    try {
	XrlCmdError e = redist_transaction4_0_1_start_transaction(
	    r_tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", r_tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction4_0_1_commit_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/commit_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction4_0_1_commit_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction401CommitTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_commit_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction4_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/commit_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401CommitTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction4_0_1_commit_transaction, pxa_outputs);
	async_redist_transaction4_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction4_0_1_abort_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/abort_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction4_0_1_abort_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction401AbortTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_abort_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction4_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/abort_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401AbortTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction4_0_1_abort_transaction, pxa_outputs);
	async_redist_transaction4_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction4_0_1_add_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/add_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction4_0_1_add_route(
	const uint32_t&	arg_tid,
	const IPv4Net&	arg_dst,
	const IPv4&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction401AddRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_add_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction4_0_1_add_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/add_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401AddRouteRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction4_0_1_add_route, pxa_outputs);
	async_redist_transaction4_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/add_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction4_0_1_delete_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/delete_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction4_0_1_delete_route(
	const uint32_t&	arg_tid,
	const IPv4Net&	arg_dst,
	const IPv4&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction401DeleteRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_delete_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/delete_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401DeleteRouteRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction4_0_1_delete_route, pxa_outputs);
	async_redist_transaction4_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv4net(),
	    xa_inputs.get(2, "nexthop").ipv4(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/delete_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction4_0_1_delete_all_routes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction4/0.1/delete_all_routes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction4_0_1_delete_all_routes(
	const uint32_t&	arg_tid,
	const string&	arg_cookie,
	RedistTransaction401DeleteAllRoutesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction4_0_1_delete_all_routes(
        arg_tid,
        arg_cookie);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction4_0_1_delete_all_routes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction4/0.1/delete_all_routes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction401DeleteAllRoutesRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction4_0_1_delete_all_routes, pxa_outputs);
	async_redist_transaction4_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction4_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction4/0.1/delete_all_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_link_0_1_send
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_link/0.1/send", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_link_0_1_send(
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const Mac&	arg_src_address,
	const Mac&	arg_dst_address,
	const uint32_t&	arg_ether_type,
	const vector<uint8_t>&	arg_payload,
	RawLink01SendCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_link_0_1_send(
        arg_if_name,
        arg_vif_name,
        arg_src_address,
        arg_dst_address,
        arg_ether_type,
        arg_payload);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_link_0_1_send(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/send");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawLink01SendRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_link_0_1_send, pxa_outputs);
	async_raw_link_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").mac(),
	    xa_inputs.get(3, "dst_address").mac(),
	    xa_inputs.get(4, "ether_type").uint32(),
	    xa_inputs.get(5, "payload").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").mac(),
	    xa_inputs.get(3, "dst_address").mac(),
	    xa_inputs.get(4, "ether_type").uint32(),
	    xa_inputs.get(5, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_link_0_1_register_receiver
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_link/0.1/register_receiver", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_link_0_1_register_receiver(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ether_type,
	const string&	arg_filter_program,
	const bool&	arg_enable_multicast_loopback,
	RawLink01RegisterReceiverCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_link_0_1_register_receiver(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ether_type,
        arg_filter_program,
        arg_enable_multicast_loopback);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_link_0_1_register_receiver(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/register_receiver");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawLink01RegisterReceiverRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_link_0_1_register_receiver, pxa_outputs);
	async_raw_link_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "enable_multicast_loopback").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "enable_multicast_loopback").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/register_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_link_0_1_unregister_receiver
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_link/0.1/unregister_receiver", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_link_0_1_unregister_receiver(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ether_type,
	const string&	arg_filter_program,
	RawLink01UnregisterReceiverCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_link_0_1_unregister_receiver(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ether_type,
        arg_filter_program);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_link_0_1_unregister_receiver(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/unregister_receiver");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawLink01UnregisterReceiverRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_link_0_1_unregister_receiver, pxa_outputs);
	async_raw_link_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/unregister_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_link_0_1_join_multicast_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_link/0.1/join_multicast_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_link_0_1_join_multicast_group(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ether_type,
	const string&	arg_filter_program,
	const Mac&	arg_group_address,
	RawLink01JoinMulticastGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_link_0_1_join_multicast_group(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ether_type,
        arg_filter_program,
        arg_group_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_link_0_1_join_multicast_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/join_multicast_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawLink01JoinMulticastGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_link_0_1_join_multicast_group, pxa_outputs);
	async_raw_link_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "group_address").mac(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "group_address").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/join_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_link_0_1_leave_multicast_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_link/0.1/leave_multicast_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_link_0_1_leave_multicast_group(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ether_type,
	const string&	arg_filter_program,
	const Mac&	arg_group_address,
	RawLink01LeaveMulticastGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_link_0_1_leave_multicast_group(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ether_type,
        arg_filter_program,
        arg_group_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_link_0_1_leave_multicast_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "raw_link/0.1/leave_multicast_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawLink01LeaveMulticastGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_link_0_1_leave_multicast_group, pxa_outputs);
	async_raw_link_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "group_address").mac(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_link_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ether_type").uint32(),
	    xa_inputs.get(4, "filter_program").text(),
	    xa_inputs.get(5, "group_address").mac());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_link/0.1/leave_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet4_0_1_send
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet4/0.1/send", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet4_0_1_send(
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const IPv4&	arg_src_address,
	const IPv4&	arg_dst_address,
	const uint32_t&	arg_ip_protocol,
	const int32_t&	arg_ip_ttl,
	const int32_t&	arg_ip_tos,
	const bool&	arg_ip_router_alert,
	const bool&	arg_ip_internet_control,
	const vector<uint8_t>&	arg_payload,
	RawPacket401SendCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet4_0_1_send(
        arg_if_name,
        arg_vif_name,
        arg_src_address,
        arg_dst_address,
        arg_ip_protocol,
        arg_ip_ttl,
        arg_ip_tos,
        arg_ip_router_alert,
        arg_ip_internet_control,
        arg_payload);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet4_0_1_send(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 10) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(10), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/send");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket401SendRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet4_0_1_send, pxa_outputs);
	async_raw_packet4_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv4(),
	    xa_inputs.get(3, "dst_address").ipv4(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "payload").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv4(),
	    xa_inputs.get(3, "dst_address").ipv4(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet4_0_1_register_receiver
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet4/0.1/register_receiver", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet4_0_1_register_receiver(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	const bool&	arg_enable_multicast_loopback,
	RawPacket401RegisterReceiverCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet4_0_1_register_receiver(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol,
        arg_enable_multicast_loopback);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet4_0_1_register_receiver(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/register_receiver");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket401RegisterReceiverRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet4_0_1_register_receiver, pxa_outputs);
	async_raw_packet4_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "enable_multicast_loopback").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "enable_multicast_loopback").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/register_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet4_0_1_unregister_receiver
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet4/0.1/unregister_receiver", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet4_0_1_unregister_receiver(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	RawPacket401UnregisterReceiverCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet4_0_1_unregister_receiver(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet4_0_1_unregister_receiver(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/unregister_receiver");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket401UnregisterReceiverRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet4_0_1_unregister_receiver, pxa_outputs);
	async_raw_packet4_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/unregister_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet4_0_1_join_multicast_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet4/0.1/join_multicast_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet4_0_1_join_multicast_group(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	const IPv4&	arg_group_address,
	RawPacket401JoinMulticastGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet4_0_1_join_multicast_group(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol,
        arg_group_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet4_0_1_join_multicast_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/join_multicast_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket401JoinMulticastGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet4_0_1_join_multicast_group, pxa_outputs);
	async_raw_packet4_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/join_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet4_0_1_leave_multicast_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet4/0.1/leave_multicast_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet4_0_1_leave_multicast_group(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	const IPv4&	arg_group_address,
	RawPacket401LeaveMulticastGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet4_0_1_leave_multicast_group(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol,
        arg_group_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet4_0_1_leave_multicast_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet4/0.1/leave_multicast_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket401LeaveMulticastGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet4_0_1_leave_multicast_group, pxa_outputs);
	async_raw_packet4_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet4_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet4/0.1/leave_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_tcp_open
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/tcp_open", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_tcp_open(
	const string&	arg_creator,
	Socket401TcpOpenCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_tcp_open(
        arg_creator,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_tcp_open(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_open");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401TcpOpenRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_tcp_open, pxa_outputs);
	async_socket4_0_1_tcp_open(
	    xa_inputs.get(0, "creator").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_tcp_open(
	    xa_inputs.get(0, "creator").text(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_open
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_open", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_open(
	const string&	arg_creator,
	Socket401UdpOpenCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_udp_open(
        arg_creator,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_open(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpOpenRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_open, pxa_outputs);
	async_socket4_0_1_udp_open(
	    xa_inputs.get(0, "creator").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open(
	    xa_inputs.get(0, "creator").text(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_tcp_open_and_bind
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/tcp_open_and_bind", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_tcp_open_and_bind(
	const string&	arg_creator,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	Socket401TcpOpenAndBindCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_tcp_open_and_bind(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_tcp_open_and_bind(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_open_and_bind");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401TcpOpenAndBindRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_tcp_open_and_bind, pxa_outputs);
	async_socket4_0_1_tcp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_tcp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_open_and_bind
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_open_and_bind", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_open_and_bind(
	const string&	arg_creator,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const string&	arg_local_dev,
	const uint32_t&	arg_reuse,
	Socket401UdpOpenAndBindCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_udp_open_and_bind(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_local_dev,
        arg_reuse,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_open_and_bind(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_and_bind");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpOpenAndBindRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_open_and_bind, pxa_outputs);
	async_socket4_0_1_udp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "local_dev").text(),
	    xa_inputs.get(4, "reuse").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "local_dev").text(),
	    xa_inputs.get(4, "reuse").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_open_bind_join
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_open_bind_join", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_open_bind_join(
	const string&	arg_creator,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv4&	arg_mcast_addr,
	const uint32_t&	arg_ttl,
	const bool&	arg_reuse,
	Socket401UdpOpenBindJoinCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_udp_open_bind_join(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_mcast_addr,
        arg_ttl,
        arg_reuse,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_join(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_bind_join");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpOpenBindJoinRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_open_bind_join, pxa_outputs);
	async_socket4_0_1_udp_open_bind_join(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "mcast_addr").ipv4(),
	    xa_inputs.get(4, "ttl").uint32(),
	    xa_inputs.get(5, "reuse").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_bind_join(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "mcast_addr").ipv4(),
	    xa_inputs.get(4, "ttl").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_bind_join", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_tcp_open_bind_connect
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/tcp_open_bind_connect", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_tcp_open_bind_connect(
	const string&	arg_creator,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv4&	arg_remote_addr,
	const uint32_t&	arg_remote_port,
	Socket401TcpOpenBindConnectCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_tcp_open_bind_connect(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_remote_addr,
        arg_remote_port,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_tcp_open_bind_connect(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_open_bind_connect");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401TcpOpenBindConnectRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_tcp_open_bind_connect, pxa_outputs);
	async_socket4_0_1_tcp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv4(),
	    xa_inputs.get(4, "remote_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_tcp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv4(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_open_bind_connect
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_open_bind_connect", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_open_bind_connect(
	const string&	arg_creator,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv4&	arg_remote_addr,
	const uint32_t&	arg_remote_port,
	Socket401UdpOpenBindConnectCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_udp_open_bind_connect(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_remote_addr,
        arg_remote_port,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_connect(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_bind_connect");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpOpenBindConnectRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_open_bind_connect, pxa_outputs);
	async_socket4_0_1_udp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv4(),
	    xa_inputs.get(4, "remote_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv4(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_open_bind_broadcast
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_open_bind_broadcast", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_open_bind_broadcast(
	const string&	arg_creator,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_local_port,
	const uint32_t&	arg_remote_port,
	const bool&	arg_reuse,
	const bool&	arg_limited,
	const bool&	arg_connected,
	Socket401UdpOpenBindBroadcastCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket4_0_1_udp_open_bind_broadcast(
        arg_creator,
        arg_ifname,
        arg_vifname,
        arg_local_port,
        arg_remote_port,
        arg_reuse,
        arg_limited,
        arg_connected,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_open_bind_broadcast(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 8) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(8), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_open_bind_broadcast");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpOpenBindBroadcastRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_open_bind_broadcast, pxa_outputs);
	async_socket4_0_1_udp_open_bind_broadcast(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vifname").text(),
	    xa_inputs.get(3, "local_port").uint32(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    xa_inputs.get(6, "limited").boolean(),
	    xa_inputs.get(7, "connected").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket4_0_1_udp_open_bind_broadcast(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "ifname").text(),
	    xa_inputs.get(2, "vifname").text(),
	    xa_inputs.get(3, "local_port").uint32(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    xa_inputs.get(6, "limited").boolean(),
	    xa_inputs.get(7, "connected").boolean(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_open_bind_broadcast", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_bind
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/bind", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_bind(
	const string&	arg_sockid,
	const IPv4&	arg_local_addr,
	const uint32_t&	arg_local_port,
	Socket401BindCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_bind(
        arg_sockid,
        arg_local_addr,
        arg_local_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_bind(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/bind");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401BindRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_bind, pxa_outputs);
	async_socket4_0_1_bind(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_bind(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "local_addr").ipv4(),
	    xa_inputs.get(2, "local_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_join_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_join_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_join_group(
	const string&	arg_sockid,
	const IPv4&	arg_mcast_addr,
	const IPv4&	arg_join_if_addr,
	Socket401UdpJoinGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_udp_join_group(
        arg_sockid,
        arg_mcast_addr,
        arg_join_if_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_join_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_join_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpJoinGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_join_group, pxa_outputs);
	async_socket4_0_1_udp_join_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv4(),
	    xa_inputs.get(2, "join_if_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_udp_join_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv4(),
	    xa_inputs.get(2, "join_if_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_join_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_leave_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_leave_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_leave_group(
	const string&	arg_sockid,
	const IPv4&	arg_mcast_addr,
	const IPv4&	arg_leave_if_addr,
	Socket401UdpLeaveGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_udp_leave_group(
        arg_sockid,
        arg_mcast_addr,
        arg_leave_if_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_leave_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_leave_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpLeaveGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_leave_group, pxa_outputs);
	async_socket4_0_1_udp_leave_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv4(),
	    xa_inputs.get(2, "leave_if_addr").ipv4(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_udp_leave_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv4(),
	    xa_inputs.get(2, "leave_if_addr").ipv4());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_leave_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_close
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/close", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_close(
	const string&	arg_sockid,
	Socket401CloseCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_close(
        arg_sockid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_close(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/close");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401CloseRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_close, pxa_outputs);
	async_socket4_0_1_close(
	    xa_inputs.get(0, "sockid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_close(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/close", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_tcp_listen
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/tcp_listen", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_tcp_listen(
	const string&	arg_sockid,
	const uint32_t&	arg_backlog,
	Socket401TcpListenCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_tcp_listen(
        arg_sockid,
        arg_backlog);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_tcp_listen(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/tcp_listen");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401TcpListenRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_tcp_listen, pxa_outputs);
	async_socket4_0_1_tcp_listen(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "backlog").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_tcp_listen(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "backlog").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/tcp_listen", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_udp_enable_recv
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/udp_enable_recv", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_udp_enable_recv(
	const string&	arg_sockid,
	Socket401UdpEnableRecvCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_udp_enable_recv(
        arg_sockid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_udp_enable_recv(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/udp_enable_recv");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401UdpEnableRecvRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_udp_enable_recv, pxa_outputs);
	async_socket4_0_1_udp_enable_recv(
	    xa_inputs.get(0, "sockid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_udp_enable_recv(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/udp_enable_recv", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_send
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/send", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_send(
	const string&	arg_sockid,
	const vector<uint8_t>&	arg_data,
	Socket401SendCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_send(
        arg_sockid,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_send(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/send");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401SendRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_send, pxa_outputs);
	async_socket4_0_1_send(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_send(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_send_to
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/send_to", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_send_to(
	const string&	arg_sockid,
	const IPv4&	arg_remote_addr,
	const uint32_t&	arg_remote_port,
	const vector<uint8_t>&	arg_data,
	Socket401SendToCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_send_to(
        arg_sockid,
        arg_remote_addr,
        arg_remote_port,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_send_to(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/send_to");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401SendToRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_send_to, pxa_outputs);
	async_socket4_0_1_send_to(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "remote_addr").ipv4(),
	    xa_inputs.get(2, "remote_port").uint32(),
	    xa_inputs.get(3, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_send_to(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "remote_addr").ipv4(),
	    xa_inputs.get(2, "remote_port").uint32(),
	    xa_inputs.get(3, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/send_to", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_send_from_multicast_if
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/send_from_multicast_if", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_send_from_multicast_if(
	const string&	arg_sockid,
	const IPv4&	arg_group_addr,
	const uint32_t&	arg_group_port,
	const IPv4&	arg_ifaddr,
	const vector<uint8_t>&	arg_data,
	Socket401SendFromMulticastIfCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_send_from_multicast_if(
        arg_sockid,
        arg_group_addr,
        arg_group_port,
        arg_ifaddr,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_send_from_multicast_if(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/send_from_multicast_if");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401SendFromMulticastIfRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_send_from_multicast_if, pxa_outputs);
	async_socket4_0_1_send_from_multicast_if(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "group_addr").ipv4(),
	    xa_inputs.get(2, "group_port").uint32(),
	    xa_inputs.get(3, "ifaddr").ipv4(),
	    xa_inputs.get(4, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_send_from_multicast_if(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "group_addr").ipv4(),
	    xa_inputs.get(2, "group_port").uint32(),
	    xa_inputs.get(3, "ifaddr").ipv4(),
	    xa_inputs.get(4, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/send_from_multicast_if", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_set_socket_option
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/set_socket_option", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_set_socket_option(
	const string&	arg_sockid,
	const string&	arg_optname,
	const uint32_t&	arg_optval,
	Socket401SetSocketOptionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_set_socket_option(
        arg_sockid,
        arg_optname,
        arg_optval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_set_socket_option(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/set_socket_option");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401SetSocketOptionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_set_socket_option, pxa_outputs);
	async_socket4_0_1_set_socket_option(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_set_socket_option(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/set_socket_option", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket4_0_1_set_socket_option_txt
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket4/0.1/set_socket_option_txt", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket4_0_1_set_socket_option_txt(
	const string&	arg_sockid,
	const string&	arg_optname,
	const string&	arg_optval,
	Socket401SetSocketOptionTxtCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket4_0_1_set_socket_option_txt(
        arg_sockid,
        arg_optname,
        arg_optval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket4_0_1_set_socket_option_txt(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket4/0.1/set_socket_option_txt");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket401SetSocketOptionTxtRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket4_0_1_set_socket_option_txt, pxa_outputs);
	async_socket4_0_1_set_socket_option_txt(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket4_0_1_set_socket_option_txt(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket4/0.1/set_socket_option_txt", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction6_0_1_start_transaction
    (const XrlCmdError &e,
     const uint32_t* rarg_tid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/start_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("tid", *rarg_tid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction6_0_1_start_transaction(
	RedistTransaction601StartTransactionCB c_b)
{

    /* Return value declarations */
    uint32_t rarg_tid;
    XrlCmdError e = redist_transaction6_0_1_start_transaction(
        rarg_tid);
    return c_b->dispatch(e,
        &rarg_tid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction6_0_1_start_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/start_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601StartTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction6_0_1_start_transaction, pxa_outputs);
	async_redist_transaction6_0_1_start_transaction( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    uint32_t r_tid;
    try {
	XrlCmdError e = redist_transaction6_0_1_start_transaction(
	    r_tid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/start_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("tid", r_tid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction6_0_1_commit_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/commit_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction6_0_1_commit_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction601CommitTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_commit_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction6_0_1_commit_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/commit_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601CommitTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction6_0_1_commit_transaction, pxa_outputs);
	async_redist_transaction6_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_commit_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/commit_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction6_0_1_abort_transaction
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/abort_transaction", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction6_0_1_abort_transaction(
	const uint32_t&	arg_tid,
	RedistTransaction601AbortTransactionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_abort_transaction(
        arg_tid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction6_0_1_abort_transaction(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/abort_transaction");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601AbortTransactionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction6_0_1_abort_transaction, pxa_outputs);
	async_redist_transaction6_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_abort_transaction(
	    xa_inputs.get(0, "tid").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/abort_transaction", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction6_0_1_add_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/add_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction6_0_1_add_route(
	const uint32_t&	arg_tid,
	const IPv6Net&	arg_dst,
	const IPv6&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction601AddRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_add_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction6_0_1_add_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/add_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601AddRouteRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction6_0_1_add_route, pxa_outputs);
	async_redist_transaction6_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_add_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/add_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction6_0_1_delete_route
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/delete_route", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction6_0_1_delete_route(
	const uint32_t&	arg_tid,
	const IPv6Net&	arg_dst,
	const IPv6&	arg_nexthop,
	const string&	arg_ifname,
	const string&	arg_vifname,
	const uint32_t&	arg_metric,
	const uint32_t&	arg_admin_distance,
	const string&	arg_cookie,
	const string&	arg_protocol_origin,
	RedistTransaction601DeleteRouteCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_delete_route(
        arg_tid,
        arg_dst,
        arg_nexthop,
        arg_ifname,
        arg_vifname,
        arg_metric,
        arg_admin_distance,
        arg_cookie,
        arg_protocol_origin);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_route(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 9) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(9), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/delete_route");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601DeleteRouteRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction6_0_1_delete_route, pxa_outputs);
	async_redist_transaction6_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_delete_route(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "dst").ipv6net(),
	    xa_inputs.get(2, "nexthop").ipv6(),
	    xa_inputs.get(3, "ifname").text(),
	    xa_inputs.get(4, "vifname").text(),
	    xa_inputs.get(5, "metric").uint32(),
	    xa_inputs.get(6, "admin_distance").uint32(),
	    xa_inputs.get(7, "cookie").text(),
	    xa_inputs.get(8, "protocol_origin").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/delete_route", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_redist_transaction6_0_1_delete_all_routes
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "redist_transaction6/0.1/delete_all_routes", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_redist_transaction6_0_1_delete_all_routes(
	const uint32_t&	arg_tid,
	const string&	arg_cookie,
	RedistTransaction601DeleteAllRoutesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = redist_transaction6_0_1_delete_all_routes(
        arg_tid,
        arg_cookie);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_redist_transaction6_0_1_delete_all_routes(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "redist_transaction6/0.1/delete_all_routes");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RedistTransaction601DeleteAllRoutesRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_redist_transaction6_0_1_delete_all_routes, pxa_outputs);
	async_redist_transaction6_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = redist_transaction6_0_1_delete_all_routes(
	    xa_inputs.get(0, "tid").uint32(),
	    xa_inputs.get(1, "cookie").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "redist_transaction6/0.1/delete_all_routes", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_tcp_open
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/tcp_open", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_tcp_open(
	const string&	arg_creator,
	Socket601TcpOpenCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_tcp_open(
        arg_creator,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_tcp_open(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_open");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601TcpOpenRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_tcp_open, pxa_outputs);
	async_socket6_0_1_tcp_open(
	    xa_inputs.get(0, "creator").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_tcp_open(
	    xa_inputs.get(0, "creator").text(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_udp_open
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/udp_open", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_udp_open(
	const string&	arg_creator,
	Socket601UdpOpenCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_udp_open(
        arg_creator,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_udp_open(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601UdpOpenRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_udp_open, pxa_outputs);
	async_socket6_0_1_udp_open(
	    xa_inputs.get(0, "creator").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open(
	    xa_inputs.get(0, "creator").text(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_tcp_open_and_bind
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/tcp_open_and_bind", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_tcp_open_and_bind(
	const string&	arg_creator,
	const IPv6&	arg_local_addr,
	const uint32_t&	arg_local_port,
	Socket601TcpOpenAndBindCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_tcp_open_and_bind(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_tcp_open_and_bind(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_open_and_bind");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601TcpOpenAndBindRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_tcp_open_and_bind, pxa_outputs);
	async_socket6_0_1_tcp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_tcp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_udp_open_and_bind
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/udp_open_and_bind", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_udp_open_and_bind(
	const string&	arg_creator,
	const IPv6&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const string&	arg_local_dev,
	const uint32_t&	arg_reuse,
	Socket601UdpOpenAndBindCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_udp_open_and_bind(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_local_dev,
        arg_reuse,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_udp_open_and_bind(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open_and_bind");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601UdpOpenAndBindRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_udp_open_and_bind, pxa_outputs);
	async_socket6_0_1_udp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "local_dev").text(),
	    xa_inputs.get(4, "reuse").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open_and_bind(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "local_dev").text(),
	    xa_inputs.get(4, "reuse").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open_and_bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_udp_open_bind_join
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/udp_open_bind_join", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_udp_open_bind_join(
	const string&	arg_creator,
	const IPv6&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv6&	arg_mcast_addr,
	const uint32_t&	arg_ttl,
	const bool&	arg_reuse,
	Socket601UdpOpenBindJoinCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_udp_open_bind_join(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_mcast_addr,
        arg_ttl,
        arg_reuse,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_join(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 6) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(6), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open_bind_join");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601UdpOpenBindJoinRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_udp_open_bind_join, pxa_outputs);
	async_socket6_0_1_udp_open_bind_join(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "mcast_addr").ipv6(),
	    xa_inputs.get(4, "ttl").uint32(),
	    xa_inputs.get(5, "reuse").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open_bind_join(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "mcast_addr").ipv6(),
	    xa_inputs.get(4, "ttl").uint32(),
	    xa_inputs.get(5, "reuse").boolean(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open_bind_join", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_tcp_open_bind_connect
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/tcp_open_bind_connect", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_tcp_open_bind_connect(
	const string&	arg_creator,
	const IPv6&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv6&	arg_remote_addr,
	const uint32_t&	arg_remote_port,
	Socket601TcpOpenBindConnectCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_tcp_open_bind_connect(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_remote_addr,
        arg_remote_port,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_tcp_open_bind_connect(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_open_bind_connect");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601TcpOpenBindConnectRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_tcp_open_bind_connect, pxa_outputs);
	async_socket6_0_1_tcp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv6(),
	    xa_inputs.get(4, "remote_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_tcp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv6(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_udp_open_bind_connect
    (const XrlCmdError &e,
     const string* rarg_sockid,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/udp_open_bind_connect", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("sockid", *rarg_sockid);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_udp_open_bind_connect(
	const string&	arg_creator,
	const IPv6&	arg_local_addr,
	const uint32_t&	arg_local_port,
	const IPv6&	arg_remote_addr,
	const uint32_t&	arg_remote_port,
	Socket601UdpOpenBindConnectCB c_b)
{

    /* Return value declarations */
    string rarg_sockid;
    XrlCmdError e = socket6_0_1_udp_open_bind_connect(
        arg_creator,
        arg_local_addr,
        arg_local_port,
        arg_remote_addr,
        arg_remote_port,
        rarg_sockid);
    return c_b->dispatch(e,
        &rarg_sockid);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_udp_open_bind_connect(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_open_bind_connect");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601UdpOpenBindConnectRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_udp_open_bind_connect, pxa_outputs);
	async_socket6_0_1_udp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv6(),
	    xa_inputs.get(4, "remote_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_sockid;
    try {
	XrlCmdError e = socket6_0_1_udp_open_bind_connect(
	    xa_inputs.get(0, "creator").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(),
	    xa_inputs.get(3, "remote_addr").ipv6(),
	    xa_inputs.get(4, "remote_port").uint32(),
	    r_sockid);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_open_bind_connect", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("sockid", r_sockid);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_bind
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/bind", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_bind(
	const string&	arg_sockid,
	const IPv6&	arg_local_addr,
	const uint32_t&	arg_local_port,
	Socket601BindCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_bind(
        arg_sockid,
        arg_local_addr,
        arg_local_port);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_bind(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/bind");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601BindRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_bind, pxa_outputs);
	async_socket6_0_1_bind(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_bind(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "local_addr").ipv6(),
	    xa_inputs.get(2, "local_port").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/bind", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_udp_join_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/udp_join_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_udp_join_group(
	const string&	arg_sockid,
	const IPv6&	arg_mcast_addr,
	const IPv6&	arg_join_if_addr,
	Socket601UdpJoinGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_udp_join_group(
        arg_sockid,
        arg_mcast_addr,
        arg_join_if_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_udp_join_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_join_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601UdpJoinGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_udp_join_group, pxa_outputs);
	async_socket6_0_1_udp_join_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv6(),
	    xa_inputs.get(2, "join_if_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_udp_join_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv6(),
	    xa_inputs.get(2, "join_if_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_join_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_udp_leave_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/udp_leave_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_udp_leave_group(
	const string&	arg_sockid,
	const IPv6&	arg_mcast_addr,
	const IPv6&	arg_leave_if_addr,
	Socket601UdpLeaveGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_udp_leave_group(
        arg_sockid,
        arg_mcast_addr,
        arg_leave_if_addr);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_udp_leave_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/udp_leave_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601UdpLeaveGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_udp_leave_group, pxa_outputs);
	async_socket6_0_1_udp_leave_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv6(),
	    xa_inputs.get(2, "leave_if_addr").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_udp_leave_group(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "mcast_addr").ipv6(),
	    xa_inputs.get(2, "leave_if_addr").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/udp_leave_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_close
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/close", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_close(
	const string&	arg_sockid,
	Socket601CloseCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_close(
        arg_sockid);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_close(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/close");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601CloseRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_close, pxa_outputs);
	async_socket6_0_1_close(
	    xa_inputs.get(0, "sockid").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_close(
	    xa_inputs.get(0, "sockid").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/close", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_tcp_listen
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/tcp_listen", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_tcp_listen(
	const string&	arg_sockid,
	const uint32_t&	arg_backlog,
	Socket601TcpListenCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_tcp_listen(
        arg_sockid,
        arg_backlog);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_tcp_listen(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/tcp_listen");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601TcpListenRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_tcp_listen, pxa_outputs);
	async_socket6_0_1_tcp_listen(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "backlog").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_tcp_listen(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "backlog").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/tcp_listen", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_send
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/send", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_send(
	const string&	arg_sockid,
	const vector<uint8_t>&	arg_data,
	Socket601SendCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_send(
        arg_sockid,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_send(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/send");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601SendRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_send, pxa_outputs);
	async_socket6_0_1_send(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_send(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_send_to
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/send_to", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_send_to(
	const string&	arg_sockid,
	const IPv6&	arg_remote_addr,
	const uint32_t&	arg_remote_port,
	const vector<uint8_t>&	arg_data,
	Socket601SendToCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_send_to(
        arg_sockid,
        arg_remote_addr,
        arg_remote_port,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_send_to(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/send_to");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601SendToRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_send_to, pxa_outputs);
	async_socket6_0_1_send_to(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "remote_addr").ipv6(),
	    xa_inputs.get(2, "remote_port").uint32(),
	    xa_inputs.get(3, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_send_to(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "remote_addr").ipv6(),
	    xa_inputs.get(2, "remote_port").uint32(),
	    xa_inputs.get(3, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/send_to", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_send_from_multicast_if
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/send_from_multicast_if", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_send_from_multicast_if(
	const string&	arg_sockid,
	const IPv6&	arg_group_addr,
	const uint32_t&	arg_group_port,
	const IPv6&	arg_ifaddr,
	const vector<uint8_t>&	arg_data,
	Socket601SendFromMulticastIfCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_send_from_multicast_if(
        arg_sockid,
        arg_group_addr,
        arg_group_port,
        arg_ifaddr,
        arg_data);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_send_from_multicast_if(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/send_from_multicast_if");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601SendFromMulticastIfRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_send_from_multicast_if, pxa_outputs);
	async_socket6_0_1_send_from_multicast_if(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "group_addr").ipv6(),
	    xa_inputs.get(2, "group_port").uint32(),
	    xa_inputs.get(3, "ifaddr").ipv6(),
	    xa_inputs.get(4, "data").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_send_from_multicast_if(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "group_addr").ipv6(),
	    xa_inputs.get(2, "group_port").uint32(),
	    xa_inputs.get(3, "ifaddr").ipv6(),
	    xa_inputs.get(4, "data").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/send_from_multicast_if", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_socket6_0_1_set_socket_option
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "socket6/0.1/set_socket_option", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_socket6_0_1_set_socket_option(
	const string&	arg_sockid,
	const string&	arg_optname,
	const uint32_t&	arg_optval,
	Socket601SetSocketOptionCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = socket6_0_1_set_socket_option(
        arg_sockid,
        arg_optname,
        arg_optval);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_socket6_0_1_set_socket_option(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 3) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(3), XORP_UINT_CAST(xa_inputs.size()), "socket6/0.1/set_socket_option");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Socket601SetSocketOptionRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_socket6_0_1_set_socket_option, pxa_outputs);
	async_socket6_0_1_set_socket_option(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = socket6_0_1_set_socket_option(
	    xa_inputs.get(0, "sockid").text(),
	    xa_inputs.get(1, "optname").text(),
	    xa_inputs.get(2, "optval").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "socket6/0.1/set_socket_option", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet6_0_1_send
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet6/0.1/send", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet6_0_1_send(
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const IPv6&	arg_src_address,
	const IPv6&	arg_dst_address,
	const uint32_t&	arg_ip_protocol,
	const int32_t&	arg_ip_ttl,
	const int32_t&	arg_ip_tos,
	const bool&	arg_ip_router_alert,
	const bool&	arg_ip_internet_control,
	const XrlAtomList&	arg_ext_headers_type,
	const XrlAtomList&	arg_ext_headers_payload,
	const vector<uint8_t>&	arg_payload,
	RawPacket601SendCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet6_0_1_send(
        arg_if_name,
        arg_vif_name,
        arg_src_address,
        arg_dst_address,
        arg_ip_protocol,
        arg_ip_ttl,
        arg_ip_tos,
        arg_ip_router_alert,
        arg_ip_internet_control,
        arg_ext_headers_type,
        arg_ext_headers_payload,
        arg_payload);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet6_0_1_send(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 12) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(12), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/send");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket601SendRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet6_0_1_send, pxa_outputs);
	async_raw_packet6_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv6(),
	    xa_inputs.get(3, "dst_address").ipv6(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "ext_headers_type").list(),
	    xa_inputs.get(10, "ext_headers_payload").list(),
	    xa_inputs.get(11, "payload").binary(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_send(
	    xa_inputs.get(0, "if_name").text(),
	    xa_inputs.get(1, "vif_name").text(),
	    xa_inputs.get(2, "src_address").ipv6(),
	    xa_inputs.get(3, "dst_address").ipv6(),
	    xa_inputs.get(4, "ip_protocol").uint32(),
	    xa_inputs.get(5, "ip_ttl").int32(),
	    xa_inputs.get(6, "ip_tos").int32(),
	    xa_inputs.get(7, "ip_router_alert").boolean(),
	    xa_inputs.get(8, "ip_internet_control").boolean(),
	    xa_inputs.get(9, "ext_headers_type").list(),
	    xa_inputs.get(10, "ext_headers_payload").list(),
	    xa_inputs.get(11, "payload").binary());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/send", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet6_0_1_register_receiver
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet6/0.1/register_receiver", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet6_0_1_register_receiver(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	const bool&	arg_enable_multicast_loopback,
	RawPacket601RegisterReceiverCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet6_0_1_register_receiver(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol,
        arg_enable_multicast_loopback);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet6_0_1_register_receiver(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/register_receiver");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket601RegisterReceiverRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet6_0_1_register_receiver, pxa_outputs);
	async_raw_packet6_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "enable_multicast_loopback").boolean(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_register_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "enable_multicast_loopback").boolean());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/register_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet6_0_1_unregister_receiver
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet6/0.1/unregister_receiver", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet6_0_1_unregister_receiver(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	RawPacket601UnregisterReceiverCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet6_0_1_unregister_receiver(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet6_0_1_unregister_receiver(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 4) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(4), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/unregister_receiver");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket601UnregisterReceiverRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet6_0_1_unregister_receiver, pxa_outputs);
	async_raw_packet6_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_unregister_receiver(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/unregister_receiver", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet6_0_1_join_multicast_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet6/0.1/join_multicast_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet6_0_1_join_multicast_group(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	const IPv6&	arg_group_address,
	RawPacket601JoinMulticastGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet6_0_1_join_multicast_group(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol,
        arg_group_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet6_0_1_join_multicast_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/join_multicast_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket601JoinMulticastGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet6_0_1_join_multicast_group, pxa_outputs);
	async_raw_packet6_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_join_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/join_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_raw_packet6_0_1_leave_multicast_group
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "raw_packet6/0.1/leave_multicast_group", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_raw_packet6_0_1_leave_multicast_group(
	const string&	arg_xrl_target_instance_name,
	const string&	arg_if_name,
	const string&	arg_vif_name,
	const uint32_t&	arg_ip_protocol,
	const IPv6&	arg_group_address,
	RawPacket601LeaveMulticastGroupCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = raw_packet6_0_1_leave_multicast_group(
        arg_xrl_target_instance_name,
        arg_if_name,
        arg_vif_name,
        arg_ip_protocol,
        arg_group_address);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_raw_packet6_0_1_leave_multicast_group(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 5) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(5), XORP_UINT_CAST(xa_inputs.size()), "raw_packet6/0.1/leave_multicast_group");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	RawPacket601LeaveMulticastGroupRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_raw_packet6_0_1_leave_multicast_group, pxa_outputs);
	async_raw_packet6_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv6(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = raw_packet6_0_1_leave_multicast_group(
	    xa_inputs.get(0, "xrl_target_instance_name").text(),
	    xa_inputs.get(1, "if_name").text(),
	    xa_inputs.get(2, "vif_name").text(),
	    xa_inputs.get(3, "ip_protocol").uint32(),
	    xa_inputs.get(4, "group_address").ipv6());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "raw_packet6/0.1/leave_multicast_group", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_profile_0_1_enable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/enable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_profile_0_1_enable(
	const string&	arg_pname,
	Profile01EnableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_enable(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_profile_0_1_enable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/enable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01EnableRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_profile_0_1_enable, pxa_outputs);
	async_profile_0_1_enable(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_enable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/enable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_profile_0_1_disable
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/disable", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_profile_0_1_disable(
	const string&	arg_pname,
	Profile01DisableCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_disable(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_profile_0_1_disable(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/disable");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01DisableRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_profile_0_1_disable, pxa_outputs);
	async_profile_0_1_disable(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_disable(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/disable", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_profile_0_1_get_entries
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/get_entries", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_profile_0_1_get_entries(
	const string&	arg_pname,
	const string&	arg_instance_name,
	Profile01GetEntriesCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_get_entries(
        arg_pname,
        arg_instance_name);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_profile_0_1_get_entries(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 2) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(2), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/get_entries");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01GetEntriesRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_profile_0_1_get_entries, pxa_outputs);
	async_profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_get_entries(
	    xa_inputs.get(0, "pname").text(),
	    xa_inputs.get(1, "instance_name").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/get_entries", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_profile_0_1_clear
    (const XrlCmdError &e,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/clear", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;
        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_profile_0_1_clear(
	const string&	arg_pname,
	Profile01ClearCB c_b)
{

    /* Return value declarations */
    XrlCmdError e = profile_0_1_clear(
        arg_pname);
    return c_b->dispatch(e);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_profile_0_1_clear(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 1) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(1), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/clear");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    UNUSED(pxa_outputs);
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01ClearRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_profile_0_1_clear, pxa_outputs);
	async_profile_0_1_clear(
	    xa_inputs.get(0, "pname").text(), mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    try {
	XrlCmdError e = profile_0_1_clear(
	    xa_inputs.get(0, "pname").text());
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/clear", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }
    return XrlCmdError::OKAY();
#endif
}


#ifdef XORP_ENABLE_ASYNC_SERVER
void
XrlFeaTargetBase::callback_profile_0_1_list
    (const XrlCmdError &e,
     const string* rarg_info,
     XrlRespCallback c_b)
{
    if (e != XrlCmdError::OKAY()) {
	XLOG_WARNING("Handling method for %s failed: %s",
		     "profile/0.1/list", e.str().c_str());
	return c_b->dispatch(e, NULL);
    } else {
	XrlArgs out;

        /* Marshall return values */
        try {
	    out.add("info", *rarg_info);
        } catch (const XrlArgs::XrlAtomFound& ) {
	    XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
        }

        return c_b->dispatch(e, &out);
    }
}


void
XrlFeaTargetBase::async_profile_0_1_list(
	Profile01ListCB c_b)
{

    /* Return value declarations */
    string rarg_info;
    XrlCmdError e = profile_0_1_list(
        rarg_info);
    return c_b->dispatch(e,
        &rarg_info);
}
#endif

XrlCmdRT
XrlFeaTargetBase::handle_profile_0_1_list(const XrlArgs& xa_inputs, XrlCmdOT pxa_outputs)
{
    if (xa_inputs.size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u) handling %s",
            XORP_UINT_CAST(0), XORP_UINT_CAST(xa_inputs.size()), "profile/0.1/list");
	XRL_CMD_RETURN_ERROR(pxa_outputs, XrlCmdError::BAD_ARGS());
    }

#ifndef XORP_ENABLE_ASYNC_SERVER
    if (pxa_outputs == 0) {
	XLOG_FATAL("Return list empty");
	return XrlCmdError::BAD_ARGS();
    }
#endif

#ifdef XORP_ENABLE_ASYNC_SERVER
    try {
	Profile01ListRF mycb =
	    callback(this, &XrlFeaTargetBase::callback_profile_0_1_list, pxa_outputs);
	async_profile_0_1_list( mycb);
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return pxa_outputs->dispatch(XrlCmdError::BAD_ARGS(e.str()), NULL);
    }
#else

    /* Return value declarations */
    string r_info;
    try {
	XrlCmdError e = profile_0_1_list(
	    r_info);
	if (e != XrlCmdError::OKAY()) {
	    XLOG_WARNING("Handling method for %s failed: %s",
            		 "profile/0.1/list", e.str().c_str());
	    return e;
        }
    } catch (const XrlArgs::BadArgs& e) {
	XLOG_ERROR("Error decoding the arguments: %s", e.str().c_str());
	return XrlCmdError::BAD_ARGS(e.str());
    }

    /* Marshall return values */
    try {
	pxa_outputs->add("info", r_info);
    } catch (const XrlArgs::XrlAtomFound& ) {
	XLOG_FATAL("Duplicate atom name"); /* XXX Should never happen */
    }
    return XrlCmdError::OKAY();
#endif
}

void
XrlFeaTargetBase::add_handlers()
{
    for (size_t i = 0; i < num_handlers; ++i) {
        if (!_cmds->add_handler(handlers[i].name,
                                callback(this, handlers[i].method))) {
            XLOG_ERROR("Failed to register xrl handler finder://%s/%s", "fea", handlers[i].name);
        }
    }
    _cmds->finalize();
}

void
XrlFeaTargetBase::remove_handlers()
{
     for (size_t i = 0; i < num_handlers; ++i) {
         _cmds->remove_handler(handlers[i].name);
     }
}
