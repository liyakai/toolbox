/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/fea_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_FEA_BASE_HH__
#define __XRL_TARGETS_FEA_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlFeaTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlFeaTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlFeaTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlFeaTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "fea/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add a FIB client.
     *
     *  @param client_target_name the target name of the FIB client to add.
     *
     *  @param send_updates whether updates should be sent.
     *
     *  @param send_resolves whether resolution requests should be sent.
     */
    virtual XrlCmdError fea_fib_0_1_add_fib_client4(
	// Input values,
	const string&	client_target_name,
	const bool&	send_updates,
	const bool&	send_resolves) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFib01AddFibClient4RF;

    class FeaFib01AddFibClient4CB {
        FeaFib01AddFibClient4RF cb;

    public:
        operator const FeaFib01AddFibClient4RF& () const { return cb; }
        const FeaFib01AddFibClient4RF& operator ->() const { return cb; }
        FeaFib01AddFibClient4CB(const FeaFib01AddFibClient4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFib01AddFibClient4Rsp :
      public FeaFib01AddFibClient4CB {
        FeaFib01AddFibClient4Rsp(const FeaFib01AddFibClient4RF& cb)
          : FeaFib01AddFibClient4CB(cb) { }

    };

    virtual void async_fea_fib_0_1_add_fib_client4
       (
	const string&	client_target_name,
	const bool&	send_updates,
	const bool&	send_resolves,
	FeaFib01AddFibClient4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete a FIB client.
     *
     *  @param client_target_name the target name of the FIB client to delete.
     */
    virtual XrlCmdError fea_fib_0_1_delete_fib_client4(
	// Input values,
	const string&	client_target_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFib01DeleteFibClient4RF;

    class FeaFib01DeleteFibClient4CB {
        FeaFib01DeleteFibClient4RF cb;

    public:
        operator const FeaFib01DeleteFibClient4RF& () const { return cb; }
        const FeaFib01DeleteFibClient4RF& operator ->() const { return cb; }
        FeaFib01DeleteFibClient4CB(const FeaFib01DeleteFibClient4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFib01DeleteFibClient4Rsp :
      public FeaFib01DeleteFibClient4CB {
        FeaFib01DeleteFibClient4Rsp(const FeaFib01DeleteFibClient4RF& cb)
          : FeaFib01DeleteFibClient4CB(cb) { }

    };

    virtual void async_fea_fib_0_1_delete_fib_client4
       (
	const string&	client_target_name,
	FeaFib01DeleteFibClient4CB);
#endif

    virtual XrlCmdError fea_fib_0_1_add_fib_client6(
	// Input values,
	const string&	client_target_name,
	const bool&	send_updates,
	const bool&	send_resolves) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFib01AddFibClient6RF;

    class FeaFib01AddFibClient6CB {
        FeaFib01AddFibClient6RF cb;

    public:
        operator const FeaFib01AddFibClient6RF& () const { return cb; }
        const FeaFib01AddFibClient6RF& operator ->() const { return cb; }
        FeaFib01AddFibClient6CB(const FeaFib01AddFibClient6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFib01AddFibClient6Rsp :
      public FeaFib01AddFibClient6CB {
        FeaFib01AddFibClient6Rsp(const FeaFib01AddFibClient6RF& cb)
          : FeaFib01AddFibClient6CB(cb) { }

    };

    virtual void async_fea_fib_0_1_add_fib_client6
       (
	const string&	client_target_name,
	const bool&	send_updates,
	const bool&	send_resolves,
	FeaFib01AddFibClient6CB);
#endif

    virtual XrlCmdError fea_fib_0_1_delete_fib_client6(
	// Input values,
	const string&	client_target_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFib01DeleteFibClient6RF;

    class FeaFib01DeleteFibClient6CB {
        FeaFib01DeleteFibClient6RF cb;

    public:
        operator const FeaFib01DeleteFibClient6RF& () const { return cb; }
        const FeaFib01DeleteFibClient6RF& operator ->() const { return cb; }
        FeaFib01DeleteFibClient6CB(const FeaFib01DeleteFibClient6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFib01DeleteFibClient6Rsp :
      public FeaFib01DeleteFibClient6CB {
        FeaFib01DeleteFibClient6Rsp(const FeaFib01DeleteFibClient6RF& cb)
          : FeaFib01DeleteFibClient6CB(cb) { }

    };

    virtual void async_fea_fib_0_1_delete_fib_client6
       (
	const string&	client_target_name,
	FeaFib01DeleteFibClient6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start firewall configuration transaction.
     *
     *  @param tid the transaction ID returned by this operation.
     */
    virtual XrlCmdError fea_firewall_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    FeaFirewall01StartTransactionRF;

    class FeaFirewall01StartTransactionCB {
        FeaFirewall01StartTransactionRF cb;

    public:
        operator const FeaFirewall01StartTransactionRF& () const { return cb; }
        const FeaFirewall01StartTransactionRF& operator ->() const { return cb; }
        FeaFirewall01StartTransactionCB(const FeaFirewall01StartTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_tid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tid);
        }
    };

    struct FeaFirewall01StartTransactionRsp :
      public FeaFirewall01StartTransactionCB {
        struct args_str {
            uint32_t tid;
        };

    private:
        args_str args;

    public:
        FeaFirewall01StartTransactionRsp(const FeaFirewall01StartTransactionRF& cb)
          : FeaFirewall01StartTransactionCB(cb) { }

        void respond() const {
            FeaFirewall01StartTransactionCB::
            respond(args.tid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fea_firewall_0_1_start_transaction
       (
	FeaFirewall01StartTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit firewall configuration transaction.
     *
     *  @param tid the transaction ID for this operation.
     */
    virtual XrlCmdError fea_firewall_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01CommitTransactionRF;

    class FeaFirewall01CommitTransactionCB {
        FeaFirewall01CommitTransactionRF cb;

    public:
        operator const FeaFirewall01CommitTransactionRF& () const { return cb; }
        const FeaFirewall01CommitTransactionRF& operator ->() const { return cb; }
        FeaFirewall01CommitTransactionCB(const FeaFirewall01CommitTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01CommitTransactionRsp :
      public FeaFirewall01CommitTransactionCB {
        FeaFirewall01CommitTransactionRsp(const FeaFirewall01CommitTransactionRF& cb)
          : FeaFirewall01CommitTransactionCB(cb) { }

    };

    virtual void async_fea_firewall_0_1_commit_transaction
       (
	const uint32_t&	tid,
	FeaFirewall01CommitTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort firewall configuration transaction.
     *
     *  @param tid the transaction ID for this operation.
     */
    virtual XrlCmdError fea_firewall_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01AbortTransactionRF;

    class FeaFirewall01AbortTransactionCB {
        FeaFirewall01AbortTransactionRF cb;

    public:
        operator const FeaFirewall01AbortTransactionRF& () const { return cb; }
        const FeaFirewall01AbortTransactionRF& operator ->() const { return cb; }
        FeaFirewall01AbortTransactionCB(const FeaFirewall01AbortTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01AbortTransactionRsp :
      public FeaFirewall01AbortTransactionCB {
        FeaFirewall01AbortTransactionRsp(const FeaFirewall01AbortTransactionRF& cb)
          : FeaFirewall01AbortTransactionCB(cb) { }

    };

    virtual void async_fea_firewall_0_1_abort_transaction
       (
	const uint32_t&	tid,
	FeaFirewall01AbortTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add an IPv4 firewall entry.
     *
     *  @param tid the transaction ID for this operation.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter is to be
     *  applied.
     *
     *  @param vifname the name of the vif where this filter is to be applied.
     *
     *  @param src_network the source IPv4 network address prefix.
     *
     *  @param dst_network the destination IPv4 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     *
     *  @param action the action to be taken when this filter is matched. It is
     *  one of the following keywords: "none", "pass", "drop", "reject".
     */
    virtual XrlCmdError fea_firewall_0_1_add_entry4(
	// Input values,
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src_network,
	const IPv4Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01AddEntry4RF;

    class FeaFirewall01AddEntry4CB {
        FeaFirewall01AddEntry4RF cb;

    public:
        operator const FeaFirewall01AddEntry4RF& () const { return cb; }
        const FeaFirewall01AddEntry4RF& operator ->() const { return cb; }
        FeaFirewall01AddEntry4CB(const FeaFirewall01AddEntry4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01AddEntry4Rsp :
      public FeaFirewall01AddEntry4CB {
        FeaFirewall01AddEntry4Rsp(const FeaFirewall01AddEntry4RF& cb)
          : FeaFirewall01AddEntry4CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_add_entry4
       (
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src_network,
	const IPv4Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action,
	FeaFirewall01AddEntry4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Replace an IPv4 firewall entry.
     *
     *  @param tid the transaction ID for this operation.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter is to be
     *  applied.
     *
     *  @param vifname the name of the vif where this filter is to be applied.
     *
     *  @param src_network the source IPv4 network address prefix.
     *
     *  @param dst_network the destination IPv4 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     *
     *  @param action the action to be taken when this filter is matched. It is
     *  one of the following keywords: "none", "pass", "drop", "reject".
     */
    virtual XrlCmdError fea_firewall_0_1_replace_entry4(
	// Input values,
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src_network,
	const IPv4Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01ReplaceEntry4RF;

    class FeaFirewall01ReplaceEntry4CB {
        FeaFirewall01ReplaceEntry4RF cb;

    public:
        operator const FeaFirewall01ReplaceEntry4RF& () const { return cb; }
        const FeaFirewall01ReplaceEntry4RF& operator ->() const { return cb; }
        FeaFirewall01ReplaceEntry4CB(const FeaFirewall01ReplaceEntry4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01ReplaceEntry4Rsp :
      public FeaFirewall01ReplaceEntry4CB {
        FeaFirewall01ReplaceEntry4Rsp(const FeaFirewall01ReplaceEntry4RF& cb)
          : FeaFirewall01ReplaceEntry4CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_replace_entry4
       (
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src_network,
	const IPv4Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action,
	FeaFirewall01ReplaceEntry4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete an IPv4 firewall entry.
     *
     *  @param tid the transaction ID for this operation.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter is to be
     *  deleted.
     *
     *  @param vifname the name of the vif where this filter is to be deleted.
     *
     *  @param src_network the source IPv4 network address prefix.
     *
     *  @param dst_network the destination IPv4 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     */
    virtual XrlCmdError fea_firewall_0_1_delete_entry4(
	// Input values,
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src_network,
	const IPv4Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01DeleteEntry4RF;

    class FeaFirewall01DeleteEntry4CB {
        FeaFirewall01DeleteEntry4RF cb;

    public:
        operator const FeaFirewall01DeleteEntry4RF& () const { return cb; }
        const FeaFirewall01DeleteEntry4RF& operator ->() const { return cb; }
        FeaFirewall01DeleteEntry4CB(const FeaFirewall01DeleteEntry4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01DeleteEntry4Rsp :
      public FeaFirewall01DeleteEntry4CB {
        FeaFirewall01DeleteEntry4Rsp(const FeaFirewall01DeleteEntry4RF& cb)
          : FeaFirewall01DeleteEntry4CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_delete_entry4
       (
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv4Net&	src_network,
	const IPv4Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	FeaFirewall01DeleteEntry4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all IPv4 firewall entries.
     *
     *  @param tid the transaction ID for this operation.
     */
    virtual XrlCmdError fea_firewall_0_1_delete_all_entries4(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01DeleteAllEntries4RF;

    class FeaFirewall01DeleteAllEntries4CB {
        FeaFirewall01DeleteAllEntries4RF cb;

    public:
        operator const FeaFirewall01DeleteAllEntries4RF& () const { return cb; }
        const FeaFirewall01DeleteAllEntries4RF& operator ->() const { return cb; }
        FeaFirewall01DeleteAllEntries4CB(const FeaFirewall01DeleteAllEntries4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01DeleteAllEntries4Rsp :
      public FeaFirewall01DeleteAllEntries4CB {
        FeaFirewall01DeleteAllEntries4Rsp(const FeaFirewall01DeleteAllEntries4RF& cb)
          : FeaFirewall01DeleteAllEntries4CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_delete_all_entries4
       (
	const uint32_t&	tid,
	FeaFirewall01DeleteAllEntries4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get a token for a list of IPv4 firewall entries.
     *
     *  @param token to be provided when calling get_entry_list_next4.
     *
     *  @param more true if the list is not empty.
     */
    virtual XrlCmdError fea_firewall_0_1_get_entry_list_start4(
	// Output values,
	uint32_t&	token,
	bool&	more) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const bool*>::RefPtr
    FeaFirewall01GetEntryListStart4RF;

    class FeaFirewall01GetEntryListStart4CB {
        FeaFirewall01GetEntryListStart4RF cb;

    public:
        operator const FeaFirewall01GetEntryListStart4RF& () const { return cb; }
        const FeaFirewall01GetEntryListStart4RF& operator ->() const { return cb; }
        FeaFirewall01GetEntryListStart4CB(const FeaFirewall01GetEntryListStart4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_token,
                     const bool& arg_more) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_token,
                         &arg_more);
        }
    };

    struct FeaFirewall01GetEntryListStart4Rsp :
      public FeaFirewall01GetEntryListStart4CB {
        struct args_str {
            uint32_t token;
            bool more;
        };

    private:
        args_str args;

    public:
        FeaFirewall01GetEntryListStart4Rsp(const FeaFirewall01GetEntryListStart4RF& cb)
          : FeaFirewall01GetEntryListStart4CB(cb) { }

        void respond() const {
            FeaFirewall01GetEntryListStart4CB::
            respond(args.token,
                        args.more);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fea_firewall_0_1_get_entry_list_start4
       (
	FeaFirewall01GetEntryListStart4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the next item in a list of IPv4 firewall entries.
     *
     *  @param token returned by a previous call to get_entry_list_start4.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter exists.
     *
     *  @param vifname the name of the vif where this filter exists.
     *
     *  @param src_network the source IPv4 network address prefix.
     *
     *  @param dst_network the destination IPv4 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     *
     *  @param action the action taken when this filter is matched. It is one
     *  of the following keywords: "none", "pass", "drop", "reject".
     *
     *  @param more true if the list has more items remaining.
     */
    virtual XrlCmdError fea_firewall_0_1_get_entry_list_next4(
	// Input values,
	const uint32_t&	token,
	// Output values,
	uint32_t&	rule_number,
	string&	ifname,
	string&	vifname,
	IPv4Net&	src_network,
	IPv4Net&	dst_network,
	uint32_t&	ip_protocol,
	uint32_t&	src_port_begin,
	uint32_t&	src_port_end,
	uint32_t&	dst_port_begin,
	uint32_t&	dst_port_end,
	string&	action,
	bool&	more) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback13<void, const XrlCmdError &,
	const uint32_t*,
	const string*,
	const string*,
	const IPv4Net*,
	const IPv4Net*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const string*,
	const bool*>::RefPtr
    FeaFirewall01GetEntryListNext4RF;

    class FeaFirewall01GetEntryListNext4CB {
        FeaFirewall01GetEntryListNext4RF cb;

    public:
        operator const FeaFirewall01GetEntryListNext4RF& () const { return cb; }
        const FeaFirewall01GetEntryListNext4RF& operator ->() const { return cb; }
        FeaFirewall01GetEntryListNext4CB(const FeaFirewall01GetEntryListNext4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_rule_number,
                     const string& arg_ifname,
                     const string& arg_vifname,
                     const IPv4Net& arg_src_network,
                     const IPv4Net& arg_dst_network,
                     const uint32_t& arg_ip_protocol,
                     const uint32_t& arg_src_port_begin,
                     const uint32_t& arg_src_port_end,
                     const uint32_t& arg_dst_port_begin,
                     const uint32_t& arg_dst_port_end,
                     const string& arg_action,
                     const bool& arg_more) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_rule_number,
                         &arg_ifname,
                         &arg_vifname,
                         &arg_src_network,
                         &arg_dst_network,
                         &arg_ip_protocol,
                         &arg_src_port_begin,
                         &arg_src_port_end,
                         &arg_dst_port_begin,
                         &arg_dst_port_end,
                         &arg_action,
                         &arg_more);
        }
    };

    struct FeaFirewall01GetEntryListNext4Rsp :
      public FeaFirewall01GetEntryListNext4CB {
        struct args_str {
            uint32_t rule_number;
            string ifname;
            string vifname;
            IPv4Net src_network;
            IPv4Net dst_network;
            uint32_t ip_protocol;
            uint32_t src_port_begin;
            uint32_t src_port_end;
            uint32_t dst_port_begin;
            uint32_t dst_port_end;
            string action;
            bool more;
        };

    private:
        args_str args;

    public:
        FeaFirewall01GetEntryListNext4Rsp(const FeaFirewall01GetEntryListNext4RF& cb)
          : FeaFirewall01GetEntryListNext4CB(cb) { }

        void respond() const {
            FeaFirewall01GetEntryListNext4CB::
            respond(args.rule_number,
                        args.ifname,
                        args.vifname,
                        args.src_network,
                        args.dst_network,
                        args.ip_protocol,
                        args.src_port_begin,
                        args.src_port_end,
                        args.dst_port_begin,
                        args.dst_port_end,
                        args.action,
                        args.more);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fea_firewall_0_1_get_entry_list_next4
       (
	const uint32_t&	token,
	FeaFirewall01GetEntryListNext4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add an IPv6 firewall entry.
     *
     *  @param tid the transaction ID for this operation.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter is to be
     *  applied.
     *
     *  @param vifname the name of the vif where this filter is to be applied.
     *
     *  @param src_network the source IPv6 network address prefix.
     *
     *  @param dst_network the destination IPv6 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     *
     *  @param action the action to be taken when this filter is matched. It is
     *  one of the following keywords: "none", "pass", "drop", "reject".
     */
    virtual XrlCmdError fea_firewall_0_1_add_entry6(
	// Input values,
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src_network,
	const IPv6Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01AddEntry6RF;

    class FeaFirewall01AddEntry6CB {
        FeaFirewall01AddEntry6RF cb;

    public:
        operator const FeaFirewall01AddEntry6RF& () const { return cb; }
        const FeaFirewall01AddEntry6RF& operator ->() const { return cb; }
        FeaFirewall01AddEntry6CB(const FeaFirewall01AddEntry6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01AddEntry6Rsp :
      public FeaFirewall01AddEntry6CB {
        FeaFirewall01AddEntry6Rsp(const FeaFirewall01AddEntry6RF& cb)
          : FeaFirewall01AddEntry6CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_add_entry6
       (
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src_network,
	const IPv6Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action,
	FeaFirewall01AddEntry6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Replace an IPv6 firewall entry.
     *
     *  @param tid the transaction ID for this operation.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter is to be
     *  applied.
     *
     *  @param vifname the name of the vif where this filter is to be applied.
     *
     *  @param src_network the source IPv6 network address prefix.
     *
     *  @param dst_network the destination IPv6 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     *
     *  @param action the action to be taken when this filter is matched. It is
     *  one of the following keywords: "none", "pass", "drop", "reject".
     */
    virtual XrlCmdError fea_firewall_0_1_replace_entry6(
	// Input values,
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src_network,
	const IPv6Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01ReplaceEntry6RF;

    class FeaFirewall01ReplaceEntry6CB {
        FeaFirewall01ReplaceEntry6RF cb;

    public:
        operator const FeaFirewall01ReplaceEntry6RF& () const { return cb; }
        const FeaFirewall01ReplaceEntry6RF& operator ->() const { return cb; }
        FeaFirewall01ReplaceEntry6CB(const FeaFirewall01ReplaceEntry6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01ReplaceEntry6Rsp :
      public FeaFirewall01ReplaceEntry6CB {
        FeaFirewall01ReplaceEntry6Rsp(const FeaFirewall01ReplaceEntry6RF& cb)
          : FeaFirewall01ReplaceEntry6CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_replace_entry6
       (
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src_network,
	const IPv6Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	const string&	action,
	FeaFirewall01ReplaceEntry6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete an IPv6 firewall entry.
     *
     *  @param tid the transaction ID for this operation.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter is to be
     *  deleted.
     *
     *  @param vifname the name of the vif where this filter is to be deleted.
     *
     *  @param src_network the source IPv6 network address prefix.
     *
     *  @param dst_network the destination IPv6 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     */
    virtual XrlCmdError fea_firewall_0_1_delete_entry6(
	// Input values,
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src_network,
	const IPv6Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01DeleteEntry6RF;

    class FeaFirewall01DeleteEntry6CB {
        FeaFirewall01DeleteEntry6RF cb;

    public:
        operator const FeaFirewall01DeleteEntry6RF& () const { return cb; }
        const FeaFirewall01DeleteEntry6RF& operator ->() const { return cb; }
        FeaFirewall01DeleteEntry6CB(const FeaFirewall01DeleteEntry6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01DeleteEntry6Rsp :
      public FeaFirewall01DeleteEntry6CB {
        FeaFirewall01DeleteEntry6Rsp(const FeaFirewall01DeleteEntry6RF& cb)
          : FeaFirewall01DeleteEntry6CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_delete_entry6
       (
	const uint32_t&	tid,
	const uint32_t&	rule_number,
	const string&	ifname,
	const string&	vifname,
	const IPv6Net&	src_network,
	const IPv6Net&	dst_network,
	const uint32_t&	ip_protocol,
	const uint32_t&	src_port_begin,
	const uint32_t&	src_port_end,
	const uint32_t&	dst_port_begin,
	const uint32_t&	dst_port_end,
	FeaFirewall01DeleteEntry6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all IPv6 firewall entries.
     *
     *  @param tid the transaction ID for this operation.
     */
    virtual XrlCmdError fea_firewall_0_1_delete_all_entries6(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01DeleteAllEntries6RF;

    class FeaFirewall01DeleteAllEntries6CB {
        FeaFirewall01DeleteAllEntries6RF cb;

    public:
        operator const FeaFirewall01DeleteAllEntries6RF& () const { return cb; }
        const FeaFirewall01DeleteAllEntries6RF& operator ->() const { return cb; }
        FeaFirewall01DeleteAllEntries6CB(const FeaFirewall01DeleteAllEntries6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01DeleteAllEntries6Rsp :
      public FeaFirewall01DeleteAllEntries6CB {
        FeaFirewall01DeleteAllEntries6Rsp(const FeaFirewall01DeleteAllEntries6RF& cb)
          : FeaFirewall01DeleteAllEntries6CB(cb) { }

    };

    virtual void async_fea_firewall_0_1_delete_all_entries6
       (
	const uint32_t&	tid,
	FeaFirewall01DeleteAllEntries6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get a token for a list of IPv6 firewall entries.
     *
     *  @param token to be provided when calling get_entry_list_next6.
     *
     *  @param more true if the list is not empty.
     */
    virtual XrlCmdError fea_firewall_0_1_get_entry_list_start6(
	// Output values,
	uint32_t&	token,
	bool&	more) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const bool*>::RefPtr
    FeaFirewall01GetEntryListStart6RF;

    class FeaFirewall01GetEntryListStart6CB {
        FeaFirewall01GetEntryListStart6RF cb;

    public:
        operator const FeaFirewall01GetEntryListStart6RF& () const { return cb; }
        const FeaFirewall01GetEntryListStart6RF& operator ->() const { return cb; }
        FeaFirewall01GetEntryListStart6CB(const FeaFirewall01GetEntryListStart6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_token,
                     const bool& arg_more) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_token,
                         &arg_more);
        }
    };

    struct FeaFirewall01GetEntryListStart6Rsp :
      public FeaFirewall01GetEntryListStart6CB {
        struct args_str {
            uint32_t token;
            bool more;
        };

    private:
        args_str args;

    public:
        FeaFirewall01GetEntryListStart6Rsp(const FeaFirewall01GetEntryListStart6RF& cb)
          : FeaFirewall01GetEntryListStart6CB(cb) { }

        void respond() const {
            FeaFirewall01GetEntryListStart6CB::
            respond(args.token,
                        args.more);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fea_firewall_0_1_get_entry_list_start6
       (
	FeaFirewall01GetEntryListStart6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the next item in a list of IPv6 firewall entries.
     *
     *  @param token returned by a previous call to get_entry_list_start6.
     *
     *  @param rule_number the rule number for this entry.
     *
     *  @param ifname the name of the interface where this filter exists.
     *
     *  @param vifname the name of the vif where this filter exists.
     *
     *  @param src_network the source IPv6 network address prefix.
     *
     *  @param dst_network the destination IPv6 network address prefix.
     *
     *  @param ip_protocol the IP protocol number (1-255, or 0 if wildcard).
     *
     *  @param src_port_begin the source TCP/UDP begin port (0-65535).
     *
     *  @param src_port_end the source TCP/UDP end port (0-65535).
     *
     *  @param dst_port_begin the destination TCP/UDP begin port (0-65535).
     *
     *  @param dst_port_end the destination TCP/UDP end port (0-65535).
     *
     *  @param action the action taken when this filter is matched. It is one
     *  of the following keywords: "none", "pass", "drop", "reject".
     *
     *  @param more true if the list has more items remaining.
     */
    virtual XrlCmdError fea_firewall_0_1_get_entry_list_next6(
	// Input values,
	const uint32_t&	token,
	// Output values,
	uint32_t&	rule_number,
	string&	ifname,
	string&	vifname,
	IPv6Net&	src_network,
	IPv6Net&	dst_network,
	uint32_t&	ip_protocol,
	uint32_t&	src_port_begin,
	uint32_t&	src_port_end,
	uint32_t&	dst_port_begin,
	uint32_t&	dst_port_end,
	string&	action,
	bool&	more) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback13<void, const XrlCmdError &,
	const uint32_t*,
	const string*,
	const string*,
	const IPv6Net*,
	const IPv6Net*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const string*,
	const bool*>::RefPtr
    FeaFirewall01GetEntryListNext6RF;

    class FeaFirewall01GetEntryListNext6CB {
        FeaFirewall01GetEntryListNext6RF cb;

    public:
        operator const FeaFirewall01GetEntryListNext6RF& () const { return cb; }
        const FeaFirewall01GetEntryListNext6RF& operator ->() const { return cb; }
        FeaFirewall01GetEntryListNext6CB(const FeaFirewall01GetEntryListNext6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_rule_number,
                     const string& arg_ifname,
                     const string& arg_vifname,
                     const IPv6Net& arg_src_network,
                     const IPv6Net& arg_dst_network,
                     const uint32_t& arg_ip_protocol,
                     const uint32_t& arg_src_port_begin,
                     const uint32_t& arg_src_port_end,
                     const uint32_t& arg_dst_port_begin,
                     const uint32_t& arg_dst_port_end,
                     const string& arg_action,
                     const bool& arg_more) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_rule_number,
                         &arg_ifname,
                         &arg_vifname,
                         &arg_src_network,
                         &arg_dst_network,
                         &arg_ip_protocol,
                         &arg_src_port_begin,
                         &arg_src_port_end,
                         &arg_dst_port_begin,
                         &arg_dst_port_end,
                         &arg_action,
                         &arg_more);
        }
    };

    struct FeaFirewall01GetEntryListNext6Rsp :
      public FeaFirewall01GetEntryListNext6CB {
        struct args_str {
            uint32_t rule_number;
            string ifname;
            string vifname;
            IPv6Net src_network;
            IPv6Net dst_network;
            uint32_t ip_protocol;
            uint32_t src_port_begin;
            uint32_t src_port_end;
            uint32_t dst_port_begin;
            uint32_t dst_port_end;
            string action;
            bool more;
        };

    private:
        args_str args;

    public:
        FeaFirewall01GetEntryListNext6Rsp(const FeaFirewall01GetEntryListNext6RF& cb)
          : FeaFirewall01GetEntryListNext6CB(cb) { }

        void respond() const {
            FeaFirewall01GetEntryListNext6CB::
            respond(args.rule_number,
                        args.ifname,
                        args.vifname,
                        args.src_network,
                        args.dst_network,
                        args.ip_protocol,
                        args.src_port_begin,
                        args.src_port_end,
                        args.dst_port_begin,
                        args.dst_port_end,
                        args.action,
                        args.more);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fea_firewall_0_1_get_entry_list_next6
       (
	const uint32_t&	token,
	FeaFirewall01GetEntryListNext6CB);
#endif

    virtual XrlCmdError fea_firewall_0_1_startup_firewall() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FeaFirewall01StartupFirewallRF;

    class FeaFirewall01StartupFirewallCB {
        FeaFirewall01StartupFirewallRF cb;

    public:
        operator const FeaFirewall01StartupFirewallRF& () const { return cb; }
        const FeaFirewall01StartupFirewallRF& operator ->() const { return cb; }
        FeaFirewall01StartupFirewallCB(const FeaFirewall01StartupFirewallRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FeaFirewall01StartupFirewallRsp :
      public FeaFirewall01StartupFirewallCB {
        FeaFirewall01StartupFirewallRsp(const FeaFirewall01StartupFirewallRF& cb)
          : FeaFirewall01StartupFirewallCB(cb) { }

    };

    virtual void async_fea_firewall_0_1_startup_firewall
       (
	FeaFirewall01StartupFirewallCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_restore_original_config_on_shutdown(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetRestoreOriginalConfigOnShutdownRF;

    class Ifmgr01SetRestoreOriginalConfigOnShutdownCB {
        Ifmgr01SetRestoreOriginalConfigOnShutdownRF cb;

    public:
        operator const Ifmgr01SetRestoreOriginalConfigOnShutdownRF& () const { return cb; }
        const Ifmgr01SetRestoreOriginalConfigOnShutdownRF& operator ->() const { return cb; }
        Ifmgr01SetRestoreOriginalConfigOnShutdownCB(const Ifmgr01SetRestoreOriginalConfigOnShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetRestoreOriginalConfigOnShutdownRsp :
      public Ifmgr01SetRestoreOriginalConfigOnShutdownCB {
        Ifmgr01SetRestoreOriginalConfigOnShutdownRsp(const Ifmgr01SetRestoreOriginalConfigOnShutdownRF& cb)
          : Ifmgr01SetRestoreOriginalConfigOnShutdownCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_restore_original_config_on_shutdown
       (
	const bool&	enable,
	Ifmgr01SetRestoreOriginalConfigOnShutdownCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_names(
	// Output values,
	XrlAtomList&	ifnames) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ifmgr01GetConfiguredInterfaceNamesRF;

    class Ifmgr01GetConfiguredInterfaceNamesCB {
        Ifmgr01GetConfiguredInterfaceNamesRF cb;

    public:
        operator const Ifmgr01GetConfiguredInterfaceNamesRF& () const { return cb; }
        const Ifmgr01GetConfiguredInterfaceNamesRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredInterfaceNamesCB(const Ifmgr01GetConfiguredInterfaceNamesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_ifnames) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ifnames);
        }
    };

    struct Ifmgr01GetConfiguredInterfaceNamesRsp :
      public Ifmgr01GetConfiguredInterfaceNamesCB {
        struct args_str {
            XrlAtomList ifnames;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredInterfaceNamesRsp(const Ifmgr01GetConfiguredInterfaceNamesRF& cb)
          : Ifmgr01GetConfiguredInterfaceNamesCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredInterfaceNamesCB::
            respond(args.ifnames);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_interface_names
       (
	Ifmgr01GetConfiguredInterfaceNamesCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_names(
	// Input values,
	const string&	ifname,
	// Output values,
	XrlAtomList&	vifs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ifmgr01GetConfiguredVifNamesRF;

    class Ifmgr01GetConfiguredVifNamesCB {
        Ifmgr01GetConfiguredVifNamesRF cb;

    public:
        operator const Ifmgr01GetConfiguredVifNamesRF& () const { return cb; }
        const Ifmgr01GetConfiguredVifNamesRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredVifNamesCB(const Ifmgr01GetConfiguredVifNamesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_vifs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_vifs);
        }
    };

    struct Ifmgr01GetConfiguredVifNamesRsp :
      public Ifmgr01GetConfiguredVifNamesCB {
        struct args_str {
            XrlAtomList vifs;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredVifNamesRsp(const Ifmgr01GetConfiguredVifNamesRF& cb)
          : Ifmgr01GetConfiguredVifNamesCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredVifNamesCB::
            respond(args.vifs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_vif_names
       (
	const string&	ifname,
	Ifmgr01GetConfiguredVifNamesCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_flags(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	bool&	enabled,
	bool&	broadcast,
	bool&	loopback,
	bool&	point_to_point,
	bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const bool*,
	const bool*,
	const bool*,
	const bool*,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredVifFlagsRF;

    class Ifmgr01GetConfiguredVifFlagsCB {
        Ifmgr01GetConfiguredVifFlagsRF cb;

    public:
        operator const Ifmgr01GetConfiguredVifFlagsRF& () const { return cb; }
        const Ifmgr01GetConfiguredVifFlagsRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredVifFlagsCB(const Ifmgr01GetConfiguredVifFlagsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const bool& arg_enabled,
                     const bool& arg_broadcast,
                     const bool& arg_loopback,
                     const bool& arg_point_to_point,
                     const bool& arg_multicast) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled,
                         &arg_broadcast,
                         &arg_loopback,
                         &arg_point_to_point,
                         &arg_multicast);
        }
    };

    struct Ifmgr01GetConfiguredVifFlagsRsp :
      public Ifmgr01GetConfiguredVifFlagsCB {
        struct args_str {
            bool enabled;
            bool broadcast;
            bool loopback;
            bool point_to_point;
            bool multicast;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredVifFlagsRsp(const Ifmgr01GetConfiguredVifFlagsRF& cb)
          : Ifmgr01GetConfiguredVifFlagsCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredVifFlagsCB::
            respond(args.enabled,
                        args.broadcast,
                        args.loopback,
                        args.point_to_point,
                        args.multicast);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_vif_flags
       (
	const string&	ifname,
	const string&	vif,
	Ifmgr01GetConfiguredVifFlagsCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_pif_index(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	uint32_t&	pif_index) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ifmgr01GetConfiguredVifPifIndexRF;

    class Ifmgr01GetConfiguredVifPifIndexCB {
        Ifmgr01GetConfiguredVifPifIndexRF cb;

    public:
        operator const Ifmgr01GetConfiguredVifPifIndexRF& () const { return cb; }
        const Ifmgr01GetConfiguredVifPifIndexRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredVifPifIndexCB(const Ifmgr01GetConfiguredVifPifIndexRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_pif_index) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_pif_index);
        }
    };

    struct Ifmgr01GetConfiguredVifPifIndexRsp :
      public Ifmgr01GetConfiguredVifPifIndexCB {
        struct args_str {
            uint32_t pif_index;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredVifPifIndexRsp(const Ifmgr01GetConfiguredVifPifIndexRF& cb)
          : Ifmgr01GetConfiguredVifPifIndexCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredVifPifIndexCB::
            respond(args.pif_index);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_vif_pif_index
       (
	const string&	ifname,
	const string&	vif,
	Ifmgr01GetConfiguredVifPifIndexCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_addresses4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	XrlAtomList&	addresses) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ifmgr01GetConfiguredVifAddresses4RF;

    class Ifmgr01GetConfiguredVifAddresses4CB {
        Ifmgr01GetConfiguredVifAddresses4RF cb;

    public:
        operator const Ifmgr01GetConfiguredVifAddresses4RF& () const { return cb; }
        const Ifmgr01GetConfiguredVifAddresses4RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredVifAddresses4CB(const Ifmgr01GetConfiguredVifAddresses4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_addresses) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_addresses);
        }
    };

    struct Ifmgr01GetConfiguredVifAddresses4Rsp :
      public Ifmgr01GetConfiguredVifAddresses4CB {
        struct args_str {
            XrlAtomList addresses;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredVifAddresses4Rsp(const Ifmgr01GetConfiguredVifAddresses4RF& cb)
          : Ifmgr01GetConfiguredVifAddresses4CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredVifAddresses4CB::
            respond(args.addresses);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_vif_addresses4
       (
	const string&	ifname,
	const string&	vif,
	Ifmgr01GetConfiguredVifAddresses4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_address_flags4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	bool&	enabled,
	bool&	broadcast,
	bool&	loopback,
	bool&	point_to_point,
	bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const bool*,
	const bool*,
	const bool*,
	const bool*,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredAddressFlags4RF;

    class Ifmgr01GetConfiguredAddressFlags4CB {
        Ifmgr01GetConfiguredAddressFlags4RF cb;

    public:
        operator const Ifmgr01GetConfiguredAddressFlags4RF& () const { return cb; }
        const Ifmgr01GetConfiguredAddressFlags4RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredAddressFlags4CB(const Ifmgr01GetConfiguredAddressFlags4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const bool& arg_enabled,
                     const bool& arg_broadcast,
                     const bool& arg_loopback,
                     const bool& arg_point_to_point,
                     const bool& arg_multicast) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled,
                         &arg_broadcast,
                         &arg_loopback,
                         &arg_point_to_point,
                         &arg_multicast);
        }
    };

    struct Ifmgr01GetConfiguredAddressFlags4Rsp :
      public Ifmgr01GetConfiguredAddressFlags4CB {
        struct args_str {
            bool enabled;
            bool broadcast;
            bool loopback;
            bool point_to_point;
            bool multicast;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredAddressFlags4Rsp(const Ifmgr01GetConfiguredAddressFlags4RF& cb)
          : Ifmgr01GetConfiguredAddressFlags4CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredAddressFlags4CB::
            respond(args.enabled,
                        args.broadcast,
                        args.loopback,
                        args.point_to_point,
                        args.multicast);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_address_flags4
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01GetConfiguredAddressFlags4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_enabled(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredInterfaceEnabledRF;

    class Ifmgr01GetConfiguredInterfaceEnabledCB {
        Ifmgr01GetConfiguredInterfaceEnabledRF cb;

    public:
        operator const Ifmgr01GetConfiguredInterfaceEnabledRF& () const { return cb; }
        const Ifmgr01GetConfiguredInterfaceEnabledRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredInterfaceEnabledCB(const Ifmgr01GetConfiguredInterfaceEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Ifmgr01GetConfiguredInterfaceEnabledRsp :
      public Ifmgr01GetConfiguredInterfaceEnabledCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredInterfaceEnabledRsp(const Ifmgr01GetConfiguredInterfaceEnabledRF& cb)
          : Ifmgr01GetConfiguredInterfaceEnabledCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredInterfaceEnabledCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_interface_enabled
       (
	const string&	ifname,
	Ifmgr01GetConfiguredInterfaceEnabledCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_discard(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	discard) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredInterfaceDiscardRF;

    class Ifmgr01GetConfiguredInterfaceDiscardCB {
        Ifmgr01GetConfiguredInterfaceDiscardRF cb;

    public:
        operator const Ifmgr01GetConfiguredInterfaceDiscardRF& () const { return cb; }
        const Ifmgr01GetConfiguredInterfaceDiscardRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredInterfaceDiscardCB(const Ifmgr01GetConfiguredInterfaceDiscardRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_discard) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_discard);
        }
    };

    struct Ifmgr01GetConfiguredInterfaceDiscardRsp :
      public Ifmgr01GetConfiguredInterfaceDiscardCB {
        struct args_str {
            bool discard;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredInterfaceDiscardRsp(const Ifmgr01GetConfiguredInterfaceDiscardRF& cb)
          : Ifmgr01GetConfiguredInterfaceDiscardCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredInterfaceDiscardCB::
            respond(args.discard);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_interface_discard
       (
	const string&	ifname,
	Ifmgr01GetConfiguredInterfaceDiscardCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_unreachable(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	unreachable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredInterfaceUnreachableRF;

    class Ifmgr01GetConfiguredInterfaceUnreachableCB {
        Ifmgr01GetConfiguredInterfaceUnreachableRF cb;

    public:
        operator const Ifmgr01GetConfiguredInterfaceUnreachableRF& () const { return cb; }
        const Ifmgr01GetConfiguredInterfaceUnreachableRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredInterfaceUnreachableCB(const Ifmgr01GetConfiguredInterfaceUnreachableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_unreachable) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_unreachable);
        }
    };

    struct Ifmgr01GetConfiguredInterfaceUnreachableRsp :
      public Ifmgr01GetConfiguredInterfaceUnreachableCB {
        struct args_str {
            bool unreachable;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredInterfaceUnreachableRsp(const Ifmgr01GetConfiguredInterfaceUnreachableRF& cb)
          : Ifmgr01GetConfiguredInterfaceUnreachableCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredInterfaceUnreachableCB::
            respond(args.unreachable);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_interface_unreachable
       (
	const string&	ifname,
	Ifmgr01GetConfiguredInterfaceUnreachableCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_interface_management(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	management) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredInterfaceManagementRF;

    class Ifmgr01GetConfiguredInterfaceManagementCB {
        Ifmgr01GetConfiguredInterfaceManagementRF cb;

    public:
        operator const Ifmgr01GetConfiguredInterfaceManagementRF& () const { return cb; }
        const Ifmgr01GetConfiguredInterfaceManagementRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredInterfaceManagementCB(const Ifmgr01GetConfiguredInterfaceManagementRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_management) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_management);
        }
    };

    struct Ifmgr01GetConfiguredInterfaceManagementRsp :
      public Ifmgr01GetConfiguredInterfaceManagementCB {
        struct args_str {
            bool management;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredInterfaceManagementRsp(const Ifmgr01GetConfiguredInterfaceManagementRF& cb)
          : Ifmgr01GetConfiguredInterfaceManagementCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredInterfaceManagementCB::
            respond(args.management);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_interface_management
       (
	const string&	ifname,
	Ifmgr01GetConfiguredInterfaceManagementCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_mac(
	// Input values,
	const string&	ifname,
	// Output values,
	Mac&	mac) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const Mac*>::RefPtr
    Ifmgr01GetConfiguredMacRF;

    class Ifmgr01GetConfiguredMacCB {
        Ifmgr01GetConfiguredMacRF cb;

    public:
        operator const Ifmgr01GetConfiguredMacRF& () const { return cb; }
        const Ifmgr01GetConfiguredMacRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredMacCB(const Ifmgr01GetConfiguredMacRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const Mac& arg_mac) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_mac);
        }
    };

    struct Ifmgr01GetConfiguredMacRsp :
      public Ifmgr01GetConfiguredMacCB {
        struct args_str {
            Mac mac;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredMacRsp(const Ifmgr01GetConfiguredMacRF& cb)
          : Ifmgr01GetConfiguredMacCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredMacCB::
            respond(args.mac);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_mac
       (
	const string&	ifname,
	Ifmgr01GetConfiguredMacCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_mtu(
	// Input values,
	const string&	ifname,
	// Output values,
	uint32_t&	mtu) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ifmgr01GetConfiguredMtuRF;

    class Ifmgr01GetConfiguredMtuCB {
        Ifmgr01GetConfiguredMtuRF cb;

    public:
        operator const Ifmgr01GetConfiguredMtuRF& () const { return cb; }
        const Ifmgr01GetConfiguredMtuRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredMtuCB(const Ifmgr01GetConfiguredMtuRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_mtu) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_mtu);
        }
    };

    struct Ifmgr01GetConfiguredMtuRsp :
      public Ifmgr01GetConfiguredMtuCB {
        struct args_str {
            uint32_t mtu;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredMtuRsp(const Ifmgr01GetConfiguredMtuRF& cb)
          : Ifmgr01GetConfiguredMtuCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredMtuCB::
            respond(args.mtu);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_mtu
       (
	const string&	ifname,
	Ifmgr01GetConfiguredMtuCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_no_carrier(
	// Input values,
	const string&	ifname,
	// Output values,
	bool&	no_carrier) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredNoCarrierRF;

    class Ifmgr01GetConfiguredNoCarrierCB {
        Ifmgr01GetConfiguredNoCarrierRF cb;

    public:
        operator const Ifmgr01GetConfiguredNoCarrierRF& () const { return cb; }
        const Ifmgr01GetConfiguredNoCarrierRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredNoCarrierCB(const Ifmgr01GetConfiguredNoCarrierRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_no_carrier) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_no_carrier);
        }
    };

    struct Ifmgr01GetConfiguredNoCarrierRsp :
      public Ifmgr01GetConfiguredNoCarrierCB {
        struct args_str {
            bool no_carrier;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredNoCarrierRsp(const Ifmgr01GetConfiguredNoCarrierRF& cb)
          : Ifmgr01GetConfiguredNoCarrierCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredNoCarrierCB::
            respond(args.no_carrier);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_no_carrier
       (
	const string&	ifname,
	Ifmgr01GetConfiguredNoCarrierCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_baudrate(
	// Input values,
	const string&	ifname,
	// Output values,
	uint64_t&	baudrate) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint64_t*>::RefPtr
    Ifmgr01GetConfiguredBaudrateRF;

    class Ifmgr01GetConfiguredBaudrateCB {
        Ifmgr01GetConfiguredBaudrateRF cb;

    public:
        operator const Ifmgr01GetConfiguredBaudrateRF& () const { return cb; }
        const Ifmgr01GetConfiguredBaudrateRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredBaudrateCB(const Ifmgr01GetConfiguredBaudrateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint64_t& arg_baudrate) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_baudrate);
        }
    };

    struct Ifmgr01GetConfiguredBaudrateRsp :
      public Ifmgr01GetConfiguredBaudrateCB {
        struct args_str {
            uint64_t baudrate;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredBaudrateRsp(const Ifmgr01GetConfiguredBaudrateRF& cb)
          : Ifmgr01GetConfiguredBaudrateCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredBaudrateCB::
            respond(args.baudrate);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_baudrate
       (
	const string&	ifname,
	Ifmgr01GetConfiguredBaudrateCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_enabled(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredVifEnabledRF;

    class Ifmgr01GetConfiguredVifEnabledCB {
        Ifmgr01GetConfiguredVifEnabledRF cb;

    public:
        operator const Ifmgr01GetConfiguredVifEnabledRF& () const { return cb; }
        const Ifmgr01GetConfiguredVifEnabledRF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredVifEnabledCB(const Ifmgr01GetConfiguredVifEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Ifmgr01GetConfiguredVifEnabledRsp :
      public Ifmgr01GetConfiguredVifEnabledCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredVifEnabledRsp(const Ifmgr01GetConfiguredVifEnabledRF& cb)
          : Ifmgr01GetConfiguredVifEnabledCB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredVifEnabledCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_vif_enabled
       (
	const string&	ifname,
	const string&	vif,
	Ifmgr01GetConfiguredVifEnabledCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_prefix4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ifmgr01GetConfiguredPrefix4RF;

    class Ifmgr01GetConfiguredPrefix4CB {
        Ifmgr01GetConfiguredPrefix4RF cb;

    public:
        operator const Ifmgr01GetConfiguredPrefix4RF& () const { return cb; }
        const Ifmgr01GetConfiguredPrefix4RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredPrefix4CB(const Ifmgr01GetConfiguredPrefix4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_prefix_len) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_prefix_len);
        }
    };

    struct Ifmgr01GetConfiguredPrefix4Rsp :
      public Ifmgr01GetConfiguredPrefix4CB {
        struct args_str {
            uint32_t prefix_len;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredPrefix4Rsp(const Ifmgr01GetConfiguredPrefix4RF& cb)
          : Ifmgr01GetConfiguredPrefix4CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredPrefix4CB::
            respond(args.prefix_len);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_prefix4
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01GetConfiguredPrefix4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_broadcast4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	IPv4&	broadcast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Ifmgr01GetConfiguredBroadcast4RF;

    class Ifmgr01GetConfiguredBroadcast4CB {
        Ifmgr01GetConfiguredBroadcast4RF cb;

    public:
        operator const Ifmgr01GetConfiguredBroadcast4RF& () const { return cb; }
        const Ifmgr01GetConfiguredBroadcast4RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredBroadcast4CB(const Ifmgr01GetConfiguredBroadcast4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_broadcast) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_broadcast);
        }
    };

    struct Ifmgr01GetConfiguredBroadcast4Rsp :
      public Ifmgr01GetConfiguredBroadcast4CB {
        struct args_str {
            IPv4 broadcast;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredBroadcast4Rsp(const Ifmgr01GetConfiguredBroadcast4RF& cb)
          : Ifmgr01GetConfiguredBroadcast4CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredBroadcast4CB::
            respond(args.broadcast);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_broadcast4
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01GetConfiguredBroadcast4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_endpoint4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	IPv4&	endpoint) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Ifmgr01GetConfiguredEndpoint4RF;

    class Ifmgr01GetConfiguredEndpoint4CB {
        Ifmgr01GetConfiguredEndpoint4RF cb;

    public:
        operator const Ifmgr01GetConfiguredEndpoint4RF& () const { return cb; }
        const Ifmgr01GetConfiguredEndpoint4RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredEndpoint4CB(const Ifmgr01GetConfiguredEndpoint4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_endpoint) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_endpoint);
        }
    };

    struct Ifmgr01GetConfiguredEndpoint4Rsp :
      public Ifmgr01GetConfiguredEndpoint4CB {
        struct args_str {
            IPv4 endpoint;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredEndpoint4Rsp(const Ifmgr01GetConfiguredEndpoint4RF& cb)
          : Ifmgr01GetConfiguredEndpoint4CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredEndpoint4CB::
            respond(args.endpoint);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_endpoint4
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01GetConfiguredEndpoint4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ifmgr01StartTransactionRF;

    class Ifmgr01StartTransactionCB {
        Ifmgr01StartTransactionRF cb;

    public:
        operator const Ifmgr01StartTransactionRF& () const { return cb; }
        const Ifmgr01StartTransactionRF& operator ->() const { return cb; }
        Ifmgr01StartTransactionCB(const Ifmgr01StartTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_tid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tid);
        }
    };

    struct Ifmgr01StartTransactionRsp :
      public Ifmgr01StartTransactionCB {
        struct args_str {
            uint32_t tid;
        };

    private:
        args_str args;

    public:
        Ifmgr01StartTransactionRsp(const Ifmgr01StartTransactionRF& cb)
          : Ifmgr01StartTransactionCB(cb) { }

        void respond() const {
            Ifmgr01StartTransactionCB::
            respond(args.tid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_start_transaction
       (
	Ifmgr01StartTransactionCB);
#endif

    virtual XrlCmdError ifmgr_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CommitTransactionRF;

    class Ifmgr01CommitTransactionCB {
        Ifmgr01CommitTransactionRF cb;

    public:
        operator const Ifmgr01CommitTransactionRF& () const { return cb; }
        const Ifmgr01CommitTransactionRF& operator ->() const { return cb; }
        Ifmgr01CommitTransactionCB(const Ifmgr01CommitTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CommitTransactionRsp :
      public Ifmgr01CommitTransactionCB {
        Ifmgr01CommitTransactionRsp(const Ifmgr01CommitTransactionRF& cb)
          : Ifmgr01CommitTransactionCB(cb) { }

    };

    virtual void async_ifmgr_0_1_commit_transaction
       (
	const uint32_t&	tid,
	Ifmgr01CommitTransactionCB);
#endif

    virtual XrlCmdError ifmgr_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01AbortTransactionRF;

    class Ifmgr01AbortTransactionCB {
        Ifmgr01AbortTransactionRF cb;

    public:
        operator const Ifmgr01AbortTransactionRF& () const { return cb; }
        const Ifmgr01AbortTransactionRF& operator ->() const { return cb; }
        Ifmgr01AbortTransactionCB(const Ifmgr01AbortTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01AbortTransactionRsp :
      public Ifmgr01AbortTransactionCB {
        Ifmgr01AbortTransactionRsp(const Ifmgr01AbortTransactionRF& cb)
          : Ifmgr01AbortTransactionCB(cb) { }

    };

    virtual void async_ifmgr_0_1_abort_transaction
       (
	const uint32_t&	tid,
	Ifmgr01AbortTransactionCB);
#endif

    virtual XrlCmdError ifmgr_0_1_create_interface(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CreateInterfaceRF;

    class Ifmgr01CreateInterfaceCB {
        Ifmgr01CreateInterfaceRF cb;

    public:
        operator const Ifmgr01CreateInterfaceRF& () const { return cb; }
        const Ifmgr01CreateInterfaceRF& operator ->() const { return cb; }
        Ifmgr01CreateInterfaceCB(const Ifmgr01CreateInterfaceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CreateInterfaceRsp :
      public Ifmgr01CreateInterfaceCB {
        Ifmgr01CreateInterfaceRsp(const Ifmgr01CreateInterfaceRF& cb)
          : Ifmgr01CreateInterfaceCB(cb) { }

    };

    virtual void async_ifmgr_0_1_create_interface
       (
	const uint32_t&	tid,
	const string&	ifname,
	Ifmgr01CreateInterfaceCB);
#endif

    virtual XrlCmdError ifmgr_0_1_delete_interface(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01DeleteInterfaceRF;

    class Ifmgr01DeleteInterfaceCB {
        Ifmgr01DeleteInterfaceRF cb;

    public:
        operator const Ifmgr01DeleteInterfaceRF& () const { return cb; }
        const Ifmgr01DeleteInterfaceRF& operator ->() const { return cb; }
        Ifmgr01DeleteInterfaceCB(const Ifmgr01DeleteInterfaceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01DeleteInterfaceRsp :
      public Ifmgr01DeleteInterfaceCB {
        Ifmgr01DeleteInterfaceRsp(const Ifmgr01DeleteInterfaceRF& cb)
          : Ifmgr01DeleteInterfaceCB(cb) { }

    };

    virtual void async_ifmgr_0_1_delete_interface
       (
	const uint32_t&	tid,
	const string&	ifname,
	Ifmgr01DeleteInterfaceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Implicitly configure all interfaces within the FEA by using information
     *  from the underlying system.
     *
     *  @param tid the transaction ID.
     *
     *  @param enable if true, then enable the implicit configuration,
     *  otherwise disable it.
     */
    virtual XrlCmdError ifmgr_0_1_configure_all_interfaces_from_system(
	// Input values,
	const uint32_t&	tid,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01ConfigureAllInterfacesFromSystemRF;

    class Ifmgr01ConfigureAllInterfacesFromSystemCB {
        Ifmgr01ConfigureAllInterfacesFromSystemRF cb;

    public:
        operator const Ifmgr01ConfigureAllInterfacesFromSystemRF& () const { return cb; }
        const Ifmgr01ConfigureAllInterfacesFromSystemRF& operator ->() const { return cb; }
        Ifmgr01ConfigureAllInterfacesFromSystemCB(const Ifmgr01ConfigureAllInterfacesFromSystemRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01ConfigureAllInterfacesFromSystemRsp :
      public Ifmgr01ConfigureAllInterfacesFromSystemCB {
        Ifmgr01ConfigureAllInterfacesFromSystemRsp(const Ifmgr01ConfigureAllInterfacesFromSystemRF& cb)
          : Ifmgr01ConfigureAllInterfacesFromSystemCB(cb) { }

    };

    virtual void async_ifmgr_0_1_configure_all_interfaces_from_system
       (
	const uint32_t&	tid,
	const bool&	enable,
	Ifmgr01ConfigureAllInterfacesFromSystemCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Implicitly configure an interface within the FEA by using information
     *  from the underlying system.
     *
     *  @param tid the transaction ID.
     *
     *  @param ifname the name of the interface to configure.
     *
     *  @param enable if true, then enable the implicit configuration,
     *  otherwise disable it.
     */
    virtual XrlCmdError ifmgr_0_1_configure_interface_from_system(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01ConfigureInterfaceFromSystemRF;

    class Ifmgr01ConfigureInterfaceFromSystemCB {
        Ifmgr01ConfigureInterfaceFromSystemRF cb;

    public:
        operator const Ifmgr01ConfigureInterfaceFromSystemRF& () const { return cb; }
        const Ifmgr01ConfigureInterfaceFromSystemRF& operator ->() const { return cb; }
        Ifmgr01ConfigureInterfaceFromSystemCB(const Ifmgr01ConfigureInterfaceFromSystemRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01ConfigureInterfaceFromSystemRsp :
      public Ifmgr01ConfigureInterfaceFromSystemCB {
        Ifmgr01ConfigureInterfaceFromSystemRsp(const Ifmgr01ConfigureInterfaceFromSystemRF& cb)
          : Ifmgr01ConfigureInterfaceFromSystemCB(cb) { }

    };

    virtual void async_ifmgr_0_1_configure_interface_from_system
       (
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enable,
	Ifmgr01ConfigureInterfaceFromSystemCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_interface_enabled(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetInterfaceEnabledRF;

    class Ifmgr01SetInterfaceEnabledCB {
        Ifmgr01SetInterfaceEnabledRF cb;

    public:
        operator const Ifmgr01SetInterfaceEnabledRF& () const { return cb; }
        const Ifmgr01SetInterfaceEnabledRF& operator ->() const { return cb; }
        Ifmgr01SetInterfaceEnabledCB(const Ifmgr01SetInterfaceEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetInterfaceEnabledRsp :
      public Ifmgr01SetInterfaceEnabledCB {
        Ifmgr01SetInterfaceEnabledRsp(const Ifmgr01SetInterfaceEnabledRF& cb)
          : Ifmgr01SetInterfaceEnabledCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_interface_enabled
       (
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	enabled,
	Ifmgr01SetInterfaceEnabledCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_interface_discard(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	discard) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetInterfaceDiscardRF;

    class Ifmgr01SetInterfaceDiscardCB {
        Ifmgr01SetInterfaceDiscardRF cb;

    public:
        operator const Ifmgr01SetInterfaceDiscardRF& () const { return cb; }
        const Ifmgr01SetInterfaceDiscardRF& operator ->() const { return cb; }
        Ifmgr01SetInterfaceDiscardCB(const Ifmgr01SetInterfaceDiscardRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetInterfaceDiscardRsp :
      public Ifmgr01SetInterfaceDiscardCB {
        Ifmgr01SetInterfaceDiscardRsp(const Ifmgr01SetInterfaceDiscardRF& cb)
          : Ifmgr01SetInterfaceDiscardCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_interface_discard
       (
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	discard,
	Ifmgr01SetInterfaceDiscardCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_interface_unreachable(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	unreachable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetInterfaceUnreachableRF;

    class Ifmgr01SetInterfaceUnreachableCB {
        Ifmgr01SetInterfaceUnreachableRF cb;

    public:
        operator const Ifmgr01SetInterfaceUnreachableRF& () const { return cb; }
        const Ifmgr01SetInterfaceUnreachableRF& operator ->() const { return cb; }
        Ifmgr01SetInterfaceUnreachableCB(const Ifmgr01SetInterfaceUnreachableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetInterfaceUnreachableRsp :
      public Ifmgr01SetInterfaceUnreachableCB {
        Ifmgr01SetInterfaceUnreachableRsp(const Ifmgr01SetInterfaceUnreachableRF& cb)
          : Ifmgr01SetInterfaceUnreachableCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_interface_unreachable
       (
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	unreachable,
	Ifmgr01SetInterfaceUnreachableCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_interface_management(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	management) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetInterfaceManagementRF;

    class Ifmgr01SetInterfaceManagementCB {
        Ifmgr01SetInterfaceManagementRF cb;

    public:
        operator const Ifmgr01SetInterfaceManagementRF& () const { return cb; }
        const Ifmgr01SetInterfaceManagementRF& operator ->() const { return cb; }
        Ifmgr01SetInterfaceManagementCB(const Ifmgr01SetInterfaceManagementRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetInterfaceManagementRsp :
      public Ifmgr01SetInterfaceManagementCB {
        Ifmgr01SetInterfaceManagementRsp(const Ifmgr01SetInterfaceManagementRF& cb)
          : Ifmgr01SetInterfaceManagementCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_interface_management
       (
	const uint32_t&	tid,
	const string&	ifname,
	const bool&	management,
	Ifmgr01SetInterfaceManagementCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_mac(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const Mac&	mac) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetMacRF;

    class Ifmgr01SetMacCB {
        Ifmgr01SetMacRF cb;

    public:
        operator const Ifmgr01SetMacRF& () const { return cb; }
        const Ifmgr01SetMacRF& operator ->() const { return cb; }
        Ifmgr01SetMacCB(const Ifmgr01SetMacRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetMacRsp :
      public Ifmgr01SetMacCB {
        Ifmgr01SetMacRsp(const Ifmgr01SetMacRF& cb)
          : Ifmgr01SetMacCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_mac
       (
	const uint32_t&	tid,
	const string&	ifname,
	const Mac&	mac,
	Ifmgr01SetMacCB);
#endif

    virtual XrlCmdError ifmgr_0_1_create_mac(
	// Input values,
	const string&	ifname,
	const Mac&	mac) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CreateMacRF;

    class Ifmgr01CreateMacCB {
        Ifmgr01CreateMacRF cb;

    public:
        operator const Ifmgr01CreateMacRF& () const { return cb; }
        const Ifmgr01CreateMacRF& operator ->() const { return cb; }
        Ifmgr01CreateMacCB(const Ifmgr01CreateMacRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CreateMacRsp :
      public Ifmgr01CreateMacCB {
        Ifmgr01CreateMacRsp(const Ifmgr01CreateMacRF& cb)
          : Ifmgr01CreateMacCB(cb) { }

    };

    virtual void async_ifmgr_0_1_create_mac
       (
	const string&	ifname,
	const Mac&	mac,
	Ifmgr01CreateMacCB);
#endif

    virtual XrlCmdError ifmgr_0_1_delete_mac(
	// Input values,
	const string&	ifname,
	const Mac&	mac) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01DeleteMacRF;

    class Ifmgr01DeleteMacCB {
        Ifmgr01DeleteMacRF cb;

    public:
        operator const Ifmgr01DeleteMacRF& () const { return cb; }
        const Ifmgr01DeleteMacRF& operator ->() const { return cb; }
        Ifmgr01DeleteMacCB(const Ifmgr01DeleteMacRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01DeleteMacRsp :
      public Ifmgr01DeleteMacCB {
        Ifmgr01DeleteMacRsp(const Ifmgr01DeleteMacRF& cb)
          : Ifmgr01DeleteMacCB(cb) { }

    };

    virtual void async_ifmgr_0_1_delete_mac
       (
	const string&	ifname,
	const Mac&	mac,
	Ifmgr01DeleteMacCB);
#endif

    virtual XrlCmdError ifmgr_0_1_restore_original_mac(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01RestoreOriginalMacRF;

    class Ifmgr01RestoreOriginalMacCB {
        Ifmgr01RestoreOriginalMacRF cb;

    public:
        operator const Ifmgr01RestoreOriginalMacRF& () const { return cb; }
        const Ifmgr01RestoreOriginalMacRF& operator ->() const { return cb; }
        Ifmgr01RestoreOriginalMacCB(const Ifmgr01RestoreOriginalMacRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01RestoreOriginalMacRsp :
      public Ifmgr01RestoreOriginalMacCB {
        Ifmgr01RestoreOriginalMacRsp(const Ifmgr01RestoreOriginalMacRF& cb)
          : Ifmgr01RestoreOriginalMacCB(cb) { }

    };

    virtual void async_ifmgr_0_1_restore_original_mac
       (
	const uint32_t&	tid,
	const string&	ifname,
	Ifmgr01RestoreOriginalMacCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_mtu(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const uint32_t&	mtu) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetMtuRF;

    class Ifmgr01SetMtuCB {
        Ifmgr01SetMtuRF cb;

    public:
        operator const Ifmgr01SetMtuRF& () const { return cb; }
        const Ifmgr01SetMtuRF& operator ->() const { return cb; }
        Ifmgr01SetMtuCB(const Ifmgr01SetMtuRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetMtuRsp :
      public Ifmgr01SetMtuCB {
        Ifmgr01SetMtuRsp(const Ifmgr01SetMtuRF& cb)
          : Ifmgr01SetMtuCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_mtu
       (
	const uint32_t&	tid,
	const string&	ifname,
	const uint32_t&	mtu,
	Ifmgr01SetMtuCB);
#endif

    virtual XrlCmdError ifmgr_0_1_restore_original_mtu(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01RestoreOriginalMtuRF;

    class Ifmgr01RestoreOriginalMtuCB {
        Ifmgr01RestoreOriginalMtuRF cb;

    public:
        operator const Ifmgr01RestoreOriginalMtuRF& () const { return cb; }
        const Ifmgr01RestoreOriginalMtuRF& operator ->() const { return cb; }
        Ifmgr01RestoreOriginalMtuCB(const Ifmgr01RestoreOriginalMtuRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01RestoreOriginalMtuRsp :
      public Ifmgr01RestoreOriginalMtuCB {
        Ifmgr01RestoreOriginalMtuRsp(const Ifmgr01RestoreOriginalMtuRF& cb)
          : Ifmgr01RestoreOriginalMtuCB(cb) { }

    };

    virtual void async_ifmgr_0_1_restore_original_mtu
       (
	const uint32_t&	tid,
	const string&	ifname,
	Ifmgr01RestoreOriginalMtuCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a vif.
     *
     *  @param ifname the name of the physical interface associated with the
     *  new vif.
     *
     *  @param vif name for new vif, must be unique across all the vifs in the
     *  system.
     */
    virtual XrlCmdError ifmgr_0_1_create_vif(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CreateVifRF;

    class Ifmgr01CreateVifCB {
        Ifmgr01CreateVifRF cb;

    public:
        operator const Ifmgr01CreateVifRF& () const { return cb; }
        const Ifmgr01CreateVifRF& operator ->() const { return cb; }
        Ifmgr01CreateVifCB(const Ifmgr01CreateVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CreateVifRsp :
      public Ifmgr01CreateVifCB {
        Ifmgr01CreateVifRsp(const Ifmgr01CreateVifRF& cb)
          : Ifmgr01CreateVifCB(cb) { }

    };

    virtual void async_ifmgr_0_1_create_vif
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	Ifmgr01CreateVifCB);
#endif

    virtual XrlCmdError ifmgr_0_1_delete_vif(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01DeleteVifRF;

    class Ifmgr01DeleteVifCB {
        Ifmgr01DeleteVifRF cb;

    public:
        operator const Ifmgr01DeleteVifRF& () const { return cb; }
        const Ifmgr01DeleteVifRF& operator ->() const { return cb; }
        Ifmgr01DeleteVifCB(const Ifmgr01DeleteVifRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01DeleteVifRsp :
      public Ifmgr01DeleteVifCB {
        Ifmgr01DeleteVifRsp(const Ifmgr01DeleteVifRF& cb)
          : Ifmgr01DeleteVifCB(cb) { }

    };

    virtual void async_ifmgr_0_1_delete_vif
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	Ifmgr01DeleteVifCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_vif_enabled(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetVifEnabledRF;

    class Ifmgr01SetVifEnabledCB {
        Ifmgr01SetVifEnabledRF cb;

    public:
        operator const Ifmgr01SetVifEnabledRF& () const { return cb; }
        const Ifmgr01SetVifEnabledRF& operator ->() const { return cb; }
        Ifmgr01SetVifEnabledCB(const Ifmgr01SetVifEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetVifEnabledRsp :
      public Ifmgr01SetVifEnabledCB {
        Ifmgr01SetVifEnabledRsp(const Ifmgr01SetVifEnabledRF& cb)
          : Ifmgr01SetVifEnabledCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_vif_enabled
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const bool&	enabled,
	Ifmgr01SetVifEnabledCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_parent_ifname(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	parent_ifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetParentIfnameRF;

    class Ifmgr01SetParentIfnameCB {
        Ifmgr01SetParentIfnameRF cb;

    public:
        operator const Ifmgr01SetParentIfnameRF& () const { return cb; }
        const Ifmgr01SetParentIfnameRF& operator ->() const { return cb; }
        Ifmgr01SetParentIfnameCB(const Ifmgr01SetParentIfnameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetParentIfnameRsp :
      public Ifmgr01SetParentIfnameCB {
        Ifmgr01SetParentIfnameRsp(const Ifmgr01SetParentIfnameRF& cb)
          : Ifmgr01SetParentIfnameCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_parent_ifname
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	parent_ifname,
	Ifmgr01SetParentIfnameCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_iface_type(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	iface_type) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetIfaceTypeRF;

    class Ifmgr01SetIfaceTypeCB {
        Ifmgr01SetIfaceTypeRF cb;

    public:
        operator const Ifmgr01SetIfaceTypeRF& () const { return cb; }
        const Ifmgr01SetIfaceTypeRF& operator ->() const { return cb; }
        Ifmgr01SetIfaceTypeCB(const Ifmgr01SetIfaceTypeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetIfaceTypeRsp :
      public Ifmgr01SetIfaceTypeCB {
        Ifmgr01SetIfaceTypeRsp(const Ifmgr01SetIfaceTypeRF& cb)
          : Ifmgr01SetIfaceTypeCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_iface_type
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	iface_type,
	Ifmgr01SetIfaceTypeCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_vid(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetVidRF;

    class Ifmgr01SetVidCB {
        Ifmgr01SetVidRF cb;

    public:
        operator const Ifmgr01SetVidRF& () const { return cb; }
        const Ifmgr01SetVidRF& operator ->() const { return cb; }
        Ifmgr01SetVidCB(const Ifmgr01SetVidRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetVidRsp :
      public Ifmgr01SetVidCB {
        Ifmgr01SetVidRsp(const Ifmgr01SetVidRF& cb)
          : Ifmgr01SetVidCB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_vid
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vid,
	Ifmgr01SetVidCB);
#endif

    virtual XrlCmdError ifmgr_0_1_create_address4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CreateAddress4RF;

    class Ifmgr01CreateAddress4CB {
        Ifmgr01CreateAddress4RF cb;

    public:
        operator const Ifmgr01CreateAddress4RF& () const { return cb; }
        const Ifmgr01CreateAddress4RF& operator ->() const { return cb; }
        Ifmgr01CreateAddress4CB(const Ifmgr01CreateAddress4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CreateAddress4Rsp :
      public Ifmgr01CreateAddress4CB {
        Ifmgr01CreateAddress4Rsp(const Ifmgr01CreateAddress4RF& cb)
          : Ifmgr01CreateAddress4CB(cb) { }

    };

    virtual void async_ifmgr_0_1_create_address4
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01CreateAddress4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_delete_address4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01DeleteAddress4RF;

    class Ifmgr01DeleteAddress4CB {
        Ifmgr01DeleteAddress4RF cb;

    public:
        operator const Ifmgr01DeleteAddress4RF& () const { return cb; }
        const Ifmgr01DeleteAddress4RF& operator ->() const { return cb; }
        Ifmgr01DeleteAddress4CB(const Ifmgr01DeleteAddress4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01DeleteAddress4Rsp :
      public Ifmgr01DeleteAddress4CB {
        Ifmgr01DeleteAddress4Rsp(const Ifmgr01DeleteAddress4RF& cb)
          : Ifmgr01DeleteAddress4CB(cb) { }

    };

    virtual void async_ifmgr_0_1_delete_address4
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01DeleteAddress4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_create_address_atomic(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_length) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CreateAddressAtomicRF;

    class Ifmgr01CreateAddressAtomicCB {
        Ifmgr01CreateAddressAtomicRF cb;

    public:
        operator const Ifmgr01CreateAddressAtomicRF& () const { return cb; }
        const Ifmgr01CreateAddressAtomicRF& operator ->() const { return cb; }
        Ifmgr01CreateAddressAtomicCB(const Ifmgr01CreateAddressAtomicRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CreateAddressAtomicRsp :
      public Ifmgr01CreateAddressAtomicCB {
        Ifmgr01CreateAddressAtomicRsp(const Ifmgr01CreateAddressAtomicRF& cb)
          : Ifmgr01CreateAddressAtomicCB(cb) { }

    };

    virtual void async_ifmgr_0_1_create_address_atomic
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_length,
	Ifmgr01CreateAddressAtomicCB);
#endif

    virtual XrlCmdError ifmgr_0_1_delete_address_atomic(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01DeleteAddressAtomicRF;

    class Ifmgr01DeleteAddressAtomicCB {
        Ifmgr01DeleteAddressAtomicRF cb;

    public:
        operator const Ifmgr01DeleteAddressAtomicRF& () const { return cb; }
        const Ifmgr01DeleteAddressAtomicRF& operator ->() const { return cb; }
        Ifmgr01DeleteAddressAtomicCB(const Ifmgr01DeleteAddressAtomicRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01DeleteAddressAtomicRsp :
      public Ifmgr01DeleteAddressAtomicCB {
        Ifmgr01DeleteAddressAtomicRsp(const Ifmgr01DeleteAddressAtomicRF& cb)
          : Ifmgr01DeleteAddressAtomicCB(cb) { }

    };

    virtual void async_ifmgr_0_1_delete_address_atomic
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01DeleteAddressAtomicCB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_address_enabled4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetAddressEnabled4RF;

    class Ifmgr01SetAddressEnabled4CB {
        Ifmgr01SetAddressEnabled4RF cb;

    public:
        operator const Ifmgr01SetAddressEnabled4RF& () const { return cb; }
        const Ifmgr01SetAddressEnabled4RF& operator ->() const { return cb; }
        Ifmgr01SetAddressEnabled4CB(const Ifmgr01SetAddressEnabled4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetAddressEnabled4Rsp :
      public Ifmgr01SetAddressEnabled4CB {
        Ifmgr01SetAddressEnabled4Rsp(const Ifmgr01SetAddressEnabled4RF& cb)
          : Ifmgr01SetAddressEnabled4CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_address_enabled4
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const bool&	enabled,
	Ifmgr01SetAddressEnabled4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_address_enabled4(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredAddressEnabled4RF;

    class Ifmgr01GetConfiguredAddressEnabled4CB {
        Ifmgr01GetConfiguredAddressEnabled4RF cb;

    public:
        operator const Ifmgr01GetConfiguredAddressEnabled4RF& () const { return cb; }
        const Ifmgr01GetConfiguredAddressEnabled4RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredAddressEnabled4CB(const Ifmgr01GetConfiguredAddressEnabled4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Ifmgr01GetConfiguredAddressEnabled4Rsp :
      public Ifmgr01GetConfiguredAddressEnabled4CB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredAddressEnabled4Rsp(const Ifmgr01GetConfiguredAddressEnabled4RF& cb)
          : Ifmgr01GetConfiguredAddressEnabled4CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredAddressEnabled4CB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_address_enabled4
       (
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	Ifmgr01GetConfiguredAddressEnabled4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_prefix4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetPrefix4RF;

    class Ifmgr01SetPrefix4CB {
        Ifmgr01SetPrefix4RF cb;

    public:
        operator const Ifmgr01SetPrefix4RF& () const { return cb; }
        const Ifmgr01SetPrefix4RF& operator ->() const { return cb; }
        Ifmgr01SetPrefix4CB(const Ifmgr01SetPrefix4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetPrefix4Rsp :
      public Ifmgr01SetPrefix4CB {
        Ifmgr01SetPrefix4Rsp(const Ifmgr01SetPrefix4RF& cb)
          : Ifmgr01SetPrefix4CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_prefix4
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const uint32_t&	prefix_len,
	Ifmgr01SetPrefix4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_broadcast4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	broadcast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetBroadcast4RF;

    class Ifmgr01SetBroadcast4CB {
        Ifmgr01SetBroadcast4RF cb;

    public:
        operator const Ifmgr01SetBroadcast4RF& () const { return cb; }
        const Ifmgr01SetBroadcast4RF& operator ->() const { return cb; }
        Ifmgr01SetBroadcast4CB(const Ifmgr01SetBroadcast4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetBroadcast4Rsp :
      public Ifmgr01SetBroadcast4CB {
        Ifmgr01SetBroadcast4Rsp(const Ifmgr01SetBroadcast4RF& cb)
          : Ifmgr01SetBroadcast4CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_broadcast4
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	broadcast,
	Ifmgr01SetBroadcast4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_endpoint4(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	endpoint) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetEndpoint4RF;

    class Ifmgr01SetEndpoint4CB {
        Ifmgr01SetEndpoint4RF cb;

    public:
        operator const Ifmgr01SetEndpoint4RF& () const { return cb; }
        const Ifmgr01SetEndpoint4RF& operator ->() const { return cb; }
        Ifmgr01SetEndpoint4CB(const Ifmgr01SetEndpoint4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetEndpoint4Rsp :
      public Ifmgr01SetEndpoint4CB {
        Ifmgr01SetEndpoint4Rsp(const Ifmgr01SetEndpoint4RF& cb)
          : Ifmgr01SetEndpoint4CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_endpoint4
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv4&	address,
	const IPv4&	endpoint,
	Ifmgr01SetEndpoint4CB);
#endif

    virtual XrlCmdError ifmgr_0_1_startup_ifmgr() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01StartupIfmgrRF;

    class Ifmgr01StartupIfmgrCB {
        Ifmgr01StartupIfmgrRF cb;

    public:
        operator const Ifmgr01StartupIfmgrRF& () const { return cb; }
        const Ifmgr01StartupIfmgrRF& operator ->() const { return cb; }
        Ifmgr01StartupIfmgrCB(const Ifmgr01StartupIfmgrRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01StartupIfmgrRsp :
      public Ifmgr01StartupIfmgrCB {
        Ifmgr01StartupIfmgrRsp(const Ifmgr01StartupIfmgrRF& cb)
          : Ifmgr01StartupIfmgrCB(cb) { }

    };

    virtual void async_ifmgr_0_1_startup_ifmgr
       (
	Ifmgr01StartupIfmgrCB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_vif_addresses6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	// Output values,
	XrlAtomList&	addresses) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ifmgr01GetConfiguredVifAddresses6RF;

    class Ifmgr01GetConfiguredVifAddresses6CB {
        Ifmgr01GetConfiguredVifAddresses6RF cb;

    public:
        operator const Ifmgr01GetConfiguredVifAddresses6RF& () const { return cb; }
        const Ifmgr01GetConfiguredVifAddresses6RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredVifAddresses6CB(const Ifmgr01GetConfiguredVifAddresses6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_addresses) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_addresses);
        }
    };

    struct Ifmgr01GetConfiguredVifAddresses6Rsp :
      public Ifmgr01GetConfiguredVifAddresses6CB {
        struct args_str {
            XrlAtomList addresses;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredVifAddresses6Rsp(const Ifmgr01GetConfiguredVifAddresses6RF& cb)
          : Ifmgr01GetConfiguredVifAddresses6CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredVifAddresses6CB::
            respond(args.addresses);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_vif_addresses6
       (
	const string&	ifname,
	const string&	vif,
	Ifmgr01GetConfiguredVifAddresses6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_address_flags6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	bool&	enabled,
	bool&	loopback,
	bool&	point_to_point,
	bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const bool*,
	const bool*,
	const bool*,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredAddressFlags6RF;

    class Ifmgr01GetConfiguredAddressFlags6CB {
        Ifmgr01GetConfiguredAddressFlags6RF cb;

    public:
        operator const Ifmgr01GetConfiguredAddressFlags6RF& () const { return cb; }
        const Ifmgr01GetConfiguredAddressFlags6RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredAddressFlags6CB(const Ifmgr01GetConfiguredAddressFlags6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const bool& arg_enabled,
                     const bool& arg_loopback,
                     const bool& arg_point_to_point,
                     const bool& arg_multicast) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled,
                         &arg_loopback,
                         &arg_point_to_point,
                         &arg_multicast);
        }
    };

    struct Ifmgr01GetConfiguredAddressFlags6Rsp :
      public Ifmgr01GetConfiguredAddressFlags6CB {
        struct args_str {
            bool enabled;
            bool loopback;
            bool point_to_point;
            bool multicast;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredAddressFlags6Rsp(const Ifmgr01GetConfiguredAddressFlags6RF& cb)
          : Ifmgr01GetConfiguredAddressFlags6CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredAddressFlags6CB::
            respond(args.enabled,
                        args.loopback,
                        args.point_to_point,
                        args.multicast);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_address_flags6
       (
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	Ifmgr01GetConfiguredAddressFlags6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_prefix6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ifmgr01GetConfiguredPrefix6RF;

    class Ifmgr01GetConfiguredPrefix6CB {
        Ifmgr01GetConfiguredPrefix6RF cb;

    public:
        operator const Ifmgr01GetConfiguredPrefix6RF& () const { return cb; }
        const Ifmgr01GetConfiguredPrefix6RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredPrefix6CB(const Ifmgr01GetConfiguredPrefix6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_prefix_len) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_prefix_len);
        }
    };

    struct Ifmgr01GetConfiguredPrefix6Rsp :
      public Ifmgr01GetConfiguredPrefix6CB {
        struct args_str {
            uint32_t prefix_len;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredPrefix6Rsp(const Ifmgr01GetConfiguredPrefix6RF& cb)
          : Ifmgr01GetConfiguredPrefix6CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredPrefix6CB::
            respond(args.prefix_len);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_prefix6
       (
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	Ifmgr01GetConfiguredPrefix6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_endpoint6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	IPv6&	endpoint) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv6*>::RefPtr
    Ifmgr01GetConfiguredEndpoint6RF;

    class Ifmgr01GetConfiguredEndpoint6CB {
        Ifmgr01GetConfiguredEndpoint6RF cb;

    public:
        operator const Ifmgr01GetConfiguredEndpoint6RF& () const { return cb; }
        const Ifmgr01GetConfiguredEndpoint6RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredEndpoint6CB(const Ifmgr01GetConfiguredEndpoint6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv6& arg_endpoint) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_endpoint);
        }
    };

    struct Ifmgr01GetConfiguredEndpoint6Rsp :
      public Ifmgr01GetConfiguredEndpoint6CB {
        struct args_str {
            IPv6 endpoint;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredEndpoint6Rsp(const Ifmgr01GetConfiguredEndpoint6RF& cb)
          : Ifmgr01GetConfiguredEndpoint6CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredEndpoint6CB::
            respond(args.endpoint);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_endpoint6
       (
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	Ifmgr01GetConfiguredEndpoint6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_create_address6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01CreateAddress6RF;

    class Ifmgr01CreateAddress6CB {
        Ifmgr01CreateAddress6RF cb;

    public:
        operator const Ifmgr01CreateAddress6RF& () const { return cb; }
        const Ifmgr01CreateAddress6RF& operator ->() const { return cb; }
        Ifmgr01CreateAddress6CB(const Ifmgr01CreateAddress6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01CreateAddress6Rsp :
      public Ifmgr01CreateAddress6CB {
        Ifmgr01CreateAddress6Rsp(const Ifmgr01CreateAddress6RF& cb)
          : Ifmgr01CreateAddress6CB(cb) { }

    };

    virtual void async_ifmgr_0_1_create_address6
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	Ifmgr01CreateAddress6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_delete_address6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01DeleteAddress6RF;

    class Ifmgr01DeleteAddress6CB {
        Ifmgr01DeleteAddress6RF cb;

    public:
        operator const Ifmgr01DeleteAddress6RF& () const { return cb; }
        const Ifmgr01DeleteAddress6RF& operator ->() const { return cb; }
        Ifmgr01DeleteAddress6CB(const Ifmgr01DeleteAddress6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01DeleteAddress6Rsp :
      public Ifmgr01DeleteAddress6CB {
        Ifmgr01DeleteAddress6Rsp(const Ifmgr01DeleteAddress6RF& cb)
          : Ifmgr01DeleteAddress6CB(cb) { }

    };

    virtual void async_ifmgr_0_1_delete_address6
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	Ifmgr01DeleteAddress6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_address_enabled6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetAddressEnabled6RF;

    class Ifmgr01SetAddressEnabled6CB {
        Ifmgr01SetAddressEnabled6RF cb;

    public:
        operator const Ifmgr01SetAddressEnabled6RF& () const { return cb; }
        const Ifmgr01SetAddressEnabled6RF& operator ->() const { return cb; }
        Ifmgr01SetAddressEnabled6CB(const Ifmgr01SetAddressEnabled6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetAddressEnabled6Rsp :
      public Ifmgr01SetAddressEnabled6CB {
        Ifmgr01SetAddressEnabled6Rsp(const Ifmgr01SetAddressEnabled6RF& cb)
          : Ifmgr01SetAddressEnabled6CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_address_enabled6
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const bool&	enabled,
	Ifmgr01SetAddressEnabled6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_get_configured_address_enabled6(
	// Input values,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ifmgr01GetConfiguredAddressEnabled6RF;

    class Ifmgr01GetConfiguredAddressEnabled6CB {
        Ifmgr01GetConfiguredAddressEnabled6RF cb;

    public:
        operator const Ifmgr01GetConfiguredAddressEnabled6RF& () const { return cb; }
        const Ifmgr01GetConfiguredAddressEnabled6RF& operator ->() const { return cb; }
        Ifmgr01GetConfiguredAddressEnabled6CB(const Ifmgr01GetConfiguredAddressEnabled6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Ifmgr01GetConfiguredAddressEnabled6Rsp :
      public Ifmgr01GetConfiguredAddressEnabled6CB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Ifmgr01GetConfiguredAddressEnabled6Rsp(const Ifmgr01GetConfiguredAddressEnabled6RF& cb)
          : Ifmgr01GetConfiguredAddressEnabled6CB(cb) { }

        void respond() const {
            Ifmgr01GetConfiguredAddressEnabled6CB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ifmgr_0_1_get_configured_address_enabled6
       (
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	Ifmgr01GetConfiguredAddressEnabled6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_prefix6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetPrefix6RF;

    class Ifmgr01SetPrefix6CB {
        Ifmgr01SetPrefix6RF cb;

    public:
        operator const Ifmgr01SetPrefix6RF& () const { return cb; }
        const Ifmgr01SetPrefix6RF& operator ->() const { return cb; }
        Ifmgr01SetPrefix6CB(const Ifmgr01SetPrefix6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetPrefix6Rsp :
      public Ifmgr01SetPrefix6CB {
        Ifmgr01SetPrefix6Rsp(const Ifmgr01SetPrefix6RF& cb)
          : Ifmgr01SetPrefix6CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_prefix6
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const uint32_t&	prefix_len,
	Ifmgr01SetPrefix6CB);
#endif

    virtual XrlCmdError ifmgr_0_1_set_endpoint6(
	// Input values,
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const IPv6&	endpoint) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ifmgr01SetEndpoint6RF;

    class Ifmgr01SetEndpoint6CB {
        Ifmgr01SetEndpoint6RF cb;

    public:
        operator const Ifmgr01SetEndpoint6RF& () const { return cb; }
        const Ifmgr01SetEndpoint6RF& operator ->() const { return cb; }
        Ifmgr01SetEndpoint6CB(const Ifmgr01SetEndpoint6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ifmgr01SetEndpoint6Rsp :
      public Ifmgr01SetEndpoint6CB {
        Ifmgr01SetEndpoint6Rsp(const Ifmgr01SetEndpoint6RF& cb)
          : Ifmgr01SetEndpoint6CB(cb) { }

    };

    virtual void async_ifmgr_0_1_set_endpoint6
       (
	const uint32_t&	tid,
	const string&	ifname,
	const string&	vif,
	const IPv6&	address,
	const IPv6&	endpoint,
	Ifmgr01SetEndpoint6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register remote mirror of interface state.
     */
    virtual XrlCmdError ifmgr_replicator_0_1_register_ifmgr_mirror(
	// Input values,
	const string&	clientname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    IfmgrReplicator01RegisterIfmgrMirrorRF;

    class IfmgrReplicator01RegisterIfmgrMirrorCB {
        IfmgrReplicator01RegisterIfmgrMirrorRF cb;

    public:
        operator const IfmgrReplicator01RegisterIfmgrMirrorRF& () const { return cb; }
        const IfmgrReplicator01RegisterIfmgrMirrorRF& operator ->() const { return cb; }
        IfmgrReplicator01RegisterIfmgrMirrorCB(const IfmgrReplicator01RegisterIfmgrMirrorRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct IfmgrReplicator01RegisterIfmgrMirrorRsp :
      public IfmgrReplicator01RegisterIfmgrMirrorCB {
        IfmgrReplicator01RegisterIfmgrMirrorRsp(const IfmgrReplicator01RegisterIfmgrMirrorRF& cb)
          : IfmgrReplicator01RegisterIfmgrMirrorCB(cb) { }

    };

    virtual void async_ifmgr_replicator_0_1_register_ifmgr_mirror
       (
	const string&	clientname,
	IfmgrReplicator01RegisterIfmgrMirrorCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register remote mirror of interface state.
     */
    virtual XrlCmdError ifmgr_replicator_0_1_unregister_ifmgr_mirror(
	// Input values,
	const string&	clientname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    IfmgrReplicator01UnregisterIfmgrMirrorRF;

    class IfmgrReplicator01UnregisterIfmgrMirrorCB {
        IfmgrReplicator01UnregisterIfmgrMirrorRF cb;

    public:
        operator const IfmgrReplicator01UnregisterIfmgrMirrorRF& () const { return cb; }
        const IfmgrReplicator01UnregisterIfmgrMirrorRF& operator ->() const { return cb; }
        IfmgrReplicator01UnregisterIfmgrMirrorCB(const IfmgrReplicator01UnregisterIfmgrMirrorRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct IfmgrReplicator01UnregisterIfmgrMirrorRsp :
      public IfmgrReplicator01UnregisterIfmgrMirrorCB {
        IfmgrReplicator01UnregisterIfmgrMirrorRsp(const IfmgrReplicator01UnregisterIfmgrMirrorRF& cb)
          : IfmgrReplicator01UnregisterIfmgrMirrorCB(cb) { }

    };

    virtual void async_ifmgr_replicator_0_1_unregister_ifmgr_mirror
       (
	const string&	clientname,
	IfmgrReplicator01UnregisterIfmgrMirrorCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination host address.
     *
     *  @param dst the destination host address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_dest4(
	// Input values,
	const IPv4&	dst,
	// Output values,
	IPv4Net&	netmask,
	IPv4&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback8<void, const XrlCmdError &,
	const IPv4Net*,
	const IPv4*,
	const string*,
	const string*,
	const uint32_t*,
	const uint32_t*,
	const string*>::RefPtr
    Fti02LookupRouteByDest4RF;

    class Fti02LookupRouteByDest4CB {
        Fti02LookupRouteByDest4RF cb;

    public:
        operator const Fti02LookupRouteByDest4RF& () const { return cb; }
        const Fti02LookupRouteByDest4RF& operator ->() const { return cb; }
        Fti02LookupRouteByDest4CB(const Fti02LookupRouteByDest4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4Net& arg_netmask,
                     const IPv4& arg_nexthop,
                     const string& arg_ifname,
                     const string& arg_vifname,
                     const uint32_t& arg_metric,
                     const uint32_t& arg_admin_distance,
                     const string& arg_protocol_origin) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_netmask,
                         &arg_nexthop,
                         &arg_ifname,
                         &arg_vifname,
                         &arg_metric,
                         &arg_admin_distance,
                         &arg_protocol_origin);
        }
    };

    struct Fti02LookupRouteByDest4Rsp :
      public Fti02LookupRouteByDest4CB {
        struct args_str {
            IPv4Net netmask;
            IPv4 nexthop;
            string ifname;
            string vifname;
            uint32_t metric;
            uint32_t admin_distance;
            string protocol_origin;
        };

    private:
        args_str args;

    public:
        Fti02LookupRouteByDest4Rsp(const Fti02LookupRouteByDest4RF& cb)
          : Fti02LookupRouteByDest4CB(cb) { }

        void respond() const {
            Fti02LookupRouteByDest4CB::
            respond(args.netmask,
                        args.nexthop,
                        args.ifname,
                        args.vifname,
                        args.metric,
                        args.admin_distance,
                        args.protocol_origin);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_lookup_route_by_dest4
       (
	const IPv4&	dst,
	Fti02LookupRouteByDest4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination subnet address.
     *
     *  @param dst the destination subnet address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_network4(
	// Input values,
	const IPv4Net&	dst,
	// Output values,
	IPv4&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const IPv4*,
	const string*,
	const string*,
	const uint32_t*,
	const uint32_t*,
	const string*>::RefPtr
    Fti02LookupRouteByNetwork4RF;

    class Fti02LookupRouteByNetwork4CB {
        Fti02LookupRouteByNetwork4RF cb;

    public:
        operator const Fti02LookupRouteByNetwork4RF& () const { return cb; }
        const Fti02LookupRouteByNetwork4RF& operator ->() const { return cb; }
        Fti02LookupRouteByNetwork4CB(const Fti02LookupRouteByNetwork4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_nexthop,
                     const string& arg_ifname,
                     const string& arg_vifname,
                     const uint32_t& arg_metric,
                     const uint32_t& arg_admin_distance,
                     const string& arg_protocol_origin) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_nexthop,
                         &arg_ifname,
                         &arg_vifname,
                         &arg_metric,
                         &arg_admin_distance,
                         &arg_protocol_origin);
        }
    };

    struct Fti02LookupRouteByNetwork4Rsp :
      public Fti02LookupRouteByNetwork4CB {
        struct args_str {
            IPv4 nexthop;
            string ifname;
            string vifname;
            uint32_t metric;
            uint32_t admin_distance;
            string protocol_origin;
        };

    private:
        args_str args;

    public:
        Fti02LookupRouteByNetwork4Rsp(const Fti02LookupRouteByNetwork4RF& cb)
          : Fti02LookupRouteByNetwork4CB(cb) { }

        void respond() const {
            Fti02LookupRouteByNetwork4CB::
            respond(args.nexthop,
                        args.ifname,
                        args.vifname,
                        args.metric,
                        args.admin_distance,
                        args.protocol_origin);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_lookup_route_by_network4
       (
	const IPv4Net&	dst,
	Fti02LookupRouteByNetwork4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test if the underlying system supports IPv4.
     *
     *  @param result true if the underlying system supports IPv4, otherwise
     *  false.
     */
    virtual XrlCmdError fti_0_2_have_ipv4(
	// Output values,
	bool&	result) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Fti02HaveIpv4RF;

    class Fti02HaveIpv4CB {
        Fti02HaveIpv4RF cb;

    public:
        operator const Fti02HaveIpv4RF& () const { return cb; }
        const Fti02HaveIpv4RF& operator ->() const { return cb; }
        Fti02HaveIpv4CB(const Fti02HaveIpv4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_result) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_result);
        }
    };

    struct Fti02HaveIpv4Rsp :
      public Fti02HaveIpv4CB {
        struct args_str {
            bool result;
        };

    private:
        args_str args;

    public:
        Fti02HaveIpv4Rsp(const Fti02HaveIpv4RF& cb)
          : Fti02HaveIpv4CB(cb) { }

        void respond() const {
            Fti02HaveIpv4CB::
            respond(args.result);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_have_ipv4
       (
	Fti02HaveIpv4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test whether the IPv4 unicast forwarding engine is enabled or disabled
     *  to forward packets.
     *
     *  @param enabled if true, then the IPv4 unicast forwarding is enabled,
     *  otherwise is disabled.
     */
    virtual XrlCmdError fti_0_2_get_unicast_forwarding_enabled4(
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Fti02GetUnicastForwardingEnabled4RF;

    class Fti02GetUnicastForwardingEnabled4CB {
        Fti02GetUnicastForwardingEnabled4RF cb;

    public:
        operator const Fti02GetUnicastForwardingEnabled4RF& () const { return cb; }
        const Fti02GetUnicastForwardingEnabled4RF& operator ->() const { return cb; }
        Fti02GetUnicastForwardingEnabled4CB(const Fti02GetUnicastForwardingEnabled4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Fti02GetUnicastForwardingEnabled4Rsp :
      public Fti02GetUnicastForwardingEnabled4CB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Fti02GetUnicastForwardingEnabled4Rsp(const Fti02GetUnicastForwardingEnabled4RF& cb)
          : Fti02GetUnicastForwardingEnabled4CB(cb) { }

        void respond() const {
            Fti02GetUnicastForwardingEnabled4CB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_get_unicast_forwarding_enabled4
       (
	Fti02GetUnicastForwardingEnabled4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding engine to enable or disable forwarding
     *  of packets.
     *
     *  @param enabled if true, then enable IPv4 unicast forwarding, otherwise
     *  disable it.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_enabled4(
	// Input values,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingEnabled4RF;

    class Fti02SetUnicastForwardingEnabled4CB {
        Fti02SetUnicastForwardingEnabled4RF cb;

    public:
        operator const Fti02SetUnicastForwardingEnabled4RF& () const { return cb; }
        const Fti02SetUnicastForwardingEnabled4RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingEnabled4CB(const Fti02SetUnicastForwardingEnabled4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingEnabled4Rsp :
      public Fti02SetUnicastForwardingEnabled4CB {
        Fti02SetUnicastForwardingEnabled4Rsp(const Fti02SetUnicastForwardingEnabled4RF& cb)
          : Fti02SetUnicastForwardingEnabled4CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_enabled4
       (
	const bool&	enabled,
	Fti02SetUnicastForwardingEnabled4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on startup.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(
	// Input values,
	const bool&	retain) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingEntriesRetainOnStartup4RF;

    class Fti02SetUnicastForwardingEntriesRetainOnStartup4CB {
        Fti02SetUnicastForwardingEntriesRetainOnStartup4RF cb;

    public:
        operator const Fti02SetUnicastForwardingEntriesRetainOnStartup4RF& () const { return cb; }
        const Fti02SetUnicastForwardingEntriesRetainOnStartup4RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingEntriesRetainOnStartup4CB(const Fti02SetUnicastForwardingEntriesRetainOnStartup4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingEntriesRetainOnStartup4Rsp :
      public Fti02SetUnicastForwardingEntriesRetainOnStartup4CB {
        Fti02SetUnicastForwardingEntriesRetainOnStartup4Rsp(const Fti02SetUnicastForwardingEntriesRetainOnStartup4RF& cb)
          : Fti02SetUnicastForwardingEntriesRetainOnStartup4CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4
       (
	const bool&	retain,
	Fti02SetUnicastForwardingEntriesRetainOnStartup4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on shutdown.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(
	// Input values,
	const bool&	retain) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF;

    class Fti02SetUnicastForwardingEntriesRetainOnShutdown4CB {
        Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF cb;

    public:
        operator const Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF& () const { return cb; }
        const Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingEntriesRetainOnShutdown4CB(const Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingEntriesRetainOnShutdown4Rsp :
      public Fti02SetUnicastForwardingEntriesRetainOnShutdown4CB {
        Fti02SetUnicastForwardingEntriesRetainOnShutdown4Rsp(const Fti02SetUnicastForwardingEntriesRetainOnShutdown4RF& cb)
          : Fti02SetUnicastForwardingEntriesRetainOnShutdown4CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4
       (
	const bool&	retain,
	Fti02SetUnicastForwardingEntriesRetainOnShutdown4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv4 unicast forwarding table ID to be used.
     *
     *  @param is_configured if true, the forwarding table ID is configured,
     *  otherwise the default table should be used.
     *
     *  @param table_id the IPv4 unicast forwarding table ID to be used.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_table_id4(
	// Input values,
	const bool&	is_configured,
	const uint32_t&	table_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingTableId4RF;

    class Fti02SetUnicastForwardingTableId4CB {
        Fti02SetUnicastForwardingTableId4RF cb;

    public:
        operator const Fti02SetUnicastForwardingTableId4RF& () const { return cb; }
        const Fti02SetUnicastForwardingTableId4RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingTableId4CB(const Fti02SetUnicastForwardingTableId4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingTableId4Rsp :
      public Fti02SetUnicastForwardingTableId4CB {
        Fti02SetUnicastForwardingTableId4Rsp(const Fti02SetUnicastForwardingTableId4RF& cb)
          : Fti02SetUnicastForwardingTableId4CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_table_id4
       (
	const bool&	is_configured,
	const uint32_t&	table_id,
	Fti02SetUnicastForwardingTableId4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination host address.
     *
     *  @param dst the destination host address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_dest6(
	// Input values,
	const IPv6&	dst,
	// Output values,
	IPv6Net&	netmask,
	IPv6&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback8<void, const XrlCmdError &,
	const IPv6Net*,
	const IPv6*,
	const string*,
	const string*,
	const uint32_t*,
	const uint32_t*,
	const string*>::RefPtr
    Fti02LookupRouteByDest6RF;

    class Fti02LookupRouteByDest6CB {
        Fti02LookupRouteByDest6RF cb;

    public:
        operator const Fti02LookupRouteByDest6RF& () const { return cb; }
        const Fti02LookupRouteByDest6RF& operator ->() const { return cb; }
        Fti02LookupRouteByDest6CB(const Fti02LookupRouteByDest6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv6Net& arg_netmask,
                     const IPv6& arg_nexthop,
                     const string& arg_ifname,
                     const string& arg_vifname,
                     const uint32_t& arg_metric,
                     const uint32_t& arg_admin_distance,
                     const string& arg_protocol_origin) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_netmask,
                         &arg_nexthop,
                         &arg_ifname,
                         &arg_vifname,
                         &arg_metric,
                         &arg_admin_distance,
                         &arg_protocol_origin);
        }
    };

    struct Fti02LookupRouteByDest6Rsp :
      public Fti02LookupRouteByDest6CB {
        struct args_str {
            IPv6Net netmask;
            IPv6 nexthop;
            string ifname;
            string vifname;
            uint32_t metric;
            uint32_t admin_distance;
            string protocol_origin;
        };

    private:
        args_str args;

    public:
        Fti02LookupRouteByDest6Rsp(const Fti02LookupRouteByDest6RF& cb)
          : Fti02LookupRouteByDest6CB(cb) { }

        void respond() const {
            Fti02LookupRouteByDest6CB::
            respond(args.netmask,
                        args.nexthop,
                        args.ifname,
                        args.vifname,
                        args.metric,
                        args.admin_distance,
                        args.protocol_origin);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_lookup_route_by_dest6
       (
	const IPv6&	dst,
	Fti02LookupRouteByDest6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Lookup a route for a destination subnet address.
     *
     *  @param dst the destination subnet address to lookup.
     *
     *  @param nexthop the address of the next-hop router toward dst.
     *
     *  @param ifname the name of the physical interface toward dst.
     *
     *  @param vifname the name of the virtual interface toward dst.
     *
     *  @param metric the routing metric toward dst.
     *
     *  @param admin_distance the administratively defined distance toward dst.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError fti_0_2_lookup_route_by_network6(
	// Input values,
	const IPv6Net&	dst,
	// Output values,
	IPv6&	nexthop,
	string&	ifname,
	string&	vifname,
	uint32_t&	metric,
	uint32_t&	admin_distance,
	string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const IPv6*,
	const string*,
	const string*,
	const uint32_t*,
	const uint32_t*,
	const string*>::RefPtr
    Fti02LookupRouteByNetwork6RF;

    class Fti02LookupRouteByNetwork6CB {
        Fti02LookupRouteByNetwork6RF cb;

    public:
        operator const Fti02LookupRouteByNetwork6RF& () const { return cb; }
        const Fti02LookupRouteByNetwork6RF& operator ->() const { return cb; }
        Fti02LookupRouteByNetwork6CB(const Fti02LookupRouteByNetwork6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv6& arg_nexthop,
                     const string& arg_ifname,
                     const string& arg_vifname,
                     const uint32_t& arg_metric,
                     const uint32_t& arg_admin_distance,
                     const string& arg_protocol_origin) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_nexthop,
                         &arg_ifname,
                         &arg_vifname,
                         &arg_metric,
                         &arg_admin_distance,
                         &arg_protocol_origin);
        }
    };

    struct Fti02LookupRouteByNetwork6Rsp :
      public Fti02LookupRouteByNetwork6CB {
        struct args_str {
            IPv6 nexthop;
            string ifname;
            string vifname;
            uint32_t metric;
            uint32_t admin_distance;
            string protocol_origin;
        };

    private:
        args_str args;

    public:
        Fti02LookupRouteByNetwork6Rsp(const Fti02LookupRouteByNetwork6RF& cb)
          : Fti02LookupRouteByNetwork6CB(cb) { }

        void respond() const {
            Fti02LookupRouteByNetwork6CB::
            respond(args.nexthop,
                        args.ifname,
                        args.vifname,
                        args.metric,
                        args.admin_distance,
                        args.protocol_origin);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_lookup_route_by_network6
       (
	const IPv6Net&	dst,
	Fti02LookupRouteByNetwork6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test if the underlying system supports IPv6.
     *
     *  @param result true if the underlying system supports IPv4, otherwise
     *  false.
     */
    virtual XrlCmdError fti_0_2_have_ipv6(
	// Output values,
	bool&	result) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Fti02HaveIpv6RF;

    class Fti02HaveIpv6CB {
        Fti02HaveIpv6RF cb;

    public:
        operator const Fti02HaveIpv6RF& () const { return cb; }
        const Fti02HaveIpv6RF& operator ->() const { return cb; }
        Fti02HaveIpv6CB(const Fti02HaveIpv6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_result) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_result);
        }
    };

    struct Fti02HaveIpv6Rsp :
      public Fti02HaveIpv6CB {
        struct args_str {
            bool result;
        };

    private:
        args_str args;

    public:
        Fti02HaveIpv6Rsp(const Fti02HaveIpv6RF& cb)
          : Fti02HaveIpv6CB(cb) { }

        void respond() const {
            Fti02HaveIpv6CB::
            respond(args.result);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_have_ipv6
       (
	Fti02HaveIpv6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Test whether the IPv6 unicast forwarding engine is enabled or disabled
     *  to forward packets.
     *
     *  @param enabled if true, then the IPv6 unicast forwarding is enabled,
     *  otherwise is disabled.
     */
    virtual XrlCmdError fti_0_2_get_unicast_forwarding_enabled6(
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Fti02GetUnicastForwardingEnabled6RF;

    class Fti02GetUnicastForwardingEnabled6CB {
        Fti02GetUnicastForwardingEnabled6RF cb;

    public:
        operator const Fti02GetUnicastForwardingEnabled6RF& () const { return cb; }
        const Fti02GetUnicastForwardingEnabled6RF& operator ->() const { return cb; }
        Fti02GetUnicastForwardingEnabled6CB(const Fti02GetUnicastForwardingEnabled6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Fti02GetUnicastForwardingEnabled6Rsp :
      public Fti02GetUnicastForwardingEnabled6CB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Fti02GetUnicastForwardingEnabled6Rsp(const Fti02GetUnicastForwardingEnabled6RF& cb)
          : Fti02GetUnicastForwardingEnabled6CB(cb) { }

        void respond() const {
            Fti02GetUnicastForwardingEnabled6CB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_fti_0_2_get_unicast_forwarding_enabled6
       (
	Fti02GetUnicastForwardingEnabled6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding engine to enable or disable forwarding
     *  of packets.
     *
     *  @param enabled if true, then enable IPv6 unicast forwarding, otherwise
     *  disable it.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_enabled6(
	// Input values,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingEnabled6RF;

    class Fti02SetUnicastForwardingEnabled6CB {
        Fti02SetUnicastForwardingEnabled6RF cb;

    public:
        operator const Fti02SetUnicastForwardingEnabled6RF& () const { return cb; }
        const Fti02SetUnicastForwardingEnabled6RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingEnabled6CB(const Fti02SetUnicastForwardingEnabled6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingEnabled6Rsp :
      public Fti02SetUnicastForwardingEnabled6CB {
        Fti02SetUnicastForwardingEnabled6Rsp(const Fti02SetUnicastForwardingEnabled6RF& cb)
          : Fti02SetUnicastForwardingEnabled6CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_enabled6
       (
	const bool&	enabled,
	Fti02SetUnicastForwardingEnabled6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on startup.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(
	// Input values,
	const bool&	retain) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingEntriesRetainOnStartup6RF;

    class Fti02SetUnicastForwardingEntriesRetainOnStartup6CB {
        Fti02SetUnicastForwardingEntriesRetainOnStartup6RF cb;

    public:
        operator const Fti02SetUnicastForwardingEntriesRetainOnStartup6RF& () const { return cb; }
        const Fti02SetUnicastForwardingEntriesRetainOnStartup6RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingEntriesRetainOnStartup6CB(const Fti02SetUnicastForwardingEntriesRetainOnStartup6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingEntriesRetainOnStartup6Rsp :
      public Fti02SetUnicastForwardingEntriesRetainOnStartup6CB {
        Fti02SetUnicastForwardingEntriesRetainOnStartup6Rsp(const Fti02SetUnicastForwardingEntriesRetainOnStartup6RF& cb)
          : Fti02SetUnicastForwardingEntriesRetainOnStartup6CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6
       (
	const bool&	retain,
	Fti02SetUnicastForwardingEntriesRetainOnStartup6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding engine whether to retain existing XORP
     *  forwarding entries on shutdown.
     *
     *  @param retain if true, then retain the XORP forwarding entries,
     *  otherwise delete them.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(
	// Input values,
	const bool&	retain) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF;

    class Fti02SetUnicastForwardingEntriesRetainOnShutdown6CB {
        Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF cb;

    public:
        operator const Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF& () const { return cb; }
        const Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingEntriesRetainOnShutdown6CB(const Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingEntriesRetainOnShutdown6Rsp :
      public Fti02SetUnicastForwardingEntriesRetainOnShutdown6CB {
        Fti02SetUnicastForwardingEntriesRetainOnShutdown6Rsp(const Fti02SetUnicastForwardingEntriesRetainOnShutdown6RF& cb)
          : Fti02SetUnicastForwardingEntriesRetainOnShutdown6CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6
       (
	const bool&	retain,
	Fti02SetUnicastForwardingEntriesRetainOnShutdown6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 unicast forwarding table ID to be used.
     *
     *  @param is_configured if true, the forwarding table ID is configured,
     *  otherwise the default table should be used.
     *
     *  @param table_id the IPv6 unicast forwarding table ID to be used.
     */
    virtual XrlCmdError fti_0_2_set_unicast_forwarding_table_id6(
	// Input values,
	const bool&	is_configured,
	const uint32_t&	table_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Fti02SetUnicastForwardingTableId6RF;

    class Fti02SetUnicastForwardingTableId6CB {
        Fti02SetUnicastForwardingTableId6RF cb;

    public:
        operator const Fti02SetUnicastForwardingTableId6RF& () const { return cb; }
        const Fti02SetUnicastForwardingTableId6RF& operator ->() const { return cb; }
        Fti02SetUnicastForwardingTableId6CB(const Fti02SetUnicastForwardingTableId6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Fti02SetUnicastForwardingTableId6Rsp :
      public Fti02SetUnicastForwardingTableId6CB {
        Fti02SetUnicastForwardingTableId6Rsp(const Fti02SetUnicastForwardingTableId6RF& cb)
          : Fti02SetUnicastForwardingTableId6CB(cb) { }

    };

    virtual void async_fti_0_2_set_unicast_forwarding_table_id6
       (
	const bool&	is_configured,
	const uint32_t&	table_id,
	Fti02SetUnicastForwardingTableId6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start transaction.
     *
     *  @param tid the transaction ID to use for this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    RedistTransaction401StartTransactionRF;

    class RedistTransaction401StartTransactionCB {
        RedistTransaction401StartTransactionRF cb;

    public:
        operator const RedistTransaction401StartTransactionRF& () const { return cb; }
        const RedistTransaction401StartTransactionRF& operator ->() const { return cb; }
        RedistTransaction401StartTransactionCB(const RedistTransaction401StartTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_tid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tid);
        }
    };

    struct RedistTransaction401StartTransactionRsp :
      public RedistTransaction401StartTransactionCB {
        struct args_str {
            uint32_t tid;
        };

    private:
        args_str args;

    public:
        RedistTransaction401StartTransactionRsp(const RedistTransaction401StartTransactionRF& cb)
          : RedistTransaction401StartTransactionCB(cb) { }

        void respond() const {
            RedistTransaction401StartTransactionCB::
            respond(args.tid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_redist_transaction4_0_1_start_transaction
       (
	RedistTransaction401StartTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401CommitTransactionRF;

    class RedistTransaction401CommitTransactionCB {
        RedistTransaction401CommitTransactionRF cb;

    public:
        operator const RedistTransaction401CommitTransactionRF& () const { return cb; }
        const RedistTransaction401CommitTransactionRF& operator ->() const { return cb; }
        RedistTransaction401CommitTransactionCB(const RedistTransaction401CommitTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401CommitTransactionRsp :
      public RedistTransaction401CommitTransactionCB {
        RedistTransaction401CommitTransactionRsp(const RedistTransaction401CommitTransactionRF& cb)
          : RedistTransaction401CommitTransactionCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_commit_transaction
       (
	const uint32_t&	tid,
	RedistTransaction401CommitTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction4_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401AbortTransactionRF;

    class RedistTransaction401AbortTransactionCB {
        RedistTransaction401AbortTransactionRF cb;

    public:
        operator const RedistTransaction401AbortTransactionRF& () const { return cb; }
        const RedistTransaction401AbortTransactionRF& operator ->() const { return cb; }
        RedistTransaction401AbortTransactionCB(const RedistTransaction401AbortTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401AbortTransactionRsp :
      public RedistTransaction401AbortTransactionCB {
        RedistTransaction401AbortTransactionRsp(const RedistTransaction401AbortTransactionRF& cb)
          : RedistTransaction401AbortTransactionCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_abort_transaction
       (
	const uint32_t&	tid,
	RedistTransaction401AbortTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete a routing entry.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param dst destination network.
     *
     *  @param nexthop nexthop router address.
     *
     *  @param ifname interface name associated with nexthop.
     *
     *  @param vifname virtual interface name with nexthop.
     *
     *  @param metric origin routing protocol metric for route.
     *
     *  @param admin_distance administrative distance of origin routing
     *  protocol.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError redist_transaction4_0_1_add_route(
	// Input values,
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401AddRouteRF;

    class RedistTransaction401AddRouteCB {
        RedistTransaction401AddRouteRF cb;

    public:
        operator const RedistTransaction401AddRouteRF& () const { return cb; }
        const RedistTransaction401AddRouteRF& operator ->() const { return cb; }
        RedistTransaction401AddRouteCB(const RedistTransaction401AddRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401AddRouteRsp :
      public RedistTransaction401AddRouteCB {
        RedistTransaction401AddRouteRsp(const RedistTransaction401AddRouteRF& cb)
          : RedistTransaction401AddRouteCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_add_route
       (
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction401AddRouteCB);
#endif

    virtual XrlCmdError redist_transaction4_0_1_delete_route(
	// Input values,
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401DeleteRouteRF;

    class RedistTransaction401DeleteRouteCB {
        RedistTransaction401DeleteRouteRF cb;

    public:
        operator const RedistTransaction401DeleteRouteRF& () const { return cb; }
        const RedistTransaction401DeleteRouteRF& operator ->() const { return cb; }
        RedistTransaction401DeleteRouteCB(const RedistTransaction401DeleteRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401DeleteRouteRsp :
      public RedistTransaction401DeleteRouteCB {
        RedistTransaction401DeleteRouteRsp(const RedistTransaction401DeleteRouteRF& cb)
          : RedistTransaction401DeleteRouteCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_delete_route
       (
	const uint32_t&	tid,
	const IPv4Net&	dst,
	const IPv4&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction401DeleteRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all routing entries.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     */
    virtual XrlCmdError redist_transaction4_0_1_delete_all_routes(
	// Input values,
	const uint32_t&	tid,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction401DeleteAllRoutesRF;

    class RedistTransaction401DeleteAllRoutesCB {
        RedistTransaction401DeleteAllRoutesRF cb;

    public:
        operator const RedistTransaction401DeleteAllRoutesRF& () const { return cb; }
        const RedistTransaction401DeleteAllRoutesRF& operator ->() const { return cb; }
        RedistTransaction401DeleteAllRoutesCB(const RedistTransaction401DeleteAllRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction401DeleteAllRoutesRsp :
      public RedistTransaction401DeleteAllRoutesCB {
        RedistTransaction401DeleteAllRoutesRsp(const RedistTransaction401DeleteAllRoutesRF& cb)
          : RedistTransaction401DeleteAllRoutesCB(cb) { }

    };

    virtual void async_redist_transaction4_0_1_delete_all_routes
       (
	const uint32_t&	tid,
	const string&	cookie,
	RedistTransaction401DeleteAllRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send a raw link-level packet on an interface.
     *
     *  @param if_name the interface to send the packet on.
     *
     *  @param vif_name the vif to send the packet on.
     *
     *  @param src_address the MAC source address.
     *
     *  @param dst_address the MAC destination address.
     *
     *  @param ether_type the EtherType protocol type or the Destination SAP.
     *  It must be between 1536 and 65535 to specify the EtherType, or between
     *  1 and 255 to specify the Destination SAP IEEE 802.2 LLC frames.
     *
     *  @param payload the payload, everything after the MAC header.
     */
    virtual XrlCmdError raw_link_0_1_send(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const Mac&	src_address,
	const Mac&	dst_address,
	const uint32_t&	ether_type,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawLink01SendRF;

    class RawLink01SendCB {
        RawLink01SendRF cb;

    public:
        operator const RawLink01SendRF& () const { return cb; }
        const RawLink01SendRF& operator ->() const { return cb; }
        RawLink01SendCB(const RawLink01SendRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawLink01SendRsp :
      public RawLink01SendCB {
        RawLink01SendRsp(const RawLink01SendRF& cb)
          : RawLink01SendCB(cb) { }

    };

    virtual void async_raw_link_0_1_send
       (
	const string&	if_name,
	const string&	vif_name,
	const Mac&	src_address,
	const Mac&	dst_address,
	const uint32_t&	ether_type,
	const vector<uint8_t>&	payload,
	RawLink01SendCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register to receive raw link-level packets. The receiver is expected to
     *  support raw_link_client/0.1 interface.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ether_type the EtherType protocol number or the Destination SAP
     *  that the receiver is interested in. It must be between 1536 and 65535
     *  to specify the EtherType, or between 1 and 255 to specify the
     *  Destination SAP for IEEE 802.2 LLC frames. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param filter_program the optional filter program to be applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     *
     *  @param enable_multicast_loopback if true then enable delivering of
     *  multicast datagrams back to this host (assuming the host is a member of
     *  the same multicast group).
     */
    virtual XrlCmdError raw_link_0_1_register_receiver(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const bool&	enable_multicast_loopback) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawLink01RegisterReceiverRF;

    class RawLink01RegisterReceiverCB {
        RawLink01RegisterReceiverRF cb;

    public:
        operator const RawLink01RegisterReceiverRF& () const { return cb; }
        const RawLink01RegisterReceiverRF& operator ->() const { return cb; }
        RawLink01RegisterReceiverCB(const RawLink01RegisterReceiverRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawLink01RegisterReceiverRsp :
      public RawLink01RegisterReceiverCB {
        RawLink01RegisterReceiverRsp(const RawLink01RegisterReceiverRF& cb)
          : RawLink01RegisterReceiverCB(cb) { }

    };

    virtual void async_raw_link_0_1_register_receiver
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const bool&	enable_multicast_loopback,
	RawLink01RegisterReceiverCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unregister to receive raw link-level packets.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ether_type the EtherType protocol number or the Destination SAP
     *  that the receiver is not interested in anymore. It must be between 1536
     *  and 65535 to specify the EtherType, or between 1 and 255 to specify the
     *  Destination SAP for IEEE 802.2 LLC frames. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param filter_program the filter program that was applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     */
    virtual XrlCmdError raw_link_0_1_unregister_receiver(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawLink01UnregisterReceiverRF;

    class RawLink01UnregisterReceiverCB {
        RawLink01UnregisterReceiverRF cb;

    public:
        operator const RawLink01UnregisterReceiverRF& () const { return cb; }
        const RawLink01UnregisterReceiverRF& operator ->() const { return cb; }
        RawLink01UnregisterReceiverCB(const RawLink01UnregisterReceiverRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawLink01UnregisterReceiverRsp :
      public RawLink01UnregisterReceiverCB {
        RawLink01UnregisterReceiverRsp(const RawLink01UnregisterReceiverRF& cb)
          : RawLink01UnregisterReceiverCB(cb) { }

    };

    virtual void async_raw_link_0_1_unregister_receiver
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	RawLink01UnregisterReceiverCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join a MAC multicast group.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ether_type the EtherType protocol number or the Destination SAP
     *  that the receiver is interested in. It must be between 1536 and 65535
     *  to specify the EtherType, or between 1 and 255 to specify the
     *  Destination SAP for IEEE 802.2 LLC frames. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param filter_program the optional filter program to be applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     *
     *  @param group_address the multicast group address to join.
     */
    virtual XrlCmdError raw_link_0_1_join_multicast_group(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const Mac&	group_address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawLink01JoinMulticastGroupRF;

    class RawLink01JoinMulticastGroupCB {
        RawLink01JoinMulticastGroupRF cb;

    public:
        operator const RawLink01JoinMulticastGroupRF& () const { return cb; }
        const RawLink01JoinMulticastGroupRF& operator ->() const { return cb; }
        RawLink01JoinMulticastGroupCB(const RawLink01JoinMulticastGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawLink01JoinMulticastGroupRsp :
      public RawLink01JoinMulticastGroupCB {
        RawLink01JoinMulticastGroupRsp(const RawLink01JoinMulticastGroupRF& cb)
          : RawLink01JoinMulticastGroupCB(cb) { }

    };

    virtual void async_raw_link_0_1_join_multicast_group
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const Mac&	group_address,
	RawLink01JoinMulticastGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave a MAC multicast group.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ether_type the EtherType protocol number or the Destination SAP
     *  that the receiver is not interested in anymore. It must be between 1536
     *  and 65535 to specify the EtherType, or between 1 and 255 to specify the
     *  Destination SAP for IEEE 802.2 LLC frames. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param filter_program the filter program that was applied on the
     *  received packets. The program uses tcpdump(1) style expression.
     *
     *  @param group_address the multicast group address to leave.
     */
    virtual XrlCmdError raw_link_0_1_leave_multicast_group(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const Mac&	group_address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawLink01LeaveMulticastGroupRF;

    class RawLink01LeaveMulticastGroupCB {
        RawLink01LeaveMulticastGroupRF cb;

    public:
        operator const RawLink01LeaveMulticastGroupRF& () const { return cb; }
        const RawLink01LeaveMulticastGroupRF& operator ->() const { return cb; }
        RawLink01LeaveMulticastGroupCB(const RawLink01LeaveMulticastGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawLink01LeaveMulticastGroupRsp :
      public RawLink01LeaveMulticastGroupCB {
        RawLink01LeaveMulticastGroupRsp(const RawLink01LeaveMulticastGroupRF& cb)
          : RawLink01LeaveMulticastGroupCB(cb) { }

    };

    virtual void async_raw_link_0_1_leave_multicast_group
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ether_type,
	const string&	filter_program,
	const Mac&	group_address,
	RawLink01LeaveMulticastGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send an IPv4 packet on a raw socket.
     *
     *  @param if_name the interface to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param vif_name the vif to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number. It must be between 1 and
     *  255.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, the
     *  TTL will be set internally before transmission.
     *
     *  @param ip_tos the Type Of Service (Diffserv/ECN bits for IPv4). If it
     *  has a negative value, the TOS will be set internally before
     *  transmission.
     *
     *  @param ip_router_alert if true, then add the IP Router Alert option to
     *  the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet4_0_1_send(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket401SendRF;

    class RawPacket401SendCB {
        RawPacket401SendRF cb;

    public:
        operator const RawPacket401SendRF& () const { return cb; }
        const RawPacket401SendRF& operator ->() const { return cb; }
        RawPacket401SendCB(const RawPacket401SendRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket401SendRsp :
      public RawPacket401SendCB {
        RawPacket401SendRsp(const RawPacket401SendRF& cb)
          : RawPacket401SendCB(cb) { }

    };

    virtual void async_raw_packet4_0_1_send
       (
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload,
	RawPacket401SendCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register to receive IPv4 packets. The receiver is expected to support
     *  raw_packet4_client/0.1 interface.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param enable_multicast_loopback if true then enable delivering of
     *  multicast datagrams back to this host (assuming the host is a member of
     *  the same multicast group.
     */
    virtual XrlCmdError raw_packet4_0_1_register_receiver(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const bool&	enable_multicast_loopback) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket401RegisterReceiverRF;

    class RawPacket401RegisterReceiverCB {
        RawPacket401RegisterReceiverRF cb;

    public:
        operator const RawPacket401RegisterReceiverRF& () const { return cb; }
        const RawPacket401RegisterReceiverRF& operator ->() const { return cb; }
        RawPacket401RegisterReceiverCB(const RawPacket401RegisterReceiverRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket401RegisterReceiverRsp :
      public RawPacket401RegisterReceiverCB {
        RawPacket401RegisterReceiverRsp(const RawPacket401RegisterReceiverRF& cb)
          : RawPacket401RegisterReceiverCB(cb) { }

    };

    virtual void async_raw_packet4_0_1_register_receiver
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const bool&	enable_multicast_loopback,
	RawPacket401RegisterReceiverCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unregister to receive IPv4 packets.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP Protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     */
    virtual XrlCmdError raw_packet4_0_1_unregister_receiver(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket401UnregisterReceiverRF;

    class RawPacket401UnregisterReceiverCB {
        RawPacket401UnregisterReceiverRF cb;

    public:
        operator const RawPacket401UnregisterReceiverRF& () const { return cb; }
        const RawPacket401UnregisterReceiverRF& operator ->() const { return cb; }
        RawPacket401UnregisterReceiverCB(const RawPacket401UnregisterReceiverRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket401UnregisterReceiverRsp :
      public RawPacket401UnregisterReceiverCB {
        RawPacket401UnregisterReceiverRsp(const RawPacket401UnregisterReceiverRF& cb)
          : RawPacket401UnregisterReceiverCB(cb) { }

    };

    virtual void async_raw_packet4_0_1_unregister_receiver
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	RawPacket401UnregisterReceiverCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join an IPv4 multicast group.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param group_address the multicast group address to join.
     */
    virtual XrlCmdError raw_packet4_0_1_join_multicast_group(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv4&	group_address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket401JoinMulticastGroupRF;

    class RawPacket401JoinMulticastGroupCB {
        RawPacket401JoinMulticastGroupRF cb;

    public:
        operator const RawPacket401JoinMulticastGroupRF& () const { return cb; }
        const RawPacket401JoinMulticastGroupRF& operator ->() const { return cb; }
        RawPacket401JoinMulticastGroupCB(const RawPacket401JoinMulticastGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket401JoinMulticastGroupRsp :
      public RawPacket401JoinMulticastGroupCB {
        RawPacket401JoinMulticastGroupRsp(const RawPacket401JoinMulticastGroupRF& cb)
          : RawPacket401JoinMulticastGroupCB(cb) { }

    };

    virtual void async_raw_packet4_0_1_join_multicast_group
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv4&	group_address,
	RawPacket401JoinMulticastGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave an IPv4 multicast group.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     *
     *  @param group_address the multicast group address to leave.
     */
    virtual XrlCmdError raw_packet4_0_1_leave_multicast_group(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv4&	group_address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket401LeaveMulticastGroupRF;

    class RawPacket401LeaveMulticastGroupCB {
        RawPacket401LeaveMulticastGroupRF cb;

    public:
        operator const RawPacket401LeaveMulticastGroupRF& () const { return cb; }
        const RawPacket401LeaveMulticastGroupRF& operator ->() const { return cb; }
        RawPacket401LeaveMulticastGroupCB(const RawPacket401LeaveMulticastGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket401LeaveMulticastGroupRsp :
      public RawPacket401LeaveMulticastGroupCB {
        RawPacket401LeaveMulticastGroupRsp(const RawPacket401LeaveMulticastGroupRF& cb)
          : RawPacket401LeaveMulticastGroupCB(cb) { }

    };

    virtual void async_raw_packet4_0_1_leave_multicast_group
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv4&	group_address,
	RawPacket401LeaveMulticastGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open a TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_tcp_open(
	// Input values,
	const string&	creator,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401TcpOpenRF;

    class Socket401TcpOpenCB {
        Socket401TcpOpenRF cb;

    public:
        operator const Socket401TcpOpenRF& () const { return cb; }
        const Socket401TcpOpenRF& operator ->() const { return cb; }
        Socket401TcpOpenCB(const Socket401TcpOpenRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401TcpOpenRsp :
      public Socket401TcpOpenCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401TcpOpenRsp(const Socket401TcpOpenRF& cb)
          : Socket401TcpOpenCB(cb) { }

        void respond() const {
            Socket401TcpOpenCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_tcp_open
       (
	const string&	creator,
	Socket401TcpOpenCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open an UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open(
	// Input values,
	const string&	creator,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401UdpOpenRF;

    class Socket401UdpOpenCB {
        Socket401UdpOpenRF cb;

    public:
        operator const Socket401UdpOpenRF& () const { return cb; }
        const Socket401UdpOpenRF& operator ->() const { return cb; }
        Socket401UdpOpenCB(const Socket401UdpOpenRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401UdpOpenRsp :
      public Socket401UdpOpenCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401UdpOpenRsp(const Socket401UdpOpenRF& cb)
          : Socket401UdpOpenCB(cb) { }

        void respond() const {
            Socket401UdpOpenCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_udp_open
       (
	const string&	creator,
	Socket401UdpOpenCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_tcp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401TcpOpenAndBindRF;

    class Socket401TcpOpenAndBindCB {
        Socket401TcpOpenAndBindRF cb;

    public:
        operator const Socket401TcpOpenAndBindRF& () const { return cb; }
        const Socket401TcpOpenAndBindRF& operator ->() const { return cb; }
        Socket401TcpOpenAndBindCB(const Socket401TcpOpenAndBindRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401TcpOpenAndBindRsp :
      public Socket401TcpOpenAndBindCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401TcpOpenAndBindRsp(const Socket401TcpOpenAndBindRF& cb)
          : Socket401TcpOpenAndBindCB(cb) { }

        void respond() const {
            Socket401TcpOpenAndBindCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_tcp_open_and_bind
       (
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	Socket401TcpOpenAndBindCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const string&	local_dev,
	const uint32_t&	reuse,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401UdpOpenAndBindRF;

    class Socket401UdpOpenAndBindCB {
        Socket401UdpOpenAndBindRF cb;

    public:
        operator const Socket401UdpOpenAndBindRF& () const { return cb; }
        const Socket401UdpOpenAndBindRF& operator ->() const { return cb; }
        Socket401UdpOpenAndBindCB(const Socket401UdpOpenAndBindRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401UdpOpenAndBindRsp :
      public Socket401UdpOpenAndBindCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401UdpOpenAndBindRsp(const Socket401UdpOpenAndBindRF& cb)
          : Socket401UdpOpenAndBindCB(cb) { }

        void respond() const {
            Socket401UdpOpenAndBindCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_udp_open_and_bind
       (
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const string&	local_dev,
	const uint32_t&	reuse,
	Socket401UdpOpenAndBindCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP multicast socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param mcast_addr the multicast group address to join.
     *
     *  @param ttl the TTL to use for this multicast socket.
     *
     *  @param reuse allow other sockets to bind to same multicast group.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_bind_join(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401UdpOpenBindJoinRF;

    class Socket401UdpOpenBindJoinCB {
        Socket401UdpOpenBindJoinRF cb;

    public:
        operator const Socket401UdpOpenBindJoinRF& () const { return cb; }
        const Socket401UdpOpenBindJoinRF& operator ->() const { return cb; }
        Socket401UdpOpenBindJoinCB(const Socket401UdpOpenBindJoinRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401UdpOpenBindJoinRsp :
      public Socket401UdpOpenBindJoinCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401UdpOpenBindJoinRsp(const Socket401UdpOpenBindJoinRF& cb)
          : Socket401UdpOpenBindJoinCB(cb) { }

        void respond() const {
            Socket401UdpOpenBindJoinCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_udp_open_bind_join
       (
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	Socket401UdpOpenBindJoinCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_tcp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401TcpOpenBindConnectRF;

    class Socket401TcpOpenBindConnectCB {
        Socket401TcpOpenBindConnectRF cb;

    public:
        operator const Socket401TcpOpenBindConnectRF& () const { return cb; }
        const Socket401TcpOpenBindConnectRF& operator ->() const { return cb; }
        Socket401TcpOpenBindConnectCB(const Socket401TcpOpenBindConnectRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401TcpOpenBindConnectRsp :
      public Socket401TcpOpenBindConnectCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401TcpOpenBindConnectRsp(const Socket401TcpOpenBindConnectRF& cb)
          : Socket401TcpOpenBindConnectCB(cb) { }

        void respond() const {
            Socket401TcpOpenBindConnectCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_tcp_open_bind_connect
       (
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	Socket401TcpOpenBindConnectCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401UdpOpenBindConnectRF;

    class Socket401UdpOpenBindConnectCB {
        Socket401UdpOpenBindConnectRF cb;

    public:
        operator const Socket401UdpOpenBindConnectRF& () const { return cb; }
        const Socket401UdpOpenBindConnectRF& operator ->() const { return cb; }
        Socket401UdpOpenBindConnectCB(const Socket401UdpOpenBindConnectRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401UdpOpenBindConnectRsp :
      public Socket401UdpOpenBindConnectCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401UdpOpenBindConnectRsp(const Socket401UdpOpenBindConnectRF& cb)
          : Socket401UdpOpenBindConnectCB(cb) { }

        void respond() const {
            Socket401UdpOpenBindConnectCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_udp_open_bind_connect
       (
	const string&	creator,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	Socket401UdpOpenBindConnectCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound, and optionally connected, UDP broadcast socket. This
     *  socket may be used for sending and receiving IPv4 broadcasts on a named
     *  if/vif. The TTL is always set to 1 on creation. The creator must
     *  specify if this socket is to be used for limited broadcasts
     *  (255.255.255.255) as this is a special case on many platforms.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param ifname the interface name to bind socket to.
     *
     *  @param vifname the vif to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param reuse allow other sockets to bind to same port.
     *
     *  @param limited set the socket up for transmission to the limited
     *  broadcast address 255.255.255.255.
     *
     *  @param connected connect the socket for use with send() not sendto().
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket4_0_1_udp_open_bind_broadcast(
	// Input values,
	const string&	creator,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	local_port,
	const uint32_t&	remote_port,
	const bool&	reuse,
	const bool&	limited,
	const bool&	connected,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket401UdpOpenBindBroadcastRF;

    class Socket401UdpOpenBindBroadcastCB {
        Socket401UdpOpenBindBroadcastRF cb;

    public:
        operator const Socket401UdpOpenBindBroadcastRF& () const { return cb; }
        const Socket401UdpOpenBindBroadcastRF& operator ->() const { return cb; }
        Socket401UdpOpenBindBroadcastCB(const Socket401UdpOpenBindBroadcastRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket401UdpOpenBindBroadcastRsp :
      public Socket401UdpOpenBindBroadcastCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket401UdpOpenBindBroadcastRsp(const Socket401UdpOpenBindBroadcastRF& cb)
          : Socket401UdpOpenBindBroadcastCB(cb) { }

        void respond() const {
            Socket401UdpOpenBindBroadcastCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket4_0_1_udp_open_bind_broadcast
       (
	const string&	creator,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	local_port,
	const uint32_t&	remote_port,
	const bool&	reuse,
	const bool&	limited,
	const bool&	connected,
	Socket401UdpOpenBindBroadcastCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Bind a socket.
     *
     *  @param sockid the socket ID of the socket to bind.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     */
    virtual XrlCmdError socket4_0_1_bind(
	// Input values,
	const string&	sockid,
	const IPv4&	local_addr,
	const uint32_t&	local_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401BindRF;

    class Socket401BindCB {
        Socket401BindRF cb;

    public:
        operator const Socket401BindRF& () const { return cb; }
        const Socket401BindRF& operator ->() const { return cb; }
        Socket401BindCB(const Socket401BindRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401BindRsp :
      public Socket401BindCB {
        Socket401BindRsp(const Socket401BindRF& cb)
          : Socket401BindCB(cb) { }

    };

    virtual void async_socket4_0_1_bind
       (
	const string&	sockid,
	const IPv4&	local_addr,
	const uint32_t&	local_port,
	Socket401BindCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to join.
     *
     *  @param join_if_addr interface address to perform join on.
     */
    virtual XrlCmdError socket4_0_1_udp_join_group(
	// Input values,
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	join_if_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401UdpJoinGroupRF;

    class Socket401UdpJoinGroupCB {
        Socket401UdpJoinGroupRF cb;

    public:
        operator const Socket401UdpJoinGroupRF& () const { return cb; }
        const Socket401UdpJoinGroupRF& operator ->() const { return cb; }
        Socket401UdpJoinGroupCB(const Socket401UdpJoinGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401UdpJoinGroupRsp :
      public Socket401UdpJoinGroupCB {
        Socket401UdpJoinGroupRsp(const Socket401UdpJoinGroupRF& cb)
          : Socket401UdpJoinGroupCB(cb) { }

    };

    virtual void async_socket4_0_1_udp_join_group
       (
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	join_if_addr,
	Socket401UdpJoinGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to leave.
     *
     *  @param leave_if_addr interface address to perform leave on.
     */
    virtual XrlCmdError socket4_0_1_udp_leave_group(
	// Input values,
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	leave_if_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401UdpLeaveGroupRF;

    class Socket401UdpLeaveGroupCB {
        Socket401UdpLeaveGroupRF cb;

    public:
        operator const Socket401UdpLeaveGroupRF& () const { return cb; }
        const Socket401UdpLeaveGroupRF& operator ->() const { return cb; }
        Socket401UdpLeaveGroupCB(const Socket401UdpLeaveGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401UdpLeaveGroupRsp :
      public Socket401UdpLeaveGroupCB {
        Socket401UdpLeaveGroupRsp(const Socket401UdpLeaveGroupRF& cb)
          : Socket401UdpLeaveGroupCB(cb) { }

    };

    virtual void async_socket4_0_1_udp_leave_group
       (
	const string&	sockid,
	const IPv4&	mcast_addr,
	const IPv4&	leave_if_addr,
	Socket401UdpLeaveGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Close socket.
     *
     *  @param sockid unique socket ID of socket to be closed.
     */
    virtual XrlCmdError socket4_0_1_close(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401CloseRF;

    class Socket401CloseCB {
        Socket401CloseRF cb;

    public:
        operator const Socket401CloseRF& () const { return cb; }
        const Socket401CloseRF& operator ->() const { return cb; }
        Socket401CloseCB(const Socket401CloseRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401CloseRsp :
      public Socket401CloseCB {
        Socket401CloseRsp(const Socket401CloseRF& cb)
          : Socket401CloseCB(cb) { }

    };

    virtual void async_socket4_0_1_close
       (
	const string&	sockid,
	Socket401CloseCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Listen for inbound connections on socket. When a connection request
     *  received the socket creator will receive notification through
     *  socket4_user/0.1/inbound_connect_event.
     *
     *  @param sockid the unique socket ID of the socket to perform listen.
     *
     *  @param backlog the maximum number of pending connections.
     */
    virtual XrlCmdError socket4_0_1_tcp_listen(
	// Input values,
	const string&	sockid,
	const uint32_t&	backlog) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401TcpListenRF;

    class Socket401TcpListenCB {
        Socket401TcpListenRF cb;

    public:
        operator const Socket401TcpListenRF& () const { return cb; }
        const Socket401TcpListenRF& operator ->() const { return cb; }
        Socket401TcpListenCB(const Socket401TcpListenRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401TcpListenRsp :
      public Socket401TcpListenCB {
        Socket401TcpListenRsp(const Socket401TcpListenRF& cb)
          : Socket401TcpListenCB(cb) { }

    };

    virtual void async_socket4_0_1_tcp_listen
       (
	const string&	sockid,
	const uint32_t&	backlog,
	Socket401TcpListenCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable a UDP socket for datagram reception. If a UDP socket has been
     *  created without using the usual convenience XRLs, it is necessary to
     *  hook up its FEA internal input path by calling this XRL. It is similar
     *  in intent to tcp_listen, but named differently as it never uses the
     *  listen() socket API.
     *
     *  @param sockid the unique socket ID of the socket to enable for datagram
     *  reception.
     */
    virtual XrlCmdError socket4_0_1_udp_enable_recv(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401UdpEnableRecvRF;

    class Socket401UdpEnableRecvCB {
        Socket401UdpEnableRecvRF cb;

    public:
        operator const Socket401UdpEnableRecvRF& () const { return cb; }
        const Socket401UdpEnableRecvRF& operator ->() const { return cb; }
        Socket401UdpEnableRecvCB(const Socket401UdpEnableRecvRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401UdpEnableRecvRsp :
      public Socket401UdpEnableRecvCB {
        Socket401UdpEnableRecvRsp(const Socket401UdpEnableRecvRF& cb)
          : Socket401UdpEnableRecvCB(cb) { }

    };

    virtual void async_socket4_0_1_udp_enable_recv
       (
	const string&	sockid,
	Socket401UdpEnableRecvCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket4_0_1_send(
	// Input values,
	const string&	sockid,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401SendRF;

    class Socket401SendCB {
        Socket401SendRF cb;

    public:
        operator const Socket401SendRF& () const { return cb; }
        const Socket401SendRF& operator ->() const { return cb; }
        Socket401SendCB(const Socket401SendRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401SendRsp :
      public Socket401SendCB {
        Socket401SendRsp(const Socket401SendRF& cb)
          : Socket401SendCB(cb) { }

    };

    virtual void async_socket4_0_1_send
       (
	const string&	sockid,
	const vector<uint8_t>&	data,
	Socket401SendCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given destination. The packet is not routed as
     *  the forwarding engine sending the packet may not have access to the
     *  full routing table.
     *
     *  @param sockid unique socket ID.
     *
     *  @param remote_addr destination address for data.
     *
     *  @param remote_port destination port for data.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket4_0_1_send_to(
	// Input values,
	const string&	sockid,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401SendToRF;

    class Socket401SendToCB {
        Socket401SendToRF cb;

    public:
        operator const Socket401SendToRF& () const { return cb; }
        const Socket401SendToRF& operator ->() const { return cb; }
        Socket401SendToCB(const Socket401SendToRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401SendToRsp :
      public Socket401SendToCB {
        Socket401SendToRsp(const Socket401SendToRF& cb)
          : Socket401SendToCB(cb) { }

    };

    virtual void async_socket4_0_1_send_to
       (
	const string&	sockid,
	const IPv4&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data,
	Socket401SendToCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given multicast group from a given interface.
     *
     *  @param sockid unique socket ID.
     *
     *  @param group_addr destination address for data.
     *
     *  @param group_port destination port for data.
     *
     *  @param ifaddr interface address
     */
    virtual XrlCmdError socket4_0_1_send_from_multicast_if(
	// Input values,
	const string&	sockid,
	const IPv4&	group_addr,
	const uint32_t&	group_port,
	const IPv4&	ifaddr,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401SendFromMulticastIfRF;

    class Socket401SendFromMulticastIfCB {
        Socket401SendFromMulticastIfRF cb;

    public:
        operator const Socket401SendFromMulticastIfRF& () const { return cb; }
        const Socket401SendFromMulticastIfRF& operator ->() const { return cb; }
        Socket401SendFromMulticastIfCB(const Socket401SendFromMulticastIfRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401SendFromMulticastIfRsp :
      public Socket401SendFromMulticastIfCB {
        Socket401SendFromMulticastIfRsp(const Socket401SendFromMulticastIfRF& cb)
          : Socket401SendFromMulticastIfCB(cb) { }

    };

    virtual void async_socket4_0_1_send_from_multicast_if
       (
	const string&	sockid,
	const IPv4&	group_addr,
	const uint32_t&	group_port,
	const IPv4&	ifaddr,
	const vector<uint8_t>&	data,
	Socket401SendFromMulticastIfCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set a named socket option with an integer value. XXX: The "onesbcast"
     *  and "reuseport" options exist to work around an architectural issue in
     *  the BSD IPv4 stack. They SHOULD NOT be used for new code.
     *
     *  @param sockid unique socket ID.
     *
     *  @param optname name of option to be set. Valid values are: "onesbcast"
     *  "receive_broadcast" "reuseport" "send_broadcast" "tos" "ttl"
     *  "multicast_loopback" "multicast_ttl"
     *
     *  @param optval integer value of option to be set. If value is logically
     *  boolean, then zero represents 'false', and any non-zero value
     *  represents 'true'.
     */
    virtual XrlCmdError socket4_0_1_set_socket_option(
	// Input values,
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401SetSocketOptionRF;

    class Socket401SetSocketOptionCB {
        Socket401SetSocketOptionRF cb;

    public:
        operator const Socket401SetSocketOptionRF& () const { return cb; }
        const Socket401SetSocketOptionRF& operator ->() const { return cb; }
        Socket401SetSocketOptionCB(const Socket401SetSocketOptionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401SetSocketOptionRsp :
      public Socket401SetSocketOptionCB {
        Socket401SetSocketOptionRsp(const Socket401SetSocketOptionRF& cb)
          : Socket401SetSocketOptionCB(cb) { }

    };

    virtual void async_socket4_0_1_set_socket_option
       (
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval,
	Socket401SetSocketOptionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set a named socket option with a string value. XXX: The "bindtodevice"
     *  option exists to workaround an architectural issue in the Linux IPv4
     *  stack. It SHOULD NOT be used for new code.
     *
     *  @param sockid unique socket ID.
     *
     *  @param optname name of option to be set. Valid values are:
     *  "bindtodevice"
     *
     *  @param optval value of option to be set.
     */
    virtual XrlCmdError socket4_0_1_set_socket_option_txt(
	// Input values,
	const string&	sockid,
	const string&	optname,
	const string&	optval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket401SetSocketOptionTxtRF;

    class Socket401SetSocketOptionTxtCB {
        Socket401SetSocketOptionTxtRF cb;

    public:
        operator const Socket401SetSocketOptionTxtRF& () const { return cb; }
        const Socket401SetSocketOptionTxtRF& operator ->() const { return cb; }
        Socket401SetSocketOptionTxtCB(const Socket401SetSocketOptionTxtRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket401SetSocketOptionTxtRsp :
      public Socket401SetSocketOptionTxtCB {
        Socket401SetSocketOptionTxtRsp(const Socket401SetSocketOptionTxtRF& cb)
          : Socket401SetSocketOptionTxtCB(cb) { }

    };

    virtual void async_socket4_0_1_set_socket_option_txt
       (
	const string&	sockid,
	const string&	optname,
	const string&	optval,
	Socket401SetSocketOptionTxtCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start transaction.
     *
     *  @param tid the transaction ID to use for this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_start_transaction(
	// Output values,
	uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    RedistTransaction601StartTransactionRF;

    class RedistTransaction601StartTransactionCB {
        RedistTransaction601StartTransactionRF cb;

    public:
        operator const RedistTransaction601StartTransactionRF& () const { return cb; }
        const RedistTransaction601StartTransactionRF& operator ->() const { return cb; }
        RedistTransaction601StartTransactionCB(const RedistTransaction601StartTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_tid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_tid);
        }
    };

    struct RedistTransaction601StartTransactionRsp :
      public RedistTransaction601StartTransactionCB {
        struct args_str {
            uint32_t tid;
        };

    private:
        args_str args;

    public:
        RedistTransaction601StartTransactionRsp(const RedistTransaction601StartTransactionRF& cb)
          : RedistTransaction601StartTransactionCB(cb) { }

        void respond() const {
            RedistTransaction601StartTransactionCB::
            respond(args.tid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_redist_transaction6_0_1_start_transaction
       (
	RedistTransaction601StartTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Commit transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_commit_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601CommitTransactionRF;

    class RedistTransaction601CommitTransactionCB {
        RedistTransaction601CommitTransactionRF cb;

    public:
        operator const RedistTransaction601CommitTransactionRF& () const { return cb; }
        const RedistTransaction601CommitTransactionRF& operator ->() const { return cb; }
        RedistTransaction601CommitTransactionCB(const RedistTransaction601CommitTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601CommitTransactionRsp :
      public RedistTransaction601CommitTransactionCB {
        RedistTransaction601CommitTransactionRsp(const RedistTransaction601CommitTransactionRF& cb)
          : RedistTransaction601CommitTransactionCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_commit_transaction
       (
	const uint32_t&	tid,
	RedistTransaction601CommitTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Abort transaction.
     *
     *  @param tid the transaction ID of this transaction.
     */
    virtual XrlCmdError redist_transaction6_0_1_abort_transaction(
	// Input values,
	const uint32_t&	tid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601AbortTransactionRF;

    class RedistTransaction601AbortTransactionCB {
        RedistTransaction601AbortTransactionRF cb;

    public:
        operator const RedistTransaction601AbortTransactionRF& () const { return cb; }
        const RedistTransaction601AbortTransactionRF& operator ->() const { return cb; }
        RedistTransaction601AbortTransactionCB(const RedistTransaction601AbortTransactionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601AbortTransactionRsp :
      public RedistTransaction601AbortTransactionCB {
        RedistTransaction601AbortTransactionRsp(const RedistTransaction601AbortTransactionRF& cb)
          : RedistTransaction601AbortTransactionCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_abort_transaction
       (
	const uint32_t&	tid,
	RedistTransaction601AbortTransactionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add/delete a routing entry.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param dst destination network.
     *
     *  @param nexthop nexthop router address.
     *
     *  @param ifname interface name associated with nexthop.
     *
     *  @param vifname virtual interface name with nexthop.
     *
     *  @param metric origin routing protocol metric for route.
     *
     *  @param admin_distance administrative distance of origin routing
     *  protocol.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError redist_transaction6_0_1_add_route(
	// Input values,
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601AddRouteRF;

    class RedistTransaction601AddRouteCB {
        RedistTransaction601AddRouteRF cb;

    public:
        operator const RedistTransaction601AddRouteRF& () const { return cb; }
        const RedistTransaction601AddRouteRF& operator ->() const { return cb; }
        RedistTransaction601AddRouteCB(const RedistTransaction601AddRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601AddRouteRsp :
      public RedistTransaction601AddRouteCB {
        RedistTransaction601AddRouteRsp(const RedistTransaction601AddRouteRF& cb)
          : RedistTransaction601AddRouteCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_add_route
       (
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction601AddRouteCB);
#endif

    virtual XrlCmdError redist_transaction6_0_1_delete_route(
	// Input values,
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601DeleteRouteRF;

    class RedistTransaction601DeleteRouteCB {
        RedistTransaction601DeleteRouteRF cb;

    public:
        operator const RedistTransaction601DeleteRouteRF& () const { return cb; }
        const RedistTransaction601DeleteRouteRF& operator ->() const { return cb; }
        RedistTransaction601DeleteRouteCB(const RedistTransaction601DeleteRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601DeleteRouteRsp :
      public RedistTransaction601DeleteRouteCB {
        RedistTransaction601DeleteRouteRsp(const RedistTransaction601DeleteRouteRF& cb)
          : RedistTransaction601DeleteRouteCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_delete_route
       (
	const uint32_t&	tid,
	const IPv6Net&	dst,
	const IPv6&	nexthop,
	const string&	ifname,
	const string&	vifname,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	cookie,
	const string&	protocol_origin,
	RedistTransaction601DeleteRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete all routing entries.
     *
     *  @param tid the transaction ID of this transaction.
     *
     *  @param cookie value set by the requestor to identify redistribution
     *  source. Typical value is the originating protocol name.
     */
    virtual XrlCmdError redist_transaction6_0_1_delete_all_routes(
	// Input values,
	const uint32_t&	tid,
	const string&	cookie) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RedistTransaction601DeleteAllRoutesRF;

    class RedistTransaction601DeleteAllRoutesCB {
        RedistTransaction601DeleteAllRoutesRF cb;

    public:
        operator const RedistTransaction601DeleteAllRoutesRF& () const { return cb; }
        const RedistTransaction601DeleteAllRoutesRF& operator ->() const { return cb; }
        RedistTransaction601DeleteAllRoutesCB(const RedistTransaction601DeleteAllRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RedistTransaction601DeleteAllRoutesRsp :
      public RedistTransaction601DeleteAllRoutesCB {
        RedistTransaction601DeleteAllRoutesRsp(const RedistTransaction601DeleteAllRoutesRF& cb)
          : RedistTransaction601DeleteAllRoutesCB(cb) { }

    };

    virtual void async_redist_transaction6_0_1_delete_all_routes
       (
	const uint32_t&	tid,
	const string&	cookie,
	RedistTransaction601DeleteAllRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open a TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_tcp_open(
	// Input values,
	const string&	creator,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601TcpOpenRF;

    class Socket601TcpOpenCB {
        Socket601TcpOpenRF cb;

    public:
        operator const Socket601TcpOpenRF& () const { return cb; }
        const Socket601TcpOpenRF& operator ->() const { return cb; }
        Socket601TcpOpenCB(const Socket601TcpOpenRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601TcpOpenRsp :
      public Socket601TcpOpenCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601TcpOpenRsp(const Socket601TcpOpenRF& cb)
          : Socket601TcpOpenCB(cb) { }

        void respond() const {
            Socket601TcpOpenCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_tcp_open
       (
	const string&	creator,
	Socket601TcpOpenCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Open an UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket4_user/0.1.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open(
	// Input values,
	const string&	creator,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601UdpOpenRF;

    class Socket601UdpOpenCB {
        Socket601UdpOpenRF cb;

    public:
        operator const Socket601UdpOpenRF& () const { return cb; }
        const Socket601UdpOpenRF& operator ->() const { return cb; }
        Socket601UdpOpenCB(const Socket601UdpOpenRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601UdpOpenRsp :
      public Socket601UdpOpenCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601UdpOpenRsp(const Socket601UdpOpenRF& cb)
          : Socket601UdpOpenCB(cb) { }

        void respond() const {
            Socket601UdpOpenCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_udp_open
       (
	const string&	creator,
	Socket601UdpOpenCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_tcp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601TcpOpenAndBindRF;

    class Socket601TcpOpenAndBindCB {
        Socket601TcpOpenAndBindRF cb;

    public:
        operator const Socket601TcpOpenAndBindRF& () const { return cb; }
        const Socket601TcpOpenAndBindRF& operator ->() const { return cb; }
        Socket601TcpOpenAndBindCB(const Socket601TcpOpenAndBindRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601TcpOpenAndBindRsp :
      public Socket601TcpOpenAndBindCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601TcpOpenAndBindRsp(const Socket601TcpOpenAndBindRF& cb)
          : Socket601TcpOpenAndBindCB(cb) { }

        void respond() const {
            Socket601TcpOpenAndBindCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_tcp_open_and_bind
       (
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	Socket601TcpOpenAndBindCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open_and_bind(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const string&	local_dev,
	const uint32_t&	reuse,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601UdpOpenAndBindRF;

    class Socket601UdpOpenAndBindCB {
        Socket601UdpOpenAndBindRF cb;

    public:
        operator const Socket601UdpOpenAndBindRF& () const { return cb; }
        const Socket601UdpOpenAndBindRF& operator ->() const { return cb; }
        Socket601UdpOpenAndBindCB(const Socket601UdpOpenAndBindRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601UdpOpenAndBindRsp :
      public Socket601UdpOpenAndBindCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601UdpOpenAndBindRsp(const Socket601UdpOpenAndBindRF& cb)
          : Socket601UdpOpenAndBindCB(cb) { }

        void respond() const {
            Socket601UdpOpenAndBindCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_udp_open_and_bind
       (
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const string&	local_dev,
	const uint32_t&	reuse,
	Socket601UdpOpenAndBindCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound UDP multicast socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param mcast_addr the multicast group address to join.
     *
     *  @param ttl the ttl to use for this multicast socket.
     *
     *  @param reuse allow other sockets to bind to same multicast group.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open_bind_join(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601UdpOpenBindJoinRF;

    class Socket601UdpOpenBindJoinCB {
        Socket601UdpOpenBindJoinRF cb;

    public:
        operator const Socket601UdpOpenBindJoinRF& () const { return cb; }
        const Socket601UdpOpenBindJoinRF& operator ->() const { return cb; }
        Socket601UdpOpenBindJoinCB(const Socket601UdpOpenBindJoinRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601UdpOpenBindJoinRsp :
      public Socket601UdpOpenBindJoinCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601UdpOpenBindJoinRsp(const Socket601UdpOpenBindJoinRF& cb)
          : Socket601UdpOpenBindJoinCB(cb) { }

        void respond() const {
            Socket601UdpOpenBindJoinCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_udp_open_bind_join
       (
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	mcast_addr,
	const uint32_t&	ttl,
	const bool&	reuse,
	Socket601UdpOpenBindJoinCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected TCP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_tcp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601TcpOpenBindConnectRF;

    class Socket601TcpOpenBindConnectCB {
        Socket601TcpOpenBindConnectRF cb;

    public:
        operator const Socket601TcpOpenBindConnectRF& () const { return cb; }
        const Socket601TcpOpenBindConnectRF& operator ->() const { return cb; }
        Socket601TcpOpenBindConnectCB(const Socket601TcpOpenBindConnectRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601TcpOpenBindConnectRsp :
      public Socket601TcpOpenBindConnectCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601TcpOpenBindConnectRsp(const Socket601TcpOpenBindConnectRF& cb)
          : Socket601TcpOpenBindConnectCB(cb) { }

        void respond() const {
            Socket601TcpOpenBindConnectCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_tcp_open_bind_connect
       (
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	Socket601TcpOpenBindConnectCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a bound and connected UDP socket.
     *
     *  @param creator the Xrl Target instance name of the socket creator. The
     *  named target must implement socket6_user/0.1.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     *
     *  @param remote_addr the address to connect to.
     *
     *  @param remote_port the remote port to connect to.
     *
     *  @param sockid return parameter that contains unique socket ID when
     *  socket instantiation is successful.
     */
    virtual XrlCmdError socket6_0_1_udp_open_bind_connect(
	// Input values,
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	// Output values,
	string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Socket601UdpOpenBindConnectRF;

    class Socket601UdpOpenBindConnectCB {
        Socket601UdpOpenBindConnectRF cb;

    public:
        operator const Socket601UdpOpenBindConnectRF& () const { return cb; }
        const Socket601UdpOpenBindConnectRF& operator ->() const { return cb; }
        Socket601UdpOpenBindConnectCB(const Socket601UdpOpenBindConnectRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_sockid) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_sockid);
        }
    };

    struct Socket601UdpOpenBindConnectRsp :
      public Socket601UdpOpenBindConnectCB {
        struct args_str {
            string sockid;
        };

    private:
        args_str args;

    public:
        Socket601UdpOpenBindConnectRsp(const Socket601UdpOpenBindConnectRF& cb)
          : Socket601UdpOpenBindConnectCB(cb) { }

        void respond() const {
            Socket601UdpOpenBindConnectCB::
            respond(args.sockid);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_0_1_udp_open_bind_connect
       (
	const string&	creator,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	Socket601UdpOpenBindConnectCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Bind a socket.
     *
     *  @param sockid the socket ID of the socket to bind.
     *
     *  @param local_addr the interface address to bind socket to.
     *
     *  @param local_port the port to bind socket to.
     */
    virtual XrlCmdError socket6_0_1_bind(
	// Input values,
	const string&	sockid,
	const IPv6&	local_addr,
	const uint32_t&	local_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601BindRF;

    class Socket601BindCB {
        Socket601BindRF cb;

    public:
        operator const Socket601BindRF& () const { return cb; }
        const Socket601BindRF& operator ->() const { return cb; }
        Socket601BindCB(const Socket601BindRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601BindRsp :
      public Socket601BindCB {
        Socket601BindRsp(const Socket601BindRF& cb)
          : Socket601BindCB(cb) { }

    };

    virtual void async_socket6_0_1_bind
       (
	const string&	sockid,
	const IPv6&	local_addr,
	const uint32_t&	local_port,
	Socket601BindCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to join.
     *
     *  @param join_if_addr interface address to perform join on.
     */
    virtual XrlCmdError socket6_0_1_udp_join_group(
	// Input values,
	const string&	sockid,
	const IPv6&	mcast_addr,
	const IPv6&	join_if_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601UdpJoinGroupRF;

    class Socket601UdpJoinGroupCB {
        Socket601UdpJoinGroupRF cb;

    public:
        operator const Socket601UdpJoinGroupRF& () const { return cb; }
        const Socket601UdpJoinGroupRF& operator ->() const { return cb; }
        Socket601UdpJoinGroupCB(const Socket601UdpJoinGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601UdpJoinGroupRsp :
      public Socket601UdpJoinGroupCB {
        Socket601UdpJoinGroupRsp(const Socket601UdpJoinGroupRF& cb)
          : Socket601UdpJoinGroupCB(cb) { }

    };

    virtual void async_socket6_0_1_udp_join_group
       (
	const string&	sockid,
	const IPv6&	mcast_addr,
	const IPv6&	join_if_addr,
	Socket601UdpJoinGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave multicast group on already bound socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param mcast_addr group to leave.
     *
     *  @param leave_if_addr interface address to perform leave on.
     */
    virtual XrlCmdError socket6_0_1_udp_leave_group(
	// Input values,
	const string&	sockid,
	const IPv6&	mcast_addr,
	const IPv6&	leave_if_addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601UdpLeaveGroupRF;

    class Socket601UdpLeaveGroupCB {
        Socket601UdpLeaveGroupRF cb;

    public:
        operator const Socket601UdpLeaveGroupRF& () const { return cb; }
        const Socket601UdpLeaveGroupRF& operator ->() const { return cb; }
        Socket601UdpLeaveGroupCB(const Socket601UdpLeaveGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601UdpLeaveGroupRsp :
      public Socket601UdpLeaveGroupCB {
        Socket601UdpLeaveGroupRsp(const Socket601UdpLeaveGroupRF& cb)
          : Socket601UdpLeaveGroupCB(cb) { }

    };

    virtual void async_socket6_0_1_udp_leave_group
       (
	const string&	sockid,
	const IPv6&	mcast_addr,
	const IPv6&	leave_if_addr,
	Socket601UdpLeaveGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Close socket.
     *
     *  @param sockid unique socket ID of socket to be closed.
     */
    virtual XrlCmdError socket6_0_1_close(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601CloseRF;

    class Socket601CloseCB {
        Socket601CloseRF cb;

    public:
        operator const Socket601CloseRF& () const { return cb; }
        const Socket601CloseRF& operator ->() const { return cb; }
        Socket601CloseCB(const Socket601CloseRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601CloseRsp :
      public Socket601CloseCB {
        Socket601CloseRsp(const Socket601CloseRF& cb)
          : Socket601CloseCB(cb) { }

    };

    virtual void async_socket6_0_1_close
       (
	const string&	sockid,
	Socket601CloseCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Listen for inbound connections on socket. When a connection request
     *  received the socket creator will receive notification through
     *  socket6_user/0.1/inbound_connect_event.
     *
     *  @param sockid the unique socket ID of the socket to perform listen.
     *
     *  @param backlog the maximum number of pending connections.
     */
    virtual XrlCmdError socket6_0_1_tcp_listen(
	// Input values,
	const string&	sockid,
	const uint32_t&	backlog) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601TcpListenRF;

    class Socket601TcpListenCB {
        Socket601TcpListenRF cb;

    public:
        operator const Socket601TcpListenRF& () const { return cb; }
        const Socket601TcpListenRF& operator ->() const { return cb; }
        Socket601TcpListenCB(const Socket601TcpListenRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601TcpListenRsp :
      public Socket601TcpListenCB {
        Socket601TcpListenRsp(const Socket601TcpListenRF& cb)
          : Socket601TcpListenCB(cb) { }

    };

    virtual void async_socket6_0_1_tcp_listen
       (
	const string&	sockid,
	const uint32_t&	backlog,
	Socket601TcpListenCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket.
     *
     *  @param sockid unique socket ID.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket6_0_1_send(
	// Input values,
	const string&	sockid,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601SendRF;

    class Socket601SendCB {
        Socket601SendRF cb;

    public:
        operator const Socket601SendRF& () const { return cb; }
        const Socket601SendRF& operator ->() const { return cb; }
        Socket601SendCB(const Socket601SendRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601SendRsp :
      public Socket601SendCB {
        Socket601SendRsp(const Socket601SendRF& cb)
          : Socket601SendCB(cb) { }

    };

    virtual void async_socket6_0_1_send
       (
	const string&	sockid,
	const vector<uint8_t>&	data,
	Socket601SendCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given destination. The packet is not routed as
     *  the forwarding engine sending the packet may not have access to the
     *  full routing table.
     *
     *  @param sockid unique socket ID.
     *
     *  @param remote_addr destination address for data.
     *
     *  @param remote_port destination port for data.
     *
     *  @param data block of data to be sent.
     */
    virtual XrlCmdError socket6_0_1_send_to(
	// Input values,
	const string&	sockid,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601SendToRF;

    class Socket601SendToCB {
        Socket601SendToRF cb;

    public:
        operator const Socket601SendToRF& () const { return cb; }
        const Socket601SendToRF& operator ->() const { return cb; }
        Socket601SendToCB(const Socket601SendToRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601SendToRsp :
      public Socket601SendToCB {
        Socket601SendToRsp(const Socket601SendToRF& cb)
          : Socket601SendToCB(cb) { }

    };

    virtual void async_socket6_0_1_send_to
       (
	const string&	sockid,
	const IPv6&	remote_addr,
	const uint32_t&	remote_port,
	const vector<uint8_t>&	data,
	Socket601SendToCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send data on socket to a given multicast group from a given interface.
     *
     *  @param sockid unique socket ID.
     *
     *  @param group_addr destination address for data.
     *
     *  @param group_port destination port for data.
     *
     *  @param ifaddr interface address
     */
    virtual XrlCmdError socket6_0_1_send_from_multicast_if(
	// Input values,
	const string&	sockid,
	const IPv6&	group_addr,
	const uint32_t&	group_port,
	const IPv6&	ifaddr,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601SendFromMulticastIfRF;

    class Socket601SendFromMulticastIfCB {
        Socket601SendFromMulticastIfRF cb;

    public:
        operator const Socket601SendFromMulticastIfRF& () const { return cb; }
        const Socket601SendFromMulticastIfRF& operator ->() const { return cb; }
        Socket601SendFromMulticastIfCB(const Socket601SendFromMulticastIfRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601SendFromMulticastIfRsp :
      public Socket601SendFromMulticastIfCB {
        Socket601SendFromMulticastIfRsp(const Socket601SendFromMulticastIfRF& cb)
          : Socket601SendFromMulticastIfCB(cb) { }

    };

    virtual void async_socket6_0_1_send_from_multicast_if
       (
	const string&	sockid,
	const IPv6&	group_addr,
	const uint32_t&	group_port,
	const IPv6&	ifaddr,
	const vector<uint8_t>&	data,
	Socket601SendFromMulticastIfCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set a named socket option with an integer value.
     *
     *  @param sockid unique socket ID.
     *
     *  @param optname name of option to be set. Valid values are: "reuseport"
     *  "ttl" "multicast_loopback" "multicast_ttl"
     *
     *  @param optval value of option to be set. If value is logically boolean
     *  then zero represents false and any non-zero value true.
     */
    virtual XrlCmdError socket6_0_1_set_socket_option(
	// Input values,
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket601SetSocketOptionRF;

    class Socket601SetSocketOptionCB {
        Socket601SetSocketOptionRF cb;

    public:
        operator const Socket601SetSocketOptionRF& () const { return cb; }
        const Socket601SetSocketOptionRF& operator ->() const { return cb; }
        Socket601SetSocketOptionCB(const Socket601SetSocketOptionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket601SetSocketOptionRsp :
      public Socket601SetSocketOptionCB {
        Socket601SetSocketOptionRsp(const Socket601SetSocketOptionRF& cb)
          : Socket601SetSocketOptionCB(cb) { }

    };

    virtual void async_socket6_0_1_set_socket_option
       (
	const string&	sockid,
	const string&	optname,
	const uint32_t&	optval,
	Socket601SetSocketOptionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Send an IPv6 packet on a raw socket.
     *
     *  @param if_name the interface to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param vif_name the vif to send the packet on. It is essential for
     *  multicast. In the unicast case this field may be empty.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number. It must be between 1 and
     *  255.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, the
     *  TTL will be set internally before transmission.
     *
     *  @param ip_tos the Type Of Service (IP traffic class for IPv6). If it
     *  has a negative value, the TOS will be set internally before
     *  transmission.
     *
     *  @param ip_router_alert if true, then add the IP Router Alert option to
     *  the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param ext_headers_type a list of u32 integers with the types of the
     *  optional extention headers.
     *
     *  @param ext_headers_payload a list of payload data, one for each
     *  optional extention header. The number of entries must match
     *  ext_headers_type.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet6_0_1_send(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket601SendRF;

    class RawPacket601SendCB {
        RawPacket601SendRF cb;

    public:
        operator const RawPacket601SendRF& () const { return cb; }
        const RawPacket601SendRF& operator ->() const { return cb; }
        RawPacket601SendCB(const RawPacket601SendRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket601SendRsp :
      public RawPacket601SendCB {
        RawPacket601SendRsp(const RawPacket601SendRF& cb)
          : RawPacket601SendCB(cb) { }

    };

    virtual void async_raw_packet6_0_1_send
       (
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload,
	RawPacket601SendCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register to receive IPv6 packets. The receiver is expected to support
     *  raw_packet6_client/0.1 interface.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param enable_multicast_loopback if true then enable delivering of
     *  multicast datagrams back to this host (assuming the host is a member of
     *  the same multicast group.
     */
    virtual XrlCmdError raw_packet6_0_1_register_receiver(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const bool&	enable_multicast_loopback) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket601RegisterReceiverRF;

    class RawPacket601RegisterReceiverCB {
        RawPacket601RegisterReceiverRF cb;

    public:
        operator const RawPacket601RegisterReceiverRF& () const { return cb; }
        const RawPacket601RegisterReceiverRF& operator ->() const { return cb; }
        RawPacket601RegisterReceiverCB(const RawPacket601RegisterReceiverRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket601RegisterReceiverRsp :
      public RawPacket601RegisterReceiverCB {
        RawPacket601RegisterReceiverRsp(const RawPacket601RegisterReceiverRF& cb)
          : RawPacket601RegisterReceiverCB(cb) { }

    };

    virtual void async_raw_packet6_0_1_register_receiver
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const bool&	enable_multicast_loopback,
	RawPacket601RegisterReceiverCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Unregister to receive IPv6 packets.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP Protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     */
    virtual XrlCmdError raw_packet6_0_1_unregister_receiver(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket601UnregisterReceiverRF;

    class RawPacket601UnregisterReceiverCB {
        RawPacket601UnregisterReceiverRF cb;

    public:
        operator const RawPacket601UnregisterReceiverRF& () const { return cb; }
        const RawPacket601UnregisterReceiverRF& operator ->() const { return cb; }
        RawPacket601UnregisterReceiverCB(const RawPacket601UnregisterReceiverRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket601UnregisterReceiverRsp :
      public RawPacket601UnregisterReceiverCB {
        RawPacket601UnregisterReceiverRsp(const RawPacket601UnregisterReceiverRF& cb)
          : RawPacket601UnregisterReceiverCB(cb) { }

    };

    virtual void async_raw_packet6_0_1_unregister_receiver
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	RawPacket601UnregisterReceiverCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Join an IPv6 multicast group.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should be accepted.
     *
     *  @param vif_name the vif through which packets should be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is
     *  interested in. It must be between 0 and 255. A protocol number of 0 is
     *  used to specify all protocols.
     *
     *  @param group_address the multicast group address to join.
     */
    virtual XrlCmdError raw_packet6_0_1_join_multicast_group(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv6&	group_address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket601JoinMulticastGroupRF;

    class RawPacket601JoinMulticastGroupCB {
        RawPacket601JoinMulticastGroupRF cb;

    public:
        operator const RawPacket601JoinMulticastGroupRF& () const { return cb; }
        const RawPacket601JoinMulticastGroupRF& operator ->() const { return cb; }
        RawPacket601JoinMulticastGroupCB(const RawPacket601JoinMulticastGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket601JoinMulticastGroupRsp :
      public RawPacket601JoinMulticastGroupCB {
        RawPacket601JoinMulticastGroupRsp(const RawPacket601JoinMulticastGroupRF& cb)
          : RawPacket601JoinMulticastGroupCB(cb) { }

    };

    virtual void async_raw_packet6_0_1_join_multicast_group
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv6&	group_address,
	RawPacket601JoinMulticastGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Leave an IPv6 multicast group.
     *
     *  @param xrl_target_instance_name the receiver's XRL target instance
     *  name.
     *
     *  @param if_name the interface through which packets should not be
     *  accepted.
     *
     *  @param vif_name the vif through which packets should not be accepted.
     *
     *  @param ip_protocol the IP protocol number that the receiver is not
     *  interested in anymore. It must be between 0 and 255. A protocol number
     *  of 0 is used to specify all protocols.
     *
     *  @param group_address the multicast group address to leave.
     */
    virtual XrlCmdError raw_packet6_0_1_leave_multicast_group(
	// Input values,
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv6&	group_address) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket601LeaveMulticastGroupRF;

    class RawPacket601LeaveMulticastGroupCB {
        RawPacket601LeaveMulticastGroupRF cb;

    public:
        operator const RawPacket601LeaveMulticastGroupRF& () const { return cb; }
        const RawPacket601LeaveMulticastGroupRF& operator ->() const { return cb; }
        RawPacket601LeaveMulticastGroupCB(const RawPacket601LeaveMulticastGroupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket601LeaveMulticastGroupRsp :
      public RawPacket601LeaveMulticastGroupCB {
        RawPacket601LeaveMulticastGroupRsp(const RawPacket601LeaveMulticastGroupRF& cb)
          : RawPacket601LeaveMulticastGroupCB(cb) { }

    };

    virtual void async_raw_packet6_0_1_leave_multicast_group
       (
	const string&	xrl_target_instance_name,
	const string&	if_name,
	const string&	vif_name,
	const uint32_t&	ip_protocol,
	const IPv6&	group_address,
	RawPacket601LeaveMulticastGroupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_enable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01EnableRF;

    class Profile01EnableCB {
        Profile01EnableRF cb;

    public:
        operator const Profile01EnableRF& () const { return cb; }
        const Profile01EnableRF& operator ->() const { return cb; }
        Profile01EnableCB(const Profile01EnableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01EnableRsp :
      public Profile01EnableCB {
        Profile01EnableRsp(const Profile01EnableRF& cb)
          : Profile01EnableCB(cb) { }

    };

    virtual void async_profile_0_1_enable
       (
	const string&	pname,
	Profile01EnableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_disable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01DisableRF;

    class Profile01DisableCB {
        Profile01DisableRF cb;

    public:
        operator const Profile01DisableRF& () const { return cb; }
        const Profile01DisableRF& operator ->() const { return cb; }
        Profile01DisableCB(const Profile01DisableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01DisableRsp :
      public Profile01DisableCB {
        Profile01DisableRsp(const Profile01DisableRF& cb)
          : Profile01DisableCB(cb) { }

    };

    virtual void async_profile_0_1_disable
       (
	const string&	pname,
	Profile01DisableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get log entries.
     *
     *  @param pname profile variable
     *
     *  @param instance_name to send the profiling info to.
     */
    virtual XrlCmdError profile_0_1_get_entries(
	// Input values,
	const string&	pname,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01GetEntriesRF;

    class Profile01GetEntriesCB {
        Profile01GetEntriesRF cb;

    public:
        operator const Profile01GetEntriesRF& () const { return cb; }
        const Profile01GetEntriesRF& operator ->() const { return cb; }
        Profile01GetEntriesCB(const Profile01GetEntriesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01GetEntriesRsp :
      public Profile01GetEntriesCB {
        Profile01GetEntriesRsp(const Profile01GetEntriesRF& cb)
          : Profile01GetEntriesCB(cb) { }

    };

    virtual void async_profile_0_1_get_entries
       (
	const string&	pname,
	const string&	instance_name,
	Profile01GetEntriesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the profiling entries
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_clear(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01ClearRF;

    class Profile01ClearCB {
        Profile01ClearRF cb;

    public:
        operator const Profile01ClearRF& () const { return cb; }
        const Profile01ClearRF& operator ->() const { return cb; }
        Profile01ClearCB(const Profile01ClearRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01ClearRsp :
      public Profile01ClearCB {
        Profile01ClearRsp(const Profile01ClearRF& cb)
          : Profile01ClearCB(cb) { }

    };

    virtual void async_profile_0_1_clear
       (
	const string&	pname,
	Profile01ClearCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  List all the profiling variables registered with this target.
     */
    virtual XrlCmdError profile_0_1_list(
	// Output values,
	string&	info) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Profile01ListRF;

    class Profile01ListCB {
        Profile01ListRF cb;

    public:
        operator const Profile01ListRF& () const { return cb; }
        const Profile01ListRF& operator ->() const { return cb; }
        Profile01ListCB(const Profile01ListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_info) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_info);
        }
    };

    struct Profile01ListRsp :
      public Profile01ListCB {
        struct args_str {
            string info;
        };

    private:
        args_str args;

    public:
        Profile01ListRsp(const Profile01ListRF& cb)
          : Profile01ListCB(cb) { }

        void respond() const {
            Profile01ListCB::
            respond(args.info);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_profile_0_1_list
       (
	Profile01ListCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_fib_0_1_add_fib_client4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_fib_0_1_add_fib_client4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_fib_0_1_delete_fib_client4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_fib_0_1_delete_fib_client4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_fib_0_1_add_fib_client6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_fib_0_1_add_fib_client6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_fib_0_1_delete_fib_client6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_fib_0_1_delete_fib_client6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_start_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_start_transaction
       (const XrlCmdError &e,
	const uint32_t* arg_tid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_commit_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_commit_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_abort_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_abort_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_add_entry4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_add_entry4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_replace_entry4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_replace_entry4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_delete_entry4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_delete_entry4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_delete_all_entries4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_delete_all_entries4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_get_entry_list_start4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_get_entry_list_start4
       (const XrlCmdError &e,
	const uint32_t* arg_token,
	const bool* arg_more,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_get_entry_list_next4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_get_entry_list_next4
       (const XrlCmdError &e,
	const uint32_t* arg_rule_number,
	const string* arg_ifname,
	const string* arg_vifname,
	const IPv4Net* arg_src_network,
	const IPv4Net* arg_dst_network,
	const uint32_t* arg_ip_protocol,
	const uint32_t* arg_src_port_begin,
	const uint32_t* arg_src_port_end,
	const uint32_t* arg_dst_port_begin,
	const uint32_t* arg_dst_port_end,
	const string* arg_action,
	const bool* arg_more,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_add_entry6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_add_entry6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_replace_entry6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_replace_entry6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_delete_entry6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_delete_entry6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_delete_all_entries6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_delete_all_entries6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_get_entry_list_start6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_get_entry_list_start6
       (const XrlCmdError &e,
	const uint32_t* arg_token,
	const bool* arg_more,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_get_entry_list_next6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_get_entry_list_next6
       (const XrlCmdError &e,
	const uint32_t* arg_rule_number,
	const string* arg_ifname,
	const string* arg_vifname,
	const IPv6Net* arg_src_network,
	const IPv6Net* arg_dst_network,
	const uint32_t* arg_ip_protocol,
	const uint32_t* arg_src_port_begin,
	const uint32_t* arg_src_port_end,
	const uint32_t* arg_dst_port_begin,
	const uint32_t* arg_dst_port_end,
	const string* arg_action,
	const bool* arg_more,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fea_firewall_0_1_startup_firewall(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fea_firewall_0_1_startup_firewall
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_restore_original_config_on_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_restore_original_config_on_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_interface_names(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_interface_names
       (const XrlCmdError &e,
	const XrlAtomList* arg_ifnames,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_vif_names(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_vif_names
       (const XrlCmdError &e,
	const XrlAtomList* arg_vifs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_vif_flags(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_vif_flags
       (const XrlCmdError &e,
	const bool* arg_enabled,
	const bool* arg_broadcast,
	const bool* arg_loopback,
	const bool* arg_point_to_point,
	const bool* arg_multicast,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_vif_pif_index(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_vif_pif_index
       (const XrlCmdError &e,
	const uint32_t* arg_pif_index,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_vif_addresses4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_vif_addresses4
       (const XrlCmdError &e,
	const XrlAtomList* arg_addresses,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_address_flags4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_address_flags4
       (const XrlCmdError &e,
	const bool* arg_enabled,
	const bool* arg_broadcast,
	const bool* arg_loopback,
	const bool* arg_point_to_point,
	const bool* arg_multicast,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_interface_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_interface_enabled
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_interface_discard(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_interface_discard
       (const XrlCmdError &e,
	const bool* arg_discard,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_interface_unreachable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_interface_unreachable
       (const XrlCmdError &e,
	const bool* arg_unreachable,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_interface_management(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_interface_management
       (const XrlCmdError &e,
	const bool* arg_management,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_mac(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_mac
       (const XrlCmdError &e,
	const Mac* arg_mac,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_mtu(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_mtu
       (const XrlCmdError &e,
	const uint32_t* arg_mtu,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_no_carrier(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_no_carrier
       (const XrlCmdError &e,
	const bool* arg_no_carrier,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_baudrate(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_baudrate
       (const XrlCmdError &e,
	const uint64_t* arg_baudrate,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_vif_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_vif_enabled
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_prefix4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_prefix4
       (const XrlCmdError &e,
	const uint32_t* arg_prefix_len,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_broadcast4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_broadcast4
       (const XrlCmdError &e,
	const IPv4* arg_broadcast,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_endpoint4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_endpoint4
       (const XrlCmdError &e,
	const IPv4* arg_endpoint,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_start_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_start_transaction
       (const XrlCmdError &e,
	const uint32_t* arg_tid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_commit_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_commit_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_abort_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_abort_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_create_interface(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_create_interface
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_delete_interface(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_delete_interface
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_configure_all_interfaces_from_system(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_configure_all_interfaces_from_system
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_configure_interface_from_system(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_configure_interface_from_system
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_interface_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_interface_enabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_interface_discard(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_interface_discard
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_interface_unreachable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_interface_unreachable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_interface_management(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_interface_management
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_mac(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_mac
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_create_mac(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_create_mac
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_delete_mac(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_delete_mac
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_restore_original_mac(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_restore_original_mac
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_mtu(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_mtu
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_restore_original_mtu(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_restore_original_mtu
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_create_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_create_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_delete_vif(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_delete_vif
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_vif_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_vif_enabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_parent_ifname(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_parent_ifname
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_iface_type(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_iface_type
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_vid(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_vid
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_create_address4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_create_address4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_delete_address4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_delete_address4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_create_address_atomic(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_create_address_atomic
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_delete_address_atomic(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_delete_address_atomic
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_address_enabled4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_address_enabled4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_address_enabled4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_address_enabled4
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_prefix4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_prefix4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_broadcast4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_broadcast4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_endpoint4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_endpoint4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_startup_ifmgr(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_startup_ifmgr
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_vif_addresses6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_vif_addresses6
       (const XrlCmdError &e,
	const XrlAtomList* arg_addresses,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_address_flags6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_address_flags6
       (const XrlCmdError &e,
	const bool* arg_enabled,
	const bool* arg_loopback,
	const bool* arg_point_to_point,
	const bool* arg_multicast,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_prefix6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_prefix6
       (const XrlCmdError &e,
	const uint32_t* arg_prefix_len,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_endpoint6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_endpoint6
       (const XrlCmdError &e,
	const IPv6* arg_endpoint,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_create_address6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_create_address6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_delete_address6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_delete_address6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_address_enabled6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_address_enabled6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_get_configured_address_enabled6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_get_configured_address_enabled6
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_prefix6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_prefix6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_0_1_set_endpoint6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_0_1_set_endpoint6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_replicator_0_1_register_ifmgr_mirror(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_replicator_0_1_register_ifmgr_mirror
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ifmgr_replicator_0_1_unregister_ifmgr_mirror(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ifmgr_replicator_0_1_unregister_ifmgr_mirror
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_lookup_route_by_dest4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_lookup_route_by_dest4
       (const XrlCmdError &e,
	const IPv4Net* arg_netmask,
	const IPv4* arg_nexthop,
	const string* arg_ifname,
	const string* arg_vifname,
	const uint32_t* arg_metric,
	const uint32_t* arg_admin_distance,
	const string* arg_protocol_origin,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_lookup_route_by_network4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_lookup_route_by_network4
       (const XrlCmdError &e,
	const IPv4* arg_nexthop,
	const string* arg_ifname,
	const string* arg_vifname,
	const uint32_t* arg_metric,
	const uint32_t* arg_admin_distance,
	const string* arg_protocol_origin,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_have_ipv4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_have_ipv4
       (const XrlCmdError &e,
	const bool* arg_result,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_get_unicast_forwarding_enabled4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_get_unicast_forwarding_enabled4
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_enabled4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_enabled4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_entries_retain_on_startup4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_table_id4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_table_id4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_lookup_route_by_dest6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_lookup_route_by_dest6
       (const XrlCmdError &e,
	const IPv6Net* arg_netmask,
	const IPv6* arg_nexthop,
	const string* arg_ifname,
	const string* arg_vifname,
	const uint32_t* arg_metric,
	const uint32_t* arg_admin_distance,
	const string* arg_protocol_origin,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_lookup_route_by_network6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_lookup_route_by_network6
       (const XrlCmdError &e,
	const IPv6* arg_nexthop,
	const string* arg_ifname,
	const string* arg_vifname,
	const uint32_t* arg_metric,
	const uint32_t* arg_admin_distance,
	const string* arg_protocol_origin,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_have_ipv6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_have_ipv6
       (const XrlCmdError &e,
	const bool* arg_result,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_get_unicast_forwarding_enabled6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_get_unicast_forwarding_enabled6
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_enabled6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_enabled6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_entries_retain_on_startup6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_entries_retain_on_shutdown6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_fti_0_2_set_unicast_forwarding_table_id6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_fti_0_2_set_unicast_forwarding_table_id6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_start_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_start_transaction
       (const XrlCmdError &e,
	const uint32_t* arg_tid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_commit_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_commit_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_abort_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_abort_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_add_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_add_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_delete_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_delete_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction4_0_1_delete_all_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction4_0_1_delete_all_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_link_0_1_send(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_link_0_1_send
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_link_0_1_register_receiver(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_link_0_1_register_receiver
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_link_0_1_unregister_receiver(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_link_0_1_unregister_receiver
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_link_0_1_join_multicast_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_link_0_1_join_multicast_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_link_0_1_leave_multicast_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_link_0_1_leave_multicast_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_0_1_send(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_0_1_send
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_0_1_register_receiver(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_0_1_register_receiver
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_0_1_unregister_receiver(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_0_1_unregister_receiver
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_0_1_join_multicast_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_0_1_join_multicast_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_0_1_leave_multicast_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_0_1_leave_multicast_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_tcp_open(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_tcp_open
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_open(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_open
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_tcp_open_and_bind(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_tcp_open_and_bind
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_open_and_bind(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_open_and_bind
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_open_bind_join(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_open_bind_join
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_tcp_open_bind_connect(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_tcp_open_bind_connect
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_open_bind_connect(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_open_bind_connect
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_open_bind_broadcast(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_open_bind_broadcast
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_bind(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_bind
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_join_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_join_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_leave_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_leave_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_close(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_close
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_tcp_listen(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_tcp_listen
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_udp_enable_recv(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_udp_enable_recv
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_send(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_send
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_send_to(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_send_to
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_send_from_multicast_if(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_send_from_multicast_if
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_set_socket_option(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_set_socket_option
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket4_0_1_set_socket_option_txt(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket4_0_1_set_socket_option_txt
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_start_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_start_transaction
       (const XrlCmdError &e,
	const uint32_t* arg_tid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_commit_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_commit_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_abort_transaction(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_abort_transaction
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_add_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_add_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_delete_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_delete_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_redist_transaction6_0_1_delete_all_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_redist_transaction6_0_1_delete_all_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_tcp_open(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_tcp_open
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_udp_open(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_udp_open
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_tcp_open_and_bind(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_tcp_open_and_bind
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_udp_open_and_bind(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_udp_open_and_bind
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_udp_open_bind_join(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_udp_open_bind_join
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_tcp_open_bind_connect(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_tcp_open_bind_connect
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_udp_open_bind_connect(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_udp_open_bind_connect
       (const XrlCmdError &e,
	const string* arg_sockid,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_bind(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_bind
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_udp_join_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_udp_join_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_udp_leave_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_udp_leave_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_close(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_close
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_tcp_listen(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_tcp_listen
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_send(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_send
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_send_to(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_send_to
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_send_from_multicast_if(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_send_from_multicast_if
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_0_1_set_socket_option(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_0_1_set_socket_option
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_0_1_send(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_0_1_send
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_0_1_register_receiver(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_0_1_register_receiver
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_0_1_unregister_receiver(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_0_1_unregister_receiver
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_0_1_join_multicast_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_0_1_join_multicast_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_0_1_leave_multicast_group(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_0_1_leave_multicast_group
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_enable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_enable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_disable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_disable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_get_entries(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_get_entries
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_clear(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_clear
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_list
       (const XrlCmdError &e,
	const string* arg_info,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlFeaTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_FEA_BASE_HH__
