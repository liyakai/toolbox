/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/ospfv3_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_OSPFV3_BASE_HH__
#define __XRL_TARGETS_OSPFV3_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlOspfv3Target"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlOspfv3TargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlOspfv3TargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlOspfv3TargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "ospfv3/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Receive an IPv4 packet from a raw socket.
     *
     *  @param if_name the interface name the packet arrived on.
     *
     *  @param vif_name the vif name the packet arrived on.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, then
     *  the received value is unknown.
     *
     *  @param ip_tos the Type of Service (Diffserv/ECN bits for IPv4). If it
     *  has a negative value, then the received value is unknown.
     *
     *  @param ip_router_alert if true, the IP Router Alert option was included
     *  in the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet4_client_0_1_recv(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket4Client01RecvRF;

    class RawPacket4Client01RecvCB {
        RawPacket4Client01RecvRF cb;

    public:
        operator const RawPacket4Client01RecvRF& () const { return cb; }
        const RawPacket4Client01RecvRF& operator ->() const { return cb; }
        RawPacket4Client01RecvCB(const RawPacket4Client01RecvRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket4Client01RecvRsp :
      public RawPacket4Client01RecvCB {
        RawPacket4Client01RecvRsp(const RawPacket4Client01RecvRF& cb)
          : RawPacket4Client01RecvCB(cb) { }

    };

    virtual void async_raw_packet4_client_0_1_recv
       (
	const string&	if_name,
	const string&	vif_name,
	const IPv4&	src_address,
	const IPv4&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const vector<uint8_t>&	payload,
	RawPacket4Client01RecvCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Receive an IPv6 packet from a raw socket.
     *
     *  @param if_name the interface name the packet arrived on.
     *
     *  @param vif_name the vif name the packet arrived on.
     *
     *  @param src_address the IP source address.
     *
     *  @param dst_address the IP destination address.
     *
     *  @param ip_protocol the IP protocol number.
     *
     *  @param ip_ttl the IP TTL (hop-limit). If it has a negative value, then
     *  the received value is unknown.
     *
     *  @param ip_tos the Type Of Service (IP traffic class for IPv4). If it
     *  has a negative value, then the received value is unknown.
     *
     *  @param ip_router_alert if true, the IP Router Alert option was included
     *  in the IP packet.
     *
     *  @param ip_internet_control if true, then this is IP control traffic.
     *
     *  @param ext_headers_type a list of u32 integers with the types of the
     *  optional extention headers.
     *
     *  @param ext_headers_payload a list of payload data, one for each
     *  optional extention header. The number of entries must match
     *  ext_headers_type.
     *
     *  @param payload the payload, everything after the IP header and options.
     */
    virtual XrlCmdError raw_packet6_client_0_1_recv(
	// Input values,
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RawPacket6Client01RecvRF;

    class RawPacket6Client01RecvCB {
        RawPacket6Client01RecvRF cb;

    public:
        operator const RawPacket6Client01RecvRF& () const { return cb; }
        const RawPacket6Client01RecvRF& operator ->() const { return cb; }
        RawPacket6Client01RecvCB(const RawPacket6Client01RecvRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RawPacket6Client01RecvRsp :
      public RawPacket6Client01RecvCB {
        RawPacket6Client01RecvRsp(const RawPacket6Client01RecvRF& cb)
          : RawPacket6Client01RecvCB(cb) { }

    };

    virtual void async_raw_packet6_client_0_1_recv
       (
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_address,
	const IPv6&	dst_address,
	const uint32_t&	ip_protocol,
	const int32_t&	ip_ttl,
	const int32_t&	ip_tos,
	const bool&	ip_router_alert,
	const bool&	ip_internet_control,
	const XrlAtomList&	ext_headers_type,
	const XrlAtomList&	ext_headers_payload,
	const vector<uint8_t>&	payload,
	RawPacket6Client01RecvCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv6 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist6_0_1_add_route6(
	// Input values,
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist601AddRoute6RF;

    class PolicyRedist601AddRoute6CB {
        PolicyRedist601AddRoute6RF cb;

    public:
        operator const PolicyRedist601AddRoute6RF& () const { return cb; }
        const PolicyRedist601AddRoute6RF& operator ->() const { return cb; }
        PolicyRedist601AddRoute6CB(const PolicyRedist601AddRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist601AddRoute6Rsp :
      public PolicyRedist601AddRoute6CB {
        PolicyRedist601AddRoute6Rsp(const PolicyRedist601AddRoute6RF& cb)
          : PolicyRedist601AddRoute6CB(cb) { }

    };

    virtual void async_policy_redist6_0_1_add_route6
       (
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist601AddRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv6 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist6_0_1_delete_route6(
	// Input values,
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist601DeleteRoute6RF;

    class PolicyRedist601DeleteRoute6CB {
        PolicyRedist601DeleteRoute6RF cb;

    public:
        operator const PolicyRedist601DeleteRoute6RF& () const { return cb; }
        const PolicyRedist601DeleteRoute6RF& operator ->() const { return cb; }
        PolicyRedist601DeleteRoute6CB(const PolicyRedist601DeleteRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist601DeleteRoute6Rsp :
      public PolicyRedist601DeleteRoute6CB {
        PolicyRedist601DeleteRoute6Rsp(const PolicyRedist601DeleteRoute6RF& cb)
          : PolicyRedist601DeleteRoute6CB(cb) { }

    };

    virtual void async_policy_redist6_0_1_delete_route6
       (
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist601DeleteRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set instance id
     */
    virtual XrlCmdError ospfv3_0_1_set_instance_id(
	// Input values,
	const uint32_t&	id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetInstanceIdRF;

    class Ospfv301SetInstanceIdCB {
        Ospfv301SetInstanceIdRF cb;

    public:
        operator const Ospfv301SetInstanceIdRF& () const { return cb; }
        const Ospfv301SetInstanceIdRF& operator ->() const { return cb; }
        Ospfv301SetInstanceIdCB(const Ospfv301SetInstanceIdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetInstanceIdRsp :
      public Ospfv301SetInstanceIdCB {
        Ospfv301SetInstanceIdRsp(const Ospfv301SetInstanceIdRF& cb)
          : Ospfv301SetInstanceIdCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_instance_id
       (
	const uint32_t&	id,
	Ospfv301SetInstanceIdCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set router id
     */
    virtual XrlCmdError ospfv3_0_1_set_router_id(
	// Input values,
	const IPv4&	id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetRouterIdRF;

    class Ospfv301SetRouterIdCB {
        Ospfv301SetRouterIdRF cb;

    public:
        operator const Ospfv301SetRouterIdRF& () const { return cb; }
        const Ospfv301SetRouterIdRF& operator ->() const { return cb; }
        Ospfv301SetRouterIdCB(const Ospfv301SetRouterIdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetRouterIdRsp :
      public Ospfv301SetRouterIdCB {
        Ospfv301SetRouterIdRsp(const Ospfv301SetRouterIdRF& cb)
          : Ospfv301SetRouterIdCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_router_id
       (
	const IPv4&	id,
	Ospfv301SetRouterIdCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the router alert in the IP options.
     */
    virtual XrlCmdError ospfv3_0_1_set_ip_router_alert(
	// Input values,
	const bool&	ip_router_alert) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetIpRouterAlertRF;

    class Ospfv301SetIpRouterAlertCB {
        Ospfv301SetIpRouterAlertRF cb;

    public:
        operator const Ospfv301SetIpRouterAlertRF& () const { return cb; }
        const Ospfv301SetIpRouterAlertRF& operator ->() const { return cb; }
        Ospfv301SetIpRouterAlertCB(const Ospfv301SetIpRouterAlertRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetIpRouterAlertRsp :
      public Ospfv301SetIpRouterAlertCB {
        Ospfv301SetIpRouterAlertRsp(const Ospfv301SetIpRouterAlertRF& cb)
          : Ospfv301SetIpRouterAlertCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_ip_router_alert
       (
	const bool&	ip_router_alert,
	Ospfv301SetIpRouterAlertCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create an area.
     *
     *  @param area id of the area
     *
     *  @param type of area "border", "stub", "nssa"
     */
    virtual XrlCmdError ospfv3_0_1_create_area_router(
	// Input values,
	const IPv4&	area,
	const string&	type) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301CreateAreaRouterRF;

    class Ospfv301CreateAreaRouterCB {
        Ospfv301CreateAreaRouterRF cb;

    public:
        operator const Ospfv301CreateAreaRouterRF& () const { return cb; }
        const Ospfv301CreateAreaRouterRF& operator ->() const { return cb; }
        Ospfv301CreateAreaRouterCB(const Ospfv301CreateAreaRouterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301CreateAreaRouterRsp :
      public Ospfv301CreateAreaRouterCB {
        Ospfv301CreateAreaRouterRsp(const Ospfv301CreateAreaRouterRF& cb)
          : Ospfv301CreateAreaRouterCB(cb) { }

    };

    virtual void async_ospfv3_0_1_create_area_router
       (
	const IPv4&	area,
	const string&	type,
	Ospfv301CreateAreaRouterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change area type.
     *
     *  @param area id of the area
     *
     *  @param type of area "border", "stub", "nssa"
     */
    virtual XrlCmdError ospfv3_0_1_change_area_router_type(
	// Input values,
	const IPv4&	area,
	const string&	type) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301ChangeAreaRouterTypeRF;

    class Ospfv301ChangeAreaRouterTypeCB {
        Ospfv301ChangeAreaRouterTypeRF cb;

    public:
        operator const Ospfv301ChangeAreaRouterTypeRF& () const { return cb; }
        const Ospfv301ChangeAreaRouterTypeRF& operator ->() const { return cb; }
        Ospfv301ChangeAreaRouterTypeCB(const Ospfv301ChangeAreaRouterTypeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301ChangeAreaRouterTypeRsp :
      public Ospfv301ChangeAreaRouterTypeCB {
        Ospfv301ChangeAreaRouterTypeRsp(const Ospfv301ChangeAreaRouterTypeRF& cb)
          : Ospfv301ChangeAreaRouterTypeCB(cb) { }

    };

    virtual void async_ospfv3_0_1_change_area_router_type
       (
	const IPv4&	area,
	const string&	type,
	Ospfv301ChangeAreaRouterTypeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Destroy area.
     *
     *  @param area id of the area
     */
    virtual XrlCmdError ospfv3_0_1_destroy_area_router(
	// Input values,
	const IPv4&	area) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301DestroyAreaRouterRF;

    class Ospfv301DestroyAreaRouterCB {
        Ospfv301DestroyAreaRouterRF cb;

    public:
        operator const Ospfv301DestroyAreaRouterRF& () const { return cb; }
        const Ospfv301DestroyAreaRouterRF& operator ->() const { return cb; }
        Ospfv301DestroyAreaRouterCB(const Ospfv301DestroyAreaRouterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301DestroyAreaRouterRsp :
      public Ospfv301DestroyAreaRouterCB {
        Ospfv301DestroyAreaRouterRsp(const Ospfv301DestroyAreaRouterRF& cb)
          : Ospfv301DestroyAreaRouterCB(cb) { }

    };

    virtual void async_ospfv3_0_1_destroy_area_router
       (
	const IPv4&	area,
	Ospfv301DestroyAreaRouterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a binding to an interface.
     *
     *  @param ifname the interface.
     *
     *  @param vifname virtual interface.
     *
     *  @param type of link "p2p", "broadcast", "nbma", "p2m", "vlink"
     *
     *  @param area id of the area
     */
    virtual XrlCmdError ospfv3_0_1_create_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const string&	type,
	const IPv4&	area) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301CreatePeerRF;

    class Ospfv301CreatePeerCB {
        Ospfv301CreatePeerRF cb;

    public:
        operator const Ospfv301CreatePeerRF& () const { return cb; }
        const Ospfv301CreatePeerRF& operator ->() const { return cb; }
        Ospfv301CreatePeerCB(const Ospfv301CreatePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301CreatePeerRsp :
      public Ospfv301CreatePeerCB {
        Ospfv301CreatePeerRsp(const Ospfv301CreatePeerRF& cb)
          : Ospfv301CreatePeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_create_peer
       (
	const string&	ifname,
	const string&	vifname,
	const string&	type,
	const IPv4&	area,
	Ospfv301CreatePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete peer.
     */
    virtual XrlCmdError ospfv3_0_1_delete_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301DeletePeerRF;

    class Ospfv301DeletePeerCB {
        Ospfv301DeletePeerRF cb;

    public:
        operator const Ospfv301DeletePeerRF& () const { return cb; }
        const Ospfv301DeletePeerRF& operator ->() const { return cb; }
        Ospfv301DeletePeerCB(const Ospfv301DeletePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301DeletePeerRsp :
      public Ospfv301DeletePeerCB {
        Ospfv301DeletePeerRsp(const Ospfv301DeletePeerRF& cb)
          : Ospfv301DeletePeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_delete_peer
       (
	const string&	ifname,
	const string&	vifname,
	Ospfv301DeletePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the peer state up or down.
     */
    virtual XrlCmdError ospfv3_0_1_set_peer_state(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetPeerStateRF;

    class Ospfv301SetPeerStateCB {
        Ospfv301SetPeerStateRF cb;

    public:
        operator const Ospfv301SetPeerStateRF& () const { return cb; }
        const Ospfv301SetPeerStateRF& operator ->() const { return cb; }
        Ospfv301SetPeerStateCB(const Ospfv301SetPeerStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetPeerStateRsp :
      public Ospfv301SetPeerStateCB {
        Ospfv301SetPeerStateRsp(const Ospfv301SetPeerStateRF& cb)
          : Ospfv301SetPeerStateCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_peer_state
       (
	const string&	ifname,
	const string&	vifname,
	const bool&	enable,
	Ospfv301SetPeerStateCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add an address to the peer.
     */
    virtual XrlCmdError ospfv3_0_1_add_address_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301AddAddressPeerRF;

    class Ospfv301AddAddressPeerCB {
        Ospfv301AddAddressPeerRF cb;

    public:
        operator const Ospfv301AddAddressPeerRF& () const { return cb; }
        const Ospfv301AddAddressPeerRF& operator ->() const { return cb; }
        Ospfv301AddAddressPeerCB(const Ospfv301AddAddressPeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301AddAddressPeerRsp :
      public Ospfv301AddAddressPeerCB {
        Ospfv301AddAddressPeerRsp(const Ospfv301AddAddressPeerRF& cb)
          : Ospfv301AddAddressPeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_add_address_peer
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	addr,
	Ospfv301AddAddressPeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Remove an address from the peer.
     */
    virtual XrlCmdError ospfv3_0_1_remove_address_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301RemoveAddressPeerRF;

    class Ospfv301RemoveAddressPeerCB {
        Ospfv301RemoveAddressPeerRF cb;

    public:
        operator const Ospfv301RemoveAddressPeerRF& () const { return cb; }
        const Ospfv301RemoveAddressPeerRF& operator ->() const { return cb; }
        Ospfv301RemoveAddressPeerCB(const Ospfv301RemoveAddressPeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301RemoveAddressPeerRsp :
      public Ospfv301RemoveAddressPeerCB {
        Ospfv301RemoveAddressPeerRsp(const Ospfv301RemoveAddressPeerRF& cb)
          : Ospfv301RemoveAddressPeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_remove_address_peer
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	addr,
	Ospfv301RemoveAddressPeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the address state up or down.
     */
    virtual XrlCmdError ospfv3_0_1_set_address_state_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	addr,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetAddressStatePeerRF;

    class Ospfv301SetAddressStatePeerCB {
        Ospfv301SetAddressStatePeerRF cb;

    public:
        operator const Ospfv301SetAddressStatePeerRF& () const { return cb; }
        const Ospfv301SetAddressStatePeerRF& operator ->() const { return cb; }
        Ospfv301SetAddressStatePeerCB(const Ospfv301SetAddressStatePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetAddressStatePeerRsp :
      public Ospfv301SetAddressStatePeerCB {
        Ospfv301SetAddressStatePeerRsp(const Ospfv301SetAddressStatePeerRF& cb)
          : Ospfv301SetAddressStatePeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_address_state_peer
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	addr,
	const bool&	enable,
	Ospfv301SetAddressStatePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Activate peer. Called once the peer and child nodes have been
     *  configured.
     */
    virtual XrlCmdError ospfv3_0_1_activate_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301ActivatePeerRF;

    class Ospfv301ActivatePeerCB {
        Ospfv301ActivatePeerRF cb;

    public:
        operator const Ospfv301ActivatePeerRF& () const { return cb; }
        const Ospfv301ActivatePeerRF& operator ->() const { return cb; }
        Ospfv301ActivatePeerCB(const Ospfv301ActivatePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301ActivatePeerRsp :
      public Ospfv301ActivatePeerCB {
        Ospfv301ActivatePeerRsp(const Ospfv301ActivatePeerRF& cb)
          : Ospfv301ActivatePeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_activate_peer
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	Ospfv301ActivatePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Update peer. Called if the peer and child nodes are modified.
     */
    virtual XrlCmdError ospfv3_0_1_update_peer(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301UpdatePeerRF;

    class Ospfv301UpdatePeerCB {
        Ospfv301UpdatePeerRF cb;

    public:
        operator const Ospfv301UpdatePeerRF& () const { return cb; }
        const Ospfv301UpdatePeerRF& operator ->() const { return cb; }
        Ospfv301UpdatePeerCB(const Ospfv301UpdatePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301UpdatePeerRsp :
      public Ospfv301UpdatePeerCB {
        Ospfv301UpdatePeerRsp(const Ospfv301UpdatePeerRF& cb)
          : Ospfv301UpdatePeerCB(cb) { }

    };

    virtual void async_ospfv3_0_1_update_peer
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	Ospfv301UpdatePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add a neighbour to the peer.
     */
    virtual XrlCmdError ospfv3_0_1_add_neighbour(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	neighbour_address,
	const IPv4&	neighbour_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301AddNeighbourRF;

    class Ospfv301AddNeighbourCB {
        Ospfv301AddNeighbourRF cb;

    public:
        operator const Ospfv301AddNeighbourRF& () const { return cb; }
        const Ospfv301AddNeighbourRF& operator ->() const { return cb; }
        Ospfv301AddNeighbourCB(const Ospfv301AddNeighbourRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301AddNeighbourRsp :
      public Ospfv301AddNeighbourCB {
        Ospfv301AddNeighbourRsp(const Ospfv301AddNeighbourRF& cb)
          : Ospfv301AddNeighbourCB(cb) { }

    };

    virtual void async_ospfv3_0_1_add_neighbour
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	neighbour_address,
	const IPv4&	neighbour_id,
	Ospfv301AddNeighbourCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Remove a neighbour from the peer.
     */
    virtual XrlCmdError ospfv3_0_1_remove_neighbour(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	neighbour_address,
	const IPv4&	neighbour_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301RemoveNeighbourRF;

    class Ospfv301RemoveNeighbourCB {
        Ospfv301RemoveNeighbourRF cb;

    public:
        operator const Ospfv301RemoveNeighbourRF& () const { return cb; }
        const Ospfv301RemoveNeighbourRF& operator ->() const { return cb; }
        Ospfv301RemoveNeighbourCB(const Ospfv301RemoveNeighbourRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301RemoveNeighbourRsp :
      public Ospfv301RemoveNeighbourCB {
        Ospfv301RemoveNeighbourRsp(const Ospfv301RemoveNeighbourRF& cb)
          : Ospfv301RemoveNeighbourCB(cb) { }

    };

    virtual void async_ospfv3_0_1_remove_neighbour
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const IPv6&	neighbour_address,
	const IPv4&	neighbour_id,
	Ospfv301RemoveNeighbourCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Create a virtual link.
     *
     *  @param neighbour_id the router ID of the other end of the link.
     *
     *  @param area in which an attempt has been made to configure a virtual
     *  link it has to be the backbone. Its just being passed in so it can be
     *  checked by the protocol.
     */
    virtual XrlCmdError ospfv3_0_1_create_virtual_link(
	// Input values,
	const IPv4&	neighbour_id,
	const IPv4&	area) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301CreateVirtualLinkRF;

    class Ospfv301CreateVirtualLinkCB {
        Ospfv301CreateVirtualLinkRF cb;

    public:
        operator const Ospfv301CreateVirtualLinkRF& () const { return cb; }
        const Ospfv301CreateVirtualLinkRF& operator ->() const { return cb; }
        Ospfv301CreateVirtualLinkCB(const Ospfv301CreateVirtualLinkRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301CreateVirtualLinkRsp :
      public Ospfv301CreateVirtualLinkCB {
        Ospfv301CreateVirtualLinkRsp(const Ospfv301CreateVirtualLinkRF& cb)
          : Ospfv301CreateVirtualLinkCB(cb) { }

    };

    virtual void async_ospfv3_0_1_create_virtual_link
       (
	const IPv4&	neighbour_id,
	const IPv4&	area,
	Ospfv301CreateVirtualLinkCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete virtual link
     *
     *  @param neighbour_id the router ID of the other end of the link.
     */
    virtual XrlCmdError ospfv3_0_1_delete_virtual_link(
	// Input values,
	const IPv4&	neighbour_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301DeleteVirtualLinkRF;

    class Ospfv301DeleteVirtualLinkCB {
        Ospfv301DeleteVirtualLinkRF cb;

    public:
        operator const Ospfv301DeleteVirtualLinkRF& () const { return cb; }
        const Ospfv301DeleteVirtualLinkRF& operator ->() const { return cb; }
        Ospfv301DeleteVirtualLinkCB(const Ospfv301DeleteVirtualLinkRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301DeleteVirtualLinkRsp :
      public Ospfv301DeleteVirtualLinkCB {
        Ospfv301DeleteVirtualLinkRsp(const Ospfv301DeleteVirtualLinkRF& cb)
          : Ospfv301DeleteVirtualLinkCB(cb) { }

    };

    virtual void async_ospfv3_0_1_delete_virtual_link
       (
	const IPv4&	neighbour_id,
	Ospfv301DeleteVirtualLinkCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  The area through which the virtual link transits.
     *
     *  @param neighbour_id the router ID of the other end of the link.
     *
     *  @param transit_area that the virtual link transits.
     */
    virtual XrlCmdError ospfv3_0_1_transit_area_virtual_link(
	// Input values,
	const IPv4&	neighbour_id,
	const IPv4&	transit_area) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301TransitAreaVirtualLinkRF;

    class Ospfv301TransitAreaVirtualLinkCB {
        Ospfv301TransitAreaVirtualLinkRF cb;

    public:
        operator const Ospfv301TransitAreaVirtualLinkRF& () const { return cb; }
        const Ospfv301TransitAreaVirtualLinkRF& operator ->() const { return cb; }
        Ospfv301TransitAreaVirtualLinkCB(const Ospfv301TransitAreaVirtualLinkRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301TransitAreaVirtualLinkRsp :
      public Ospfv301TransitAreaVirtualLinkCB {
        Ospfv301TransitAreaVirtualLinkRsp(const Ospfv301TransitAreaVirtualLinkRF& cb)
          : Ospfv301TransitAreaVirtualLinkCB(cb) { }

    };

    virtual void async_ospfv3_0_1_transit_area_virtual_link
       (
	const IPv4&	neighbour_id,
	const IPv4&	transit_area,
	Ospfv301TransitAreaVirtualLinkCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  The edge cost of this interface.
     */
    virtual XrlCmdError ospfv3_0_1_set_interface_cost(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetInterfaceCostRF;

    class Ospfv301SetInterfaceCostCB {
        Ospfv301SetInterfaceCostRF cb;

    public:
        operator const Ospfv301SetInterfaceCostRF& () const { return cb; }
        const Ospfv301SetInterfaceCostRF& operator ->() const { return cb; }
        Ospfv301SetInterfaceCostCB(const Ospfv301SetInterfaceCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetInterfaceCostRsp :
      public Ospfv301SetInterfaceCostCB {
        Ospfv301SetInterfaceCostRsp(const Ospfv301SetInterfaceCostRF& cb)
          : Ospfv301SetInterfaceCostCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_interface_cost
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	cost,
	Ospfv301SetInterfaceCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  RxmtInterval The number of seconds between LSA retransmissions, for
     *  adjacencies belonging to this interface. Also used when retransmitting
     *  Database Description and Link State Request Packets. This should be
     *  well over the expected round-trip delay between any two routers on the
     *  attached network. The setting of this value should be conservative or
     *  needless retransmissions will result. Sample value for a local area
     *  network: 5 seconds.
     */
    virtual XrlCmdError ospfv3_0_1_set_retransmit_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetRetransmitIntervalRF;

    class Ospfv301SetRetransmitIntervalCB {
        Ospfv301SetRetransmitIntervalRF cb;

    public:
        operator const Ospfv301SetRetransmitIntervalRF& () const { return cb; }
        const Ospfv301SetRetransmitIntervalRF& operator ->() const { return cb; }
        Ospfv301SetRetransmitIntervalCB(const Ospfv301SetRetransmitIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetRetransmitIntervalRsp :
      public Ospfv301SetRetransmitIntervalCB {
        Ospfv301SetRetransmitIntervalRsp(const Ospfv301SetRetransmitIntervalRF& cb)
          : Ospfv301SetRetransmitIntervalCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_retransmit_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	interval,
	Ospfv301SetRetransmitIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  The estimated number of seconds it takes to transmit a Link State
     *  Update Packet over this interface. LSAs contained in the Link State
     *  Update packet will have their age incremented by this amount before
     *  transmission. This value should take into account transmission and
     *  propagation delays; it must be greater than zero.
     */
    virtual XrlCmdError ospfv3_0_1_set_inftransdelay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	delay) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetInftransdelayRF;

    class Ospfv301SetInftransdelayCB {
        Ospfv301SetInftransdelayRF cb;

    public:
        operator const Ospfv301SetInftransdelayRF& () const { return cb; }
        const Ospfv301SetInftransdelayRF& operator ->() const { return cb; }
        Ospfv301SetInftransdelayCB(const Ospfv301SetInftransdelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetInftransdelayRsp :
      public Ospfv301SetInftransdelayCB {
        Ospfv301SetInftransdelayRsp(const Ospfv301SetInftransdelayRF& cb)
          : Ospfv301SetInftransdelayCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_inftransdelay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	delay,
	Ospfv301SetInftransdelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Used in the designated router election.
     */
    virtual XrlCmdError ospfv3_0_1_set_router_priority(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	priority) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetRouterPriorityRF;

    class Ospfv301SetRouterPriorityCB {
        Ospfv301SetRouterPriorityRF cb;

    public:
        operator const Ospfv301SetRouterPriorityRF& () const { return cb; }
        const Ospfv301SetRouterPriorityRF& operator ->() const { return cb; }
        Ospfv301SetRouterPriorityCB(const Ospfv301SetRouterPriorityRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetRouterPriorityRsp :
      public Ospfv301SetRouterPriorityCB {
        Ospfv301SetRouterPriorityRsp(const Ospfv301SetRouterPriorityRF& cb)
          : Ospfv301SetRouterPriorityCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_router_priority
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	priority,
	Ospfv301SetRouterPriorityCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  The interval between hello messages.
     */
    virtual XrlCmdError ospfv3_0_1_set_hello_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetHelloIntervalRF;

    class Ospfv301SetHelloIntervalCB {
        Ospfv301SetHelloIntervalRF cb;

    public:
        operator const Ospfv301SetHelloIntervalRF& () const { return cb; }
        const Ospfv301SetHelloIntervalRF& operator ->() const { return cb; }
        Ospfv301SetHelloIntervalCB(const Ospfv301SetHelloIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetHelloIntervalRsp :
      public Ospfv301SetHelloIntervalCB {
        Ospfv301SetHelloIntervalRsp(const Ospfv301SetHelloIntervalRF& cb)
          : Ospfv301SetHelloIntervalCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_hello_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	interval,
	Ospfv301SetHelloIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  The period to wait before considering a router dead.
     */
    virtual XrlCmdError ospfv3_0_1_set_router_dead_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetRouterDeadIntervalRF;

    class Ospfv301SetRouterDeadIntervalCB {
        Ospfv301SetRouterDeadIntervalRF cb;

    public:
        operator const Ospfv301SetRouterDeadIntervalRF& () const { return cb; }
        const Ospfv301SetRouterDeadIntervalRF& operator ->() const { return cb; }
        Ospfv301SetRouterDeadIntervalCB(const Ospfv301SetRouterDeadIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetRouterDeadIntervalRsp :
      public Ospfv301SetRouterDeadIntervalCB {
        Ospfv301SetRouterDeadIntervalRsp(const Ospfv301SetRouterDeadIntervalRF& cb)
          : Ospfv301SetRouterDeadIntervalCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_router_dead_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const uint32_t&	interval,
	Ospfv301SetRouterDeadIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Toggle the passive status of an interface.
     */
    virtual XrlCmdError ospfv3_0_1_set_passive(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const bool&	passive) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SetPassiveRF;

    class Ospfv301SetPassiveCB {
        Ospfv301SetPassiveRF cb;

    public:
        operator const Ospfv301SetPassiveRF& () const { return cb; }
        const Ospfv301SetPassiveRF& operator ->() const { return cb; }
        Ospfv301SetPassiveCB(const Ospfv301SetPassiveRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SetPassiveRsp :
      public Ospfv301SetPassiveCB {
        Ospfv301SetPassiveRsp(const Ospfv301SetPassiveRF& cb)
          : Ospfv301SetPassiveCB(cb) { }

    };

    virtual void async_ospfv3_0_1_set_passive
       (
	const string&	ifname,
	const string&	vifname,
	const IPv4&	area,
	const bool&	passive,
	Ospfv301SetPassiveCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  If this is a "stub" or "nssa" area toggle the sending of a default
     *  route.
     */
    virtual XrlCmdError ospfv3_0_1_originate_default_route(
	// Input values,
	const IPv4&	area,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301OriginateDefaultRouteRF;

    class Ospfv301OriginateDefaultRouteCB {
        Ospfv301OriginateDefaultRouteRF cb;

    public:
        operator const Ospfv301OriginateDefaultRouteRF& () const { return cb; }
        const Ospfv301OriginateDefaultRouteRF& operator ->() const { return cb; }
        Ospfv301OriginateDefaultRouteCB(const Ospfv301OriginateDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301OriginateDefaultRouteRsp :
      public Ospfv301OriginateDefaultRouteCB {
        Ospfv301OriginateDefaultRouteRsp(const Ospfv301OriginateDefaultRouteRF& cb)
          : Ospfv301OriginateDefaultRouteCB(cb) { }

    };

    virtual void async_ospfv3_0_1_originate_default_route
       (
	const IPv4&	area,
	const bool&	enable,
	Ospfv301OriginateDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the StubDefaultCost, the default cost sent in a default route in a
     *  "stub" or "nssa" area.
     */
    virtual XrlCmdError ospfv3_0_1_stub_default_cost(
	// Input values,
	const IPv4&	area,
	const uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301StubDefaultCostRF;

    class Ospfv301StubDefaultCostCB {
        Ospfv301StubDefaultCostRF cb;

    public:
        operator const Ospfv301StubDefaultCostRF& () const { return cb; }
        const Ospfv301StubDefaultCostRF& operator ->() const { return cb; }
        Ospfv301StubDefaultCostCB(const Ospfv301StubDefaultCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301StubDefaultCostRsp :
      public Ospfv301StubDefaultCostCB {
        Ospfv301StubDefaultCostRsp(const Ospfv301StubDefaultCostRF& cb)
          : Ospfv301StubDefaultCostCB(cb) { }

    };

    virtual void async_ospfv3_0_1_stub_default_cost
       (
	const IPv4&	area,
	const uint32_t&	cost,
	Ospfv301StubDefaultCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Toggle the sending of summaries into "stub" or "nssa" areas.
     */
    virtual XrlCmdError ospfv3_0_1_summaries(
	// Input values,
	const IPv4&	area,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301SummariesRF;

    class Ospfv301SummariesCB {
        Ospfv301SummariesRF cb;

    public:
        operator const Ospfv301SummariesRF& () const { return cb; }
        const Ospfv301SummariesRF& operator ->() const { return cb; }
        Ospfv301SummariesCB(const Ospfv301SummariesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301SummariesRsp :
      public Ospfv301SummariesCB {
        Ospfv301SummariesRsp(const Ospfv301SummariesRF& cb)
          : Ospfv301SummariesCB(cb) { }

    };

    virtual void async_ospfv3_0_1_summaries
       (
	const IPv4&	area,
	const bool&	enable,
	Ospfv301SummariesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add area range.
     */
    virtual XrlCmdError ospfv3_0_1_area_range_add(
	// Input values,
	const IPv4&	area,
	const IPv6Net&	net,
	const bool&	advertise) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301AreaRangeAddRF;

    class Ospfv301AreaRangeAddCB {
        Ospfv301AreaRangeAddRF cb;

    public:
        operator const Ospfv301AreaRangeAddRF& () const { return cb; }
        const Ospfv301AreaRangeAddRF& operator ->() const { return cb; }
        Ospfv301AreaRangeAddCB(const Ospfv301AreaRangeAddRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301AreaRangeAddRsp :
      public Ospfv301AreaRangeAddCB {
        Ospfv301AreaRangeAddRsp(const Ospfv301AreaRangeAddRF& cb)
          : Ospfv301AreaRangeAddCB(cb) { }

    };

    virtual void async_ospfv3_0_1_area_range_add
       (
	const IPv4&	area,
	const IPv6Net&	net,
	const bool&	advertise,
	Ospfv301AreaRangeAddCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete area range.
     */
    virtual XrlCmdError ospfv3_0_1_area_range_delete(
	// Input values,
	const IPv4&	area,
	const IPv6Net&	net) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301AreaRangeDeleteRF;

    class Ospfv301AreaRangeDeleteCB {
        Ospfv301AreaRangeDeleteRF cb;

    public:
        operator const Ospfv301AreaRangeDeleteRF& () const { return cb; }
        const Ospfv301AreaRangeDeleteRF& operator ->() const { return cb; }
        Ospfv301AreaRangeDeleteCB(const Ospfv301AreaRangeDeleteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301AreaRangeDeleteRsp :
      public Ospfv301AreaRangeDeleteCB {
        Ospfv301AreaRangeDeleteRsp(const Ospfv301AreaRangeDeleteRF& cb)
          : Ospfv301AreaRangeDeleteCB(cb) { }

    };

    virtual void async_ospfv3_0_1_area_range_delete
       (
	const IPv4&	area,
	const IPv6Net&	net,
	Ospfv301AreaRangeDeleteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change the advertised state of this area.
     */
    virtual XrlCmdError ospfv3_0_1_area_range_change_state(
	// Input values,
	const IPv4&	area,
	const IPv6Net&	net,
	const bool&	advertise) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301AreaRangeChangeStateRF;

    class Ospfv301AreaRangeChangeStateCB {
        Ospfv301AreaRangeChangeStateRF cb;

    public:
        operator const Ospfv301AreaRangeChangeStateRF& () const { return cb; }
        const Ospfv301AreaRangeChangeStateRF& operator ->() const { return cb; }
        Ospfv301AreaRangeChangeStateCB(const Ospfv301AreaRangeChangeStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301AreaRangeChangeStateRsp :
      public Ospfv301AreaRangeChangeStateCB {
        Ospfv301AreaRangeChangeStateRsp(const Ospfv301AreaRangeChangeStateRF& cb)
          : Ospfv301AreaRangeChangeStateCB(cb) { }

    };

    virtual void async_ospfv3_0_1_area_range_change_state
       (
	const IPv4&	area,
	const IPv6Net&	net,
	const bool&	advertise,
	Ospfv301AreaRangeChangeStateCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/Disable tracing.
     *
     *  @param tvar trace variable.
     *
     *  @param enable set to true to enable false to disable.
     */
    virtual XrlCmdError ospfv3_0_1_trace(
	// Input values,
	const string&	tvar,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301TraceRF;

    class Ospfv301TraceCB {
        Ospfv301TraceRF cb;

    public:
        operator const Ospfv301TraceRF& () const { return cb; }
        const Ospfv301TraceRF& operator ->() const { return cb; }
        Ospfv301TraceCB(const Ospfv301TraceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301TraceRsp :
      public Ospfv301TraceCB {
        Ospfv301TraceRsp(const Ospfv301TraceRF& cb)
          : Ospfv301TraceCB(cb) { }

    };

    virtual void async_ospfv3_0_1_trace
       (
	const string&	tvar,
	const bool&	enable,
	Ospfv301TraceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get a single lsa from an area. A stateless mechanism to get LSAs. The
     *  client of this interface should start from zero and continue to request
     *  LSAs (incrementing index) until toohigh becomes true.
     *
     *  @param area database that is being searched.
     *
     *  @param index into database starting from 0.
     *
     *  @param valid true if a LSA has been returned. Some index values do not
     *  contain LSAs. This should not be considered an error.
     *
     *  @param toohigh true if no more LSA exist after this index.
     *
     *  @param self if true this LSA was originated by this router.
     *
     *  @param lsa if valid is true the LSA at index.
     */
    virtual XrlCmdError ospfv3_0_1_get_lsa(
	// Input values,
	const IPv4&	area,
	const uint32_t&	index,
	// Output values,
	bool&	valid,
	bool&	toohigh,
	bool&	self,
	vector<uint8_t>&	lsa) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const bool*,
	const bool*,
	const bool*,
	const vector<uint8_t>*>::RefPtr
    Ospfv301GetLsaRF;

    class Ospfv301GetLsaCB {
        Ospfv301GetLsaRF cb;

    public:
        operator const Ospfv301GetLsaRF& () const { return cb; }
        const Ospfv301GetLsaRF& operator ->() const { return cb; }
        Ospfv301GetLsaCB(const Ospfv301GetLsaRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const bool& arg_valid,
                     const bool& arg_toohigh,
                     const bool& arg_self,
                     const vector<uint8_t>& arg_lsa) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_valid,
                         &arg_toohigh,
                         &arg_self,
                         &arg_lsa);
        }
    };

    struct Ospfv301GetLsaRsp :
      public Ospfv301GetLsaCB {
        struct args_str {
            bool valid;
            bool toohigh;
            bool self;
            vector<uint8_t> lsa;
        };

    private:
        args_str args;

    public:
        Ospfv301GetLsaRsp(const Ospfv301GetLsaRF& cb)
          : Ospfv301GetLsaCB(cb) { }

        void respond() const {
            Ospfv301GetLsaCB::
            respond(args.valid,
                        args.toohigh,
                        args.self,
                        args.lsa);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ospfv3_0_1_get_lsa
       (
	const IPv4&	area,
	const uint32_t&	index,
	Ospfv301GetLsaCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get a list of all the configured areas. Return a list of u32 type
     *  values. Each value is an area ID.
     */
    virtual XrlCmdError ospfv3_0_1_get_area_list(
	// Output values,
	XrlAtomList&	areas) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ospfv301GetAreaListRF;

    class Ospfv301GetAreaListCB {
        Ospfv301GetAreaListRF cb;

    public:
        operator const Ospfv301GetAreaListRF& () const { return cb; }
        const Ospfv301GetAreaListRF& operator ->() const { return cb; }
        Ospfv301GetAreaListCB(const Ospfv301GetAreaListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_areas) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_areas);
        }
    };

    struct Ospfv301GetAreaListRsp :
      public Ospfv301GetAreaListCB {
        struct args_str {
            XrlAtomList areas;
        };

    private:
        args_str args;

    public:
        Ospfv301GetAreaListRsp(const Ospfv301GetAreaListRF& cb)
          : Ospfv301GetAreaListCB(cb) { }

        void respond() const {
            Ospfv301GetAreaListCB::
            respond(args.areas);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ospfv3_0_1_get_area_list
       (
	Ospfv301GetAreaListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of neighbours. Return a list of u32 type values. Each
     *  value is an internal identifier that can be used with the
     *  get_neighbour_info XRL.
     */
    virtual XrlCmdError ospfv3_0_1_get_neighbour_list(
	// Output values,
	XrlAtomList&	areas) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ospfv301GetNeighbourListRF;

    class Ospfv301GetNeighbourListCB {
        Ospfv301GetNeighbourListRF cb;

    public:
        operator const Ospfv301GetNeighbourListRF& () const { return cb; }
        const Ospfv301GetNeighbourListRF& operator ->() const { return cb; }
        Ospfv301GetNeighbourListCB(const Ospfv301GetNeighbourListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_areas) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_areas);
        }
    };

    struct Ospfv301GetNeighbourListRsp :
      public Ospfv301GetNeighbourListCB {
        struct args_str {
            XrlAtomList areas;
        };

    private:
        args_str args;

    public:
        Ospfv301GetNeighbourListRsp(const Ospfv301GetNeighbourListRF& cb)
          : Ospfv301GetNeighbourListCB(cb) { }

        void respond() const {
            Ospfv301GetNeighbourListCB::
            respond(args.areas);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ospfv3_0_1_get_neighbour_list
       (
	Ospfv301GetNeighbourListCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get information on a neighbour.
     *
     *  @param nid neighbour ID returned by the get_neighbour_list.
     *
     *  @param address of neighbour in txt to allow IPv4 and IPv6.
     *
     *  @param interface with which the neighbour forms the adjacency.
     *
     *  @param state of the adjacency.
     *
     *  @param rid router ID of the neighbour.
     *
     *  @param priority of the neighbour (used for DR election).
     *
     *  @param deadtime time until neighbour is considered dead.
     *
     *  @param area the neighbour is in.
     *
     *  @param opt value in the neighbours hello packet.
     *
     *  @param dr designated router.
     *
     *  @param bdr backup designated router.
     *
     *  @param up time in seconds that the neigbour has been up.
     *
     *  @param adjacent time in seconds that there has been an adjacency.
     */
    virtual XrlCmdError ospfv3_0_1_get_neighbour_info(
	// Input values,
	const uint32_t&	nid,
	// Output values,
	string&	address,
	string&	interface,
	string&	state,
	IPv4&	rid,
	uint32_t&	priority,
	uint32_t&	deadtime,
	IPv4&	area,
	uint32_t&	opt,
	IPv4&	dr,
	IPv4&	bdr,
	uint32_t&	up,
	uint32_t&	adjacent) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback13<void, const XrlCmdError &,
	const string*,
	const string*,
	const string*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*,
	const IPv4*,
	const uint32_t*,
	const IPv4*,
	const IPv4*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Ospfv301GetNeighbourInfoRF;

    class Ospfv301GetNeighbourInfoCB {
        Ospfv301GetNeighbourInfoRF cb;

    public:
        operator const Ospfv301GetNeighbourInfoRF& () const { return cb; }
        const Ospfv301GetNeighbourInfoRF& operator ->() const { return cb; }
        Ospfv301GetNeighbourInfoCB(const Ospfv301GetNeighbourInfoRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const string& arg_address,
                     const string& arg_interface,
                     const string& arg_state,
                     const IPv4& arg_rid,
                     const uint32_t& arg_priority,
                     const uint32_t& arg_deadtime,
                     const IPv4& arg_area,
                     const uint32_t& arg_opt,
                     const IPv4& arg_dr,
                     const IPv4& arg_bdr,
                     const uint32_t& arg_up,
                     const uint32_t& arg_adjacent) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_address,
                         &arg_interface,
                         &arg_state,
                         &arg_rid,
                         &arg_priority,
                         &arg_deadtime,
                         &arg_area,
                         &arg_opt,
                         &arg_dr,
                         &arg_bdr,
                         &arg_up,
                         &arg_adjacent);
        }
    };

    struct Ospfv301GetNeighbourInfoRsp :
      public Ospfv301GetNeighbourInfoCB {
        struct args_str {
            string address;
            string interface;
            string state;
            IPv4 rid;
            uint32_t priority;
            uint32_t deadtime;
            IPv4 area;
            uint32_t opt;
            IPv4 dr;
            IPv4 bdr;
            uint32_t up;
            uint32_t adjacent;
        };

    private:
        args_str args;

    public:
        Ospfv301GetNeighbourInfoRsp(const Ospfv301GetNeighbourInfoRF& cb)
          : Ospfv301GetNeighbourInfoCB(cb) { }

        void respond() const {
            Ospfv301GetNeighbourInfoCB::
            respond(args.address,
                        args.interface,
                        args.state,
                        args.rid,
                        args.priority,
                        args.deadtime,
                        args.area,
                        args.opt,
                        args.dr,
                        args.bdr,
                        args.up,
                        args.adjacent);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ospfv3_0_1_get_neighbour_info
       (
	const uint32_t&	nid,
	Ospfv301GetNeighbourInfoCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the OSPF database.
     */
    virtual XrlCmdError ospfv3_0_1_clear_database() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ospfv301ClearDatabaseRF;

    class Ospfv301ClearDatabaseCB {
        Ospfv301ClearDatabaseRF cb;

    public:
        operator const Ospfv301ClearDatabaseRF& () const { return cb; }
        const Ospfv301ClearDatabaseRF& operator ->() const { return cb; }
        Ospfv301ClearDatabaseCB(const Ospfv301ClearDatabaseRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ospfv301ClearDatabaseRsp :
      public Ospfv301ClearDatabaseCB {
        Ospfv301ClearDatabaseRsp(const Ospfv301ClearDatabaseRF& cb)
          : Ospfv301ClearDatabaseCB(cb) { }

    };

    virtual void async_ospfv3_0_1_clear_database
       (
	Ospfv301ClearDatabaseCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet4_client_0_1_recv(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet4_client_0_1_recv
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_raw_packet6_client_0_1_recv(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_raw_packet6_client_0_1_recv
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist6_0_1_add_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist6_0_1_add_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist6_0_1_delete_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist6_0_1_delete_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_instance_id(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_instance_id
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_router_id(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_router_id
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_ip_router_alert(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_ip_router_alert
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_create_area_router(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_create_area_router
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_change_area_router_type(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_change_area_router_type
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_destroy_area_router(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_destroy_area_router
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_create_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_create_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_delete_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_delete_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_peer_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_peer_state
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_add_address_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_add_address_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_remove_address_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_remove_address_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_address_state_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_address_state_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_activate_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_activate_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_update_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_update_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_add_neighbour(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_add_neighbour
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_remove_neighbour(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_remove_neighbour
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_create_virtual_link(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_create_virtual_link
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_delete_virtual_link(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_delete_virtual_link
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_transit_area_virtual_link(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_transit_area_virtual_link
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_interface_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_interface_cost
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_retransmit_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_retransmit_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_inftransdelay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_inftransdelay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_router_priority(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_router_priority
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_hello_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_hello_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_router_dead_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_router_dead_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_set_passive(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_set_passive
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_originate_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_originate_default_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_stub_default_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_stub_default_cost
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_summaries(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_summaries
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_area_range_add(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_area_range_add
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_area_range_delete(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_area_range_delete
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_area_range_change_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_area_range_change_state
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_trace(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_trace
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_get_lsa(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_get_lsa
       (const XrlCmdError &e,
	const bool* arg_valid,
	const bool* arg_toohigh,
	const bool* arg_self,
	const vector<uint8_t>* arg_lsa,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_get_area_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_get_area_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_areas,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_get_neighbour_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_get_neighbour_list
       (const XrlCmdError &e,
	const XrlAtomList* arg_areas,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_get_neighbour_info(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_get_neighbour_info
       (const XrlCmdError &e,
	const string* arg_address,
	const string* arg_interface,
	const string* arg_state,
	const IPv4* arg_rid,
	const uint32_t* arg_priority,
	const uint32_t* arg_deadtime,
	const IPv4* arg_area,
	const uint32_t* arg_opt,
	const IPv4* arg_dr,
	const IPv4* arg_bdr,
	const uint32_t* arg_up,
	const uint32_t* arg_adjacent,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ospfv3_0_1_clear_database(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ospfv3_0_1_clear_database
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlOspfv3TargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_OSPFV3_BASE_HH__
