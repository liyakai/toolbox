/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/ripng_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_RIPNG_BASE_HH__
#define __XRL_TARGETS_RIPNG_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlRipngTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlRipngTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlRipngTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlRipngTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "ripng/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv6 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist6_0_1_add_route6(
	// Input values,
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist601AddRoute6RF;

    class PolicyRedist601AddRoute6CB {
        PolicyRedist601AddRoute6RF cb;

    public:
        operator const PolicyRedist601AddRoute6RF& () const { return cb; }
        const PolicyRedist601AddRoute6RF& operator ->() const { return cb; }
        PolicyRedist601AddRoute6CB(const PolicyRedist601AddRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist601AddRoute6Rsp :
      public PolicyRedist601AddRoute6CB {
        PolicyRedist601AddRoute6Rsp(const PolicyRedist601AddRoute6RF& cb)
          : PolicyRedist601AddRoute6CB(cb) { }

    };

    virtual void async_policy_redist6_0_1_add_route6
       (
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist601AddRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv6 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist6_0_1_delete_route6(
	// Input values,
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist601DeleteRoute6RF;

    class PolicyRedist601DeleteRoute6CB {
        PolicyRedist601DeleteRoute6RF cb;

    public:
        operator const PolicyRedist601DeleteRoute6RF& () const { return cb; }
        const PolicyRedist601DeleteRoute6RF& operator ->() const { return cb; }
        PolicyRedist601DeleteRoute6CB(const PolicyRedist601DeleteRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist601DeleteRoute6Rsp :
      public PolicyRedist601DeleteRoute6CB {
        PolicyRedist601DeleteRoute6Rsp(const PolicyRedist601DeleteRoute6RF& cb)
          : PolicyRedist601DeleteRoute6CB(cb) { }

    };

    virtual void async_policy_redist6_0_1_delete_route6
       (
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist601DeleteRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add an address to run RIP process on. The addition of address is not
     *  instantaneous, RIP has to instantiate state in the FEA to send and
     *  receive packets. Once instantiated the address must be explicitly
     *  enabled with set_rip_address_enabled.
     *
     *  @param ifname the interface that owns vif that has address.
     *
     *  @param vifname virtual interface owning address.
     *
     *  @param addr the address to be added.
     */
    virtual XrlCmdError ripng_0_1_add_rip_address(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01AddRipAddressRF;

    class Ripng01AddRipAddressCB {
        Ripng01AddRipAddressRF cb;

    public:
        operator const Ripng01AddRipAddressRF& () const { return cb; }
        const Ripng01AddRipAddressRF& operator ->() const { return cb; }
        Ripng01AddRipAddressCB(const Ripng01AddRipAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01AddRipAddressRsp :
      public Ripng01AddRipAddressCB {
        Ripng01AddRipAddressRsp(const Ripng01AddRipAddressRF& cb)
          : Ripng01AddRipAddressCB(cb) { }

    };

    virtual void async_ripng_0_1_add_rip_address
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01AddRipAddressCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Remove an address RIP process is running on.
     *
     *  @param ifname the interface that owns vif that has address.
     *
     *  @param vifname virtual interface owning address.
     *
     *  @param addr the address to be removed.
     */
    virtual XrlCmdError ripng_0_1_remove_rip_address(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01RemoveRipAddressRF;

    class Ripng01RemoveRipAddressCB {
        Ripng01RemoveRipAddressRF cb;

    public:
        operator const Ripng01RemoveRipAddressRF& () const { return cb; }
        const Ripng01RemoveRipAddressRF& operator ->() const { return cb; }
        Ripng01RemoveRipAddressCB(const Ripng01RemoveRipAddressRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01RemoveRipAddressRsp :
      public Ripng01RemoveRipAddressCB {
        Ripng01RemoveRipAddressRsp(const Ripng01RemoveRipAddressRF& cb)
          : Ripng01RemoveRipAddressCB(cb) { }

    };

    virtual void async_ripng_0_1_remove_rip_address
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01RemoveRipAddressCB);
#endif

    virtual XrlCmdError ripng_0_1_set_rip_address_enabled(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetRipAddressEnabledRF;

    class Ripng01SetRipAddressEnabledCB {
        Ripng01SetRipAddressEnabledRF cb;

    public:
        operator const Ripng01SetRipAddressEnabledRF& () const { return cb; }
        const Ripng01SetRipAddressEnabledRF& operator ->() const { return cb; }
        Ripng01SetRipAddressEnabledCB(const Ripng01SetRipAddressEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetRipAddressEnabledRsp :
      public Ripng01SetRipAddressEnabledCB {
        Ripng01SetRipAddressEnabledRsp(const Ripng01SetRipAddressEnabledRF& cb)
          : Ripng01SetRipAddressEnabledCB(cb) { }

    };

    virtual void async_ripng_0_1_set_rip_address_enabled
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	enabled,
	Ripng01SetRipAddressEnabledCB);
#endif

    virtual XrlCmdError ripng_0_1_rip_address_enabled(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	bool&	enabled) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ripng01RipAddressEnabledRF;

    class Ripng01RipAddressEnabledCB {
        Ripng01RipAddressEnabledRF cb;

    public:
        operator const Ripng01RipAddressEnabledRF& () const { return cb; }
        const Ripng01RipAddressEnabledRF& operator ->() const { return cb; }
        Ripng01RipAddressEnabledCB(const Ripng01RipAddressEnabledRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_enabled) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_enabled);
        }
    };

    struct Ripng01RipAddressEnabledRsp :
      public Ripng01RipAddressEnabledCB {
        struct args_str {
            bool enabled;
        };

    private:
        args_str args;

    public:
        Ripng01RipAddressEnabledRsp(const Ripng01RipAddressEnabledRF& cb)
          : Ripng01RipAddressEnabledCB(cb) { }

        void respond() const {
            Ripng01RipAddressEnabledCB::
            respond(args.enabled);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_rip_address_enabled
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01RipAddressEnabledCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set cost metric associated with address.
     */
    virtual XrlCmdError ripng_0_1_set_cost(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetCostRF;

    class Ripng01SetCostCB {
        Ripng01SetCostRF cb;

    public:
        operator const Ripng01SetCostRF& () const { return cb; }
        const Ripng01SetCostRF& operator ->() const { return cb; }
        Ripng01SetCostCB(const Ripng01SetCostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetCostRsp :
      public Ripng01SetCostCB {
        Ripng01SetCostRsp(const Ripng01SetCostRF& cb)
          : Ripng01SetCostCB(cb) { }

    };

    virtual void async_ripng_0_1_set_cost
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	cost,
	Ripng01SetCostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get cost metric associated with address.
     */
    virtual XrlCmdError ripng_0_1_cost(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	cost) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01CostRF;

    class Ripng01CostCB {
        Ripng01CostRF cb;

    public:
        operator const Ripng01CostRF& () const { return cb; }
        const Ripng01CostRF& operator ->() const { return cb; }
        Ripng01CostCB(const Ripng01CostRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_cost) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_cost);
        }
    };

    struct Ripng01CostRsp :
      public Ripng01CostCB {
        struct args_str {
            uint32_t cost;
        };

    private:
        args_str args;

    public:
        Ripng01CostRsp(const Ripng01CostRF& cb)
          : Ripng01CostCB(cb) { }

        void respond() const {
            Ripng01CostCB::
            respond(args.cost);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_cost
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01CostCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set horizon type applied to routes advertised from address.
     *
     *  @param horizon name of horizon type. Permitted values: "none",
     *  "poison-reverse" "split-horizon-poison-reverse"
     */
    virtual XrlCmdError ripng_0_1_set_horizon(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const string&	horizon) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetHorizonRF;

    class Ripng01SetHorizonCB {
        Ripng01SetHorizonRF cb;

    public:
        operator const Ripng01SetHorizonRF& () const { return cb; }
        const Ripng01SetHorizonRF& operator ->() const { return cb; }
        Ripng01SetHorizonCB(const Ripng01SetHorizonRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetHorizonRsp :
      public Ripng01SetHorizonCB {
        Ripng01SetHorizonRsp(const Ripng01SetHorizonRF& cb)
          : Ripng01SetHorizonCB(cb) { }

    };

    virtual void async_ripng_0_1_set_horizon
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const string&	horizon,
	Ripng01SetHorizonCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get horizon type applied to routes advertised from address.
     */
    virtual XrlCmdError ripng_0_1_horizon(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	string&	horizon) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Ripng01HorizonRF;

    class Ripng01HorizonCB {
        Ripng01HorizonRF cb;

    public:
        operator const Ripng01HorizonRF& () const { return cb; }
        const Ripng01HorizonRF& operator ->() const { return cb; }
        Ripng01HorizonCB(const Ripng01HorizonRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_horizon) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_horizon);
        }
    };

    struct Ripng01HorizonRsp :
      public Ripng01HorizonCB {
        struct args_str {
            string horizon;
        };

    private:
        args_str args;

    public:
        Ripng01HorizonRsp(const Ripng01HorizonRF& cb)
          : Ripng01HorizonCB(cb) { }

        void respond() const {
            Ripng01HorizonCB::
            respond(args.horizon);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_horizon
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01HorizonCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Make RIP passive (receive only) on interface/vif/address.
     */
    virtual XrlCmdError ripng_0_1_set_passive(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	passive) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetPassiveRF;

    class Ripng01SetPassiveCB {
        Ripng01SetPassiveRF cb;

    public:
        operator const Ripng01SetPassiveRF& () const { return cb; }
        const Ripng01SetPassiveRF& operator ->() const { return cb; }
        Ripng01SetPassiveCB(const Ripng01SetPassiveRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetPassiveRsp :
      public Ripng01SetPassiveCB {
        Ripng01SetPassiveRsp(const Ripng01SetPassiveRF& cb)
          : Ripng01SetPassiveCB(cb) { }

    };

    virtual void async_ripng_0_1_set_passive
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	passive,
	Ripng01SetPassiveCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get value indicating whether RIP is passive (receive only) on
     *  interface/vif/address.
     */
    virtual XrlCmdError ripng_0_1_passive(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	bool&	passive) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ripng01PassiveRF;

    class Ripng01PassiveCB {
        Ripng01PassiveRF cb;

    public:
        operator const Ripng01PassiveRF& () const { return cb; }
        const Ripng01PassiveRF& operator ->() const { return cb; }
        Ripng01PassiveCB(const Ripng01PassiveRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_passive) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_passive);
        }
    };

    struct Ripng01PassiveRsp :
      public Ripng01PassiveCB {
        struct args_str {
            bool passive;
        };

    private:
        args_str args;

    public:
        Ripng01PassiveRsp(const Ripng01PassiveRF& cb)
          : Ripng01PassiveCB(cb) { }

        void respond() const {
            Ripng01PassiveCB::
            respond(args.passive);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_passive
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01PassiveCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accept and respond to non-RIP requests.
     */
    virtual XrlCmdError ripng_0_1_set_accept_non_rip_requests(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetAcceptNonRipRequestsRF;

    class Ripng01SetAcceptNonRipRequestsCB {
        Ripng01SetAcceptNonRipRequestsRF cb;

    public:
        operator const Ripng01SetAcceptNonRipRequestsRF& () const { return cb; }
        const Ripng01SetAcceptNonRipRequestsRF& operator ->() const { return cb; }
        Ripng01SetAcceptNonRipRequestsCB(const Ripng01SetAcceptNonRipRequestsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetAcceptNonRipRequestsRsp :
      public Ripng01SetAcceptNonRipRequestsCB {
        Ripng01SetAcceptNonRipRequestsRsp(const Ripng01SetAcceptNonRipRequestsRF& cb)
          : Ripng01SetAcceptNonRipRequestsCB(cb) { }

    };

    virtual void async_ripng_0_1_set_accept_non_rip_requests
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	accept,
	Ripng01SetAcceptNonRipRequestsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get value indicating whether non-RIP requests are accepted and
     *  responded to on interface/vif/address.
     */
    virtual XrlCmdError ripng_0_1_accept_non_rip_requests(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ripng01AcceptNonRipRequestsRF;

    class Ripng01AcceptNonRipRequestsCB {
        Ripng01AcceptNonRipRequestsRF cb;

    public:
        operator const Ripng01AcceptNonRipRequestsRF& () const { return cb; }
        const Ripng01AcceptNonRipRequestsRF& operator ->() const { return cb; }
        Ripng01AcceptNonRipRequestsCB(const Ripng01AcceptNonRipRequestsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Ripng01AcceptNonRipRequestsRsp :
      public Ripng01AcceptNonRipRequestsCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Ripng01AcceptNonRipRequestsRsp(const Ripng01AcceptNonRipRequestsRF& cb)
          : Ripng01AcceptNonRipRequestsCB(cb) { }

        void respond() const {
            Ripng01AcceptNonRipRequestsCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_accept_non_rip_requests
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01AcceptNonRipRequestsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accept default route from peers.
     */
    virtual XrlCmdError ripng_0_1_set_accept_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetAcceptDefaultRouteRF;

    class Ripng01SetAcceptDefaultRouteCB {
        Ripng01SetAcceptDefaultRouteRF cb;

    public:
        operator const Ripng01SetAcceptDefaultRouteRF& () const { return cb; }
        const Ripng01SetAcceptDefaultRouteRF& operator ->() const { return cb; }
        Ripng01SetAcceptDefaultRouteCB(const Ripng01SetAcceptDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetAcceptDefaultRouteRsp :
      public Ripng01SetAcceptDefaultRouteCB {
        Ripng01SetAcceptDefaultRouteRsp(const Ripng01SetAcceptDefaultRouteRF& cb)
          : Ripng01SetAcceptDefaultRouteCB(cb) { }

    };

    virtual void async_ripng_0_1_set_accept_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	accept,
	Ripng01SetAcceptDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accessor for whether default route is accepted from peers.
     */
    virtual XrlCmdError ripng_0_1_accept_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ripng01AcceptDefaultRouteRF;

    class Ripng01AcceptDefaultRouteCB {
        Ripng01AcceptDefaultRouteRF cb;

    public:
        operator const Ripng01AcceptDefaultRouteRF& () const { return cb; }
        const Ripng01AcceptDefaultRouteRF& operator ->() const { return cb; }
        Ripng01AcceptDefaultRouteCB(const Ripng01AcceptDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Ripng01AcceptDefaultRouteRsp :
      public Ripng01AcceptDefaultRouteCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Ripng01AcceptDefaultRouteRsp(const Ripng01AcceptDefaultRouteRF& cb)
          : Ripng01AcceptDefaultRouteCB(cb) { }

        void respond() const {
            Ripng01AcceptDefaultRouteCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_accept_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01AcceptDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Advertise default route (if present).
     */
    virtual XrlCmdError ripng_0_1_set_advertise_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	advertise) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetAdvertiseDefaultRouteRF;

    class Ripng01SetAdvertiseDefaultRouteCB {
        Ripng01SetAdvertiseDefaultRouteRF cb;

    public:
        operator const Ripng01SetAdvertiseDefaultRouteRF& () const { return cb; }
        const Ripng01SetAdvertiseDefaultRouteRF& operator ->() const { return cb; }
        Ripng01SetAdvertiseDefaultRouteCB(const Ripng01SetAdvertiseDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetAdvertiseDefaultRouteRsp :
      public Ripng01SetAdvertiseDefaultRouteCB {
        Ripng01SetAdvertiseDefaultRouteRsp(const Ripng01SetAdvertiseDefaultRouteRF& cb)
          : Ripng01SetAdvertiseDefaultRouteCB(cb) { }

    };

    virtual void async_ripng_0_1_set_advertise_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const bool&	advertise,
	Ripng01SetAdvertiseDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Accessor for whether default route is advertised.
     */
    virtual XrlCmdError ripng_0_1_advertise_default_route(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	bool&	advertise) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Ripng01AdvertiseDefaultRouteRF;

    class Ripng01AdvertiseDefaultRouteCB {
        Ripng01AdvertiseDefaultRouteRF cb;

    public:
        operator const Ripng01AdvertiseDefaultRouteRF& () const { return cb; }
        const Ripng01AdvertiseDefaultRouteRF& operator ->() const { return cb; }
        Ripng01AdvertiseDefaultRouteCB(const Ripng01AdvertiseDefaultRouteRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_advertise) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_advertise);
        }
    };

    struct Ripng01AdvertiseDefaultRouteRsp :
      public Ripng01AdvertiseDefaultRouteCB {
        struct args_str {
            bool advertise;
        };

    private:
        args_str args;

    public:
        Ripng01AdvertiseDefaultRouteRsp(const Ripng01AdvertiseDefaultRouteRF& cb)
          : Ripng01AdvertiseDefaultRouteCB(cb) { }

        void respond() const {
            Ripng01AdvertiseDefaultRouteCB::
            respond(args.advertise);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_advertise_default_route
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01AdvertiseDefaultRouteCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that routes associated with reception address will expire in
     *  the absence of updates.
     */
    virtual XrlCmdError ripng_0_1_set_route_timeout(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetRouteTimeoutRF;

    class Ripng01SetRouteTimeoutCB {
        Ripng01SetRouteTimeoutRF cb;

    public:
        operator const Ripng01SetRouteTimeoutRF& () const { return cb; }
        const Ripng01SetRouteTimeoutRF& operator ->() const { return cb; }
        Ripng01SetRouteTimeoutCB(const Ripng01SetRouteTimeoutRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetRouteTimeoutRsp :
      public Ripng01SetRouteTimeoutCB {
        Ripng01SetRouteTimeoutRsp(const Ripng01SetRouteTimeoutRF& cb)
          : Ripng01SetRouteTimeoutCB(cb) { }

    };

    virtual void async_ripng_0_1_set_route_timeout
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs,
	Ripng01SetRouteTimeoutCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period that routes associated with reception address will expire in
     *  the absence of updates.
     */
    virtual XrlCmdError ripng_0_1_route_timeout(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01RouteTimeoutRF;

    class Ripng01RouteTimeoutCB {
        Ripng01RouteTimeoutRF cb;

    public:
        operator const Ripng01RouteTimeoutRF& () const { return cb; }
        const Ripng01RouteTimeoutRF& operator ->() const { return cb; }
        Ripng01RouteTimeoutCB(const Ripng01RouteTimeoutRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Ripng01RouteTimeoutRsp :
      public Ripng01RouteTimeoutCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Ripng01RouteTimeoutRsp(const Ripng01RouteTimeoutRF& cb)
          : Ripng01RouteTimeoutCB(cb) { }

        void respond() const {
            Ripng01RouteTimeoutCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_route_timeout
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01RouteTimeoutCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that routes associated with reception address will be
     *  deleted after they've expired.
     */
    virtual XrlCmdError ripng_0_1_set_deletion_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetDeletionDelayRF;

    class Ripng01SetDeletionDelayCB {
        Ripng01SetDeletionDelayRF cb;

    public:
        operator const Ripng01SetDeletionDelayRF& () const { return cb; }
        const Ripng01SetDeletionDelayRF& operator ->() const { return cb; }
        Ripng01SetDeletionDelayCB(const Ripng01SetDeletionDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetDeletionDelayRsp :
      public Ripng01SetDeletionDelayCB {
        Ripng01SetDeletionDelayRsp(const Ripng01SetDeletionDelayRF& cb)
          : Ripng01SetDeletionDelayCB(cb) { }

    };

    virtual void async_ripng_0_1_set_deletion_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs,
	Ripng01SetDeletionDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period that routes associated with reception address will be
     *  deleted after they've expired.
     */
    virtual XrlCmdError ripng_0_1_deletion_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01DeletionDelayRF;

    class Ripng01DeletionDelayCB {
        Ripng01DeletionDelayRF cb;

    public:
        operator const Ripng01DeletionDelayRF& () const { return cb; }
        const Ripng01DeletionDelayRF& operator ->() const { return cb; }
        Ripng01DeletionDelayCB(const Ripng01DeletionDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Ripng01DeletionDelayRsp :
      public Ripng01DeletionDelayCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Ripng01DeletionDelayRsp(const Ripng01DeletionDelayRF& cb)
          : Ripng01DeletionDelayCB(cb) { }

        void respond() const {
            Ripng01DeletionDelayCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_deletion_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01DeletionDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that route table requests should be sent from address when
     *  no peers are associated with it.
     */
    virtual XrlCmdError ripng_0_1_set_request_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetRequestIntervalRF;

    class Ripng01SetRequestIntervalCB {
        Ripng01SetRequestIntervalRF cb;

    public:
        operator const Ripng01SetRequestIntervalRF& () const { return cb; }
        const Ripng01SetRequestIntervalRF& operator ->() const { return cb; }
        Ripng01SetRequestIntervalCB(const Ripng01SetRequestIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetRequestIntervalRsp :
      public Ripng01SetRequestIntervalCB {
        Ripng01SetRequestIntervalRsp(const Ripng01SetRequestIntervalRF& cb)
          : Ripng01SetRequestIntervalCB(cb) { }

    };

    virtual void async_ripng_0_1_set_request_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs,
	Ripng01SetRequestIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period that route table requests should be sent from address when
     *  no peers are associated with it.
     */
    virtual XrlCmdError ripng_0_1_request_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01RequestIntervalRF;

    class Ripng01RequestIntervalCB {
        Ripng01RequestIntervalRF cb;

    public:
        operator const Ripng01RequestIntervalRF& () const { return cb; }
        const Ripng01RequestIntervalRF& operator ->() const { return cb; }
        Ripng01RequestIntervalCB(const Ripng01RequestIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Ripng01RequestIntervalRsp :
      public Ripng01RequestIntervalCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Ripng01RequestIntervalRsp(const Ripng01RequestIntervalRF& cb)
          : Ripng01RequestIntervalCB(cb) { }

        void respond() const {
            Ripng01RequestIntervalCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_request_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01RequestIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period between the unsolicited sending of the routing table from
     *  address.
     */
    virtual XrlCmdError ripng_0_1_set_update_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetUpdateIntervalRF;

    class Ripng01SetUpdateIntervalCB {
        Ripng01SetUpdateIntervalRF cb;

    public:
        operator const Ripng01SetUpdateIntervalRF& () const { return cb; }
        const Ripng01SetUpdateIntervalRF& operator ->() const { return cb; }
        Ripng01SetUpdateIntervalCB(const Ripng01SetUpdateIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetUpdateIntervalRsp :
      public Ripng01SetUpdateIntervalCB {
        Ripng01SetUpdateIntervalRsp(const Ripng01SetUpdateIntervalRF& cb)
          : Ripng01SetUpdateIntervalCB(cb) { }

    };

    virtual void async_ripng_0_1_set_update_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs,
	Ripng01SetUpdateIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get period between the unsolicited sending of the routing table from
     *  address.
     */
    virtual XrlCmdError ripng_0_1_update_interval(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01UpdateIntervalRF;

    class Ripng01UpdateIntervalCB {
        Ripng01UpdateIntervalRF cb;

    public:
        operator const Ripng01UpdateIntervalRF& () const { return cb; }
        const Ripng01UpdateIntervalRF& operator ->() const { return cb; }
        Ripng01UpdateIntervalCB(const Ripng01UpdateIntervalRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Ripng01UpdateIntervalRsp :
      public Ripng01UpdateIntervalCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Ripng01UpdateIntervalRsp(const Ripng01UpdateIntervalRF& cb)
          : Ripng01UpdateIntervalCB(cb) { }

        void respond() const {
            Ripng01UpdateIntervalCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_update_interval
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01UpdateIntervalCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set jitter between the unsolicited sending of the routing table from
     *  address (in percents of the period).
     */
    virtual XrlCmdError ripng_0_1_set_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetUpdateJitterRF;

    class Ripng01SetUpdateJitterCB {
        Ripng01SetUpdateJitterRF cb;

    public:
        operator const Ripng01SetUpdateJitterRF& () const { return cb; }
        const Ripng01SetUpdateJitterRF& operator ->() const { return cb; }
        Ripng01SetUpdateJitterCB(const Ripng01SetUpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetUpdateJitterRsp :
      public Ripng01SetUpdateJitterCB {
        Ripng01SetUpdateJitterRsp(const Ripng01SetUpdateJitterRF& cb)
          : Ripng01SetUpdateJitterCB(cb) { }

    };

    virtual void async_ripng_0_1_set_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_jitter,
	Ripng01SetUpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get jitter between the unsolicited sending of the routing table from
     *  address (in percents of the period).
     */
    virtual XrlCmdError ripng_0_1_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01UpdateJitterRF;

    class Ripng01UpdateJitterCB {
        Ripng01UpdateJitterRF cb;

    public:
        operator const Ripng01UpdateJitterRF& () const { return cb; }
        const Ripng01UpdateJitterRF& operator ->() const { return cb; }
        Ripng01UpdateJitterCB(const Ripng01UpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_jitter) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_jitter);
        }
    };

    struct Ripng01UpdateJitterRsp :
      public Ripng01UpdateJitterCB {
        struct args_str {
            uint32_t t_jitter;
        };

    private:
        args_str args;

    public:
        Ripng01UpdateJitterRsp(const Ripng01UpdateJitterRF& cb)
          : Ripng01UpdateJitterCB(cb) { }

        void respond() const {
            Ripng01UpdateJitterCB::
            respond(args.t_jitter);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01UpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period between sending triggered updates from address.
     */
    virtual XrlCmdError ripng_0_1_set_triggered_update_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetTriggeredUpdateDelayRF;

    class Ripng01SetTriggeredUpdateDelayCB {
        Ripng01SetTriggeredUpdateDelayRF cb;

    public:
        operator const Ripng01SetTriggeredUpdateDelayRF& () const { return cb; }
        const Ripng01SetTriggeredUpdateDelayRF& operator ->() const { return cb; }
        Ripng01SetTriggeredUpdateDelayCB(const Ripng01SetTriggeredUpdateDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetTriggeredUpdateDelayRsp :
      public Ripng01SetTriggeredUpdateDelayCB {
        Ripng01SetTriggeredUpdateDelayRsp(const Ripng01SetTriggeredUpdateDelayRF& cb)
          : Ripng01SetTriggeredUpdateDelayCB(cb) { }

    };

    virtual void async_ripng_0_1_set_triggered_update_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_secs,
	Ripng01SetTriggeredUpdateDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set period between sending triggered updates from address.
     */
    virtual XrlCmdError ripng_0_1_triggered_update_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_secs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01TriggeredUpdateDelayRF;

    class Ripng01TriggeredUpdateDelayCB {
        Ripng01TriggeredUpdateDelayRF cb;

    public:
        operator const Ripng01TriggeredUpdateDelayRF& () const { return cb; }
        const Ripng01TriggeredUpdateDelayRF& operator ->() const { return cb; }
        Ripng01TriggeredUpdateDelayCB(const Ripng01TriggeredUpdateDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_secs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_secs);
        }
    };

    struct Ripng01TriggeredUpdateDelayRsp :
      public Ripng01TriggeredUpdateDelayCB {
        struct args_str {
            uint32_t t_secs;
        };

    private:
        args_str args;

    public:
        Ripng01TriggeredUpdateDelayRsp(const Ripng01TriggeredUpdateDelayRF& cb)
          : Ripng01TriggeredUpdateDelayCB(cb) { }

        void respond() const {
            Ripng01TriggeredUpdateDelayCB::
            respond(args.t_secs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_triggered_update_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01TriggeredUpdateDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set jitter between sending triggered updates from address (in percents
     *  of the period).
     */
    virtual XrlCmdError ripng_0_1_set_triggered_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetTriggeredUpdateJitterRF;

    class Ripng01SetTriggeredUpdateJitterCB {
        Ripng01SetTriggeredUpdateJitterRF cb;

    public:
        operator const Ripng01SetTriggeredUpdateJitterRF& () const { return cb; }
        const Ripng01SetTriggeredUpdateJitterRF& operator ->() const { return cb; }
        Ripng01SetTriggeredUpdateJitterCB(const Ripng01SetTriggeredUpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetTriggeredUpdateJitterRsp :
      public Ripng01SetTriggeredUpdateJitterCB {
        Ripng01SetTriggeredUpdateJitterRsp(const Ripng01SetTriggeredUpdateJitterRF& cb)
          : Ripng01SetTriggeredUpdateJitterCB(cb) { }

    };

    virtual void async_ripng_0_1_set_triggered_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_jitter,
	Ripng01SetTriggeredUpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get jitter between sending triggered updates from address (in percents
     *  of the period).
     */
    virtual XrlCmdError ripng_0_1_triggered_update_jitter(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_jitter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01TriggeredUpdateJitterRF;

    class Ripng01TriggeredUpdateJitterCB {
        Ripng01TriggeredUpdateJitterRF cb;

    public:
        operator const Ripng01TriggeredUpdateJitterRF& () const { return cb; }
        const Ripng01TriggeredUpdateJitterRF& operator ->() const { return cb; }
        Ripng01TriggeredUpdateJitterCB(const Ripng01TriggeredUpdateJitterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_jitter) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_jitter);
        }
    };

    struct Ripng01TriggeredUpdateJitterRsp :
      public Ripng01TriggeredUpdateJitterCB {
        struct args_str {
            uint32_t t_jitter;
        };

    private:
        args_str args;

    public:
        Ripng01TriggeredUpdateJitterRsp(const Ripng01TriggeredUpdateJitterRF& cb)
          : Ripng01TriggeredUpdateJitterCB(cb) { }

        void respond() const {
            Ripng01TriggeredUpdateJitterCB::
            respond(args.t_jitter);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_triggered_update_jitter
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01TriggeredUpdateJitterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the inter-packet delay between the output of packets from address.
     */
    virtual XrlCmdError ripng_0_1_set_interpacket_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_msecs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01SetInterpacketDelayRF;

    class Ripng01SetInterpacketDelayCB {
        Ripng01SetInterpacketDelayRF cb;

    public:
        operator const Ripng01SetInterpacketDelayRF& () const { return cb; }
        const Ripng01SetInterpacketDelayRF& operator ->() const { return cb; }
        Ripng01SetInterpacketDelayCB(const Ripng01SetInterpacketDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01SetInterpacketDelayRsp :
      public Ripng01SetInterpacketDelayCB {
        Ripng01SetInterpacketDelayRsp(const Ripng01SetInterpacketDelayRF& cb)
          : Ripng01SetInterpacketDelayCB(cb) { }

    };

    virtual void async_ripng_0_1_set_interpacket_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const uint32_t&	t_msecs,
	Ripng01SetInterpacketDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the inter-packet delay between the output of packets from address.
     */
    virtual XrlCmdError ripng_0_1_interpacket_delay(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	uint32_t&	t_msecs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Ripng01InterpacketDelayRF;

    class Ripng01InterpacketDelayCB {
        Ripng01InterpacketDelayRF cb;

    public:
        operator const Ripng01InterpacketDelayRF& () const { return cb; }
        const Ripng01InterpacketDelayRF& operator ->() const { return cb; }
        Ripng01InterpacketDelayCB(const Ripng01InterpacketDelayRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_t_msecs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_t_msecs);
        }
    };

    struct Ripng01InterpacketDelayRsp :
      public Ripng01InterpacketDelayCB {
        struct args_str {
            uint32_t t_msecs;
        };

    private:
        args_str args;

    public:
        Ripng01InterpacketDelayRsp(const Ripng01InterpacketDelayRF& cb)
          : Ripng01InterpacketDelayCB(cb) { }

        void respond() const {
            Ripng01InterpacketDelayCB::
            respond(args.t_msecs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_interpacket_delay
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01InterpacketDelayCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get a textual description of the status of address RIP is running upon.
     *
     *  @param ifname the interface that owns vif that has the address.
     *
     *  @param vifname virtual interface owns the address.
     *
     *  @param addr the address to query.
     */
    virtual XrlCmdError ripng_0_1_rip_address_status(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	string&	status) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Ripng01RipAddressStatusRF;

    class Ripng01RipAddressStatusCB {
        Ripng01RipAddressStatusRF cb;

    public:
        operator const Ripng01RipAddressStatusRF& () const { return cb; }
        const Ripng01RipAddressStatusRF& operator ->() const { return cb; }
        Ripng01RipAddressStatusCB(const Ripng01RipAddressStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_status) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status);
        }
    };

    struct Ripng01RipAddressStatusRsp :
      public Ripng01RipAddressStatusCB {
        struct args_str {
            string status;
        };

    private:
        args_str args;

    public:
        Ripng01RipAddressStatusRsp(const Ripng01RipAddressStatusRF& cb)
          : Ripng01RipAddressStatusCB(cb) { }

        void respond() const {
            Ripng01RipAddressStatusCB::
            respond(args.status);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_rip_address_status
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01RipAddressStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get addresses running RIP.
     */
    virtual XrlCmdError ripng_0_1_get_all_addresses(
	// Output values,
	XrlAtomList&	ifnames,
	XrlAtomList&	vifnames,
	XrlAtomList&	addrs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback4<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Ripng01GetAllAddressesRF;

    class Ripng01GetAllAddressesCB {
        Ripng01GetAllAddressesRF cb;

    public:
        operator const Ripng01GetAllAddressesRF& () const { return cb; }
        const Ripng01GetAllAddressesRF& operator ->() const { return cb; }
        Ripng01GetAllAddressesCB(const Ripng01GetAllAddressesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_ifnames,
                     const XrlAtomList& arg_vifnames,
                     const XrlAtomList& arg_addrs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_ifnames,
                         &arg_vifnames,
                         &arg_addrs);
        }
    };

    struct Ripng01GetAllAddressesRsp :
      public Ripng01GetAllAddressesCB {
        struct args_str {
            XrlAtomList ifnames;
            XrlAtomList vifnames;
            XrlAtomList addrs;
        };

    private:
        args_str args;

    public:
        Ripng01GetAllAddressesRsp(const Ripng01GetAllAddressesRF& cb)
          : Ripng01GetAllAddressesCB(cb) { }

        void respond() const {
            Ripng01GetAllAddressesCB::
            respond(args.ifnames,
                        args.vifnames,
                        args.addrs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_get_all_addresses
       (
	Ripng01GetAllAddressesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get counters associated with interface / vif /address.
     */
    virtual XrlCmdError ripng_0_1_get_counters(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	XrlAtomList&	counter_descriptions,
	XrlAtomList&	counter_values) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Ripng01GetCountersRF;

    class Ripng01GetCountersCB {
        Ripng01GetCountersRF cb;

    public:
        operator const Ripng01GetCountersRF& () const { return cb; }
        const Ripng01GetCountersRF& operator ->() const { return cb; }
        Ripng01GetCountersCB(const Ripng01GetCountersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const XrlAtomList& arg_counter_descriptions,
                     const XrlAtomList& arg_counter_values) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_counter_descriptions,
                         &arg_counter_values);
        }
    };

    struct Ripng01GetCountersRsp :
      public Ripng01GetCountersCB {
        struct args_str {
            XrlAtomList counter_descriptions;
            XrlAtomList counter_values;
        };

    private:
        args_str args;

    public:
        Ripng01GetCountersRsp(const Ripng01GetCountersRF& cb)
          : Ripng01GetCountersCB(cb) { }

        void respond() const {
            Ripng01GetCountersCB::
            respond(args.counter_descriptions,
                        args.counter_values);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_get_counters
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01GetCountersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the list of peers associated with interface / vif / address.
     */
    virtual XrlCmdError ripng_0_1_get_peers(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	// Output values,
	XrlAtomList&	peers) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const XrlAtomList*>::RefPtr
    Ripng01GetPeersRF;

    class Ripng01GetPeersCB {
        Ripng01GetPeersRF cb;

    public:
        operator const Ripng01GetPeersRF& () const { return cb; }
        const Ripng01GetPeersRF& operator ->() const { return cb; }
        Ripng01GetPeersCB(const Ripng01GetPeersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const XrlAtomList& arg_peers) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peers);
        }
    };

    struct Ripng01GetPeersRsp :
      public Ripng01GetPeersCB {
        struct args_str {
            XrlAtomList peers;
        };

    private:
        args_str args;

    public:
        Ripng01GetPeersRsp(const Ripng01GetPeersRF& cb)
          : Ripng01GetPeersCB(cb) { }

        void respond() const {
            Ripng01GetPeersCB::
            respond(args.peers);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_get_peers
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	Ripng01GetPeersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get list of all peers known to RIP. There is a 1-to-1 correspondence
     *  between the items in the lists of peers, ifnames, vifnames, addrs.
     */
    virtual XrlCmdError ripng_0_1_get_all_peers(
	// Output values,
	XrlAtomList&	peers,
	XrlAtomList&	ifnames,
	XrlAtomList&	vifnames,
	XrlAtomList&	addrs) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback5<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*,
	const XrlAtomList*>::RefPtr
    Ripng01GetAllPeersRF;

    class Ripng01GetAllPeersCB {
        Ripng01GetAllPeersRF cb;

    public:
        operator const Ripng01GetAllPeersRF& () const { return cb; }
        const Ripng01GetAllPeersRF& operator ->() const { return cb; }
        Ripng01GetAllPeersCB(const Ripng01GetAllPeersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_peers,
                     const XrlAtomList& arg_ifnames,
                     const XrlAtomList& arg_vifnames,
                     const XrlAtomList& arg_addrs) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peers,
                         &arg_ifnames,
                         &arg_vifnames,
                         &arg_addrs);
        }
    };

    struct Ripng01GetAllPeersRsp :
      public Ripng01GetAllPeersCB {
        struct args_str {
            XrlAtomList peers;
            XrlAtomList ifnames;
            XrlAtomList vifnames;
            XrlAtomList addrs;
        };

    private:
        args_str args;

    public:
        Ripng01GetAllPeersRsp(const Ripng01GetAllPeersRF& cb)
          : Ripng01GetAllPeersCB(cb) { }

        void respond() const {
            Ripng01GetAllPeersCB::
            respond(args.peers,
                        args.ifnames,
                        args.vifnames,
                        args.addrs);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_get_all_peers
       (
	Ripng01GetAllPeersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get counters associated with peer of interface / vif /address.
     *
     *  @param counter_descriptions textual descriptions of counters.
     *
     *  @param counter_values values associated with counters.
     *
     *  @param peer_last_active is the number of seconds since TimeVal(0,0).
     */
    virtual XrlCmdError ripng_0_1_get_peer_counters(
	// Input values,
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const IPv6&	peer,
	// Output values,
	XrlAtomList&	counter_descriptions,
	XrlAtomList&	counter_values,
	uint32_t&	peer_last_active) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback4<void, const XrlCmdError &,
	const XrlAtomList*,
	const XrlAtomList*,
	const uint32_t*>::RefPtr
    Ripng01GetPeerCountersRF;

    class Ripng01GetPeerCountersCB {
        Ripng01GetPeerCountersRF cb;

    public:
        operator const Ripng01GetPeerCountersRF& () const { return cb; }
        const Ripng01GetPeerCountersRF& operator ->() const { return cb; }
        Ripng01GetPeerCountersCB(const Ripng01GetPeerCountersRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL); }

        void respond(const XrlAtomList& arg_counter_descriptions,
                     const XrlAtomList& arg_counter_values,
                     const uint32_t& arg_peer_last_active) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_counter_descriptions,
                         &arg_counter_values,
                         &arg_peer_last_active);
        }
    };

    struct Ripng01GetPeerCountersRsp :
      public Ripng01GetPeerCountersCB {
        struct args_str {
            XrlAtomList counter_descriptions;
            XrlAtomList counter_values;
            uint32_t peer_last_active;
        };

    private:
        args_str args;

    public:
        Ripng01GetPeerCountersRsp(const Ripng01GetPeerCountersRF& cb)
          : Ripng01GetPeerCountersCB(cb) { }

        void respond() const {
            Ripng01GetPeerCountersCB::
            respond(args.counter_descriptions,
                        args.counter_values,
                        args.peer_last_active);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_ripng_0_1_get_peer_counters
       (
	const string&	ifname,
	const string&	vifname,
	const IPv6&	addr,
	const IPv6&	peer,
	Ripng01GetPeerCountersCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/Disable tracing.
     *
     *  @param tvar trace variable.
     *
     *  @param enable set to true to enable false to disable.
     */
    virtual XrlCmdError ripng_0_1_trace(
	// Input values,
	const string&	tvar,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Ripng01TraceRF;

    class Ripng01TraceCB {
        Ripng01TraceRF cb;

    public:
        operator const Ripng01TraceRF& () const { return cb; }
        const Ripng01TraceRF& operator ->() const { return cb; }
        Ripng01TraceCB(const Ripng01TraceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Ripng01TraceRsp :
      public Ripng01TraceCB {
        Ripng01TraceRsp(const Ripng01TraceRF& cb)
          : Ripng01TraceCB(cb) { }

    };

    virtual void async_ripng_0_1_trace
       (
	const string&	tvar,
	const bool&	enable,
	Ripng01TraceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket6/0.1 when a packet arrives
     *  from an IPv6 source.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param if_name the interface name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param vif_name the vif name the packet arrived on, if known. If
     *  unknown, then it is an empty string.
     *
     *  @param src_host the originating host.
     *
     *  @param src_port the originating IP port.
     *
     *  @param data the data received.
     */
    virtual XrlCmdError socket6_user_0_1_recv_event(
	// Input values,
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket6User01RecvEventRF;

    class Socket6User01RecvEventCB {
        Socket6User01RecvEventRF cb;

    public:
        operator const Socket6User01RecvEventRF& () const { return cb; }
        const Socket6User01RecvEventRF& operator ->() const { return cb; }
        Socket6User01RecvEventCB(const Socket6User01RecvEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket6User01RecvEventRsp :
      public Socket6User01RecvEventCB {
        Socket6User01RecvEventRsp(const Socket6User01RecvEventRF& cb)
          : Socket6User01RecvEventCB(cb) { }

    };

    virtual void async_socket6_user_0_1_recv_event
       (
	const string&	sockid,
	const string&	if_name,
	const string&	vif_name,
	const IPv6&	src_host,
	const uint32_t&	src_port,
	const vector<uint8_t>&	data,
	Socket6User01RecvEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket6/0.1 when a connection
     *  request is received from an IPv6 source. It applies only to TCP
     *  sockets.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param src_host the connecting host.
     *
     *  @param src_port the connecting IP port.
     *
     *  @param new_sockid the identifier associated with the new socket that
     *  has been created to handle the new connection.
     *
     *  @param accept if true, the connection request has been accepted,
     *  otherwise it has been rejected.
     */
    virtual XrlCmdError socket6_user_0_1_inbound_connect_event(
	// Input values,
	const string&	sockid,
	const IPv6&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	// Output values,
	bool&	accept) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const bool*>::RefPtr
    Socket6User01InboundConnectEventRF;

    class Socket6User01InboundConnectEventCB {
        Socket6User01InboundConnectEventRF cb;

    public:
        operator const Socket6User01InboundConnectEventRF& () const { return cb; }
        const Socket6User01InboundConnectEventRF& operator ->() const { return cb; }
        Socket6User01InboundConnectEventCB(const Socket6User01InboundConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const bool& arg_accept) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_accept);
        }
    };

    struct Socket6User01InboundConnectEventRsp :
      public Socket6User01InboundConnectEventCB {
        struct args_str {
            bool accept;
        };

    private:
        args_str args;

    public:
        Socket6User01InboundConnectEventRsp(const Socket6User01InboundConnectEventRF& cb)
          : Socket6User01InboundConnectEventCB(cb) { }

        void respond() const {
            Socket6User01InboundConnectEventCB::
            respond(args.accept);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_socket6_user_0_1_inbound_connect_event
       (
	const string&	sockid,
	const IPv6&	src_host,
	const uint32_t&	src_port,
	const string&	new_sockid,
	Socket6User01InboundConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket6/0.1 when an outgoing
     *  connection request originated by the local host is completed. It
     *  applies only to TCP sockets. Note that if the connection failed, the
     *  error_event will be dispatched instead.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket6_user_0_1_outgoing_connect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket6User01OutgoingConnectEventRF;

    class Socket6User01OutgoingConnectEventCB {
        Socket6User01OutgoingConnectEventRF cb;

    public:
        operator const Socket6User01OutgoingConnectEventRF& () const { return cb; }
        const Socket6User01OutgoingConnectEventRF& operator ->() const { return cb; }
        Socket6User01OutgoingConnectEventCB(const Socket6User01OutgoingConnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket6User01OutgoingConnectEventRsp :
      public Socket6User01OutgoingConnectEventCB {
        Socket6User01OutgoingConnectEventRsp(const Socket6User01OutgoingConnectEventRF& cb)
          : Socket6User01OutgoingConnectEventCB(cb) { }

    };

    virtual void async_socket6_user_0_1_outgoing_connect_event
       (
	const string&	sockid,
	Socket6User01OutgoingConnectEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket6/0.1 when an error occurs.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     *
     *  @param error a textual description of the error.
     *
     *  @param fatal indication of whether socket is shutdown because of error.
     */
    virtual XrlCmdError socket6_user_0_1_error_event(
	// Input values,
	const string&	sockid,
	const string&	error,
	const bool&	fatal) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket6User01ErrorEventRF;

    class Socket6User01ErrorEventCB {
        Socket6User01ErrorEventRF cb;

    public:
        operator const Socket6User01ErrorEventRF& () const { return cb; }
        const Socket6User01ErrorEventRF& operator ->() const { return cb; }
        Socket6User01ErrorEventCB(const Socket6User01ErrorEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket6User01ErrorEventRsp :
      public Socket6User01ErrorEventCB {
        Socket6User01ErrorEventRsp(const Socket6User01ErrorEventRF& cb)
          : Socket6User01ErrorEventCB(cb) { }

    };

    virtual void async_socket6_user_0_1_error_event
       (
	const string&	sockid,
	const string&	error,
	const bool&	fatal,
	Socket6User01ErrorEventCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Method invoked by target implementing socket6/0.1 when the peer has
     *  closed the connection. It applies only to TCP sockets. Note that the
     *  socket itself is left open and must be explicitly closed.
     *
     *  @param sockid the identifier associated with socket where the event
     *  occurred.
     */
    virtual XrlCmdError socket6_user_0_1_disconnect_event(
	// Input values,
	const string&	sockid) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Socket6User01DisconnectEventRF;

    class Socket6User01DisconnectEventCB {
        Socket6User01DisconnectEventRF cb;

    public:
        operator const Socket6User01DisconnectEventRF& () const { return cb; }
        const Socket6User01DisconnectEventRF& operator ->() const { return cb; }
        Socket6User01DisconnectEventCB(const Socket6User01DisconnectEventRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Socket6User01DisconnectEventRsp :
      public Socket6User01DisconnectEventCB {
        Socket6User01DisconnectEventRsp(const Socket6User01DisconnectEventRF& cb)
          : Socket6User01DisconnectEventCB(cb) { }

    };

    virtual void async_socket6_user_0_1_disconnect_event
       (
	const string&	sockid,
	Socket6User01DisconnectEventCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist6_0_1_add_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist6_0_1_add_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist6_0_1_delete_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist6_0_1_delete_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_add_rip_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_add_rip_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_remove_rip_address(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_remove_rip_address
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_rip_address_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_rip_address_enabled
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_rip_address_enabled(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_rip_address_enabled
       (const XrlCmdError &e,
	const bool* arg_enabled,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_cost
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_cost(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_cost
       (const XrlCmdError &e,
	const uint32_t* arg_cost,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_horizon(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_horizon
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_horizon(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_horizon
       (const XrlCmdError &e,
	const string* arg_horizon,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_passive(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_passive
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_passive(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_passive
       (const XrlCmdError &e,
	const bool* arg_passive,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_accept_non_rip_requests(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_accept_non_rip_requests
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_accept_non_rip_requests(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_accept_non_rip_requests
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_accept_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_accept_default_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_accept_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_accept_default_route
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_advertise_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_advertise_default_route
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_advertise_default_route(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_advertise_default_route
       (const XrlCmdError &e,
	const bool* arg_advertise,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_route_timeout(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_route_timeout
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_route_timeout(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_route_timeout
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_deletion_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_deletion_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_deletion_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_deletion_delay
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_request_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_request_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_request_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_request_interval
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_update_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_update_interval
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_update_interval(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_update_interval
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_update_jitter
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_update_jitter
       (const XrlCmdError &e,
	const uint32_t* arg_t_jitter,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_triggered_update_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_triggered_update_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_triggered_update_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_triggered_update_delay
       (const XrlCmdError &e,
	const uint32_t* arg_t_secs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_triggered_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_triggered_update_jitter
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_triggered_update_jitter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_triggered_update_jitter
       (const XrlCmdError &e,
	const uint32_t* arg_t_jitter,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_set_interpacket_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_set_interpacket_delay
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_interpacket_delay(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_interpacket_delay
       (const XrlCmdError &e,
	const uint32_t* arg_t_msecs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_rip_address_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_rip_address_status
       (const XrlCmdError &e,
	const string* arg_status,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_get_all_addresses(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_get_all_addresses
       (const XrlCmdError &e,
	const XrlAtomList* arg_ifnames,
	const XrlAtomList* arg_vifnames,
	const XrlAtomList* arg_addrs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_get_counters(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_get_counters
       (const XrlCmdError &e,
	const XrlAtomList* arg_counter_descriptions,
	const XrlAtomList* arg_counter_values,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_get_peers(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_get_peers
       (const XrlCmdError &e,
	const XrlAtomList* arg_peers,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_get_all_peers(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_get_all_peers
       (const XrlCmdError &e,
	const XrlAtomList* arg_peers,
	const XrlAtomList* arg_ifnames,
	const XrlAtomList* arg_vifnames,
	const XrlAtomList* arg_addrs,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_get_peer_counters(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_get_peer_counters
       (const XrlCmdError &e,
	const XrlAtomList* arg_counter_descriptions,
	const XrlAtomList* arg_counter_values,
	const uint32_t* arg_peer_last_active,
        XrlRespCallback);
#endif

    XrlCmdRT handle_ripng_0_1_trace(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_ripng_0_1_trace
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_user_0_1_recv_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_user_0_1_recv_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_user_0_1_inbound_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_user_0_1_inbound_connect_event
       (const XrlCmdError &e,
	const bool* arg_accept,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_user_0_1_outgoing_connect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_user_0_1_outgoing_connect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_user_0_1_error_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_user_0_1_error_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_socket6_user_0_1_disconnect_event(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_socket6_user_0_1_disconnect_event
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlRipngTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_RIPNG_BASE_HH__
