/*
 * obj/x86_64-unknown-linux-gnu/xrl/targets/bgp_base.hh
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'tgt-gen'.
 */


#ifndef __XRL_TARGETS_BGP_BASE_HH__
#define __XRL_TARGETS_BGP_BASE_HH__

#undef XORP_LIBRARY_NAME
#define XORP_LIBRARY_NAME "XrlBgpTarget"

#include "libxorp/xlog.h"
#include "libxipc/xrl_cmd_map.hh"

class XrlBgpTargetBase {
protected:
    XrlCmdMap* _cmds;

public:
    /**
     * Constructor.
     *
     * @param cmds an XrlCmdMap that the commands associated with the target
     *		   should be added to.  This is typically the XrlRouter
     *		   associated with the target.
     */
    XrlBgpTargetBase(XrlCmdMap* cmds = 0);

    /**
     * Destructor.
     *
     * Dissociates instance commands from command map.
     */
    virtual ~XrlBgpTargetBase();

    /**
     * Set command map.
     *
     * @param cmds pointer to command map to associate commands with.  This
     * argument is typically a pointer to the XrlRouter associated with the
     * target.
     *
     * @return true on success, false if cmds is null or a command map has
     * already been supplied.
     */
    bool set_command_map(XrlCmdMap* cmds);

    /**
     * Get Xrl instance name associated with command map.
     */
    const string& get_name() const { return _cmds->name(); }

    /**
     * Get version string of instance.
     */
    const char* version() const { return "bgp/0.0"; }

protected:

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get name of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_target_name(
	// Output values,
	string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetTargetNameRF;

    class Common01GetTargetNameCB {
        Common01GetTargetNameRF cb;

    public:
        operator const Common01GetTargetNameRF& () const { return cb; }
        const Common01GetTargetNameRF& operator ->() const { return cb; }
        Common01GetTargetNameCB(const Common01GetTargetNameRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_name) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_name);
        }
    };

    struct Common01GetTargetNameRsp :
      public Common01GetTargetNameCB {
        struct args_str {
            string name;
        };

    private:
        args_str args;

    public:
        Common01GetTargetNameRsp(const Common01GetTargetNameRF& cb)
          : Common01GetTargetNameCB(cb) { }

        void respond() const {
            Common01GetTargetNameCB::
            respond(args.name);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_target_name
       (
	Common01GetTargetNameCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get version string from Xrl Target
     */
    virtual XrlCmdError common_0_1_get_version(
	// Output values,
	string&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Common01GetVersionRF;

    class Common01GetVersionCB {
        Common01GetVersionRF cb;

    public:
        operator const Common01GetVersionRF& () const { return cb; }
        const Common01GetVersionRF& operator ->() const { return cb; }
        Common01GetVersionCB(const Common01GetVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Common01GetVersionRsp :
      public Common01GetVersionCB {
        struct args_str {
            string version;
        };

    private:
        args_str args;

    public:
        Common01GetVersionRsp(const Common01GetVersionRF& cb)
          : Common01GetVersionCB(cb) { }

        void respond() const {
            Common01GetVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_version
       (
	Common01GetVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get status of Xrl Target
     */
    virtual XrlCmdError common_0_1_get_status(
	// Output values,
	uint32_t&	status,
	string&	reason) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const string*>::RefPtr
    Common01GetStatusRF;

    class Common01GetStatusCB {
        Common01GetStatusRF cb;

    public:
        operator const Common01GetStatusRF& () const { return cb; }
        const Common01GetStatusRF& operator ->() const { return cb; }
        Common01GetStatusCB(const Common01GetStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_status,
                     const string& arg_reason) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_status,
                         &arg_reason);
        }
    };

    struct Common01GetStatusRsp :
      public Common01GetStatusCB {
        struct args_str {
            uint32_t status;
            string reason;
        };

    private:
        args_str args;

    public:
        Common01GetStatusRsp(const Common01GetStatusRF& cb)
          : Common01GetStatusCB(cb) { }

        void respond() const {
            Common01GetStatusCB::
            respond(args.status,
                        args.reason);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_common_0_1_get_status
       (
	Common01GetStatusCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request clean shutdown of Xrl Target
     */
    virtual XrlCmdError common_0_1_shutdown() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01ShutdownRF;

    class Common01ShutdownCB {
        Common01ShutdownRF cb;

    public:
        operator const Common01ShutdownRF& () const { return cb; }
        const Common01ShutdownRF& operator ->() const { return cb; }
        Common01ShutdownCB(const Common01ShutdownRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01ShutdownRsp :
      public Common01ShutdownCB {
        Common01ShutdownRsp(const Common01ShutdownRF& cb)
          : Common01ShutdownCB(cb) { }

    };

    virtual void async_common_0_1_shutdown
       (
	Common01ShutdownCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Request a startup of Xrl Target
     */
    virtual XrlCmdError common_0_1_startup() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Common01StartupRF;

    class Common01StartupCB {
        Common01StartupRF cb;

    public:
        operator const Common01StartupRF& () const { return cb; }
        const Common01StartupRF& operator ->() const { return cb; }
        Common01StartupCB(const Common01StartupRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Common01StartupRsp :
      public Common01StartupCB {
        Common01StartupRsp(const Common01StartupRF& cb)
          : Common01StartupCB(cb) { }

    };

    virtual void async_common_0_1_startup
       (
	Common01StartupCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the BGP version currently running.
     */
    virtual XrlCmdError bgp_0_3_get_bgp_version(
	// Output values,
	uint32_t&	version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Bgp03GetBgpVersionRF;

    class Bgp03GetBgpVersionCB {
        Bgp03GetBgpVersionRF cb;

    public:
        operator const Bgp03GetBgpVersionRF& () const { return cb; }
        const Bgp03GetBgpVersionRF& operator ->() const { return cb; }
        Bgp03GetBgpVersionCB(const Bgp03GetBgpVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_version);
        }
    };

    struct Bgp03GetBgpVersionRsp :
      public Bgp03GetBgpVersionCB {
        struct args_str {
            uint32_t version;
        };

    private:
        args_str args;

    public:
        Bgp03GetBgpVersionRsp(const Bgp03GetBgpVersionRF& cb)
          : Bgp03GetBgpVersionCB(cb) { }

        void respond() const {
            Bgp03GetBgpVersionCB::
            respond(args.version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_bgp_version
       (
	Bgp03GetBgpVersionCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get local config
     *
     *  @param id our BGP ID.
     */
    virtual XrlCmdError bgp_0_3_local_config(
	// Input values,
	const string&	as,
	const IPv4&	id,
	const bool&	use_4byte_asnums) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03LocalConfigRF;

    class Bgp03LocalConfigCB {
        Bgp03LocalConfigRF cb;

    public:
        operator const Bgp03LocalConfigRF& () const { return cb; }
        const Bgp03LocalConfigRF& operator ->() const { return cb; }
        Bgp03LocalConfigCB(const Bgp03LocalConfigRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03LocalConfigRsp :
      public Bgp03LocalConfigCB {
        Bgp03LocalConfigRsp(const Bgp03LocalConfigRF& cb)
          : Bgp03LocalConfigCB(cb) { }

    };

    virtual void async_bgp_0_3_local_config
       (
	const string&	as,
	const IPv4&	id,
	const bool&	use_4byte_asnums,
	Bgp03LocalConfigCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the local AS number.
     *
     *  @param as our AS number.
     */
    virtual XrlCmdError bgp_0_3_set_local_as(
	// Input values,
	const string&	as) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetLocalAsRF;

    class Bgp03SetLocalAsCB {
        Bgp03SetLocalAsRF cb;

    public:
        operator const Bgp03SetLocalAsRF& () const { return cb; }
        const Bgp03SetLocalAsRF& operator ->() const { return cb; }
        Bgp03SetLocalAsCB(const Bgp03SetLocalAsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetLocalAsRsp :
      public Bgp03SetLocalAsCB {
        Bgp03SetLocalAsRsp(const Bgp03SetLocalAsRF& cb)
          : Bgp03SetLocalAsCB(cb) { }

    };

    virtual void async_bgp_0_3_set_local_as
       (
	const string&	as,
	Bgp03SetLocalAsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Allow 4-byte AS numbers.
     *
     *  @param enable whether this is enabled.
     */
    virtual XrlCmdError bgp_0_3_set_4byte_as_support(
	// Input values,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03Set4ByteAsSupportRF;

    class Bgp03Set4ByteAsSupportCB {
        Bgp03Set4ByteAsSupportRF cb;

    public:
        operator const Bgp03Set4ByteAsSupportRF& () const { return cb; }
        const Bgp03Set4ByteAsSupportRF& operator ->() const { return cb; }
        Bgp03Set4ByteAsSupportCB(const Bgp03Set4ByteAsSupportRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03Set4ByteAsSupportRsp :
      public Bgp03Set4ByteAsSupportCB {
        Bgp03Set4ByteAsSupportRsp(const Bgp03Set4ByteAsSupportRF& cb)
          : Bgp03Set4ByteAsSupportCB(cb) { }

    };

    virtual void async_bgp_0_3_set_4byte_as_support
       (
	const bool&	enable,
	Bgp03Set4ByteAsSupportCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the local AS number.
     */
    virtual XrlCmdError bgp_0_3_get_local_as(
	// Output values,
	string&	as) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Bgp03GetLocalAsRF;

    class Bgp03GetLocalAsCB {
        Bgp03GetLocalAsRF cb;

    public:
        operator const Bgp03GetLocalAsRF& () const { return cb; }
        const Bgp03GetLocalAsRF& operator ->() const { return cb; }
        Bgp03GetLocalAsCB(const Bgp03GetLocalAsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_as) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_as);
        }
    };

    struct Bgp03GetLocalAsRsp :
      public Bgp03GetLocalAsCB {
        struct args_str {
            string as;
        };

    private:
        args_str args;

    public:
        Bgp03GetLocalAsRsp(const Bgp03GetLocalAsRF& cb)
          : Bgp03GetLocalAsCB(cb) { }

        void respond() const {
            Bgp03GetLocalAsCB::
            respond(args.as);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_local_as
       (
	Bgp03GetLocalAsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the BGP id.
     *
     *  @param id our BGP ID.
     */
    virtual XrlCmdError bgp_0_3_set_bgp_id(
	// Input values,
	const IPv4&	id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetBgpIdRF;

    class Bgp03SetBgpIdCB {
        Bgp03SetBgpIdRF cb;

    public:
        operator const Bgp03SetBgpIdRF& () const { return cb; }
        const Bgp03SetBgpIdRF& operator ->() const { return cb; }
        Bgp03SetBgpIdCB(const Bgp03SetBgpIdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetBgpIdRsp :
      public Bgp03SetBgpIdCB {
        Bgp03SetBgpIdRsp(const Bgp03SetBgpIdRF& cb)
          : Bgp03SetBgpIdCB(cb) { }

    };

    virtual void async_bgp_0_3_set_bgp_id
       (
	const IPv4&	id,
	Bgp03SetBgpIdCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the BGP id.
     */
    virtual XrlCmdError bgp_0_3_get_bgp_id(
	// Output values,
	IPv4&	id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Bgp03GetBgpIdRF;

    class Bgp03GetBgpIdCB {
        Bgp03GetBgpIdRF cb;

    public:
        operator const Bgp03GetBgpIdRF& () const { return cb; }
        const Bgp03GetBgpIdRF& operator ->() const { return cb; }
        Bgp03GetBgpIdCB(const Bgp03GetBgpIdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_id) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_id);
        }
    };

    struct Bgp03GetBgpIdRsp :
      public Bgp03GetBgpIdCB {
        struct args_str {
            IPv4 id;
        };

    private:
        args_str args;

    public:
        Bgp03GetBgpIdRsp(const Bgp03GetBgpIdRF& cb)
          : Bgp03GetBgpIdCB(cb) { }

        void respond() const {
            Bgp03GetBgpIdCB::
            respond(args.id);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_bgp_id
       (
	Bgp03GetBgpIdCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Confederation identifier.
     *
     *  @param as externally visible AS number.
     *
     *  @param disable true if confederations are disabled.
     */
    virtual XrlCmdError bgp_0_3_set_confederation_identifier(
	// Input values,
	const string&	as,
	const bool&	disable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetConfederationIdentifierRF;

    class Bgp03SetConfederationIdentifierCB {
        Bgp03SetConfederationIdentifierRF cb;

    public:
        operator const Bgp03SetConfederationIdentifierRF& () const { return cb; }
        const Bgp03SetConfederationIdentifierRF& operator ->() const { return cb; }
        Bgp03SetConfederationIdentifierCB(const Bgp03SetConfederationIdentifierRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetConfederationIdentifierRsp :
      public Bgp03SetConfederationIdentifierCB {
        Bgp03SetConfederationIdentifierRsp(const Bgp03SetConfederationIdentifierRF& cb)
          : Bgp03SetConfederationIdentifierCB(cb) { }

    };

    virtual void async_bgp_0_3_set_confederation_identifier
       (
	const string&	as,
	const bool&	disable,
	Bgp03SetConfederationIdentifierCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Route reflection.
     *
     *  @param cluster_id the route reflection cluster ID.
     *
     *  @param disable if true this router is a router reflector.
     */
    virtual XrlCmdError bgp_0_3_set_cluster_id(
	// Input values,
	const IPv4&	cluster_id,
	const bool&	disable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetClusterIdRF;

    class Bgp03SetClusterIdCB {
        Bgp03SetClusterIdRF cb;

    public:
        operator const Bgp03SetClusterIdRF& () const { return cb; }
        const Bgp03SetClusterIdRF& operator ->() const { return cb; }
        Bgp03SetClusterIdCB(const Bgp03SetClusterIdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetClusterIdRsp :
      public Bgp03SetClusterIdCB {
        Bgp03SetClusterIdRsp(const Bgp03SetClusterIdRF& cb)
          : Bgp03SetClusterIdCB(cb) { }

    };

    virtual void async_bgp_0_3_set_cluster_id
       (
	const IPv4&	cluster_id,
	const bool&	disable,
	Bgp03SetClusterIdCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Route Flap Damping. RFC 2439
     *
     *  @param half_life decay half life in minutes.
     *
     *  @param max_suppress maximum time in minutes a route can be held down.
     *
     *  @param reuse threshold, point at which a route can be reused.
     */
    virtual XrlCmdError bgp_0_3_set_damping(
	// Input values,
	const uint32_t&	half_life,
	const uint32_t&	max_suppress,
	const uint32_t&	reuse,
	const uint32_t&	suppress,
	const bool&	disable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetDampingRF;

    class Bgp03SetDampingCB {
        Bgp03SetDampingRF cb;

    public:
        operator const Bgp03SetDampingRF& () const { return cb; }
        const Bgp03SetDampingRF& operator ->() const { return cb; }
        Bgp03SetDampingCB(const Bgp03SetDampingRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetDampingRsp :
      public Bgp03SetDampingCB {
        Bgp03SetDampingRsp(const Bgp03SetDampingRF& cb)
          : Bgp03SetDampingCB(cb) { }

    };

    virtual void async_bgp_0_3_set_damping
       (
	const uint32_t&	half_life,
	const uint32_t&	max_suppress,
	const uint32_t&	reuse,
	const uint32_t&	suppress,
	const bool&	disable,
	Bgp03SetDampingCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Add peer.
     *
     *  @param as the peer's AS number.
     *
     *  @param next_hop the local next hop.
     *
     *  @param holdtime if traffic is not received in holdtime seconds a
     *  peering is considered down.
     */
    virtual XrlCmdError bgp_0_3_add_peer(
	// Input values,
	const string&	local_dev,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	as,
	const IPv4&	next_hop,
	const uint32_t&	holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03AddPeerRF;

    class Bgp03AddPeerCB {
        Bgp03AddPeerRF cb;

    public:
        operator const Bgp03AddPeerRF& () const { return cb; }
        const Bgp03AddPeerRF& operator ->() const { return cb; }
        Bgp03AddPeerCB(const Bgp03AddPeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03AddPeerRsp :
      public Bgp03AddPeerCB {
        Bgp03AddPeerRsp(const Bgp03AddPeerRF& cb)
          : Bgp03AddPeerCB(cb) { }

    };

    virtual void async_bgp_0_3_add_peer
       (
	const string&	local_dev,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	as,
	const IPv4&	next_hop,
	const uint32_t&	holdtime,
	Bgp03AddPeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Delete peer.
     */
    virtual XrlCmdError bgp_0_3_delete_peer(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03DeletePeerRF;

    class Bgp03DeletePeerCB {
        Bgp03DeletePeerRF cb;

    public:
        operator const Bgp03DeletePeerRF& () const { return cb; }
        const Bgp03DeletePeerRF& operator ->() const { return cb; }
        Bgp03DeletePeerCB(const Bgp03DeletePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03DeletePeerRsp :
      public Bgp03DeletePeerCB {
        Bgp03DeletePeerRsp(const Bgp03DeletePeerRF& cb)
          : Bgp03DeletePeerCB(cb) { }

    };

    virtual void async_bgp_0_3_delete_peer
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03DeletePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable this peer.
     */
    virtual XrlCmdError bgp_0_3_enable_peer(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03EnablePeerRF;

    class Bgp03EnablePeerCB {
        Bgp03EnablePeerRF cb;

    public:
        operator const Bgp03EnablePeerRF& () const { return cb; }
        const Bgp03EnablePeerRF& operator ->() const { return cb; }
        Bgp03EnablePeerCB(const Bgp03EnablePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03EnablePeerRsp :
      public Bgp03EnablePeerCB {
        Bgp03EnablePeerRsp(const Bgp03EnablePeerRF& cb)
          : Bgp03EnablePeerCB(cb) { }

    };

    virtual void async_bgp_0_3_enable_peer
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03EnablePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable this peer.
     */
    virtual XrlCmdError bgp_0_3_disable_peer(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03DisablePeerRF;

    class Bgp03DisablePeerCB {
        Bgp03DisablePeerRF cb;

    public:
        operator const Bgp03DisablePeerRF& () const { return cb; }
        const Bgp03DisablePeerRF& operator ->() const { return cb; }
        Bgp03DisablePeerCB(const Bgp03DisablePeerRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03DisablePeerRsp :
      public Bgp03DisablePeerCB {
        Bgp03DisablePeerRsp(const Bgp03DisablePeerRF& cb)
          : Bgp03DisablePeerCB(cb) { }

    };

    virtual void async_bgp_0_3_disable_peer
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03DisablePeerCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change the local IP address and interface.
     *
     *  @param local_ip current IP address.
     *
     *  @param local_port server port.
     *
     *  @param peer_ip IP address.
     *
     *  @param peer_port peer port.
     *
     *  @param new_local_ip new IP address.
     *
     *  @param new_local_dev new Interface Name.
     */
    virtual XrlCmdError bgp_0_3_change_local_ip(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	new_local_ip,
	const string&	new_local_dev) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03ChangeLocalIpRF;

    class Bgp03ChangeLocalIpCB {
        Bgp03ChangeLocalIpRF cb;

    public:
        operator const Bgp03ChangeLocalIpRF& () const { return cb; }
        const Bgp03ChangeLocalIpRF& operator ->() const { return cb; }
        Bgp03ChangeLocalIpCB(const Bgp03ChangeLocalIpRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03ChangeLocalIpRsp :
      public Bgp03ChangeLocalIpCB {
        Bgp03ChangeLocalIpRsp(const Bgp03ChangeLocalIpRF& cb)
          : Bgp03ChangeLocalIpCB(cb) { }

    };

    virtual void async_bgp_0_3_change_local_ip
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	new_local_ip,
	const string&	new_local_dev,
	Bgp03ChangeLocalIpCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change the local port.
     *
     *  @param local_ip current IP address.
     *
     *  @param local_port server port.
     *
     *  @param peer_ip IP address.
     *
     *  @param peer_port peer port.
     *
     *  @param new_local_port new local port.
     */
    virtual XrlCmdError bgp_0_3_change_local_port(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	new_local_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03ChangeLocalPortRF;

    class Bgp03ChangeLocalPortCB {
        Bgp03ChangeLocalPortRF cb;

    public:
        operator const Bgp03ChangeLocalPortRF& () const { return cb; }
        const Bgp03ChangeLocalPortRF& operator ->() const { return cb; }
        Bgp03ChangeLocalPortCB(const Bgp03ChangeLocalPortRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03ChangeLocalPortRsp :
      public Bgp03ChangeLocalPortCB {
        Bgp03ChangeLocalPortRsp(const Bgp03ChangeLocalPortRF& cb)
          : Bgp03ChangeLocalPortCB(cb) { }

    };

    virtual void async_bgp_0_3_change_local_port
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	new_local_port,
	Bgp03ChangeLocalPortCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Change the peer port.
     *
     *  @param local_ip current IP address.
     *
     *  @param local_port server port.
     *
     *  @param peer_ip IP address.
     *
     *  @param peer_port peer port.
     */
    virtual XrlCmdError bgp_0_3_change_peer_port(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	new_peer_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03ChangePeerPortRF;

    class Bgp03ChangePeerPortCB {
        Bgp03ChangePeerPortRF cb;

    public:
        operator const Bgp03ChangePeerPortRF& () const { return cb; }
        const Bgp03ChangePeerPortRF& operator ->() const { return cb; }
        Bgp03ChangePeerPortCB(const Bgp03ChangePeerPortRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03ChangePeerPortRsp :
      public Bgp03ChangePeerPortCB {
        Bgp03ChangePeerPortRsp(const Bgp03ChangePeerPortRF& cb)
          : Bgp03ChangePeerPortCB(cb) { }

    };

    virtual void async_bgp_0_3_change_peer_port
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	new_peer_port,
	Bgp03ChangePeerPortCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the peer's AS number.
     *
     *  @param peer_as the peer's AS number.
     */
    virtual XrlCmdError bgp_0_3_set_peer_as(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	peer_as) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetPeerAsRF;

    class Bgp03SetPeerAsCB {
        Bgp03SetPeerAsRF cb;

    public:
        operator const Bgp03SetPeerAsRF& () const { return cb; }
        const Bgp03SetPeerAsRF& operator ->() const { return cb; }
        Bgp03SetPeerAsCB(const Bgp03SetPeerAsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetPeerAsRsp :
      public Bgp03SetPeerAsCB {
        Bgp03SetPeerAsRsp(const Bgp03SetPeerAsRF& cb)
          : Bgp03SetPeerAsCB(cb) { }

    };

    virtual void async_bgp_0_3_set_peer_as
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	peer_as,
	Bgp03SetPeerAsCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the holdtime
     *
     *  @param holdtime if traffic is not received in holdtime seconds a
     *  peering is considered down.
     */
    virtual XrlCmdError bgp_0_3_set_holdtime(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	holdtime) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetHoldtimeRF;

    class Bgp03SetHoldtimeCB {
        Bgp03SetHoldtimeRF cb;

    public:
        operator const Bgp03SetHoldtimeRF& () const { return cb; }
        const Bgp03SetHoldtimeRF& operator ->() const { return cb; }
        Bgp03SetHoldtimeCB(const Bgp03SetHoldtimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetHoldtimeRsp :
      public Bgp03SetHoldtimeCB {
        Bgp03SetHoldtimeRsp(const Bgp03SetHoldtimeRF& cb)
          : Bgp03SetHoldtimeCB(cb) { }

    };

    virtual void async_bgp_0_3_set_holdtime
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	holdtime,
	Bgp03SetHoldtimeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the delay open time
     *
     *  @param delay_open_time to wait is seconds before sending an open.
     */
    virtual XrlCmdError bgp_0_3_set_delay_open_time(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	delay_open_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetDelayOpenTimeRF;

    class Bgp03SetDelayOpenTimeCB {
        Bgp03SetDelayOpenTimeRF cb;

    public:
        operator const Bgp03SetDelayOpenTimeRF& () const { return cb; }
        const Bgp03SetDelayOpenTimeRF& operator ->() const { return cb; }
        Bgp03SetDelayOpenTimeCB(const Bgp03SetDelayOpenTimeRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetDelayOpenTimeRsp :
      public Bgp03SetDelayOpenTimeCB {
        Bgp03SetDelayOpenTimeRsp(const Bgp03SetDelayOpenTimeRF& cb)
          : Bgp03SetDelayOpenTimeCB(cb) { }

    };

    virtual void async_bgp_0_3_set_delay_open_time
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	delay_open_time,
	Bgp03SetDelayOpenTimeCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the route reflection client state. Is this peer a route reflector
     *  client.
     *
     *  @param state true if peer is a route reflector client.
     */
    virtual XrlCmdError bgp_0_3_set_route_reflector_client(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const bool&	state) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetRouteReflectorClientRF;

    class Bgp03SetRouteReflectorClientCB {
        Bgp03SetRouteReflectorClientRF cb;

    public:
        operator const Bgp03SetRouteReflectorClientRF& () const { return cb; }
        const Bgp03SetRouteReflectorClientRF& operator ->() const { return cb; }
        Bgp03SetRouteReflectorClientCB(const Bgp03SetRouteReflectorClientRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetRouteReflectorClientRsp :
      public Bgp03SetRouteReflectorClientCB {
        Bgp03SetRouteReflectorClientRsp(const Bgp03SetRouteReflectorClientRF& cb)
          : Bgp03SetRouteReflectorClientCB(cb) { }

    };

    virtual void async_bgp_0_3_set_route_reflector_client
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const bool&	state,
	Bgp03SetRouteReflectorClientCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Is this peer a confederation member.
     *
     *  @param state true if peer is a confederation member.
     */
    virtual XrlCmdError bgp_0_3_set_confederation_member(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const bool&	state) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetConfederationMemberRF;

    class Bgp03SetConfederationMemberCB {
        Bgp03SetConfederationMemberRF cb;

    public:
        operator const Bgp03SetConfederationMemberRF& () const { return cb; }
        const Bgp03SetConfederationMemberRF& operator ->() const { return cb; }
        Bgp03SetConfederationMemberCB(const Bgp03SetConfederationMemberRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetConfederationMemberRsp :
      public Bgp03SetConfederationMemberCB {
        Bgp03SetConfederationMemberRsp(const Bgp03SetConfederationMemberRF& cb)
          : Bgp03SetConfederationMemberCB(cb) { }

    };

    virtual void async_bgp_0_3_set_confederation_member
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const bool&	state,
	Bgp03SetConfederationMemberCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the prefix limit.
     *
     *  @param maximum number of prefixes
     *
     *  @param state true if the prefix limit is being enforced
     */
    virtual XrlCmdError bgp_0_3_set_prefix_limit(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	maximum,
	const bool&	state) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetPrefixLimitRF;

    class Bgp03SetPrefixLimitCB {
        Bgp03SetPrefixLimitRF cb;

    public:
        operator const Bgp03SetPrefixLimitRF& () const { return cb; }
        const Bgp03SetPrefixLimitRF& operator ->() const { return cb; }
        Bgp03SetPrefixLimitCB(const Bgp03SetPrefixLimitRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetPrefixLimitRsp :
      public Bgp03SetPrefixLimitCB {
        Bgp03SetPrefixLimitRsp(const Bgp03SetPrefixLimitRF& cb)
          : Bgp03SetPrefixLimitCB(cb) { }

    };

    virtual void async_bgp_0_3_set_prefix_limit
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const uint32_t&	maximum,
	const bool&	state,
	Bgp03SetPrefixLimitCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the peer's AS number.
     *
     *  @param next_hop IPv4 nexthop.
     */
    virtual XrlCmdError bgp_0_3_set_nexthop4(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const IPv4&	next_hop) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetNexthop4RF;

    class Bgp03SetNexthop4CB {
        Bgp03SetNexthop4RF cb;

    public:
        operator const Bgp03SetNexthop4RF& () const { return cb; }
        const Bgp03SetNexthop4RF& operator ->() const { return cb; }
        Bgp03SetNexthop4CB(const Bgp03SetNexthop4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetNexthop4Rsp :
      public Bgp03SetNexthop4CB {
        Bgp03SetNexthop4Rsp(const Bgp03SetNexthop4RF& cb)
          : Bgp03SetNexthop4CB(cb) { }

    };

    virtual void async_bgp_0_3_set_nexthop4
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const IPv4&	next_hop,
	Bgp03SetNexthop4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the peer state enabled or disabled.
     *
     *  @param toggle enabled or disabled.
     */
    virtual XrlCmdError bgp_0_3_set_peer_state(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const bool&	toggle) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetPeerStateRF;

    class Bgp03SetPeerStateCB {
        Bgp03SetPeerStateRF cb;

    public:
        operator const Bgp03SetPeerStateRF& () const { return cb; }
        const Bgp03SetPeerStateRF& operator ->() const { return cb; }
        Bgp03SetPeerStateCB(const Bgp03SetPeerStateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetPeerStateRsp :
      public Bgp03SetPeerStateCB {
        Bgp03SetPeerStateRsp(const Bgp03SetPeerStateRF& cb)
          : Bgp03SetPeerStateCB(cb) { }

    };

    virtual void async_bgp_0_3_set_peer_state
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const bool&	toggle,
	Bgp03SetPeerStateCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the peer md5 password.
     *
     *  @param password the password to use for TCP-MD5 authentication.
     */
    virtual XrlCmdError bgp_0_3_set_peer_md5_password(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	password) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetPeerMd5PasswordRF;

    class Bgp03SetPeerMd5PasswordCB {
        Bgp03SetPeerMd5PasswordRF cb;

    public:
        operator const Bgp03SetPeerMd5PasswordRF& () const { return cb; }
        const Bgp03SetPeerMd5PasswordRF& operator ->() const { return cb; }
        Bgp03SetPeerMd5PasswordCB(const Bgp03SetPeerMd5PasswordRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetPeerMd5PasswordRsp :
      public Bgp03SetPeerMd5PasswordCB {
        Bgp03SetPeerMd5PasswordRsp(const Bgp03SetPeerMd5PasswordRF& cb)
          : Bgp03SetPeerMd5PasswordCB(cb) { }

    };

    virtual void async_bgp_0_3_set_peer_md5_password
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	password,
	Bgp03SetPeerMd5PasswordCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable or disable the peering based on the peer state.
     */
    virtual XrlCmdError bgp_0_3_activate(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03ActivateRF;

    class Bgp03ActivateCB {
        Bgp03ActivateRF cb;

    public:
        operator const Bgp03ActivateRF& () const { return cb; }
        const Bgp03ActivateRF& operator ->() const { return cb; }
        Bgp03ActivateCB(const Bgp03ActivateRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03ActivateRsp :
      public Bgp03ActivateCB {
        Bgp03ActivateRsp(const Bgp03ActivateRF& cb)
          : Bgp03ActivateCB(cb) { }

    };

    virtual void async_bgp_0_3_activate
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03ActivateCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set which parameters we support per peer
     */
    virtual XrlCmdError bgp_0_3_set_parameter(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	parameter,
	const bool&	toggle) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetParameterRF;

    class Bgp03SetParameterCB {
        Bgp03SetParameterRF cb;

    public:
        operator const Bgp03SetParameterRF& () const { return cb; }
        const Bgp03SetParameterRF& operator ->() const { return cb; }
        Bgp03SetParameterCB(const Bgp03SetParameterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetParameterRsp :
      public Bgp03SetParameterCB {
        Bgp03SetParameterRsp(const Bgp03SetParameterRF& cb)
          : Bgp03SetParameterCB(cb) { }

    };

    virtual void async_bgp_0_3_set_parameter
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const string&	parameter,
	const bool&	toggle,
	Bgp03SetParameterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set next hop rewrite filter. XXX - This is a temporary hack until we
     *  get programmable filters.
     */
    virtual XrlCmdError bgp_0_3_next_hop_rewrite_filter(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const IPv4&	next_hop) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03NextHopRewriteFilterRF;

    class Bgp03NextHopRewriteFilterCB {
        Bgp03NextHopRewriteFilterRF cb;

    public:
        operator const Bgp03NextHopRewriteFilterRF& () const { return cb; }
        const Bgp03NextHopRewriteFilterRF& operator ->() const { return cb; }
        Bgp03NextHopRewriteFilterCB(const Bgp03NextHopRewriteFilterRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03NextHopRewriteFilterRsp :
      public Bgp03NextHopRewriteFilterCB {
        Bgp03NextHopRewriteFilterRsp(const Bgp03NextHopRewriteFilterRF& cb)
          : Bgp03NextHopRewriteFilterCB(cb) { }

    };

    virtual void async_bgp_0_3_next_hop_rewrite_filter
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const IPv4&	next_hop,
	Bgp03NextHopRewriteFilterCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Originate route IPv4
     *
     *  @param nlri subnet to announce
     *
     *  @param next_hop to forward to
     *
     *  @param unicast if true install in unicast routing table
     *
     *  @param multicast if true install in multicast routing table
     */
    virtual XrlCmdError bgp_0_3_originate_route4(
	// Input values,
	const IPv4Net&	nlri,
	const IPv4&	next_hop,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03OriginateRoute4RF;

    class Bgp03OriginateRoute4CB {
        Bgp03OriginateRoute4RF cb;

    public:
        operator const Bgp03OriginateRoute4RF& () const { return cb; }
        const Bgp03OriginateRoute4RF& operator ->() const { return cb; }
        Bgp03OriginateRoute4CB(const Bgp03OriginateRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03OriginateRoute4Rsp :
      public Bgp03OriginateRoute4CB {
        Bgp03OriginateRoute4Rsp(const Bgp03OriginateRoute4RF& cb)
          : Bgp03OriginateRoute4CB(cb) { }

    };

    virtual void async_bgp_0_3_originate_route4
       (
	const IPv4Net&	nlri,
	const IPv4&	next_hop,
	const bool&	unicast,
	const bool&	multicast,
	Bgp03OriginateRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Withdraw route IPv4
     *
     *  @param nlri subnet to withdraw
     *
     *  @param unicast if true withdraw from unicast routing table
     *
     *  @param multicast if true withdraw from multicast routing table
     */
    virtual XrlCmdError bgp_0_3_withdraw_route4(
	// Input values,
	const IPv4Net&	nlri,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03WithdrawRoute4RF;

    class Bgp03WithdrawRoute4CB {
        Bgp03WithdrawRoute4RF cb;

    public:
        operator const Bgp03WithdrawRoute4RF& () const { return cb; }
        const Bgp03WithdrawRoute4RF& operator ->() const { return cb; }
        Bgp03WithdrawRoute4CB(const Bgp03WithdrawRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03WithdrawRoute4Rsp :
      public Bgp03WithdrawRoute4CB {
        Bgp03WithdrawRoute4Rsp(const Bgp03WithdrawRoute4RF& cb)
          : Bgp03WithdrawRoute4CB(cb) { }

    };

    virtual void async_bgp_0_3_withdraw_route4
       (
	const IPv4Net&	nlri,
	const bool&	unicast,
	const bool&	multicast,
	Bgp03WithdrawRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable/Disable tracing.
     *
     *  @param tvar trace variable.
     *
     *  @param enable set to true to enable false to disable.
     */
    virtual XrlCmdError bgp_0_3_trace(
	// Input values,
	const string&	tvar,
	const bool&	enable) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03TraceRF;

    class Bgp03TraceCB {
        Bgp03TraceRF cb;

    public:
        operator const Bgp03TraceRF& () const { return cb; }
        const Bgp03TraceRF& operator ->() const { return cb; }
        Bgp03TraceCB(const Bgp03TraceRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03TraceRsp :
      public Bgp03TraceCB {
        Bgp03TraceRsp(const Bgp03TraceRF& cb)
          : Bgp03TraceCB(cb) { }

    };

    virtual void async_bgp_0_3_trace
       (
	const string&	tvar,
	const bool&	enable,
	Bgp03TraceCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the first item of a list of BGP peers See RFC 1657 (BGP MIB) for
     *  full definitions of return values.
     *
     *  @param token returned token to be provided when calling
     *  get_peer_list_next.
     *
     *  @param more returned to indicate whether there are more list items
     *  remaining.
     */
    virtual XrlCmdError bgp_0_3_get_peer_list_start(
	// Output values,
	uint32_t&	token,
	bool&	more) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const bool*>::RefPtr
    Bgp03GetPeerListStartRF;

    class Bgp03GetPeerListStartCB {
        Bgp03GetPeerListStartRF cb;

    public:
        operator const Bgp03GetPeerListStartRF& () const { return cb; }
        const Bgp03GetPeerListStartRF& operator ->() const { return cb; }
        Bgp03GetPeerListStartCB(const Bgp03GetPeerListStartRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_token,
                     const bool& arg_more) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_token,
                         &arg_more);
        }
    };

    struct Bgp03GetPeerListStartRsp :
      public Bgp03GetPeerListStartCB {
        struct args_str {
            uint32_t token;
            bool more;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerListStartRsp(const Bgp03GetPeerListStartRF& cb)
          : Bgp03GetPeerListStartCB(cb) { }

        void respond() const {
            Bgp03GetPeerListStartCB::
            respond(args.token,
                        args.more);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_list_start
       (
	Bgp03GetPeerListStartCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the next item of a list of BGP peers
     *
     *  @param token token from prior call to get_peer_list
     *
     *  @param more returned to indicate whether there are more list items
     *  remaining.
     */
    virtual XrlCmdError bgp_0_3_get_peer_list_next(
	// Input values,
	const uint32_t&	token,
	// Output values,
	string&	local_ip,
	uint32_t&	local_port,
	string&	peer_ip,
	uint32_t&	peer_port,
	bool&	more) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback6<void, const XrlCmdError &,
	const string*,
	const uint32_t*,
	const string*,
	const uint32_t*,
	const bool*>::RefPtr
    Bgp03GetPeerListNextRF;

    class Bgp03GetPeerListNextCB {
        Bgp03GetPeerListNextRF cb;

    public:
        operator const Bgp03GetPeerListNextRF& () const { return cb; }
        const Bgp03GetPeerListNextRF& operator ->() const { return cb; }
        Bgp03GetPeerListNextCB(const Bgp03GetPeerListNextRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL); }

        void respond(const string& arg_local_ip,
                     const uint32_t& arg_local_port,
                     const string& arg_peer_ip,
                     const uint32_t& arg_peer_port,
                     const bool& arg_more) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_local_ip,
                         &arg_local_port,
                         &arg_peer_ip,
                         &arg_peer_port,
                         &arg_more);
        }
    };

    struct Bgp03GetPeerListNextRsp :
      public Bgp03GetPeerListNextCB {
        struct args_str {
            string local_ip;
            uint32_t local_port;
            string peer_ip;
            uint32_t peer_port;
            bool more;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerListNextRsp(const Bgp03GetPeerListNextRF& cb)
          : Bgp03GetPeerListNextCB(cb) { }

        void respond() const {
            Bgp03GetPeerListNextCB::
            respond(args.local_ip,
                        args.local_port,
                        args.peer_ip,
                        args.peer_port,
                        args.more);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_list_next
       (
	const uint32_t&	token,
	Bgp03GetPeerListNextCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_id(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	IPv4&	peer_id) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv4*>::RefPtr
    Bgp03GetPeerIdRF;

    class Bgp03GetPeerIdCB {
        Bgp03GetPeerIdRF cb;

    public:
        operator const Bgp03GetPeerIdRF& () const { return cb; }
        const Bgp03GetPeerIdRF& operator ->() const { return cb; }
        Bgp03GetPeerIdCB(const Bgp03GetPeerIdRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv4& arg_peer_id) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peer_id);
        }
    };

    struct Bgp03GetPeerIdRsp :
      public Bgp03GetPeerIdCB {
        struct args_str {
            IPv4 peer_id;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerIdRsp(const Bgp03GetPeerIdRF& cb)
          : Bgp03GetPeerIdCB(cb) { }

        void respond() const {
            Bgp03GetPeerIdCB::
            respond(args.peer_id);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_id
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerIdCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_status(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	uint32_t&	peer_state,
	uint32_t&	admin_status) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Bgp03GetPeerStatusRF;

    class Bgp03GetPeerStatusCB {
        Bgp03GetPeerStatusRF cb;

    public:
        operator const Bgp03GetPeerStatusRF& () const { return cb; }
        const Bgp03GetPeerStatusRF& operator ->() const { return cb; }
        Bgp03GetPeerStatusCB(const Bgp03GetPeerStatusRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_peer_state,
                     const uint32_t& arg_admin_status) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peer_state,
                         &arg_admin_status);
        }
    };

    struct Bgp03GetPeerStatusRsp :
      public Bgp03GetPeerStatusCB {
        struct args_str {
            uint32_t peer_state;
            uint32_t admin_status;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerStatusRsp(const Bgp03GetPeerStatusRF& cb)
          : Bgp03GetPeerStatusCB(cb) { }

        void respond() const {
            Bgp03GetPeerStatusCB::
            respond(args.peer_state,
                        args.admin_status);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_status
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerStatusCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_negotiated_version(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	int32_t&	neg_version) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const int32_t*>::RefPtr
    Bgp03GetPeerNegotiatedVersionRF;

    class Bgp03GetPeerNegotiatedVersionCB {
        Bgp03GetPeerNegotiatedVersionRF cb;

    public:
        operator const Bgp03GetPeerNegotiatedVersionRF& () const { return cb; }
        const Bgp03GetPeerNegotiatedVersionRF& operator ->() const { return cb; }
        Bgp03GetPeerNegotiatedVersionCB(const Bgp03GetPeerNegotiatedVersionRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const int32_t& arg_neg_version) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_neg_version);
        }
    };

    struct Bgp03GetPeerNegotiatedVersionRsp :
      public Bgp03GetPeerNegotiatedVersionCB {
        struct args_str {
            int32_t neg_version;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerNegotiatedVersionRsp(const Bgp03GetPeerNegotiatedVersionRF& cb)
          : Bgp03GetPeerNegotiatedVersionCB(cb) { }

        void respond() const {
            Bgp03GetPeerNegotiatedVersionCB::
            respond(args.neg_version);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_negotiated_version
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerNegotiatedVersionCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_as(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	string&	peer_as) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Bgp03GetPeerAsRF;

    class Bgp03GetPeerAsCB {
        Bgp03GetPeerAsRF cb;

    public:
        operator const Bgp03GetPeerAsRF& () const { return cb; }
        const Bgp03GetPeerAsRF& operator ->() const { return cb; }
        Bgp03GetPeerAsCB(const Bgp03GetPeerAsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_peer_as) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peer_as);
        }
    };

    struct Bgp03GetPeerAsRsp :
      public Bgp03GetPeerAsCB {
        struct args_str {
            string peer_as;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerAsRsp(const Bgp03GetPeerAsRF& cb)
          : Bgp03GetPeerAsCB(cb) { }

        void respond() const {
            Bgp03GetPeerAsCB::
            respond(args.peer_as);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_as
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerAsCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_msg_stats(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	uint32_t&	in_updates,
	uint32_t&	out_updates,
	uint32_t&	in_msgs,
	uint32_t&	out_msgs,
	uint32_t&	last_error,
	uint32_t&	in_update_elapsed) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback7<void, const XrlCmdError &,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Bgp03GetPeerMsgStatsRF;

    class Bgp03GetPeerMsgStatsCB {
        Bgp03GetPeerMsgStatsRF cb;

    public:
        operator const Bgp03GetPeerMsgStatsRF& () const { return cb; }
        const Bgp03GetPeerMsgStatsRF& operator ->() const { return cb; }
        Bgp03GetPeerMsgStatsCB(const Bgp03GetPeerMsgStatsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_in_updates,
                     const uint32_t& arg_out_updates,
                     const uint32_t& arg_in_msgs,
                     const uint32_t& arg_out_msgs,
                     const uint32_t& arg_last_error,
                     const uint32_t& arg_in_update_elapsed) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_in_updates,
                         &arg_out_updates,
                         &arg_in_msgs,
                         &arg_out_msgs,
                         &arg_last_error,
                         &arg_in_update_elapsed);
        }
    };

    struct Bgp03GetPeerMsgStatsRsp :
      public Bgp03GetPeerMsgStatsCB {
        struct args_str {
            uint32_t in_updates;
            uint32_t out_updates;
            uint32_t in_msgs;
            uint32_t out_msgs;
            uint32_t last_error;
            uint32_t in_update_elapsed;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerMsgStatsRsp(const Bgp03GetPeerMsgStatsRF& cb)
          : Bgp03GetPeerMsgStatsCB(cb) { }

        void respond() const {
            Bgp03GetPeerMsgStatsCB::
            respond(args.in_updates,
                        args.out_updates,
                        args.in_msgs,
                        args.out_msgs,
                        args.last_error,
                        args.in_update_elapsed);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_msg_stats
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerMsgStatsCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_established_stats(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	uint32_t&	transitions,
	uint32_t&	established_time) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback3<void, const XrlCmdError &,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Bgp03GetPeerEstablishedStatsRF;

    class Bgp03GetPeerEstablishedStatsCB {
        Bgp03GetPeerEstablishedStatsRF cb;

    public:
        operator const Bgp03GetPeerEstablishedStatsRF& () const { return cb; }
        const Bgp03GetPeerEstablishedStatsRF& operator ->() const { return cb; }
        Bgp03GetPeerEstablishedStatsCB(const Bgp03GetPeerEstablishedStatsRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL); }

        void respond(const uint32_t& arg_transitions,
                     const uint32_t& arg_established_time) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_transitions,
                         &arg_established_time);
        }
    };

    struct Bgp03GetPeerEstablishedStatsRsp :
      public Bgp03GetPeerEstablishedStatsCB {
        struct args_str {
            uint32_t transitions;
            uint32_t established_time;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerEstablishedStatsRsp(const Bgp03GetPeerEstablishedStatsRF& cb)
          : Bgp03GetPeerEstablishedStatsCB(cb) { }

        void respond() const {
            Bgp03GetPeerEstablishedStatsCB::
            respond(args.transitions,
                        args.established_time);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_established_stats
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerEstablishedStatsCB);
#endif

    virtual XrlCmdError bgp_0_3_get_peer_timer_config(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	uint32_t&	retry_interval,
	uint32_t&	hold_time,
	uint32_t&	keep_alive,
	uint32_t&	hold_time_conf,
	uint32_t&	keep_alive_conf,
	uint32_t&	min_as_orgination_interval,
	uint32_t&	min_route_adv_interval) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback8<void, const XrlCmdError &,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*,
	const uint32_t*>::RefPtr
    Bgp03GetPeerTimerConfigRF;

    class Bgp03GetPeerTimerConfigCB {
        Bgp03GetPeerTimerConfigRF cb;

    public:
        operator const Bgp03GetPeerTimerConfigRF& () const { return cb; }
        const Bgp03GetPeerTimerConfigRF& operator ->() const { return cb; }
        Bgp03GetPeerTimerConfigCB(const Bgp03GetPeerTimerConfigRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const uint32_t& arg_retry_interval,
                     const uint32_t& arg_hold_time,
                     const uint32_t& arg_keep_alive,
                     const uint32_t& arg_hold_time_conf,
                     const uint32_t& arg_keep_alive_conf,
                     const uint32_t& arg_min_as_orgination_interval,
                     const uint32_t& arg_min_route_adv_interval) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_retry_interval,
                         &arg_hold_time,
                         &arg_keep_alive,
                         &arg_hold_time_conf,
                         &arg_keep_alive_conf,
                         &arg_min_as_orgination_interval,
                         &arg_min_route_adv_interval);
        }
    };

    struct Bgp03GetPeerTimerConfigRsp :
      public Bgp03GetPeerTimerConfigCB {
        struct args_str {
            uint32_t retry_interval;
            uint32_t hold_time;
            uint32_t keep_alive;
            uint32_t hold_time_conf;
            uint32_t keep_alive_conf;
            uint32_t min_as_orgination_interval;
            uint32_t min_route_adv_interval;
        };

    private:
        args_str args;

    public:
        Bgp03GetPeerTimerConfigRsp(const Bgp03GetPeerTimerConfigRF& cb)
          : Bgp03GetPeerTimerConfigCB(cb) { }

        void respond() const {
            Bgp03GetPeerTimerConfigCB::
            respond(args.retry_interval,
                        args.hold_time,
                        args.keep_alive,
                        args.hold_time_conf,
                        args.keep_alive_conf,
                        args.min_as_orgination_interval,
                        args.min_route_adv_interval);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_peer_timer_config
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetPeerTimerConfigCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Register rib.
     *
     *  @param name rib name.
     */
    virtual XrlCmdError bgp_0_3_register_rib(
	// Input values,
	const string&	name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03RegisterRibRF;

    class Bgp03RegisterRibCB {
        Bgp03RegisterRibRF cb;

    public:
        operator const Bgp03RegisterRibRF& () const { return cb; }
        const Bgp03RegisterRibRF& operator ->() const { return cb; }
        Bgp03RegisterRibCB(const Bgp03RegisterRibRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03RegisterRibRsp :
      public Bgp03RegisterRibCB {
        Bgp03RegisterRibRsp(const Bgp03RegisterRibRF& cb)
          : Bgp03RegisterRibCB(cb) { }

    };

    virtual void async_bgp_0_3_register_rib
       (
	const string&	name,
	Bgp03RegisterRibCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the first item of a list of BGP routes See RFC 1657 (BGP MIB) for
     *  full definitions of return values.
     *
     *  @param net the subtree to examine. NB Either unicast or multicast
     *  should be set to true, but not both.
     *
     *  @param unicast request start of unicast routes.
     *
     *  @param multicast request start of unicast routes.
     *
     *  @param token returned token to be provided when calling
     *  get_route_list_next.
     */
    virtual XrlCmdError bgp_0_3_get_v4_route_list_start(
	// Input values,
	const IPv4Net&	net,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	uint32_t&	token) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Bgp03GetV4RouteListStartRF;

    class Bgp03GetV4RouteListStartCB {
        Bgp03GetV4RouteListStartRF cb;

    public:
        operator const Bgp03GetV4RouteListStartRF& () const { return cb; }
        const Bgp03GetV4RouteListStartRF& operator ->() const { return cb; }
        Bgp03GetV4RouteListStartCB(const Bgp03GetV4RouteListStartRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_token) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_token);
        }
    };

    struct Bgp03GetV4RouteListStartRsp :
      public Bgp03GetV4RouteListStartCB {
        struct args_str {
            uint32_t token;
        };

    private:
        args_str args;

    public:
        Bgp03GetV4RouteListStartRsp(const Bgp03GetV4RouteListStartRF& cb)
          : Bgp03GetV4RouteListStartCB(cb) { }

        void respond() const {
            Bgp03GetV4RouteListStartCB::
            respond(args.token);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_v4_route_list_start
       (
	const IPv4Net&	net,
	const bool&	unicast,
	const bool&	multicast,
	Bgp03GetV4RouteListStartCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the next route in the list See RFC 1657 (BGP MIB) for full
     *  definitions of return values.
     */
    virtual XrlCmdError bgp_0_3_get_v4_route_list_next(
	// Input values,
	const uint32_t&	token,
	// Output values,
	IPv4&	peer_id,
	IPv4Net&	net,
	uint32_t&	best_and_origin,
	vector<uint8_t>&	aspath,
	IPv4&	nexthop,
	int32_t&	med,
	int32_t&	localpref,
	int32_t&	atomic_agg,
	vector<uint8_t>&	aggregator,
	int32_t&	calc_localpref,
	vector<uint8_t>&	attr_unknown,
	bool&	valid,
	bool&	unicast,
	bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback15<void, const XrlCmdError &,
	const IPv4*,
	const IPv4Net*,
	const uint32_t*,
	const vector<uint8_t>*,
	const IPv4*,
	const int32_t*,
	const int32_t*,
	const int32_t*,
	const vector<uint8_t>*,
	const int32_t*,
	const vector<uint8_t>*,
	const bool*,
	const bool*,
	const bool*>::RefPtr
    Bgp03GetV4RouteListNextRF;

    class Bgp03GetV4RouteListNextCB {
        Bgp03GetV4RouteListNextRF cb;

    public:
        operator const Bgp03GetV4RouteListNextRF& () const { return cb; }
        const Bgp03GetV4RouteListNextRF& operator ->() const { return cb; }
        Bgp03GetV4RouteListNextCB(const Bgp03GetV4RouteListNextRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_peer_id,
                     const IPv4Net& arg_net,
                     const uint32_t& arg_best_and_origin,
                     const vector<uint8_t>& arg_aspath,
                     const IPv4& arg_nexthop,
                     const int32_t& arg_med,
                     const int32_t& arg_localpref,
                     const int32_t& arg_atomic_agg,
                     const vector<uint8_t>& arg_aggregator,
                     const int32_t& arg_calc_localpref,
                     const vector<uint8_t>& arg_attr_unknown,
                     const bool& arg_valid,
                     const bool& arg_unicast,
                     const bool& arg_multicast) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peer_id,
                         &arg_net,
                         &arg_best_and_origin,
                         &arg_aspath,
                         &arg_nexthop,
                         &arg_med,
                         &arg_localpref,
                         &arg_atomic_agg,
                         &arg_aggregator,
                         &arg_calc_localpref,
                         &arg_attr_unknown,
                         &arg_valid,
                         &arg_unicast,
                         &arg_multicast);
        }
    };

    struct Bgp03GetV4RouteListNextRsp :
      public Bgp03GetV4RouteListNextCB {
        struct args_str {
            IPv4 peer_id;
            IPv4Net net;
            uint32_t best_and_origin;
            vector<uint8_t> aspath;
            IPv4 nexthop;
            int32_t med;
            int32_t localpref;
            int32_t atomic_agg;
            vector<uint8_t> aggregator;
            int32_t calc_localpref;
            vector<uint8_t> attr_unknown;
            bool valid;
            bool unicast;
            bool multicast;
        };

    private:
        args_str args;

    public:
        Bgp03GetV4RouteListNextRsp(const Bgp03GetV4RouteListNextRF& cb)
          : Bgp03GetV4RouteListNextCB(cb) { }

        void respond() const {
            Bgp03GetV4RouteListNextCB::
            respond(args.peer_id,
                        args.net,
                        args.best_and_origin,
                        args.aspath,
                        args.nexthop,
                        args.med,
                        args.localpref,
                        args.atomic_agg,
                        args.aggregator,
                        args.calc_localpref,
                        args.attr_unknown,
                        args.valid,
                        args.unicast,
                        args.multicast);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_v4_route_list_next
       (
	const uint32_t&	token,
	Bgp03GetV4RouteListNextCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Set the IPv6 nexthop.
     *
     *  @param next_hop IPv6 nexthop
     */
    virtual XrlCmdError bgp_0_3_set_nexthop6(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const IPv6&	next_hop) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03SetNexthop6RF;

    class Bgp03SetNexthop6CB {
        Bgp03SetNexthop6RF cb;

    public:
        operator const Bgp03SetNexthop6RF& () const { return cb; }
        const Bgp03SetNexthop6RF& operator ->() const { return cb; }
        Bgp03SetNexthop6CB(const Bgp03SetNexthop6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03SetNexthop6Rsp :
      public Bgp03SetNexthop6CB {
        Bgp03SetNexthop6Rsp(const Bgp03SetNexthop6RF& cb)
          : Bgp03SetNexthop6CB(cb) { }

    };

    virtual void async_bgp_0_3_set_nexthop6
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	const IPv6&	next_hop,
	Bgp03SetNexthop6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the IPv6 nexthop.
     *
     *  @param next_hop IPv6 nexthop
     */
    virtual XrlCmdError bgp_0_3_get_nexthop6(
	// Input values,
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	// Output values,
	IPv6&	next_hop) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const IPv6*>::RefPtr
    Bgp03GetNexthop6RF;

    class Bgp03GetNexthop6CB {
        Bgp03GetNexthop6RF cb;

    public:
        operator const Bgp03GetNexthop6RF& () const { return cb; }
        const Bgp03GetNexthop6RF& operator ->() const { return cb; }
        Bgp03GetNexthop6CB(const Bgp03GetNexthop6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const IPv6& arg_next_hop) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_next_hop);
        }
    };

    struct Bgp03GetNexthop6Rsp :
      public Bgp03GetNexthop6CB {
        struct args_str {
            IPv6 next_hop;
        };

    private:
        args_str args;

    public:
        Bgp03GetNexthop6Rsp(const Bgp03GetNexthop6RF& cb)
          : Bgp03GetNexthop6CB(cb) { }

        void respond() const {
            Bgp03GetNexthop6CB::
            respond(args.next_hop);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_nexthop6
       (
	const string&	local_ip,
	const uint32_t&	local_port,
	const string&	peer_ip,
	const uint32_t&	peer_port,
	Bgp03GetNexthop6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Withdraw route IPv6
     *
     *  @param nlri subnet to withdraw
     *
     *  @param unicast if true withdraw from unicast routing table
     *
     *  @param multicast if true withdraw from multicast routing table
     */
    virtual XrlCmdError bgp_0_3_withdraw_route6(
	// Input values,
	const IPv6Net&	nlri,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03WithdrawRoute6RF;

    class Bgp03WithdrawRoute6CB {
        Bgp03WithdrawRoute6RF cb;

    public:
        operator const Bgp03WithdrawRoute6RF& () const { return cb; }
        const Bgp03WithdrawRoute6RF& operator ->() const { return cb; }
        Bgp03WithdrawRoute6CB(const Bgp03WithdrawRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03WithdrawRoute6Rsp :
      public Bgp03WithdrawRoute6CB {
        Bgp03WithdrawRoute6Rsp(const Bgp03WithdrawRoute6RF& cb)
          : Bgp03WithdrawRoute6CB(cb) { }

    };

    virtual void async_bgp_0_3_withdraw_route6
       (
	const IPv6Net&	nlri,
	const bool&	unicast,
	const bool&	multicast,
	Bgp03WithdrawRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the first item of a list of BGP routes See RFC 1657 (BGP MIB) for
     *  full definitions of return values.
     *
     *  @param net the subtree to examine. NB Either unicast or multicast
     *  should be set to true, but not both.
     *
     *  @param unicast request start of unicast routes.
     *
     *  @param multicast request start of multicast routes.
     *
     *  @param token returned token to be provided when calling
     *  get_route_list_next.
     */
    virtual XrlCmdError bgp_0_3_get_v6_route_list_start(
	// Input values,
	const IPv6Net&	net,
	const bool&	unicast,
	const bool&	multicast,
	// Output values,
	uint32_t&	token) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const uint32_t*>::RefPtr
    Bgp03GetV6RouteListStartRF;

    class Bgp03GetV6RouteListStartCB {
        Bgp03GetV6RouteListStartRF cb;

    public:
        operator const Bgp03GetV6RouteListStartRF& () const { return cb; }
        const Bgp03GetV6RouteListStartRF& operator ->() const { return cb; }
        Bgp03GetV6RouteListStartCB(const Bgp03GetV6RouteListStartRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const uint32_t& arg_token) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_token);
        }
    };

    struct Bgp03GetV6RouteListStartRsp :
      public Bgp03GetV6RouteListStartCB {
        struct args_str {
            uint32_t token;
        };

    private:
        args_str args;

    public:
        Bgp03GetV6RouteListStartRsp(const Bgp03GetV6RouteListStartRF& cb)
          : Bgp03GetV6RouteListStartCB(cb) { }

        void respond() const {
            Bgp03GetV6RouteListStartCB::
            respond(args.token);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_v6_route_list_start
       (
	const IPv6Net&	net,
	const bool&	unicast,
	const bool&	multicast,
	Bgp03GetV6RouteListStartCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Originate route IPv6
     *
     *  @param nlri subnet to announce
     *
     *  @param next_hop to forward to
     *
     *  @param unicast if true install in unicast routing table
     *
     *  @param multicast if true install in multicast routing table
     */
    virtual XrlCmdError bgp_0_3_originate_route6(
	// Input values,
	const IPv6Net&	nlri,
	const IPv6&	next_hop,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Bgp03OriginateRoute6RF;

    class Bgp03OriginateRoute6CB {
        Bgp03OriginateRoute6RF cb;

    public:
        operator const Bgp03OriginateRoute6RF& () const { return cb; }
        const Bgp03OriginateRoute6RF& operator ->() const { return cb; }
        Bgp03OriginateRoute6CB(const Bgp03OriginateRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Bgp03OriginateRoute6Rsp :
      public Bgp03OriginateRoute6CB {
        Bgp03OriginateRoute6Rsp(const Bgp03OriginateRoute6RF& cb)
          : Bgp03OriginateRoute6CB(cb) { }

    };

    virtual void async_bgp_0_3_originate_route6
       (
	const IPv6Net&	nlri,
	const IPv6&	next_hop,
	const bool&	unicast,
	const bool&	multicast,
	Bgp03OriginateRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get the next route in the list See RFC 1657 (BGP MIB) for full
     *  definitions of return values.
     */
    virtual XrlCmdError bgp_0_3_get_v6_route_list_next(
	// Input values,
	const uint32_t&	token,
	// Output values,
	IPv4&	peer_id,
	IPv6Net&	net,
	uint32_t&	best_and_origin,
	vector<uint8_t>&	aspath,
	IPv6&	nexthop,
	int32_t&	med,
	int32_t&	localpref,
	int32_t&	atomic_agg,
	vector<uint8_t>&	aggregator,
	int32_t&	calc_localpref,
	vector<uint8_t>&	attr_unknown,
	bool&	valid,
	bool&	unicast,
	bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback15<void, const XrlCmdError &,
	const IPv4*,
	const IPv6Net*,
	const uint32_t*,
	const vector<uint8_t>*,
	const IPv6*,
	const int32_t*,
	const int32_t*,
	const int32_t*,
	const vector<uint8_t>*,
	const int32_t*,
	const vector<uint8_t>*,
	const bool*,
	const bool*,
	const bool*>::RefPtr
    Bgp03GetV6RouteListNextRF;

    class Bgp03GetV6RouteListNextCB {
        Bgp03GetV6RouteListNextRF cb;

    public:
        operator const Bgp03GetV6RouteListNextRF& () const { return cb; }
        const Bgp03GetV6RouteListNextRF& operator ->() const { return cb; }
        Bgp03GetV6RouteListNextCB(const Bgp03GetV6RouteListNextRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }

        void respond(const IPv4& arg_peer_id,
                     const IPv6Net& arg_net,
                     const uint32_t& arg_best_and_origin,
                     const vector<uint8_t>& arg_aspath,
                     const IPv6& arg_nexthop,
                     const int32_t& arg_med,
                     const int32_t& arg_localpref,
                     const int32_t& arg_atomic_agg,
                     const vector<uint8_t>& arg_aggregator,
                     const int32_t& arg_calc_localpref,
                     const vector<uint8_t>& arg_attr_unknown,
                     const bool& arg_valid,
                     const bool& arg_unicast,
                     const bool& arg_multicast) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_peer_id,
                         &arg_net,
                         &arg_best_and_origin,
                         &arg_aspath,
                         &arg_nexthop,
                         &arg_med,
                         &arg_localpref,
                         &arg_atomic_agg,
                         &arg_aggregator,
                         &arg_calc_localpref,
                         &arg_attr_unknown,
                         &arg_valid,
                         &arg_unicast,
                         &arg_multicast);
        }
    };

    struct Bgp03GetV6RouteListNextRsp :
      public Bgp03GetV6RouteListNextCB {
        struct args_str {
            IPv4 peer_id;
            IPv6Net net;
            uint32_t best_and_origin;
            vector<uint8_t> aspath;
            IPv6 nexthop;
            int32_t med;
            int32_t localpref;
            int32_t atomic_agg;
            vector<uint8_t> aggregator;
            int32_t calc_localpref;
            vector<uint8_t> attr_unknown;
            bool valid;
            bool unicast;
            bool multicast;
        };

    private:
        args_str args;

    public:
        Bgp03GetV6RouteListNextRsp(const Bgp03GetV6RouteListNextRF& cb)
          : Bgp03GetV6RouteListNextCB(cb) { }

        void respond() const {
            Bgp03GetV6RouteListNextCB::
            respond(args.peer_id,
                        args.net,
                        args.best_and_origin,
                        args.aspath,
                        args.nexthop,
                        args.med,
                        args.localpref,
                        args.atomic_agg,
                        args.aggregator,
                        args.calc_localpref,
                        args.attr_unknown,
                        args.valid,
                        args.unicast,
                        args.multicast);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_bgp_0_3_get_v6_route_list_next
       (
	const uint32_t&	token,
	Bgp03GetV6RouteListNextCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target birth to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_birth(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetBirthRF;

    class FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRF cb;

    public:
        operator const FinderEventObserver01XrlTargetBirthRF& () const { return cb; }
        const FinderEventObserver01XrlTargetBirthRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetBirthCB(const FinderEventObserver01XrlTargetBirthRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetBirthRsp :
      public FinderEventObserver01XrlTargetBirthCB {
        FinderEventObserver01XrlTargetBirthRsp(const FinderEventObserver01XrlTargetBirthRF& cb)
          : FinderEventObserver01XrlTargetBirthCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_birth
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetBirthCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Announce target death to observer.
     *
     *  @param target_class the target class name.
     *
     *  @param target_instance the target instance name.
     */
    virtual XrlCmdError finder_event_observer_0_1_xrl_target_death(
	// Input values,
	const string&	target_class,
	const string&	target_instance) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    FinderEventObserver01XrlTargetDeathRF;

    class FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRF cb;

    public:
        operator const FinderEventObserver01XrlTargetDeathRF& () const { return cb; }
        const FinderEventObserver01XrlTargetDeathRF& operator ->() const { return cb; }
        FinderEventObserver01XrlTargetDeathCB(const FinderEventObserver01XrlTargetDeathRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct FinderEventObserver01XrlTargetDeathRsp :
      public FinderEventObserver01XrlTargetDeathCB {
        FinderEventObserver01XrlTargetDeathRsp(const FinderEventObserver01XrlTargetDeathRF& cb)
          : FinderEventObserver01XrlTargetDeathCB(cb) { }

    };

    virtual void async_finder_event_observer_0_1_xrl_target_death
       (
	const string&	target_class,
	const string&	target_instance,
	FinderEventObserver01XrlTargetDeathCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Configure a policy filter.
     *
     *  @param filter the identifier of the filter to configure.
     *
     *  @param conf the configuration of the filter.
     */
    virtual XrlCmdError policy_backend_0_1_configure(
	// Input values,
	const uint32_t&	filter,
	const string&	conf) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ConfigureRF;

    class PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRF cb;

    public:
        operator const PolicyBackend01ConfigureRF& () const { return cb; }
        const PolicyBackend01ConfigureRF& operator ->() const { return cb; }
        PolicyBackend01ConfigureCB(const PolicyBackend01ConfigureRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ConfigureRsp :
      public PolicyBackend01ConfigureCB {
        PolicyBackend01ConfigureRsp(const PolicyBackend01ConfigureRF& cb)
          : PolicyBackend01ConfigureCB(cb) { }

    };

    virtual void async_policy_backend_0_1_configure
       (
	const uint32_t&	filter,
	const string&	conf,
	PolicyBackend01ConfigureCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Reset a policy filter.
     *
     *  @param filter the identifier of the filter to reset.
     */
    virtual XrlCmdError policy_backend_0_1_reset(
	// Input values,
	const uint32_t&	filter) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01ResetRF;

    class PolicyBackend01ResetCB {
        PolicyBackend01ResetRF cb;

    public:
        operator const PolicyBackend01ResetRF& () const { return cb; }
        const PolicyBackend01ResetRF& operator ->() const { return cb; }
        PolicyBackend01ResetCB(const PolicyBackend01ResetRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01ResetRsp :
      public PolicyBackend01ResetCB {
        PolicyBackend01ResetRsp(const PolicyBackend01ResetRF& cb)
          : PolicyBackend01ResetCB(cb) { }

    };

    virtual void async_policy_backend_0_1_reset
       (
	const uint32_t&	filter,
	PolicyBackend01ResetCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Push all available routes through all filters for re-filtering.
     */
    virtual XrlCmdError policy_backend_0_1_push_routes() = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyBackend01PushRoutesRF;

    class PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRF cb;

    public:
        operator const PolicyBackend01PushRoutesRF& () const { return cb; }
        const PolicyBackend01PushRoutesRF& operator ->() const { return cb; }
        PolicyBackend01PushRoutesCB(const PolicyBackend01PushRoutesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyBackend01PushRoutesRsp :
      public PolicyBackend01PushRoutesCB {
        PolicyBackend01PushRoutesRsp(const PolicyBackend01PushRoutesRF& cb)
          : PolicyBackend01PushRoutesCB(cb) { }

    };

    virtual void async_policy_backend_0_1_push_routes
       (
	PolicyBackend01PushRoutesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv4 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist4_0_1_add_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401AddRoute4RF;

    class PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4RF cb;

    public:
        operator const PolicyRedist401AddRoute4RF& () const { return cb; }
        const PolicyRedist401AddRoute4RF& operator ->() const { return cb; }
        PolicyRedist401AddRoute4CB(const PolicyRedist401AddRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401AddRoute4Rsp :
      public PolicyRedist401AddRoute4CB {
        PolicyRedist401AddRoute4Rsp(const PolicyRedist401AddRoute4RF& cb)
          : PolicyRedist401AddRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_add_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist401AddRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv4 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist4_0_1_delete_route4(
	// Input values,
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist401DeleteRoute4RF;

    class PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4RF cb;

    public:
        operator const PolicyRedist401DeleteRoute4RF& () const { return cb; }
        const PolicyRedist401DeleteRoute4RF& operator ->() const { return cb; }
        PolicyRedist401DeleteRoute4CB(const PolicyRedist401DeleteRoute4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist401DeleteRoute4Rsp :
      public PolicyRedist401DeleteRoute4CB {
        PolicyRedist401DeleteRoute4Rsp(const PolicyRedist401DeleteRoute4RF& cb)
          : PolicyRedist401DeleteRoute4CB(cb) { }

    };

    virtual void async_policy_redist4_0_1_delete_route4
       (
	const IPv4Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist401DeleteRoute4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Route Info Changed route_info_changed is called by the RIB on the RIB
     *  client (typically a routing protocol) that had registered an interest
     *  in the routing of an address. This can be because the metric and/or
     *  nexthop changed.
     *
     *  @param addr base address of the subnet that was registered
     *
     *  @param prefix_len prefix length of the subnet that was registered
     *
     *  @param metric the routing metric toward the address.
     *
     *  @param admin_distance the administratively defined distance toward the
     *  address.
     *
     *  @param protocol_origin the name of the protocol that originated this
     *  routing entry.
     */
    virtual XrlCmdError rib_client_0_1_route_info_changed4(
	// Input values,
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoChanged4RF;

    class RibClient01RouteInfoChanged4CB {
        RibClient01RouteInfoChanged4RF cb;

    public:
        operator const RibClient01RouteInfoChanged4RF& () const { return cb; }
        const RibClient01RouteInfoChanged4RF& operator ->() const { return cb; }
        RibClient01RouteInfoChanged4CB(const RibClient01RouteInfoChanged4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoChanged4Rsp :
      public RibClient01RouteInfoChanged4CB {
        RibClient01RouteInfoChanged4Rsp(const RibClient01RouteInfoChanged4RF& cb)
          : RibClient01RouteInfoChanged4CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_changed4
       (
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	const IPv4&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin,
	RibClient01RouteInfoChanged4CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Route Info Invalid route_info_invalid is called by the RIB on the RIB
     *  client (typically a routing protocol) that had registere d an interest
     *  in the routing of an address. This can be because the information
     *  previously reported as applying no longer applies for any number of
     *  reasons. When the RIB sends this message, it has automatically
     *  de-registered interest in the route, and the client will normally need
     *  to send a register_interest request again.
     */
    virtual XrlCmdError rib_client_0_1_route_info_invalid4(
	// Input values,
	const IPv4&	addr,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoInvalid4RF;

    class RibClient01RouteInfoInvalid4CB {
        RibClient01RouteInfoInvalid4RF cb;

    public:
        operator const RibClient01RouteInfoInvalid4RF& () const { return cb; }
        const RibClient01RouteInfoInvalid4RF& operator ->() const { return cb; }
        RibClient01RouteInfoInvalid4CB(const RibClient01RouteInfoInvalid4RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoInvalid4Rsp :
      public RibClient01RouteInfoInvalid4CB {
        RibClient01RouteInfoInvalid4Rsp(const RibClient01RouteInfoInvalid4RF& cb)
          : RibClient01RouteInfoInvalid4CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_invalid4
       (
	const IPv4&	addr,
	const uint32_t&	prefix_len,
	RibClient01RouteInfoInvalid4CB);
#endif

    virtual XrlCmdError rib_client_0_1_route_info_changed6(
	// Input values,
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoChanged6RF;

    class RibClient01RouteInfoChanged6CB {
        RibClient01RouteInfoChanged6RF cb;

    public:
        operator const RibClient01RouteInfoChanged6RF& () const { return cb; }
        const RibClient01RouteInfoChanged6RF& operator ->() const { return cb; }
        RibClient01RouteInfoChanged6CB(const RibClient01RouteInfoChanged6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoChanged6Rsp :
      public RibClient01RouteInfoChanged6CB {
        RibClient01RouteInfoChanged6Rsp(const RibClient01RouteInfoChanged6RF& cb)
          : RibClient01RouteInfoChanged6CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_changed6
       (
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const uint32_t&	admin_distance,
	const string&	protocol_origin,
	RibClient01RouteInfoChanged6CB);
#endif

    virtual XrlCmdError rib_client_0_1_route_info_invalid6(
	// Input values,
	const IPv6&	addr,
	const uint32_t&	prefix_len) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    RibClient01RouteInfoInvalid6RF;

    class RibClient01RouteInfoInvalid6CB {
        RibClient01RouteInfoInvalid6RF cb;

    public:
        operator const RibClient01RouteInfoInvalid6RF& () const { return cb; }
        const RibClient01RouteInfoInvalid6RF& operator ->() const { return cb; }
        RibClient01RouteInfoInvalid6CB(const RibClient01RouteInfoInvalid6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct RibClient01RouteInfoInvalid6Rsp :
      public RibClient01RouteInfoInvalid6CB {
        RibClient01RouteInfoInvalid6Rsp(const RibClient01RouteInfoInvalid6RF& cb)
          : RibClient01RouteInfoInvalid6CB(cb) { }

    };

    virtual void async_rib_client_0_1_route_info_invalid6
       (
	const IPv6&	addr,
	const uint32_t&	prefix_len,
	RibClient01RouteInfoInvalid6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Start route redistribution for an IPv6 route.
     *
     *  @param network the route to advertise.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     *
     *  @param nexthop the nexthop of the route.
     *
     *  @param metric the metric of the route.
     *
     *  @param policytags the set of policy-tags associated with the route.
     */
    virtual XrlCmdError policy_redist6_0_1_add_route6(
	// Input values,
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist601AddRoute6RF;

    class PolicyRedist601AddRoute6CB {
        PolicyRedist601AddRoute6RF cb;

    public:
        operator const PolicyRedist601AddRoute6RF& () const { return cb; }
        const PolicyRedist601AddRoute6RF& operator ->() const { return cb; }
        PolicyRedist601AddRoute6CB(const PolicyRedist601AddRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist601AddRoute6Rsp :
      public PolicyRedist601AddRoute6CB {
        PolicyRedist601AddRoute6Rsp(const PolicyRedist601AddRoute6RF& cb)
          : PolicyRedist601AddRoute6CB(cb) { }

    };

    virtual void async_policy_redist6_0_1_add_route6
       (
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	const IPv6&	nexthop,
	const uint32_t&	metric,
	const XrlAtomList&	policytags,
	PolicyRedist601AddRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Terminate route redistribution for an IPv6 route.
     *
     *  @param network the route for which advertisements should cease.
     *
     *  @param unicast whether the route is unicast.
     *
     *  @param multicast whether the route is multicast.
     */
    virtual XrlCmdError policy_redist6_0_1_delete_route6(
	// Input values,
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    PolicyRedist601DeleteRoute6RF;

    class PolicyRedist601DeleteRoute6CB {
        PolicyRedist601DeleteRoute6RF cb;

    public:
        operator const PolicyRedist601DeleteRoute6RF& () const { return cb; }
        const PolicyRedist601DeleteRoute6RF& operator ->() const { return cb; }
        PolicyRedist601DeleteRoute6CB(const PolicyRedist601DeleteRoute6RF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct PolicyRedist601DeleteRoute6Rsp :
      public PolicyRedist601DeleteRoute6CB {
        PolicyRedist601DeleteRoute6Rsp(const PolicyRedist601DeleteRoute6RF& cb)
          : PolicyRedist601DeleteRoute6CB(cb) { }

    };

    virtual void async_policy_redist6_0_1_delete_route6
       (
	const IPv6Net&	network,
	const bool&	unicast,
	const bool&	multicast,
	PolicyRedist601DeleteRoute6CB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Enable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_enable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01EnableRF;

    class Profile01EnableCB {
        Profile01EnableRF cb;

    public:
        operator const Profile01EnableRF& () const { return cb; }
        const Profile01EnableRF& operator ->() const { return cb; }
        Profile01EnableCB(const Profile01EnableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01EnableRsp :
      public Profile01EnableCB {
        Profile01EnableRsp(const Profile01EnableRF& cb)
          : Profile01EnableCB(cb) { }

    };

    virtual void async_profile_0_1_enable
       (
	const string&	pname,
	Profile01EnableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Disable profiling
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_disable(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01DisableRF;

    class Profile01DisableCB {
        Profile01DisableRF cb;

    public:
        operator const Profile01DisableRF& () const { return cb; }
        const Profile01DisableRF& operator ->() const { return cb; }
        Profile01DisableCB(const Profile01DisableRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01DisableRsp :
      public Profile01DisableCB {
        Profile01DisableRsp(const Profile01DisableRF& cb)
          : Profile01DisableCB(cb) { }

    };

    virtual void async_profile_0_1_disable
       (
	const string&	pname,
	Profile01DisableCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Get log entries.
     *
     *  @param pname profile variable
     *
     *  @param instance_name to send the profiling info to.
     */
    virtual XrlCmdError profile_0_1_get_entries(
	// Input values,
	const string&	pname,
	const string&	instance_name) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01GetEntriesRF;

    class Profile01GetEntriesCB {
        Profile01GetEntriesRF cb;

    public:
        operator const Profile01GetEntriesRF& () const { return cb; }
        const Profile01GetEntriesRF& operator ->() const { return cb; }
        Profile01GetEntriesCB(const Profile01GetEntriesRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01GetEntriesRsp :
      public Profile01GetEntriesCB {
        Profile01GetEntriesRsp(const Profile01GetEntriesRF& cb)
          : Profile01GetEntriesCB(cb) { }

    };

    virtual void async_profile_0_1_get_entries
       (
	const string&	pname,
	const string&	instance_name,
	Profile01GetEntriesCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  Clear the profiling entries
     *
     *  @param pname profile variable
     */
    virtual XrlCmdError profile_0_1_clear(
	// Input values,
	const string&	pname) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback1<void, const XrlCmdError &>::RefPtr
    Profile01ClearRF;

    class Profile01ClearCB {
        Profile01ClearRF cb;

    public:
        operator const Profile01ClearRF& () const { return cb; }
        const Profile01ClearRF& operator ->() const { return cb; }
        Profile01ClearCB(const Profile01ClearRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e); }

        void respond() const {
            cb->dispatch(XrlCmdError::OKAY());
        }
    };

    struct Profile01ClearRsp :
      public Profile01ClearCB {
        Profile01ClearRsp(const Profile01ClearRF& cb)
          : Profile01ClearCB(cb) { }

    };

    virtual void async_profile_0_1_clear
       (
	const string&	pname,
	Profile01ClearCB);
#endif

    /**
     *  Pure-virtual function that needs to be implemented to:
     *
     *  List all the profiling variables registered with this target.
     */
    virtual XrlCmdError profile_0_1_list(
	// Output values,
	string&	info) = 0;
#ifdef XORP_ENABLE_ASYNC_SERVER
    typedef
    XorpCallback2<void, const XrlCmdError &,
	const string*>::RefPtr
    Profile01ListRF;

    class Profile01ListCB {
        Profile01ListRF cb;

    public:
        operator const Profile01ListRF& () const { return cb; }
        const Profile01ListRF& operator ->() const { return cb; }
        Profile01ListCB(const Profile01ListRF& cb)
          : cb(cb) { }

        void fail(const XrlCmdError &e) const { cb->dispatch(e, NULL); }

        void respond(const string& arg_info) const {
            cb->dispatch(XrlCmdError::OKAY(),
                         &arg_info);
        }
    };

    struct Profile01ListRsp :
      public Profile01ListCB {
        struct args_str {
            string info;
        };

    private:
        args_str args;

    public:
        Profile01ListRsp(const Profile01ListRF& cb)
          : Profile01ListCB(cb) { }

        void respond() const {
            Profile01ListCB::
            respond(args.info);
        }

        args_str* operator ->() {
            return &args;
        }
    };

    virtual void async_profile_0_1_list
       (
	Profile01ListCB);
#endif

private:
    XrlCmdRT handle_common_0_1_get_target_name(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_target_name
       (const XrlCmdError &e,
	const string* arg_name,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_version
       (const XrlCmdError &e,
	const string* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_get_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_get_status
       (const XrlCmdError &e,
	const uint32_t* arg_status,
	const string* arg_reason,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_shutdown(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_shutdown
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_common_0_1_startup(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_common_0_1_startup
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_bgp_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_bgp_version
       (const XrlCmdError &e,
	const uint32_t* arg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_local_config(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_local_config
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_local_as(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_local_as
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_4byte_as_support(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_4byte_as_support
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_local_as(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_local_as
       (const XrlCmdError &e,
	const string* arg_as,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_bgp_id(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_bgp_id
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_bgp_id(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_bgp_id
       (const XrlCmdError &e,
	const IPv4* arg_id,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_confederation_identifier(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_confederation_identifier
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_cluster_id(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_cluster_id
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_damping(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_damping
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_add_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_add_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_delete_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_delete_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_enable_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_enable_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_disable_peer(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_disable_peer
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_change_local_ip(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_change_local_ip
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_change_local_port(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_change_local_port
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_change_peer_port(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_change_peer_port
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_peer_as(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_peer_as
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_holdtime(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_holdtime
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_delay_open_time(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_delay_open_time
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_route_reflector_client(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_route_reflector_client
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_confederation_member(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_confederation_member
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_prefix_limit(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_prefix_limit
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_nexthop4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_nexthop4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_peer_state(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_peer_state
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_peer_md5_password(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_peer_md5_password
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_activate(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_activate
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_parameter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_parameter
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_next_hop_rewrite_filter(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_next_hop_rewrite_filter
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_originate_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_originate_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_withdraw_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_withdraw_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_trace(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_trace
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_list_start(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_list_start
       (const XrlCmdError &e,
	const uint32_t* arg_token,
	const bool* arg_more,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_list_next(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_list_next
       (const XrlCmdError &e,
	const string* arg_local_ip,
	const uint32_t* arg_local_port,
	const string* arg_peer_ip,
	const uint32_t* arg_peer_port,
	const bool* arg_more,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_id(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_id
       (const XrlCmdError &e,
	const IPv4* arg_peer_id,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_status(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_status
       (const XrlCmdError &e,
	const uint32_t* arg_peer_state,
	const uint32_t* arg_admin_status,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_negotiated_version(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_negotiated_version
       (const XrlCmdError &e,
	const int32_t* arg_neg_version,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_as(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_as
       (const XrlCmdError &e,
	const string* arg_peer_as,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_msg_stats(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_msg_stats
       (const XrlCmdError &e,
	const uint32_t* arg_in_updates,
	const uint32_t* arg_out_updates,
	const uint32_t* arg_in_msgs,
	const uint32_t* arg_out_msgs,
	const uint32_t* arg_last_error,
	const uint32_t* arg_in_update_elapsed,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_established_stats(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_established_stats
       (const XrlCmdError &e,
	const uint32_t* arg_transitions,
	const uint32_t* arg_established_time,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_peer_timer_config(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_peer_timer_config
       (const XrlCmdError &e,
	const uint32_t* arg_retry_interval,
	const uint32_t* arg_hold_time,
	const uint32_t* arg_keep_alive,
	const uint32_t* arg_hold_time_conf,
	const uint32_t* arg_keep_alive_conf,
	const uint32_t* arg_min_as_orgination_interval,
	const uint32_t* arg_min_route_adv_interval,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_register_rib(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_register_rib
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_v4_route_list_start(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_v4_route_list_start
       (const XrlCmdError &e,
	const uint32_t* arg_token,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_v4_route_list_next(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_v4_route_list_next
       (const XrlCmdError &e,
	const IPv4* arg_peer_id,
	const IPv4Net* arg_net,
	const uint32_t* arg_best_and_origin,
	const vector<uint8_t>* arg_aspath,
	const IPv4* arg_nexthop,
	const int32_t* arg_med,
	const int32_t* arg_localpref,
	const int32_t* arg_atomic_agg,
	const vector<uint8_t>* arg_aggregator,
	const int32_t* arg_calc_localpref,
	const vector<uint8_t>* arg_attr_unknown,
	const bool* arg_valid,
	const bool* arg_unicast,
	const bool* arg_multicast,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_set_nexthop6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_set_nexthop6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_nexthop6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_nexthop6
       (const XrlCmdError &e,
	const IPv6* arg_next_hop,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_withdraw_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_withdraw_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_v6_route_list_start(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_v6_route_list_start
       (const XrlCmdError &e,
	const uint32_t* arg_token,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_originate_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_originate_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_bgp_0_3_get_v6_route_list_next(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_bgp_0_3_get_v6_route_list_next
       (const XrlCmdError &e,
	const IPv4* arg_peer_id,
	const IPv6Net* arg_net,
	const uint32_t* arg_best_and_origin,
	const vector<uint8_t>* arg_aspath,
	const IPv6* arg_nexthop,
	const int32_t* arg_med,
	const int32_t* arg_localpref,
	const int32_t* arg_atomic_agg,
	const vector<uint8_t>* arg_aggregator,
	const int32_t* arg_calc_localpref,
	const vector<uint8_t>* arg_attr_unknown,
	const bool* arg_valid,
	const bool* arg_unicast,
	const bool* arg_multicast,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_birth(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_birth
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_finder_event_observer_0_1_xrl_target_death(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_finder_event_observer_0_1_xrl_target_death
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_configure(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_configure
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_reset(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_reset
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_backend_0_1_push_routes(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_backend_0_1_push_routes
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_add_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_add_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist4_0_1_delete_route4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist4_0_1_delete_route4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_changed4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_changed4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_invalid4(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_invalid4
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_changed6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_changed6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_rib_client_0_1_route_info_invalid6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_rib_client_0_1_route_info_invalid6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist6_0_1_add_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist6_0_1_add_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_policy_redist6_0_1_delete_route6(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_policy_redist6_0_1_delete_route6
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_enable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_enable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_disable(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_disable
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_get_entries(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_get_entries
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_clear(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_clear
       (const XrlCmdError &e,
        XrlRespCallback);
#endif

    XrlCmdRT handle_profile_0_1_list(const XrlArgs& in, XrlCmdOT out);
#ifdef XORP_ENABLE_ASYNC_SERVER
    void callback_profile_0_1_list
       (const XrlCmdError &e,
	const string* arg_info,
        XrlRespCallback);
#endif

    void add_handlers();
    void remove_handlers();

    struct handler_table {
        const char *name;
        XrlCmdRT (XrlBgpTargetBase::*method)(const XrlArgs&, XrlCmdOT);
    };

    static const struct handler_table handlers[];
    static const size_t num_handlers;
};

#endif // __XRL_TARGETS_BGP_BASE_HH__
